{"version":3,"sources":["../node_modules/eme-encryption-scheme-polyfill/index.js","../node_modules/google-closure-library/closure/goog/base.js"," [synthetic:es6/util/arrayiterator] "," [synthetic:util/defineproperty] "," [synthetic:util/global] "," [synthetic:util/polyfill] "," [synthetic:es6/symbol] "," [synthetic:es6/util/makeiterator] "," [synthetic:es6/util/arrayfromiterable] "," [synthetic:es6/util/arrayfromiterator] "," [synthetic:util/objectcreate] "," [synthetic:es6/util/setprototypeof] "," [synthetic:es6/util/inherits] "," [synthetic:es6/generator_engine] ","../lib/offline/offline_manifest_parser.js"," [synthetic:es6/execute_async_generator] "," [synthetic:util/owns] "," [synthetic:util/findinternal] "," [synthetic:es6/util/iteratorfromarray] "," [synthetic:util/checkstringargs] "," [synthetic:es6/promise/promise] "," [synthetic:es6/weakmap] "," [synthetic:es6/map] "," [synthetic:es6/set] "," [synthetic:es6/array/findindex] "," [synthetic:es6/promise/finally] "," [synthetic:es6/array/keys] "," [synthetic:es6/object/is] "," [synthetic:es6/array/includes] "," [synthetic:es6/string/includes] "," [synthetic:es6/array/values] "," [synthetic:es6/array/from] "," [synthetic:es6/array/find] "," [synthetic:es6/math/log2] "," [synthetic:es6/util/assign] "," [synthetic:es6/object/assign] "," [synthetic:es6/object/values] "," [synthetic:es6/string/startswith] ","../lib/abr/ewma.js","../lib/abr/ewma_bandwidth_estimator.js","../lib/debug/log.js","../lib/util/iterables.js","../lib/util/buffer_utils.js","../lib/util/error.js","../third_party/closure-uri/utils.js","../third_party/closure-uri/uri.js","../lib/deprecate/version.js","../lib/deprecate/deprecate.js","../lib/util/functional.js","../lib/deprecate/enforcer.js","../lib/util/manifest_parser_utils.js","../lib/util/public_promise.js","../lib/util/lazy.js","../lib/util/string_utils.js","../lib/util/uint8array_utils.js","../lib/media/transmuxer.js","../lib/util/delayed_tick.js","../lib/util/timer.js","../lib/net/backoff.js","../lib/util/abortable_operation.js","../lib/util/fake_event.js","../lib/util/multi_map.js","../lib/util/fake_event_target.js","../lib/util/object_utils.js","../lib/util/array_utils.js","../lib/util/operation_manager.js","../lib/net/networking_engine.js","../lib/util/destroyer.js","../lib/util/event_manager.js","../lib/util/fairplay_utils.js","../lib/util/map_utils.js","../lib/util/mime_utils.js","../lib/util/platform.js","../lib/media/drm_engine.js","../lib/media/closed_caption_parser.js","../lib/media/time_ranges_utils.js","../lib/text/cue.js","../lib/text/text_engine.js","../lib/media/media_source_engine.js","../lib/util/language_utils.js","../lib/util/stream_utils.js","../lib/abr/simple_abr_manager.js","../lib/media/adaptation_set.js","../lib/media/adaptation_set_criteria.js","../lib/media/buffering_observer.js","../lib/player.js","../lib/media/manifest_parser.js","../lib/media/segment_reference.js","../lib/media/presentation_timeline.js","../lib/media/stall_detector.js","../lib/media/gap_jumping_controller.js","../lib/util/media_ready_state_utils.js","../lib/media/video_wrapper.js","../lib/media/playhead.js","../lib/media/segment_index.js","../lib/media/play_rate_controller.js","../lib/media/playhead_observer.js","../lib/media/region_observer.js","../lib/media/region_timeline.js","../lib/util/data_view_reader.js","../lib/util/mp4_parser.js","../lib/util/networking.js","../lib/media/streaming_engine.js","../lib/routing/walker.js","../lib/text/simple_text_displayer.js","../lib/util/dom_utils.js","../lib/text/ui_text_displayer.js","../lib/util/config_utils.js","../lib/util/player_configuration.js","../lib/util/state_history.js","../lib/util/switch_history.js","../lib/util/stats.js","../lib/ads/ads_stats.js","../lib/ads/client_side_ad.js","../lib/ads/client_side_ad_manager.js","../lib/ads/ad_manager.js","../lib/ads/server_side_ad.js","../lib/ads/server_side_ad_manager.js","../lib/cast/cast_utils.js","../lib/cast/cast_sender.js","../lib/cast/cast_proxy.js","../lib/cast/cast_receiver.js","../lib/util/pssh.js","../lib/util/xml_utils.js","../lib/dash/content_protection.js","../lib/dash/mpd_utils.js","../lib/media/mp4_segment_index_parser.js","../lib/util/ebml_parser.js","../lib/media/webm_segment_index_parser.js","../lib/dash/segment_base.js","../lib/dash/segment_list.js","../lib/dash/segment_template.js","../lib/util/periods.js","../lib/dash/dash_parser.js","../lib/hls/hls_classes.js","../lib/hls/hls_utils.js","../lib/util/text_parser.js","../lib/hls/manifest_text_parser.js","../lib/net/data_uri_plugin.js","../lib/hls/hls_parser.js","../lib/net/http_plugin_utils.js","../lib/net/http_fetch_plugin.js","../lib/net/http_xhr_plugin.js","../lib/offline/download_progress_estimator.js","../lib/offline/download_manager.js","../lib/offline/indexeddb/db_operation.js","../lib/offline/indexeddb/db_connection.js","../lib/offline/indexeddb/base_storage_cell.js","../lib/offline/indexeddb/eme_session_storage_cell.js","../lib/offline/storage_muxer.js","../lib/offline/indexeddb/storage_mechanism.js","../lib/offline/indexeddb/v1_storage_cell.js","../lib/offline/indexeddb/v2_storage_cell.js","../lib/offline/indexeddb/v5_storage_cell.js","../lib/offline/offline_uri.js","../lib/offline/manifest_converter.js","../lib/offline/offline_scheme.js","../lib/offline/session_deleter.js","../lib/offline/stored_content_utils.js","../lib/offline/stream_bandwidth_estimator.js","../lib/offline/storage.js","../lib/util/manifest_filter.js","../lib/polyfill/all.js","../lib/polyfill/fullscreen.js","../lib/polyfill/input_event.js","../lib/polyfill/mediasource.js","../lib/polyfill/patchedmediakeys_apple.js","../lib/polyfill/patchedmediakeys_ms.js","../lib/polyfill/patchedmediakeys_nop.js","../lib/polyfill/patchedmediakeys_webkit.js","../lib/polyfill/encryption_scheme.js","../lib/polyfill/languages.js","../lib/polyfill/mathround.js","../lib/polyfill/pip_webkit.js","../lib/polyfill/videoplaybackquality.js","../lib/polyfill/vttcue.js","../lib/text/ttml_text_parser.js","../lib/polyfill/video_play_promise.js","../lib/text/mp4_ttml_parser.js","../lib/text/vtt_text_parser.js","../lib/text/mp4_vtt_parser.js"],"names":["$jscomp.defineProperty","$jscomp.global","$jscomp.getGlobal","$jscomp.arrayIteratorImpl","$jscomp.polyfill","$jscomp.objectCreate","$jscomp.setPrototypeOf","$jscomp.generator.Context","$jscomp.generator.Generator_","$jscomp.generator.Engine_","$jscomp.makeIterator","$jscomp.owns","$jscomp.iteratorPrototype","$jscomp.checkStringArgs","$jscomp.assign","goog.global","self","publicPath","object","part","parts","split","cur","execScript","length","shift","undefined","Object","prototype","constructor","halfLife","alpha_","Math","exp","log","totalWeight_","estimate_","sample","weight","value","adjAlpha","pow","newEstimate","getEstimate","fast_","shaka.abr.Ewma","slow_","bytesSampled_","alwaysError","alwaysWarn","error","shaka.abr.EwmaBandwidthEstimator","getBandwidthEstimate","defaultEstimate","min","shaka.log.oneTimeWarningIssued_","Set","window","console","bind","shaka.log.logMap_","ERROR","WARNING","warn","INFO","info","DEBUG","V1","debug","V2","map","iterable","mapping","array","push","x","range","shaka.util.Iterables.range","end","i","$jscomp.generator.createGenerator","shaka.util.Iterables.enumerate","enumerate","prev","item","next","equal","arr1","arr2","byteLength","shaka.util.BufferUtils.unsafeGetArrayBuffer_","byteOffset","uint8A","shaka.util.BufferUtils.toUint8","uint8B","unsafeGetArrayBuffer_","view","buffer","toArrayBuffer","Uint8Array","toUint8","data","offset","shaka.util.BufferUtils.view_","Infinity","toDataView","DataView","view_","Type","dataEnd","start","max","severity","category","code","varArgs","handled","goog.exportSymbol","shaka.util.BufferUtils","publicName","shaka.util.BufferUtils.toDataView","shaka.util.BufferUtils.toArrayBuffer","shaka.util.BufferUtils.equal","shaka.util.Error","toString","JSON","stringify","shaka.util.Error.Severity","shaka.util.Error.Category","shaka.util.Error.Code","goog.uri.utils.splitRe_","goog.Uri","uri","m","setScheme","scheme_","setUserInfo","userInfo_","setDomain","domain_","setPort","port_","setPath","path_","setQueryData","queryData_","clone","setFragment","fragment_","String","match","SCHEME","goog.Uri.decodeOrEmpty_","USER_INFO","DOMAIN","PORT","PATH","QUERY_DATA","FRAGMENT","goog.Uri.QueryData","goog.Uri.prototype.setScheme","newScheme","decode","replace","goog.Uri.prototype.setPort","newPort","isNaN","Number","goog.Uri.prototype.setQueryData","queryData","goog.Uri.encodeSpecialChars_","goog.Uri.reDisallowedInQuery_","val","preserveReserved","decodeURI","decodeURIComponent","unescapedPart","extra","removeDoubleEncoding","encoded","encodeURI","goog.Uri.encodeChar_","ch","n","charCodeAt","goog_Uri_prototype$scheme_","goog.Uri.prototype.toString","out","scheme","getScheme","domain","goog.Uri.reDisallowedInSchemeOrUserInfo_","getDomain","userInfo","getUserInfo","encodeURIComponent","port","getPort","path","getPath","hasDomain","charAt","goog.Uri.reDisallowedInAbsolutePath_","goog.Uri.reDisallowedInRelativePath_","query","getEncodedQuery","fragment","getFragment","goog.Uri.reDisallowedInFragment_","join","resolve","goog.Uri.prototype.resolve","relativeUri","absoluteUri","overridden","hasPath","lastSlashIndex","lastIndexOf","substr","indexOf","leadingSlash","segments","pos","segment","pop","goog.Uri.prototype.clone","encodedQuery_","major","minor","major_","minor_","deprecateFeature","name","description","expiresAt","shaka.deprecate.Version","enforce","shaka.Deprecate.enforcer_","libraryVersion_","minorCheck","expiresOn","other","onPending_","onExpired_","libraryVersion","featureVersion","shaka.log.alwaysWarn","shaka.log.alwaysError","keyMap_","count_","add","goog.Uri.QueryData.prototype.add","key","ensureKeyMapInitialized_","pairs","indexOfEquals","substring","values","hasOwnProperty","goog.Uri.QueryData.prototype.toString","sb","encodedKey","j","param","goog.Uri.QueryData.prototype.clone","rv","cloneMap","concat","collapseArrays","all","noop","isNotNull","callFactory","factory","obj","create","ret","call","shaka.Deprecate.deprecateFeature","e","resolveUris","baseUris","relativeUris","relativeAsGoog","base","reduce","shaka.util.Functional.collapseArrays","createDrmInfo","keySystem","initData","licenseServerUri","distinctiveIdentifierRequired","persistentStateRequired","audioRobustness","videoRobustness","serverCertificate","keyIds","shaka.util.ManifestParserUtils.ContentType","VIDEO","AUDIO","TEXT","IMAGE","APPLICATION","resolvePromise","rejectPromise","publicPromise","promise","Promise","reject","gen","gen_","value_","fromUTF8","uint8","subarray","utf8","shaka.util.StringUtils.fromCharCode","escaped","escape","shaka.util.Error.Severity.CRITICAL","shaka.util.Error.Category.TEXT","shaka.util.Error.Code.BAD_ENCODING","fromUTF16","littleEndian","noThrow","floor","arr","Uint16Array","dataView","getUint16","fromBytesAutoDetect","isAscii","shaka.util.Error.Code.UNABLE_TO_DETECT_ENCODING","toUTF8","str","unescape","result","toUTF16","ArrayBuffer","setUint16","fromCharCode","shaka.util.PublicPromise","shaka.util.Lazy","shaka.util.StringUtils","resetFromCharCode","shaka.util.StringUtils.fromCharCodeImpl_.reset","shaka.util.StringUtils.toUTF16","shaka.util.StringUtils.toUTF8","shaka.util.StringUtils.fromBytesAutoDetect","shaka.util.StringUtils.fromUTF16","shaka.util.StringUtils.fromUTF8","shaka.util.StringUtils.fromCharCodeImpl_","supportsChunkSize","size","apply","toStandardBase64","btoa","bytes","toBase64","padding","base64","shaka.util.Uint8ArrayUtils.toStandardBase64","fromBase64","atob","fromHex","parseInt","toHex","hex","totalLength","set","muxTransmuxer_","muxjs","mp4","Transmuxer","transmuxPromise_","transmuxedData_","captions_","metadata_","isTransmuxing_","on","onTransmuxed_","captions","metadata","shaka.util.Uint8ArrayUtils.concat","initSegment","output","shaka.util.Uint8ArrayUtils.concat.apply","shaka.util.Uint8ArrayUtils","$jscomp.arrayFromIterable","onTransmuxDone_","mimeType","contentType","toLowerCase","isTypeSupported","shaka.media.Transmuxer.convertTsCodecs","audioMime","videoMime","MediaSource","convertTsCodecs","tsMimeType","mp4MimeType","exec","newCodecString","profile","level","onTick","onTick_","cancelPending_","ticker_","parameters","autoReset","defaults","maxAttempts","baseDelay","backoffFactor","fuzzFactor","timeout","maxAttempts_","baseDelay_","fuzzFactor_","backoffFactor_","numAttempts_","nextUnfuzzedDelay_","autoReset_","attempt","currentAttempt","fuzzedDelayMs","$jscomp.asyncExecutePromiseGeneratorProgram","shaka.util.Error.Category.PLAYER","shaka.util.Error.Code.ATTEMPTS_EXHAUSTED","reset_","random","shaka.util.Timer","tickAfter","onAbort","onAbort_","aborted_","failed","shaka.util.AbortableOperation","aborted","p","shaka.util.Error.Code.OPERATION_ABORTED","completed","notAbortable","operations","op","abort","type","dict","defineProperty","writable","enumerable","defaultPrevented","cancelable","bubbles","timeStamp","performance","now","Date","isTrusted","target","currentTarget","stopped","map_","listeners_","shaka.util.MultiMap","dispatchTarget","cloneObject","arg","seenObjects","has","isArray","Array","shallowCloneObject","original","k","defaultEquals","a","b","remove","element","index","splice","hasSameElements","compareFn","shaka.util.ArrayUtils.defaultEquals","copy","slice","idx","findIndex","operations_","manage","operation","shaka.util.ArrayUtils.remove","onProgressUpdated","shaka.util.FakeEventTarget.call","destroyed_","operationManager_","shaka.util.OperationManager","requestFilters_","responseFilters_","onProgressUpdated_","plugin","priority","shaka.net.NetworkingEngine.PluginPriority.APPLICATION","existing","shaka.net.NetworkingEngine.schemes_","uris","retryParams","method","body","headers","allowCrossSiteCredentials","retryParameters","licenseRequestType","sessionId","bytesToLoad_","numBytesRemainingObj","shaka.util.AbortableOperation.call","bytesRemaining_","shaka.util.Uint8ArrayUtils.toHex","shaka.util.Uint8ArrayUtils.fromHex","shaka.util.Uint8ArrayUtils.fromBase64","shaka.util.Uint8ArrayUtils.toBase64","shaka.media.Transmuxer","destroy","dispose","shaka.util.DelayedTick","delayInSeconds","stop","alive","timeoutId","this.cancelPending_","clearTimeout","setTimeout","tickNow","seconds","tickEvery","goog.exportProperty","finally","onFinal","then","chain","onSuccess","onError","makeCallback","isSuccess","newPromise","abortError","cb","callback","exception","shaka.util.AbortableOperation.wrapChainCallback_","shaka.util.AbortableOperation.all","shaka.util.AbortableOperation.notAbortable","shaka.util.AbortableOperation.completed","shaka.util.AbortableOperation.aborted","shaka.util.AbortableOperation.failed","shaka.util.FakeEvent","preventDefault","stopImmediatePropagation","stopPropagation","get","list","filter","shaka.util.FakeEventTarget","addEventListener","listener","removeEventListener","dispatchEvent","event","listeners","handleEvent","cleanup","$jscomp.inherits","shaka.net.NetworkingEngine","registerRequestFilter","unregisterRequestFilter","clearAllRequestFilters","clear","registerResponseFilter","unregisterResponseFilter","clearAllResponseFilters","shaka.net.NetworkingEngine.prototype","request","shaka.net.NetworkingEngine.NumBytesRemainingClass","shaka.net.NetworkingEngine.PendingRequest","shaka.util.ObjectUtils.cloneObject","requestOperation","requestFilterOperation","filterRequest_","filterOperation","requestFilter","shaka.util.Error.Category.NETWORK","shaka.util.Error.Code.REQUEST_FILTER_ERROR","send_","backoff","lastError","gotProgress","location","protocol","shaka.util.Error.Code.UNSUPPORTED_SCHEME","startTimeMs","backoffOperation","time","numBytesRemaining","shaka.net.NetworkingEngine.RequestType.SEGMENT","response","responseAndGotProgress","timeMs","shaka.util.Error.Severity.RECOVERABLE","makeRequestWithRetry_","shaka.net.Backoff","responseFilterOperation","filterResponse_","responseFilter","resp","shaka.util.Error.Code.RESPONSE_FILTER_ERROR","requestFilterStartTime","requestFilterMs","responseFilterStartTime","responseFilterMs","fromCache","pendingRequest","shaka.net.NetworkingEngine.makeRequest","defaultRetryParameters","unregisterScheme","shaka.net.NetworkingEngine.registerScheme","shaka.net.NetworkingEngine.RequestType","shaka.net.NetworkingEngine.PluginPriority","waitOnDestroy_","onDestroy_","ensureNotDestroyed","shaka.util.Error.Code.OBJECT_DESTROYED","bindingMap_","options","ignored","shaka.util.EventManager.Binding_.doesSupportObject_","keys","doesSupportObject_","supports","shaka.util.EventManager.Binding_.supportsObject_","prop","shaka.util.EventManager.Binding_.convertOptions_","shaka.util.Destroyer","release","removeAll","listen","binding","shaka.util.EventManager.Binding_","listenOnce","shim","unlisten","shaka.util.EventManager","defaultGetContentId","uriString","initDataTransform","contentId","cert","appendWithLength","rebuiltInitData","setUint32","shaka.util.Error.Category.DRM","shaka.util.Error.Code.SERVER_CERTIFICATE_REQUIRED","contentIdArray","utf16","sdkUri","asMap","Map","asObject","forEach","map1","map2","val2","getFullType","codecs","fullMimeType","getCodecParts_","codecString","shaka.util.FairPlayUtils","shaka.util.FairPlayUtils.initDataTransform","shaka.util.FairPlayUtils.defaultGetContentId","shaka.util.MimeUtils.EXTENDED_MIME_PARAMETERS_","supportsMediaSource","supportsMediaType","shaka.util.Platform.anyMediaElement","canPlayType","isTizen","isApple","navigator","vendor","includes","shaka.util.Platform.isTizen","safariVersion","shaka.util.Platform.isApple","userAgent","userAgentContains_","anyMediaElement","shaka.util.Platform.cachedMediaElement_","shaka.util.Platform.cacheExpirationTimer_","document","getElementsByTagName","createElement","playerInterface","updateExpirationTime","playerInterface_","supportedTypes_","video_","mediaKeys_","initialized_","licenseTimeSeconds_","currentDrmInfo_","eventManager_","activeSessions_","offlineSessionIds_","allSessionsLoaded_","config_","onError_","this.onError_","err","keyStatusByKeyId_","announcedKeyStatusByKeyId_","keyStatusTimer_","processKeyStatusChanges_","privateMap","publicMap","status","keyId","statuses","from","every","shaka.util.Error.Code.EXPIRED","onKeyStatus","shaka.util.MapUtils.asObject","usePersistentLicenses_","mediaKeyMessageEvents_","initialRequestsSent_","expirationTimer_","pollExpiration_","session","oldTime","oldExpiration","newTime","expiration","onExpirationUpdated","destroyer_","destroyNow_","closeOpenSessions_","setMediaKeys","initForPlayback","variants","offlineSessionIds","init_","clearKeyDrmInfo","configureClearKey_","clearKeys","shaka.util.MapUtils.asMap","keyHex","keyIdHex","keyObj","kty","kid","license","jwkSet","initDataStr","initDatas","initDataType","variant","video","drmInfos","audio","hadDrmInfo","some","replaceDrmInfo_","keySystems","shaka.media.DrmEngine.replaceDrmInfo_","servers","shaka.media.DrmEngine.fillInDrmInfoDefaults_","advanced","configsByKeySystem","prepareMediaKeyConfigsForVariants_","allDrmInfo","persistentState","sessionTypes","configs","config","audioCapabilities","videoCapabilities","distinctiveIdentifier","label","stream","shaka.media.DrmEngine.computeMimeType_","fallbackMimeType","capability","robustness","fallbackCapability","queryMediaKeys_","setServerCertificate","shaka.util.Error.Code.INVALID_SERVER_CERTIFICATE","message","createOrLoad","newInitData","initDataOverride","loadOfflineSession_","metadatas","shaka.util.Platform.userAgentContains_","createTemporarySession_","createSession","shaka.util.Error.Code.FAILED_TO_CREATE_SESSION","onSessionMessage_","delayLicenseRequestUntilPlayed","paused","sendLicenseRequest_","onKeyStatusesChange_","loaded","updatePromise","shakaError","shaka.util.Error.Code.INIT_DATA_TRANSFORM_ERROR","logLicenseExchange","generateRequest","errorCode","systemCode","extended","shaka.util.Error.Code.FAILED_TO_GENERATE_LICENSE_REQUEST","drmInfo","willSupport","fallback","getSessionIds","ids","shaka.util.Iterables.map","sessions","s","computeMimeType_","codecOverride","realMimeType","shaka.util.MimeUtils.getFullType","shaka.media.Transmuxer.isSupported","mediaKeySystemAccess","shouldHaveLicenseServer","realConfig","audioCaps","videoCaps","cap","mediaKeys","shaka.util.Error.Code.NO_RECOGNIZED_KEY_SYSTEMS","hasLicenseServer","requestMediaKeySystemAccess","shaka.util.Error.Code.REQUESTED_KEY_SYSTEM_CONFIG_UNAVAILABLE","getConfiguration","createDrmInfoFor_","licenseServers","serverCerts","processDrmInfos_","shaka.media.DrmEngine.createDrmInfoFor_","shaka.util.Error.Code.NO_LICENSE_SERVER_GIVEN","createMediaKeys","shaka.util.Error.Code.FAILED_TO_CREATE_CDM","present","load","areAllSessionsLoaded_","shaka.util.Error.Code.OFFLINE_SESSION_REMOVED","defaultInitDataTransform","url","advancedConfig","startTimeRequest","shakaErr","updateEvent","messageType","individualizationServer","unpackPlayReadyRequest_","xml","dom","DOMParser","parseFromString","header","textContent","netEngine","shaka.net.NetworkingEngine.RequestType.LICENSE","shaka.util.Error.Code.LICENSE_REQUEST_FAILED","update","shaka.util.Error.Code.LICENSE_RESPONSE_REJECTED","onEvent","shaka.media.DrmEngine.SESSION_LOAD_TIMEOUT_","found","hasExpiredKeys","keyStatuses","tmp","part0","getUint32","part1","part2","msUntilExpiration","close","shaka.media.DrmEngine.KEY_STATUS_BATCH_TIME","openSessions","shaka.media.DrmEngine.CLOSE_TIMEOUT_","race","closed","closeSession_","supportsVariant","encrypted","audioContentType","videoContentType","shaka.media.DrmEngine.keySystem","getCommonDrmInfos","drms1","drms2","commonDrms","drm1","drm2","mergedDrm","shaka.util.Iterables.every","test","fillInDrmInfoDefaults_","advancedConfigs","server","cast","__platform__","shaka.media.DrmEngine","configure","attach","onPlay_","shaka.util.Error.Code.FAILED_TO_ATTACH_TO_VIDEO","shaka.util.Error.Code.ENCRYPTED_CONTENT_WITHOUT_DRM_INFO","getExpiration","shaka.media.DrmEngine.DUMMY_KEY_ID","muxCaptionParser_","CaptionParser","videoTrackIds_","timescales_","bufferEnd","isBuffered","smallGapLimit","bufferedAheadOf","shaka.media.TimeRangesUtils.getBufferedInfo","getBufferedInfo","startTime","endTime","payload","direction","shaka.text.Cue.direction.HORIZONTAL_LEFT_TO_RIGHT","region","shaka.text.CueRegion","position","positionAlign","shaka.text.Cue.positionAlign.AUTO","textAlign","shaka.text.Cue.textAlign.CENTER","writingMode","shaka.text.Cue.writingMode.HORIZONTAL_TOP_TO_BOTTOM","lineInterpretation","shaka.text.Cue.lineInterpretation.LINE_NUMBER","line","lineHeight","lineAlign","shaka.text.Cue.lineAlign.START","displayAlign","shaka.text.Cue.displayAlign.AFTER","fontSize","border","backgroundImage","backgroundColor","color","fontWeight","shaka.text.Cue.fontWeight.NORMAL","fontStyle","shaka.text.Cue.fontStyle.NORMAL","linePadding","letterSpacing","fontFamily","opacity","textDecoration","wrapLine","id","nestedCues","spacer","cellResolution","columns","rows","cue1","cue2","shaka.util.ArrayUtils.equal","shaka.text.Cue.equal","k2","shaka.media.MuxJSClosedCaptionParser","init","probe","initBytes","videoTrackIds","timescale","parseFrom","onCaptions","segmentBytes","dashParsed","parse","clearParsedCaptions","reset","resetCaptionStream","shaka.media.NoopCaptionParser","shaka.text.Cue","shaka.text.Cue.positionAlign","shaka.text.Cue.textAlign","shaka.text.Cue.displayAlign","shaka.text.Cue.direction","shaka.text.Cue.writingMode","shaka.text.Cue.lineInterpretation","shaka.text.Cue.lineAlign","shaka.text.Cue.fontWeight","shaka.text.Cue.fontStyle","regionAnchorY","regionAnchorX","viewportAnchorY","viewportAnchorX","height","width","viewportAnchorUnits","widthUnits","heightUnits","shaka.text.CueRegion.units.PERCENTAGE","scroll","shaka.text.CueRegion.scrollMode.NONE","shaka.text.Cue.textDecoration","shaka.text.CueRegion.units","displayer","parser_","displayer_","appendWindowStart_","timestampOffset_","appendWindowEnd_","bufferEnd_","bufferStart_","selectedClosedCaptionId_","closedCaptionsMap_","shaka.util.MimeUtils.CLOSED_CAPTION_MIMETYPE","storeAndAppendClosedCaptions","closedCaptions","videoTimestampOffset","startAndEndTime","captionsMap","caption","cue","text","append","cues","shaka.text.CueRegion.scrollMode","shaka.text.TextEngine","unregisterParser","shaka.text.TextEngine.parserMap_","registerParser","closedCaptionParser","textDisplayer","onMetadata","textDisplayer_","sourceBuffers_","textEngine_","onMetadata_","onMetadataNoOp","queues_","transmuxers_","captionParser_","mediaSourceOpen_","mediaSource_","createMediaSource","mediaSource","URL","revokeObjectURL","onSourceOpen_","url_","shaka.media.MediaSourceEngine.createObjectURL","src","doDestroy_","q","inProgress","shaka.util.Functional.noop","removeAttribute","isStreamSupported","extendedMimeType","getExtendedType","components","mimeKey","streamKey","shaka.util.MimeUtils.getExtendedType","shaka.text.TextEngine.isTypeSupported","reinitText","shaka.util.Functional.callFactory","ended","readyState","bufferStart","shaka.media.TimeRangesUtils.bufferEnd","getBuffered_","buffered","appendBuffer","hasClosedCaptions","ContentType","transmuxedData","timestampOffset","videoOffset","allCues","cuesToAppend","parseInit","periodStart","segmentStart","segmentEnd","parseMedia","transmux","dataArray","flush","shaka.util.Error.Category.MEDIA","shaka.util.Error.Code.TRANSMUXING_FAILED","enqueueOperation_","append_","setSelectedClosedCaptionId","videoBufferEndTime","bufferEndTime","c","duration","onUpdateEnd_","remove_","popFromQueue_","startOperation_","enqueueBlockingOperation_","run","allWaiters","ready","shaka.util.Error.Code.MEDIA_SOURCE_OPERATION_THREW","shaka.util.Error.Code.QUOTA_EXCEEDED_ERROR","shaka.media.MediaSourceEngine.prototype","streamsByType","forceTransmuxTS","sourceBuffer","addSourceBuffer","shaka.util.Error.Code.MEDIA_SOURCE_OPERATION_FAILED","total","flush_","currentTime","endOfStream","reason","setDuration","getDuration","createObjectURL","areLanguageCompatible","locale1","locale2","shaka.util.LanguageUtils.normalize","isParentOf","possibleParent","possibleChild","possibleParentComponents","possibleChildComponents","isSiblingOf","localeA","localeB","localeAComponents","localeBComponents","normalize","locale","language","shaka.util.LanguageUtils.isoMap_.get","toUpperCase","relatedness","candidate","shaka.util.LanguageUtils.isParentOf","shaka.util.LanguageUtils.isSiblingOf","getLocaleForVariant","findClosestLocale","searchSpace","safeTarget","safeSearchSpace","option","shaka.util.LanguageUtils.isoMap_","chooseCodecsAndFilterManifest","manifest","preferredAudioChannelCount","variantCodecs","baseVideoCodec","shaka.util.MimeUtils.getCodecParts_","baseAudioCodec","shaka.util.StreamUtils.filterVariantsByAudioChannelCount","variantsByCodecs","group","bestCodecs","lowestAverageBandwidth","sum","num","bandwidth","averageBandwidth","meetsRestrictions","restrictions","maxHwRes","inRange","minWidth","maxWidth","minHeight","maxHeight","minPixels","maxPixels","frameRate","minFrameRate","maxFrameRate","minBandwidth","maxBandwidth","areStreamsCompatible_","s0","s1","variantToTrack","audioCodec","videoCodec","mimeTypes","kinds","kind","roles","role","track","active","pixelAspectRatio","primary","audioRoles","videoId","audioId","channelsCount","audioSamplingRate","audioBandwidth","videoBandwidth","originalVideoId","originalAudioId","originalTextId","originalId","textStreamToTrack","html5TrackId","html5Track","shaka.util.StreamUtils.nextTrackId_","html5AudioTrackToTrack","audioTrack","shaka.util.StreamUtils.html5TrackToGenericShakaTrack_","enabled","html5TrackToGenericShakaTrack_","shaka.util.StreamUtils.html5TrackId","isPlayable","allowedByApplication","allowedByKeySystem","filterVariantsByAudioChannelCount","variantsWithChannelCounts","v","variantsByChannelCount","count","channelCounts","countLessThanOrEqualtoConfig","filterStreamsByLanguageAndRole","streams","preferredLanguage","preferredRole","chosen","firstLanguage","closestLocale","shaka.util.LanguageUtils.findClosestLocale","roleMatches","shaka.util.StreamUtils.filterTextStreamsByRole_","noRoleMatches","allRoles","filterTextStreamsByRole_","textStreams","switch_","enabled_","bandwidthEstimator_","variants_","playbackRate_","startupComplete_","lastTimeChosenMs_","sort","v1","v2","root","candidates","root_","shaka.media.AdaptationSet.canTransitionBetween_","shaka.media.AdaptationSet.areRolesEqual_","codecsA","codec","codecsB","areRolesEqual_","aSet","bSet","mainRole","example","example_","fallback_","shaka.media.PreferenceBasedCriteria","channelCount","language_","role_","channelCount_","label_","previousState_","shaka.media.BufferingObserver.State.SATISFIED","thresholds_","thresholdWhenSatisfied","shaka.media.BufferingObserver.State.STARVING","thresholdWhenStarving","setThresholds","switchCallback","chooseVariant","sortedVariants","shaka.abr.SimpleAbrManager.filterAndSortVariants_","currentBandwidth","defaultBandwidthEstimate","playbackRate","abs","bandwidthUpgradeTarget","bandwidthDowngradeTarget","enable","disable","segmentDownloaded","deltaTimeMs","numBytes","minBytes_","suggestStreams_","switchInterval","minTotalBytes_","chosenVariant","setVariants","playbackRateChanged","rate","shaka.abr.SimpleAbrManager","shaka.media.AdaptationSet","canInclude","shaka.media.ExampleBasedCriteria","shortList","current","byLanguage","shaka.util.LanguageUtils.getLocaleForVariant","shaka.media.PreferenceBasedCriteria.filterByLanguage_","byPrimary","byRole","filterVariantsByRole_","shaka.media.PreferenceBasedCriteria.filterVariantsByRole_","byChannel","byLabel","filterVariantsByLabel_","preferredLabel","shaka.media.PreferenceBasedCriteria.filterVariantsByLabel_","shaka.media.AdaptationSet.areAdaptable","STARVING","SATISFIED","getFactory","extension","shaka.media.ManifestParser.parsersByMime","shaka.media.ManifestParser.getExtension","shaka.media.ManifestParser.parsersByExtension","getMimeType","shaka.net.NetworkingEngine.RequestType.MANIFEST","shaka.media.ManifestParser.getMimeType","shaka.util.Error.Category.MANIFEST","shaka.util.Error.Code.UNABLE_TO_GUESS_MANIFEST_TYPE","getExtension","filenamePieces","uriPieces","shaka.media.ManifestParser","unregisterParserByMime","registerParserByMime","parserFactory","registerParserByExtension","startByte","endByte","getUris","initSegmentReference","appendWindowStart","appendWindowEnd","presentationStartTime","presentationDelay","autoCorrectDrift","presentationStartTime_","presentationDelay_","segmentAvailabilityDuration_","duration_","maxSegmentDuration_","maxSegmentEndTime_","minSegmentStartTime_","clockOffset_","static_","userSeekStart_","autoCorrectDrift_","implementation","stallThresholdSeconds","implementation_","wasMakingProgress_","shouldBeMakingProgress","mediaElement_","lastUpdateSeconds_","didJump_","stallThresholdSeconds_","onStall_","this.onStall_","mediaElement","timeInSeconds","timeline","stallDetector","timeline_","onEvent_","seekingEventReceived_","prevReadyState_","didFireLargeGap_","stallDetector_","hadSegmentAppended_","onPollGapJump_","gapJumpTimer_","seeking","impl","wallTimeSeconds","triggerCallback","stallSeconds","gapIndex","getGapIndex","threshold","shaka.media.TimeRangesUtils.getGapIndex","jumpTo","getSeekRangeEnd","isGapSmall","jumpSize","jumpLargeGap","jumpLargeGaps","waitForReadyState","eventManager","HTMLMediaElement","HAVE_NOTHING","eventName","shaka.util.MediaReadyState.READY_STATES_TO_EVENT_NAMES_.get","shaka.media.InitSegmentReference","getStartByte","getEndByte","shaka.media.SegmentReference","getStartTime","getEndTime","getMaxSegmentDuration","getPresentationStartTime","setClockOffset","setStatic","isStatic","setSegmentAvailabilityDuration","segmentAvailabilityDuration","setDelay","delay","getDelay","notifySegments","references","lastReferenceEndTime","notifyMinSegmentStartTime","r","notifyMaxSegmentDuration","maxSegmentDuration","isLive","isInProgress","getSegmentAvailabilityStart","getSegmentAvailabilityEnd","setUserSeekStart","getLiveEdge_","getSafeSeekRangeStart","earliestSegmentTime","getSeekRangeStart","usingPresentationStartTime","shaka.media.PresentationTimeline","shaka.media.StallDetector","shaka.media.GapJumpingController","onSegmentAppended","shaka.util.MediaReadyState.READY_STATES_TO_EVENT_NAMES_","HAVE_METADATA","HAVE_CURRENT_DATA","HAVE_FUTURE_DATA","HAVE_ENOUGH_DATA","onSeek","onSeek_","startTime_","started_","mover_","shaka.media.VideoWrapper.PlayheadMover","setStartTime_","getTime","setTime","moveTo","shaka.util.MediaReadyState.waitForReadyState","startListeningToSeeks_","targetTime_","originTime_","remainingAttempts_","timer_","presentationTimeline","minBufferTime_","minBufferTime","lastCorrectiveSeek_","gapController_","createStallDetector_","stallEnabled","skip","stallSkip","detector","shaka.media.StallDetector.MediaElementImplementation","stallThreshold","onStall","doThis","pause","play","videoWrapper_","shaka.media.VideoWrapper","onSeeking_","targetTime","reposition_","shaka.media.GapJumpingController.BROWSER_GAP_TOLERANCE","getStartTime_","clampSeekToDuration_","clampTime_","checkWindowTimer_","onPollWindow_","seekStart","seekEnd","minSeekRange_","durationBackoff","rebufferingGoal","safeSeekOffset","safe","seekSafe","shaka.media.TimeRangesUtils.isBuffered","numEvicted","immutable_","shaka.media.SegmentIndex","reference","segmentIndex","segmentIndex_","nextPosition_","shaka.media.SegmentIndex.call","indexes_","harness","harness_","isBuffering_","rate_","getRate","movePlayhead","pollRate_","apply_","calculateCurrentRate_","applyRate_","setRate","newRate","observers_","pollingLoop_","pollAllObservers_","observer","regions_","previousPosition","oldPosition_","currentPosition","positionInSeconds","shaka.media.RegionObserver.RelativePosition_.BEFORE_THE_REGION","shaka.media.RegionObserver.RelativePosition_.AFTER_THE_REGION","shaka.media.RegionObserver.RelativePosition_.IN_THE_REGION","rules_","rule","weWere","weAre","invoke","wasSeeking","getSeekRange","onAddRegion_","this.onAddRegion_","getSeekRange_","filterTimer_","seekRange","filterBySeekRange_","shaka.media.RegionTimeline.REGION_FILTER_INTERVAL","onEnter_","this.onEnter_","onExit_","this.onExit_","onSkip_","this.onSkip_","this.onSeek_","shaka.media.SrcEqualsPlayhead","setStartTime","notifyOfBufferingChange","shaka.media.MediaSourcePlayhead","markImmutable","find","ref","merge","newReferences","lastOldReference","evict","oldSize","fit","windowStart","windowEnd","lastReference","updateEvery","interval","updateCallback","Symbol","iterator","getIteratorForTime","shaka.media.SegmentIterator","shaka.media.SegmentIndex.forSingleSegment","seek","shaka.media.MetaSegmentIndex","numPassedInEarlierIndexes","shaka.media.PlayRateController","shaka.media.PlayheadObserverManager","shaka.media.RegionTimeline","shaka.media.RegionObserver","BEFORE_THE_REGION","IN_THE_REGION","AFTER_THE_REGION","endianness","dataView_","littleEndian_","shaka.util.DataViewReader.Endianness.LITTLE_ENDIAN","position_","shaka.util.Error.Code.BUFFER_READ_OUT_OF_BOUNDS","hasMoreData","getPosition","getLength","readUint8","getUint8","readUint16","readUint32","readInt32","getInt32","readUint64","low","high","shaka.util.Error.Code.JS_INTEGER_OVERFLOW","readBytes","rewind","readTerminatedString","shaka.util.DataViewReader","headers_","boxDefinitions_","done_","box","flags","reader","parser","parseNext","partialOkay","sampleDescription","allData","typeFromString_","chr","typeToString","shaka.util.DataViewReader.Endianness","definition","typeCode","shaka.util.Mp4Parser.typeFromString_","shaka.util.Mp4Parser.BoxType_.BASIC_BOX","fullBox","shaka.util.Mp4Parser.BoxType_.FULL_BOX","shaka.util.DataViewReader.Endianness.BIG_ENDIAN","absStart","boxDefinition","version","versionAndFlags","payloadReader","payloadSize","shaka.util.Mp4Parser","shaka.util.Mp4Parser.typeToString","shaka.util.Mp4Parser.allData","shaka.util.Mp4Parser.sampleDescription","shaka.util.Mp4Parser.children","BASIC_BOX","FULL_BOX","createSegmentRequest","manifest_","bufferingGoalScale_","currentTextStream_","currentVariant_","mediaStates_","failureCallbackBackoff_","fatalError_","aborts","state","cancelUpdate_","abortOperations_","setTrickPlay","mediaState","trickModeVideo","restoreStreamAfterTrickPlay","switchInternal_","normalVideo","switchVariant","clearBuffer","safeMargin","switchTextStream","textStream","force","mediaSourceEngine","segmentIterator","clearingBuffer","waitingToFlushBuffer","performingUpdate","waitingToClearBuffer","clearBufferSafeMargin","clearBuffer_","makeAbortDecision_","originalStream","originalOperation","createSegmentIndex","presentationTime","shouldAbortCurrentRequest_","getPresentationTime","lastSegmentReference","newSegment","newSegmentSize","bandwidthEstimate","loadNewTextStream_","isTextVisible","alwaysStreamText","createMediaState_","scheduleUpdate_","forceClearBuffer_","updateTimer","lastInitSegmentReference","lastTimestampOffset","lastAppendWindowStart","lastAppendWindowEnd","recovering","hasError","isSegmentReferenceAvailable_","availabilityEnd","isEmbeddedText_","fetch_","requestType","shaka.util.Networking.createSegmentRequest","onUpdate_","handleStreamingError_","failureCallback","startingAt","startingWith","shaka.Player.createEmptyPayload_","currentlyAt_","currentlyWith_","waitForWork_","requests_","currentStep_","currentRoute_","mainLoopPromise_","mainLoop_","tryNewRoute_","interruptible","onCancel","newRoute","onStart","node","onSkip","takeNextStep_","getNext","enterNode","onEnd","handleError","onIdle","unblockMainLoop_","startNewRoute","onEnter","textTrack_","textTracks","mode","shaka.Player.TextTrackLabel","addTextTrack","shakaCue","vttCue","VTTCue","align","vertical","shaka.text.Cue.writingMode.VERTICAL_RIGHT_TO_LEFT","snapToLines","removeWhere_","predicate","oldState","removeCue","removeAllChildren","firstChild","removeChild","videoContainer","isTextVisible_","cues_","videoContainer_","textContainer_","tagName","classList","style","display","flexDirection","alignItems","justifyContent","appendChild","captionsTimer_","updateCaptions_","updatePeriod","currentCuesMap_","shouldCueBeDisplayed","expectedChildren","childNodes","child","currentCues","displayCue_","displayLeafCue_","container","isNested","setCaptionStyles_","nestedCuesContainer","captionsStyle","isLeaf","flexBasis","whiteSpace","paddingLeft","shaka.text.UITextDisplayer.convertLengthValue_","paddingRight","backgroundRepeat","backgroundSize","backgroundPosition","widthUnit","shaka.text.Cue.displayAlign.BEFORE","shaka.text.Cue.displayAlign.CENTER","flexWrap","margin","shaka.text.Cue.lineInterpretation.PERCENTAGE","top","shaka.text.Cue.lineAlign.END","bottom","shaka.text.Cue.writingMode.VERTICAL_LEFT_TO_RIGHT","left","right","viewportAnchorUnit","paddingTop","shaka.text.Cue.positionAlign.LEFT","cssFloat","shaka.text.Cue.positionAlign.RIGHT","convertLengthValue_","lengthValue","matches","RegExp","unit","lengthValueInfo","clientHeight","mergeConfigObjects","destination","source","template","overrides","ignoreKeys","isValid","subPath","subTemplate","subMergeValid","shaka.util.ConfigUtils.mergeConfigObjects","convertToConfigObject","fieldName","configObject","last","searchIndex","nameStart","createDefault","abrMaxHeight","connection","downlink","saveData","drm","shaka.media.DrmEngine.defaultInitDataTransform","availabilityWindowOverride","NaN","disableAudio","disableVideo","disableText","defaultPresentationDelay","dash","clockSyncUri","ignoreDrmInfo","xlinkFailGracefully","ignoreMinBufferTime","initialSegmentLimit","ignoreSuggestedPresentationDelay","ignoreEmptyAdaptationSet","hls","ignoreTextStreamFailures","useFullSegmentsForStartTime","streaming","bufferingGoal","bufferBehind","startAtSegmentBoundary","useNativeHlsOnSafari","inaccurateManifestTolerance","offline","trackSelectionCallback","tracks","progressCallback","content","progress","usePersistentLicense","abrFactory","abr","preferredAudioLanguage","preferredTextLanguage","preferredVariantRole","preferredTextRole","playRangeStart","playRangeEnd","textDisplayFactory","offline.trackSelectionCallback","defaultTrackSelect","allVariants","selectedVariants","tracksByHeight","selectedTracks","middleIndex","shaka.util.PlayerConfiguration.defaultTrackSelect","updates","shaka.util.PlayerConfiguration.createDefault","open_","closed_","start_","timestamp","currentTimeSeconds","update_","getTimeSpentIn","entry","currentText_","history_","updateCurrentVariant","newVariant","fromAdaptation","updateCurrentText","newText","bandwidthEstimate_","currentStreamBandwidth_","maxSegmentDurationSeconds_","liveLatencySeconds_","drmTimeSeconds_","manifestTimeSeconds_","loadLatencySeconds_","totalCorruptedFrames_","totalDecodedFrames_","totalDroppedFrames_","height_","width_","stateHistory_","shaka.util.StateHistory","switchHistory_","shaka.util.SwitchHistory","dependencyInjector","loadMode_","shaka.Player.LoadMode.NOT_LOADED","abrManagerFactory_","abrManager_","assetUri_","parserFactory_","streamingEngine_","regionTimeline_","bufferObserver_","bufferPoller_","playRateController_","playheadObservers_","playhead_","mediaSourceEngine_","drmEngine_","networkingEngine_","nextExternalStreamId_","defaultConfig_","maxHwRes_","stats_","currentAdaptationSetCriteria_","currentTextLanguage_","currentTextRole_","cleanupOnUnload_","createNetworkingEngine","bytesDownloaded","adManager_","shaka.Player.adManagerFactory_","retryStreaming","detachNode_","attachNode_","unloadNode_","parserNode_","manifestNode_","mediaSourceNode_","drmNode_","loadNode_","srcEqualsDrmNode_","srcEqualsNode_","actions","wants","onAttach_","videoErrorToShakaError_","onVideoError_","onDetach_","onUnload_","onInitializeMediaSourceEngine_","closedCaptionsParser","textDisplayerFactory","lastTextFactory_","createMediaSourceEngine","shaka.media.MediaSourceEngine","dispatchMetadataEvent_","processTimedMetadataMediaSrc_","metadataType","frame","onHlsTimedMetadata","onInitializeParser_","assetUri","networkingEngine","manifestConfig","shaka.media.ManifestParser.getFactory","nodeName","onParseManifest_","setListeners","onAddRegion","onRegionEvent_","shaka.Player.EventName.TimelineRegionAdded","onDashTimedMetadata","filterManifest_","makeTextStreamsForClosedCaptions","makeTextStreamsForClosedCaptions_","closedCaptionsSet","CLOSED_CAPTION","emsgSchemeIdUris","onTimelineRegionAdded","findSimilarRegion_","schemeIdUri","similarRegion","makeEvent_","shaka.Player.EventName.ManifestParsed","shaka.util.Error.Code.NO_VARIANTS","filterForAVVariants_","isAVVariant","shaka.Player.filterForAVVariants_","delta","onInitializeDrm_","firstEvent","createDrmEngine","onKeyStatus_","onExpirationUpdated_","shaka.Player.EventName.DrmSessionUpdate","onLoad_","updateStateHistory","onRateChange","rebufferThreshold","initialVariant","initialTextStream","adjustedTime","updateStateHistory_","onRateChange_","this.abrManager_.playbackRateChanged","applyPlayRange_","fullDuration","shaka.Player.applyPlayRange_","onAdaptation_","createPlayhead","pollBufferState_","createPlayheadObserversForMSE_","regionObserver","onExit","onEnterRegion","shaka.Player.EventName.TimelineRegionEnter","onExitRegion","shaka.Player.EventName.TimelineRegionExit","onSkipRegion","manager","startBufferManagement_","createStreamingEngine","shaka.media.StreamingEngine","onManifestUpdate","onManifestUpdate_","onSegmentAppended_","shaka.Player.LoadMode.MEDIA_SOURCE","shaka.Player.EventName.Streaming","updateAbrManagerVariants_","chooseVariant_","addVariantToSwitchHistory_","shaka.util.StreamUtils.filterStreamsByLanguageAndRole","chooseTextStream_","addTextStreamToSwitchHistory_","shouldInitiallyShowText_","audioStream","shaka.util.LanguageUtils.areLanguageCompatible","preferredTextLocale","audioLocale","textLocale","setInitialTextState_","setTextVisibility","onTextTrackVisibility_","shouldStreamText_","isTextTrackVisible","activeAudio","activeVideo","getAdjustedTime","audioStartTime","videoStartTime","refTime","adjustStartTime_","onAbrStatusChanged_","onTracksChanged_","startTimeOfLoad","onInitializeSrcEqualsDrm_","onSrcEquals_","preload","audioTracks","processTimedMetadataSrcEqls_","activeCues","onCueMetadataChange","getMetadataTracks_","t","textTrack","shaka.Player.LoadMode.SRC_EQUALS","fullyLoaded","unloaded","setupPreferredAudioOnSrc_","selectAudioLanguage","getFilteredTextTracks_","setupPreferredTextOnSrc_","selectTextLanguage","abortedError","walker_","shaka.routing.Walker","walkerImplementation","at","goingTo","getNextStep_","getNextMatchingAllDependencies_","shaka.Player.EventName.OnStateChange","action","shaka.Player.EventName.OnStateIdle","cleanupTasks","shaka.Player.LoadMode.DESTROYED","shaka.Player.EventName.Unloading","onAssetUnload","shaka.util.Stats","updateBufferState_","shaka.Player.EventName.Metadata","shaka.media.BufferingObserver","updateBufferingSettings_","shaka.Player.TYPICAL_BUFFERING_THRESHOLD_","isBufferedToEndSrc_","fudge","isBufferedToEndMS_","liveEdge","bufferedToEnd","bufferLead","shaka.media.TimeRangesUtils.bufferedAheadOf","newState","applyConfig_","activeVariant","chooseVariantAndSwitch_","oldTextDisplayer","config.streaming.failureCallback","shaka.util.Error.Code.BAD_HTTP_STATUS","shaka.util.Error.Code.HTTP_ERROR","shaka.util.Error.Code.TIMEOUT","defaultStreamingFailureCallback_","config.textDisplayFactory","shaka.text.UITextDisplayer","shaka.text.SimpleTextDisplayer","isBuffering","shaka.Player.EventName.Buffering","shaka.Player.EventName.RateChange","history","checkRestrictedVariants_","playableVariants","adaptationSet","onVariantChanged_","delayDispatchEvent_","shaka.Player.EventName.Adaptation","shaka.Player.EventName.TracksChanged","shaka.Player.EventName.VariantChanged","onTextChanged_","shaka.Player.EventName.TextChanged","shaka.Player.EventName.TextTrackVisibility","shaka.Player.EventName.AbrStatusChanged","newStatus","shaka.Player.EventName.Error","detail","eventElement","msExtendedCode","shaka.util.Error.Code.VIDEO_ERROR","keyStatusMap","isGlobalStatus","tracksChanged","originalAllowed","keyStatus","shaka.Player.restrictedStatuses_.includes","currentVariant","shaka.Player.EventName.ExpirationUpdated","hasPlayable","hasAppRestrictions","missingKeys","badKeyStatuses","shaka.util.Error.Code.RESTRICTIONS_CANNOT_BE_MET","restrictedKeyStatuses","getLanguagesFrom_","languages","getLanguageAndRolesFrom_","languageToRoles","pairings","createAbortLoadError_","shaka.util.Error.Code.LOAD_INTERRUPTED","destinationNode","nextNode","resetNode","createEmptyPayload_","wrapWalkerListenersWithPromise_","listeners.onCancel","listeners.onEnd","listeners.onError","listeners.onSkip","failureRetryParams","initStreams_","shaka.util.Error.Category.STREAMING","shaka.util.Error.Code.STREAMING_ENGINE_STARTUP_INVALID_STATE","setDuration_","thisStream","mediaStates","shaka.media.StreamingEngine.isEmbeddedText_","timeNeeded","bufferedAhead","scaledBufferingGoal","textState","getSegmentReferenceNeeded_","minTimeNeeded","otherState","maxRunAhead","fetchAndAppend_","iter","initSourceBuffer","fetchSegment","results","initSourceBuffer_","setProperties","fetchInit","shaka.media.StreamingEngine.APPEND_WINDOW_START_FUDGE_","shaka.media.StreamingEngine.APPEND_WINDOW_END_FUDGE_","setStreamProperties","setAppendWindow","abort_","setTimestampOffset_","setAppendWindow_","reference1","reference2","shaka.media.InitSegmentReference.equal","schemeId","presentationTimeDelta","eventDuration","messageData","parseEMSG_","shaka.Player.EventName.Emsg","emsg","evict_","overflow","handleQuotaExceeded_","ms","percentBefore","round","removeInRange","flattenPayload","flattenedCues","flatCue","textTrackCues","cuesInTextTrack","inCue","cueInTextTrack","shaka.text.SimpleTextDisplayer.convertToTextTrackCue_","sortedCues","addCue","shaka.text.SimpleTextDisplayer.removeWhere_","removeIt","shaka.util.Dom","shaka.util.Dom.removeAllChildren","cuesList","cueInList","shaka.util.ConfigUtils","shaka.util.ConfigUtils.convertToConfigObject","shaka.util.PlayerConfiguration","shaka.util.PlayerConfiguration.mergeConfigObjects","shaka.Player","events","events.onStart","events.onEnd","events.onCancel","events.onError","events.onSkip","initializeMediaSource","detach","unload","currentPayload","shaka.Player.EventName.Loading","shouldUseSrcEquals_","shaka.util.Platform.supportsMediaSource","shaka.util.Error.Code.NO_VIDEO_ELEMENT","shaka.Player.EventName.Loaded","shaka.Player.prototype","arguments","resetConfiguration","getLoadMode","getMediaElement","getNetworkingEngine","getAssetUri","getAdManager","warnOnce","args","shaka.log.oneTimeWarningIssued_.add","shaka.log.alwaysWarn.apply","shaka.log","shaka.log.warnOnce","isAudioOnly","videoTracks","videoHeight","seekable","getPlaybackRate","trickPlay","cancelTrickPlay","getVariantTracks","shaka.util.StreamUtils.isPlayable","shaka.util.StreamUtils.variantToTrack","getTextTracks","currentTextStream","shaka.util.StreamUtils.textStreamToTrack","selectTextTrack","selectVariantTrack","getAudioLanguagesAndRoles","getTextLanguagesAndRoles","getAudioLanguages","shaka.Player.getLanguagesFrom_","getTextLanguages","selectedLanguage","languageMatch","languageAndRoleMatch","shaka.util.StreamUtils.html5AudioTrackToTrack","chosenText","selectVariantsByLabel","firstVariantWithLabel","expected","setTextTrackVisibility","isVisible","newVisibility","unloadTextStream","getPlayheadTimeAsDate","walkerPayload","getStartDate","startDate","getPresentationStartTimeAsDate","getStats","streamBandwidth","decodedFrames","droppedFrames","corruptedFrames","estimatedBandwidth","loadLatency","manifestTimeSeconds","drmTimeSeconds","playTime","pauseTime","bufferingTime","licenseTime","liveLatency","switchHistory","stateHistory","getVideoPlaybackQuality","totalVideoFrames","droppedVideoFrames","decoded","corruptedVideoFrames","licenseSeconds","valueOf","estimate","getCopy","mime","shaka.util.Error.Code.CANNOT_ADD_EXTERNAL_TEXT_TO_LIVE_STREAM","setMaxHardwareResolution","getManifest","getManifestParserFactory","setVideoContainer","filterManifest","drmEngine","shaka.media.MediaSourceEngine.isStreamSupported","shaka.util.StreamUtils.areStreamsCompatible_","keep","shaka.util.StreamUtils.filterManifest","shaka.util.Error.Code.CONTENT_UNSUPPORTED_BY_BROWSER","shaka.util.StreamUtils.meetsRestrictions","curDrmInfo","probeSupport","plugins","testKeySystems","basicVideoCapabilities","support","testSystem","tests","access","shaka.media.DrmEngine.probeSupport","testExtensions","testMimeTypes","shaka.util.Platform.supportsMediaType","basicType","media","shaka.Player.supportPlugins_","isBrowserSupported","shaka.util.Platform.safariVersion","setAdManagerFactory","registerSupportPlugin","AbrStatusChanged","Adaptation","Buffering","DrmSessionUpdate","Emsg","Error","ExpirationUpdated","Loaded","Loading","ManifestParsed","Metadata","OnStateChange","OnStateIdle","RateChange","Streaming","TextChanged","TextTrackVisibility","TimelineRegionAdded","TimelineRegionEnter","TimelineRegionExit","TracksChanged","Unloading","VariantChanged","shaka.Player.EventName","LargeGap","shaka.Player.LoadMode","shaka.Player.version","shaka.Deprecate.onPending_","shaka.Deprecate.onExpired_","shaka.Player.restrictedStatuses_","loadTimes_","skipped_","playedCompletely_","imaAd","imaAdManager","ad_","manager_","isPaused_","volume_","getVolume","google","ima","AdEvent","PAUSED","RESUMED","adContainer","adContainer_","requestAdsStartTime_","settings","setLocale","adDisplayContainer","AdDisplayContainer","initialize","adsLoader_","AdsLoader","getSettings","setPlayerType","setPlayerVersion","imaAdsManager_","AdsManagerLoadedEvent","ADS_MANAGER_LOADED","onAdsManagerLoaded_","shaka.ads.AdManager.ADS_LOADED","getAdsManager","shaka.ads.AdManager.IMA_AD_MANAGER_LOADED","cuePointStarts","getCuePoints","cuePoints","shakaCuePoint","shaka.ads.CuePoint","shaka.ads.AdManager.CUEPOINTS_CHANGED","addImaEventListeners_","AdErrorEvent","AD_ERROR","onAdError_","CONTENT_PAUSE_REQUESTED","onAdStart_","STARTED","FIRST_QUARTILE","shaka.ads.AdManager.AD_FIRST_QUARTILE","MIDPOINT","shaka.ads.AdManager.AD_MIDPOINT","THIRD_QUARTILE","shaka.ads.AdManager.AD_THIRD_QUARTILE","COMPLETE","shaka.ads.AdManager.AD_COMPLETE","CONTENT_RESUME_REQUESTED","onAdComplete_","ALL_ADS_COMPLETED","SKIPPED","shaka.ads.AdManager.AD_SKIPPED","VOLUME_CHANGED","shaka.ads.AdManager.AD_VOLUME_CHANGED","VOLUME_MUTED","shaka.ads.AdManager.AD_MUTED","shaka.ads.AdManager.AD_PAUSED","shaka.ads.AdManager.AD_RESUMED","SKIPPABLE_STATE_CHANGED","shaka.ads.AdManager.AD_SKIP_STATE_CHANGED","CLICK","shaka.ads.AdManager.AD_CLICKED","AD_PROGRESS","shaka.ads.AdManager.AD_PROGRESS","AD_BUFFERING","shaka.ads.AdManager.AD_BUFFERING","IMPRESSION","shaka.ads.AdManager.AD_IMPRESSION","DURATION_CHANGE","shaka.ads.AdManager.AD_DURATION_CHANGED","USER_CLOSE","shaka.ads.AdManager.AD_CLOSED","LOADED","shaka.ads.AdManager.AD_LOADED","shaka.ads.AdManager.ALL_ADS_COMPLETED","LINEAR_CHANGED","shaka.ads.AdManager.AD_LINEAR_CHANGED","AD_METADATA","shaka.ads.AdManager.AD_METADATA","LOG","shaka.ads.AdManager.AD_RECOVERABLE_ERROR","AD_BREAK_READY","shaka.ads.AdManager.AD_BREAK_READY","INTERACTION","shaka.ads.AdManager.AD_INTERACTION","offsetWidth","offsetHeight","fullscreenElement","ViewMode","FULLSCREEN","NORMAL","resize","adError","onended","this.video_.onended","contentComplete","getError","getAd","shaka.ads.ClientSideAd","shaka.ads.AdManager.AD_STARTED","setAttribute","shaka.ads.AdManager.AD_STOPPED","adProgressData_","streamPromise_","streamRequestStartTime_","isLiveContent_","snapForwardTime_","backupUrl_","uiSettings","dai","api","UiSettings","streamManager_","StreamManager","StreamEvent","onLoaded_","getStreamData","checkForSnapback_","streamTimeForContentTime","previousCuePoint","previousCuePointForStreamTime","played","AD_BREAK_STARTED","shaka.ads.ServerSideAd","AD_BREAK_ENDED","onAdBreakEnded_","onAdProgress_","adProgressData","CUEPOINTS_CHANGED","streamData","cuepoints","point","ssAdManager_","csAdManager_","shaka.ads.AdsStats","locale_","serialize","thing","simpleEvent","eventKey","eventValue","properties","getOwnPropertyNames","contents","ranges","deserialize","simulateTimeRanges_","getRemainingTime","isPaused","isSkippable","getSkipTimeOffset","getTimeUntilSkippable","skipOffset","canSkipIn","canSkipNow","getAdSkippableState","resume","setVolume","volume","isMuted","setMuted","muted","getSequenceLength","podInfo","getAdPodInfo","getTotalAds","getPositionInSequence","getAdPosition","shaka.ads.ClientSideAdManager","shaka.ads.ServerSideAdManager","onTimedMetadata","shaka.ads.AdManager","initClientSide","shaka.util.Error.Category.ADS","shaka.util.Error.Code.CS_IMA_SDK_MISSING","loadTime","requestClientSideAds","imaRequest","shaka.util.Error.Code.CS_AD_MANAGER_NOT_INITIALIZED","requestAds","initServerSide","shaka.util.Error.Code.SS_IMA_SDK_MISSING","requestServerSideStream","backupUrl","shaka.util.Error.Code.SS_AD_MANAGER_NOT_INITIALIZED","adTagParameters","adTagParams","shaka.util.Error.Code.CURRENT_DAI_REQUEST_NOT_FINISHED","LiveStreamRequest","requestStream","replaceServerSideAdTagParameters","replaceAdTagParameters","loadTimes","started","playedCompletely","skipped","getAttribute","processMetadata","shaka.cast.CastUtils.VideoEvents","shaka.cast.CastUtils.VideoAttributes","shaka.cast.CastUtils.VideoInitStateAttributes","shaka.cast.CastUtils.VideoVoidMethods","shaka.cast.CastUtils.PlayerGetterMethods","shaka.cast.CastUtils.PlayerGetterMethodsThatRequireLive","shaka.cast.CastUtils.PlayerInitState","shaka.cast.CastUtils.PlayerInitAfterLoadState","shaka.cast.CastUtils.PlayerVoidMethods","shaka.cast.CastUtils.PlayerPromiseMethods","receiverAppId","onStatusChanged","onFirstCastStateUpdate","onRemoteEvent","onResumeLocal","onInitStateRequired","receiverAppId_","statusChangeTimer_","onFirstCastStateUpdate_","hasJoinedExistingSession_","onRemoteEvent_","onResumeLocal_","onInitStateRequired_","isCasting_","apiReady_","receiverName_","appData_","onConnectionStatusChangedBound_","this.onConnectionStatusChangedBound_","onConnectionStatusChanged_","onMessageReceivedBound_","this.onMessageReceivedBound_","namespace","serialized","shaka.cast.CastUtils.deserialize","targetName","fakeEvent","property","onMessageReceived_","cachedProperties_","asyncCallPromises_","reconstructedError","nextAsyncCallId_","castPromise_","onSessionInitiated_","initState","shaka.cast.CastSender.session_","addUpdateListener","onSessionCreated_","addMessageListener","shaka.cast.CastUtils.SHAKA_MESSAGE_NAMESPACE","sendMessage_","onConnectionError_","shaka.util.Error.Code.UNEXPECTED_CAST_ERROR","shaka.util.Error.Code.CAST_CANCELED_BY_USER","shaka.util.Error.Code.CAST_CONNECTION_TIMED_OUT","shaka.util.Error.Code.CAST_RECEIVER_APP_UNAVAILABLE","shaka.util.Error.Category.CAST","onExistingSessionJoined_","removeListeners_","removeUpdateListener","removeMessageListener","connected","shaka.cast.CastSender.session_.status","rejectAllPromises_","shaka.cast.CastSender.session_.receiver.friendlyName","receiver","friendlyName","shaka.cast.CastUtils.serialize","sendMessage","shaka.log.error","forceDisconnect","shaka.cast.CastSender.instances_.delete","isCasting","receiverName","chrome","isAvailable","sessionRequest","SessionRequest","apiConfig","ApiConfig","shaka.cast.CastSender.instances_","instance","availability","shaka.cast.CastSender.hasReceivers_","shaka.cast.CastSender.STATUS_DELAY","oldSession","SessionStatus","STOPPED","setAppData","appData","shaka.util.Error.Code.CAST_API_UNAVAILABLE","shaka.util.Error.Code.NO_CAST_RECEIVERS","shaka.util.Error.Code.ALREADY_CASTING","requestSession","shaka.cast.CastSender.prototype","shaka.cast.CastSender.session_.stop","shaka.cast.CastUtils.VideoVoidMethods.includes","remoteCall_","shaka.cast.CastUtils.PlayerVoidMethods.includes","shaka.cast.CastUtils.PlayerPromiseMethods.includes","remoteAsyncCall_","methodName","player","localVideo_","localPlayer_","playerEventTarget_","videoEventTarget_","playerProxy_","videoProxy_","compiledToExternNames_","sender_","shaka.cast.CastSender","onCastStatusChanged_","getInitState_","videoProxyLocalEvent_","playerProxyLocalEvent_","configurable","videoProxyGet_","videoProxySet_","iterateOverPlayerMethods_","playerProxyGet_","mapCompiledToUncompiledPlayerMethodNames_","methodsToNames","name2","shouldAddToTheMap","seenNames","proto","getPrototypeOf","objProto","pair","setter","manifestReady","autoplay","videoState","appDataCallback","contentIdCallback","player_","targets_","appDataCallback_","contentIdCallback_","isConnected_","isIdle_","updateNumber_","startUpdatingUpdateNumber_","initialStatusUpdatePending_","genericBus_","shakaBus_","pollTimer_","pollAttributes_","CastReceiverManager","getInstance","onSenderConnected","manager.onSenderConnected","onSendersChanged_","onSenderDisconnected","manager.onSenderDisconnected","onSystemVolumeChanged","manager.onSystemVolumeChanged","systemVolume","getSystemVolume","fakeVolumeChangeEvent_","getCastMessageBus","shaka.cast.CastUtils.GENERIC_MESSAGE_NAMESPACE","onMessage","this.genericBus_.onMessage","onGenericMessage_","sendMediaStatus_","resumeState","sendMediaInfoMessage_","volumeObject","oldVolumeLevel","oldVolumeMuted","mediaInfo","customData","this.shakaBus_.onMessage","onShakaMessage_","initState_","setSystemVolumeLevel","setSystemVolumeMuted","senderId","sendAsyncComplete_","proxyEvent_","canDisplayType","shaka.cast.CastReceiver.IDLE_INTERVAL","getSenders","maybeSendMediaInfoMessage_","shaka.cast.CastReceiver.POLL_INTERVAL","requestId","bus","getCastChannel","send","broadcast","mediaStatus","getPlayState_","shaka.cast.CastReceiver.PLAY_STATE.IDLE","shaka.cast.CastReceiver.PLAY_STATE.BUFFERING","shaka.cast.CastReceiver.PLAY_STATE.PAUSED","shaka.cast.CastReceiver.PLAY_STATE.PLAYING","__onGCastApiAvailable","shaka.cast.CastSender.onSdkLoaded_","sender","shaka.cast.CastProxy","waitFor","getVideo","getPlayer","canCast","suggestDisconnect","showDisconnectDialog","changeReceiverId","newAppId","shaka.cast.CastReceiver","isConnected","isIdle","setContentMetadata","clearContentMetadata","setContentTitle","title","MetadataType","GENERIC","setContentImage","imageUrl","setContentArtist","artist","MUSIC_TRACK","IDLE","PLAYING","BUFFERING","psshBox","systemIds","cencKeyIds","pssh","numKeyIds","parsePsshBox_","findChild","elem","children","shaka.util.XmlUtils.findChildren","findChildNS","ns","shaka.util.XmlUtils.findChildrenNS","findChildren","findChildrenNS","localName","namespaceURI","getAttributeNS","hasAttributeNS","getContents","isText","nodeType","Node","TEXT_NODE","CDATA_SECTION_NODE","trim","parseAttr","parseFunction","defaultValue","parsedValue","parseDate","dateString","parseDuration","durationString","d","parseRange","rangeString","isFinite","intString","parsePositiveInt","parseNonNegativeInt","evalDivision","exprString","res","parseXmlString","xmlString","expectedRootElemName","rootElem","documentElement","parseXml","shaka.util.XmlUtils.parseXmlString","parseFromAdaptationSet","elems","parsed","parseElements_","shaka.dash.ContentProtection.parseElement_","shaka.dash.ContentProtection.parseElements_","defaultInit","parsedNonCenc","shaka.util.Error.Code.DASH_CONFLICTING_KEY_IDS","shaka.dash.ContentProtection.MP4Protection_","schemeUri","convertElements_","elements","shaka.dash.ContentProtection.defaultKeySystems_.get","proNode","shaka.util.XmlUtils.findChildNS","systemId","dataLength","psshSize","psshData","byteCursor","shaka.util.ManifestParserUtils.createDrmInfo","proInitData","licenseParser","shaka.dash.ContentProtection.licenseUrlParsers_.get","shaka.dash.ContentProtection.convertElements_","shaka.dash.ContentProtection.defaultKeySystems_.values","defaultKeyId","firstRepresentation","parseElement_","shaka.util.XmlUtils.getAttributeNS","shaka.dash.ContentProtection.CencNamespaceUri_","psshs","shaka.util.XmlUtils.getContents","shaka.util.Error.Code.DASH_MULTIPLE_KEY_IDS_NOT_SUPPORTED","shaka.util.Error.Code.DASH_PSSH_BAD_ENCODING","shaka.dash.ContentProtection.defaultKeySystems_","shaka.dash.ContentProtection.licenseUrlParsers_","getWidevineLicenseUrl","mslaurlNode","getPlayReadyLicenseUrl","record","parseMsPro_","records","recordValue","shaka.dash.ContentProtection.parseMsPro_","rootElement","getLaurl_","shaka.dash.ContentProtection.getLaurl_","fillUriTemplate","uriTemplate","representationId","number","valueTable","re","widthStr","format","valueString","parseSegmentInfo","context","timescaleStr","shaka.dash.MpdUtils.inheritAttribute","shaka.util.XmlUtils.parsePositiveInt","segmentDuration","durationStr","startNumberStr","unscaledPresentationTimeOffset","startNumber","shaka.util.XmlUtils.parseNonNegativeInt","timelineNode","shaka.dash.MpdUtils.inheritChild","periodInfo","timePoints","lastEndTime","timePoint","shaka.util.XmlUtils.parseAttr","shaka.util.XmlUtils.parseInt","repeat","nextStartTime","ceil","periodDuration","unscaledStart","scaledPresentationTimeOffset","inheritAttribute","attribute","representation","period","shaka.util.Functional.isNotNull","inheritChild","processXlinks","failGracefully","baseUri","linkDepth","shaka.dash.MpdUtils.XlinkNamespaceUri_","handleXlinkInElement_","xlinkHref","xlinkActuate","attributes","removeAttributeNS","shaka.util.Error.Code.DASH_XLINK_DEPTH_LIMIT","shaka.util.Error.Code.DASH_UNSUPPORTED_XLINK_ACTUATE","shaka.util.ManifestParserUtils.resolveUris","shaka.util.XmlUtils.parseXml","shaka.util.Error.Code.DASH_INVALID_XML","setAttributeNode","cloneNode","shaka.dash.MpdUtils.processXlinks","shaka.dash.MpdUtils.handleXlinkInElement_","childOperations","resolveToZeroString","sidxData","sidxOffset","parseSIDX_","shaka.util.Error.Code.MP4_SIDX_INVALID_TIMESCALE","earliestPresentationTime","firstOffset","referenceCount","chunk","referenceType","referenceSize","subsegmentDuration","shaka.util.Error.Code.MP4_SIDX_TYPE_NOT_SUPPORTED","unscaledStartTime","shaka.media.Mp4SegmentIndexParser.parseSIDX_","shaka.util.Error.Code.MP4_SIDX_WRONG_BOX_TYPE","reader_","parseElement","vint","parseVint_","parseId_","shaka.util.Error.Code.EBML_OVERFLOW","shaka.util.EbmlParser.DYNAMIC_SIZES","dynamicSizeConst","elementSize","shaka.util.EbmlElement","firstByte","log2","shaka.util.EbmlParser","getUint","parseCuePoint_","cuePointElement","shaka.media.WebmSegmentIndexParser.CUE_TIME_ID","cueTimeElement","shaka.util.Error.Code.WEBM_CUE_TIME_ELEMENT_MISSING","shaka.media.WebmSegmentIndexParser.CUE_TRACK_POSITIONS_ID","unscaledTime","cueTrackPositionsElement","shaka.util.Error.Code.WEBM_CUE_TRACK_POSITIONS_ELEMENT_MISSING","cueTrackParser","relativeOffset","shaka.media.WebmSegmentIndexParser.CUE_CLUSTER_POSITION","createInitSegment","initialization","resolvedUris","shaka.util.XmlUtils.parseRange","createStreamInfo","requestInitSegment","shaka.dash.SegmentBase.fromInheritance_","shaka.dash.SegmentBase.createInitSegment","checkSegmentIndexRangeSupport_","shaka.dash.SegmentBase.checkSegmentIndexSupport","shaka.dash.SegmentBase.computeIndexRange_","shaka.util.Error.Code.DASH_NO_SEGMENT_INFO","shallowCopyOfContext","shaka.util.ObjectUtils.shallowCloneObject","generateSegmentIndex","representationIndex","indexUris","shaka.dash.SegmentBase.generateSegmentIndexFromUris","representationUri","indexRange","generateSegmentIndexFromUris","fitLast","containerType","localRequest","responses","indexData","dynamic","isLastPeriod","shaka.media.WebmSegmentIndexParser.EBML_ID","shaka.util.Error.Code.WEBM_EBML_HEADER_ELEMENT_MISSING","segmentElement","shaka.media.WebmSegmentIndexParser.SEGMENT_ID","shaka.util.Error.Code.WEBM_SEGMENT_ELEMENT_MISSING","infoElement","segmentOffset","shaka.media.WebmSegmentIndexParser.INFO_ID","shaka.util.Error.Code.WEBM_INFO_ELEMENT_MISSING","durationScale","timecodeScaleNanoseconds","shaka.media.WebmSegmentIndexParser.TIMECODE_SCALE_ID","shaka.media.WebmSegmentIndexParser.DURATION_ID","getFloat32","shaka.util.Error.Code.EBML_BAD_FLOATING_POINT_SIZE","getFloat64","shaka.util.Error.Code.WEBM_DURATION_ELEMENT_MISSING","shaka.media.WebmSegmentIndexParser.CUES_ID","timecodeScale","segmentInfo","cuesElement","cuesData","shaka.util.Error.Code.WEBM_CUES_ELEMENT_MISSING","parseCues_","lastTime","lastOffset","shaka.media.WebmSegmentIndexParser.CUE_POINT_ID","tuple","shaka.media.WebmSegmentIndexParser.parseCuePoint_","currentOffset","shaka.media.WebmSegmentIndexParser.parseCues_","fromInheritance_","segmentBase","computeIndexRange_","indexRangeElem","checkSegmentIndexSupport","shaka.util.Error.Code.DASH_UNSUPPORTED_CONTAINER","shaka.util.Error.Code.DASH_WEBM_MISSING_INIT","segmentIndexMap","shaka.dash.SegmentList.fromInheritance_","parseSegmentListInfo_","mediaSegments","parseMediaSegments_","segmentList","urlNode","indexRangeWarningGiven","mediaUri","shaka.dash.SegmentList.parseMediaSegments_","shaka.dash.MpdUtils.parseSegmentInfo","shaka.dash.SegmentList.parseSegmentListInfo_","createSegmentReferences_","prevEndTime","shaka.dash.SegmentList.createSegmentReferences_","isUpdate","segmentLimit","createInitSegment_","shaka.dash.SegmentTemplate.fromInheritance_","repId","filledTemplate","shaka.dash.MpdUtils.fillUriTemplate","shaka.dash.SegmentTemplate.createInitSegment_","parseSegmentTemplateInfo_","mediaTemplate","indexTemplate","shaka.dash.SegmentTemplate.parseSegmentTemplateInfo_","checkSegmentTemplateInfo_","generateSegmentIndexFromDuration_","createReference","segmentPeriodTime","segmentMediaTime","periodEnd","computeAvailablePositionRange","availablePeriodTimes","availablePresentationTimes","availablePeriodPositions","maxPosition","nextPosition","createFromTimeline_","segmentReplacement","timeReplacement","createUris","g","shaka.dash.SegmentTemplate.createFromTimeline_","shouldFit","segmentTemplate","audioStreams_","videoStreams_","textStreams_","usedPeriodIds_","combinePeriods","periods","isDynamic","firstPeriod","firstNewPeriodIndex","audioStreamsPerPeriod","videoStreamsPerPeriod","textStreamsPerPeriod","nextVariantId","commonDrmInfos","filterOutAudioStreamDuplicates_","filteredAudios","audioStreams","a1","duplicate","a2","shaka.util.ArrayUtils.hasSameElements","filterOutVideoStreamDuplicates_","filteredVideos","videoStreams","shaka.util.MapUtils.hasSameElements","filterOutTextStreamDuplicates_","filteredTexts","t1","t2","shaka.util.PeriodCombiner.combine_","shaka.util.PeriodCombiner.cloneStream_","shaka.util.PeriodCombiner.concatenateStreams_","shaka.media.DrmEngine.getCommonDrmInfos","combineDbStreams","streamDbsPerPeriod","audioStreamDbsPerPeriod","videoStreamDbsPerPeriod","textStreamDbsPerPeriod","combinedAudioStreamDbs","combinedVideoStreamDbs","combinedTextStreamDbs","combinedStreamDbs","variantIds","shaka.util.PeriodCombiner.cloneStreamDB_","shaka.util.PeriodCombiner.concatenateStreamDBs_","combine_","outputStreams","streamsPerPeriod","unusedStreamsPerPeriod","unusedStreams","outputStream","extendExistingOutputStream_","shaka.util.PeriodCombiner.findMatchesInAllPeriods_","shaka.util.PeriodCombiner.extendExistingOutputStream_","shaka.util.Error.Code.PERIOD_FLATTENING_FAILED","createNewOutputStream_","shaka.util.PeriodCombiner.createNewOutputStream_","extendOutputStream_","used","shaka.util.LanguageUtils.relatedness","cloneStream_","assign","clone.createSegmentIndex","cloneStreamDB_","streamDb","concatenateStreams_","input","shaka.util.Error.Code.INCONSISTENT_DRM_ACROSS_PERIODS","concatenateStreamDBs_","findMatchesInAllPeriods_","areCompatible","shaka.util.PeriodCombiner.areAVStreamsCompatible_","shaka.util.PeriodCombiner.areTextStreamsCompatible_","isBetterMatch","shaka.util.PeriodCombiner.isAudioStreamBetterMatch_","shaka.util.PeriodCombiner.isVideoStreamBetterMatch_","shaka.util.PeriodCombiner.isTextStreamBetterMatch_","best","areAVStreamsCompatible_","areTextStreamsCompatible_","isAudioStreamBetterMatch_","bestRelatedness","candidateRelatedness","candidateRoleMatches","bestRoleMatches","channelsBetterOrWorse","shaka.util.PeriodCombiner.compareClosestPreferLower","shaka.util.PeriodCombiner.BetterOrWorse.BETTER","shaka.util.PeriodCombiner.BetterOrWorse.WORSE","sampleRateBetterOrWorse","shaka.util.PeriodCombiner.compareClosestPreferMinimalAbsDiff_","isVideoStreamBetterMatch_","resolutionBetterOrWorse","frameRateBetterOrWorse","isTextStreamBetterMatch_","compareClosestPreferLower","outputValue","bestValue","candidateValue","compareClosestPreferMinimalAbsDiff_","absDiffCandidate","absDiffBest","shaka.util.PeriodCombiner.BetterOrWorse.EQUAL","shaka.util.PeriodCombiner","BETTER","EQUAL","WORSE","manifestUris_","globalId_","segmentIndexMap_","periodCombiner_","updatePeriod_","averageUpdateDuration_","updateTimer_","requestManifest_","updateDuration","unshift","parseManifest_","finalManifestUri","mpd","xlinkOperation","finalMpd","processManifest_","manifestBaseUris","locations","absoluteLocations","suggestedPresentationDelay","mpdType","periodsAndDuration","timingElements","shaka.util.XmlUtils.parseDuration","shaka.util.XmlUtils.parseDate","presentationDuration","prevEnd","periodNodes","givenDuration","nextStart","parsePeriod_","parsePeriods_","durationDerivedFromPeriods","parseUtcTiming_","schemesAndValues","sv","date","requestForTiming_","createFrame_","eventStreamNodes","parseEventStream_","adaptationSets","parseAdaptationSet_","main","roleElements","roleValues","SUBTITLE","roleElement","essentialProperties","trickModeFor","unrecognizedEssentialProperty","accessibilities","channelId","captionStr","channel","channelAndLanguage","startsWith","contentProtectionElems","contentProtection","shaka.dash.ContentProtection.parseFromAdaptationSet","labelElements","firstLabelElement","representations","parseRepresentation_","isPrimary","verifyRepresentation_","requestInitSegment_","streamInfo","shaka.dash.SegmentBase.createStreamInfo","shaka.dash.SegmentList.createStreamInfo","shaka.dash.SegmentTemplate.createStreamInfo","parseFromRepresentation","repContext","asUnknown","repUnencrypted","asInfo","repInfo","shaka.util.Error.Code.DASH_NO_COMMON_KEY_SYSTEM","shaka.dash.ContentProtection.parseFromRepresentation","supplementalPropertyElems","expectedUri","expectedValue","numChannels","shaka.util.Error.Code.DASH_EMPTY_ADAPTATION_SET","shaka.dash.DashParser.guessContentType_","repIds","representationIds","uniqueIds","shaka.util.Error.Code.DASH_DUPLICATE_REPRESENTATION_ID","normalAdaptationSets","as","trickModeAdaptationSets","targetIds","trickModeSet","normalSet","MimeUtils","shaka.util.MimeUtils","trickStream","getCodecBase","audioSets","getSetsOfType_","videoSets","textSets","shaka.util.Error.Code.DASH_EMPTY_PERIOD","audioSet","videoSet","textSet","setUpdateTimer_","shaka.dash.DashParser.MIN_UPDATE_PERIOD_","parent","shaka.util.XmlUtils.evalDivision","schemeIdUris","inBandEventStreams","parseAudioChannels_","audioChannelConfigs","intValue","hexValue","numBits","shaka.util.XmlUtils.findChild","requestUris","shaka.net.NetworkingEngine.RequestType.TIMING","eventNode","guessContentType_","tags","getAttributeValue","getRequiredAttrValue","shaka.util.Error.Code.HLS_REQUIRED_ATTRIBUTE_MISSING","filterTagsByName","tag","filterTagsByType","tagType","getFirstTagWithName","tagsWithName","shaka.hls.Utils.filterTagsByName","getFirstTagWithNameAsNumber","shaka.hls.Utils.getFirstTagWithName","data_","skipWhitespace","readRegex","regex","lastIndex","indexOf_","atEnd","readRegexReturnCapture_","parsePlaylist","absolutePlaylistUri","lines","shaka.util.Error.Code.HLS_PLAYLIST_HEADER_MISSING","playlistType","MASTER","shaka.hls.ManifestTextParser.parseTag","parseTag_","shaka.hls.ManifestTextParser.MEDIA_PLAYLIST_TAGS.includes","MEDIA","shaka.hls.ManifestTextParser.SEGMENT_TAGS.includes","shaka.util.Error.Code.HLS_INVALID_PLAYLIST_HIERARCHY","segmentsData","segmentTags","currentMapTag","absoluteSegmentUri","absoluteMediaPlaylistUri","shaka.hls.Segment","shaka.hls.Playlist","tagUri","shaka.hls.Attribute","parseTag","word","blocks","shaka.util.Error.Code.INVALID_HLS_TAG","blockAttrs","blockValue","shaka.util.TextParser","valueRegex","attributeRegex","shaka.hls.Tag","updateDelay","shaka.dash.DashParser.prototype","shaka.dash.DashParser","tagStr","appendages","attrToStr","attr","shaka.hls.ManifestTextParser.MEDIA_PLAYLIST_TAGS","shaka.hls.ManifestTextParser.SEGMENT_TAGS","shaka.net.DataUriPlugin.parseRaw","originalUri","parseRaw","shaka.util.Error.Code.MALFORMED_DATA_URI","infoAndData","dataStr","typeInfoList","base64Encoded","globalVariables_","groupIdToStreamInfosMap_","variantUriSet_","uriToStreamInfosMap_","presentationTimeline_","masterPlaylistUri_","manifestTextParser_","shaka.hls.ManifestTextParser","updatePlaylistDelay_","updatePlaylistTimer_","presentationType_","shaka.hls.HlsParser.PresentationType_.VOD","maxTargetDuration_","minTargetDuration_","segmentsToNotifyByStream_","groupIdToClosedCaptionsMap_","aesEncrypted_","groupIdToCodecsMap_","playlistStartTime_","mapTagToInitSegmentRefMap_","discontinuityToTso_","updateStream_","PresentationType","manifestUri","playlist","variablesTags","mediaVariables","newestSegment","shaka.hls.HlsParser.PresentationType_","makeNetworkRequest_","parseMediaVariables_","createSegments_","verbatimMediaPlaylistUri","mediaSequenceToStartTime","setPresentationType_","VOD","variableTag","mediaImport","globalValue","getCodecsForVariantTag_","defaultCodecsArray","seen","shortCodec","getLanguage_","languageValue","createStreamInfoFromMediaTag_","groupId","defaultAttrValue","characteristics","variableSubstitution_","channels","createStreamInfo_","drmTags","segmentKeyTags","drmTag","keyFormat","drmParser","minTimestamp","characteristic","shaka.hls.HlsParser.KEYFORMATS_TO_DRM_PARSERS_","shaka.util.Error.Code.HLS_KEYFORMATS_NOT_SUPPORTED","determinePresentationType_","presentationTypeTag","endListTag","isVod","isEvent","shaka.hls.HlsParser.PresentationType_.LIVE","shaka.hls.HlsParser.PresentationType_.EVENT","targetDurationTag","getRequiredTag_","targetDuration","guessMimeType_","variables","firstSegmentUri","parsedUri","headRequest","contentMimeType","shaka.hls.HlsParser.EXTENSION_MAP_BY_CONTENT_TYPE_","shaka.util.Error.Code.HLS_COULD_NOT_GUESS_MIME_TYPE","shaka.hls.HlsParser.RAW_FORMATS_.includes","shaka.util.Error.Code.HLS_INTERNAL_SKIP_STREAM","maxTimestamp","getInitSegmentReference_","playlistUri","mapTag","mapTagKey","absoluteInitSegmentUri","initSegmentRef","createInitSegmentReference_","byterange","createSegmentReference_","previousReference","hlsSegment","extinfValues","notifySegments_","hlsSegments","mediaSequenceNumber","firstStartTime","discontintuitySequenceNum","isLive_","shaka.hls.Utils.getFirstTagWithNameAsNumber","it","discontintuityTag","getTimestampOffset_","mediaStartTime","fetchStartOfSegment_","fullRequest","partialRequest","shaka.hls.HlsParser.START_OF_SEGMENT_SIZE_","isDiscontinuity","segmentRef","fetches","segmentResponse","initSegmentResponse","getStartTimeFromMp4Segment_","segmentUri","mediaData","shaka.util.Error.Code.HLS_COULD_NOT_PARSE_SEGMENT_START_TIME","parsedMedia","getStartTimeFromTsSegment_","skipPacket","packetStart","syncByte","fail","flagsAndPacketId","adaptationFieldControl","ptsDtsIndicator","pts0","pts1","pts2","shaka.hls.HlsParser.TS_TIMESCALE_","guessCodecs_","guessCodecsSafe_","shaka.util.Error.Code.HLS_COULD_NOT_GUESS_CODECS","shaka.hls.HlsParser.CODEC_REGEXPS_BY_CONTENT_TYPE_","newUri","uriVariables","variableName","variable","replaceValue","shaka.util.Error.Code.HLS_VARIABLE_NOT_FOUND","shaka.util.Error.Code.HLS_REQUIRED_TAG_MISSING","shaka.net.DataUriPlugin","shaka.net.DataUriPlugin.parse","mediaTags","variantTags","minFirstTimestamp","minDuration","shaka.util.Error.Code.HLS_MASTER_PLAYLIST_NOT_PROVIDED","parseMasterVariables_","variantTag","audioGroupId","videoGroupId","subGroupId","allCodecs","parseCodecs_","textCodecs","createStreamInfosFromMediaTags_","promises","closedCaptionsTags","shaka.hls.Utils.filterTagsByType","instreamId","parseClosedCaptions_","createVariantsForTags_","variantsPromises","resolution","streamInfos","createStreamInfosForVariantTag_","ignoreStream","streamURI","hasSameUri","videoCodecs","hasVideoRelatedInfo","createStreamInfoFromVariantTag_","closedCaptionsAttr","getClosedCaptions_","filterLegacyCodecs_","createVariants_","audioInfos","videoInfos","audioInfo","videoInfo","videoStream","audioDrmInfos","videoDrmInfos","variantUriKey","parseTexts_","subtitleTags","textStreamPromises","textStreamInfos","shaka.util.Error.Code.HLS_AES_128_ENCRYPTION_NOT_SUPPORTED","createPresentationTimeline_","LIVE","pending","shaka.hls.HlsParser.prototype","shaka.hls.HlsParser","shaka.hls.HlsParser.AUDIO_CODEC_REGEXPS_","shaka.hls.HlsParser.VIDEO_CODEC_REGEXPS_","shaka.hls.HlsParser.TEXT_CODEC_REGEXPS_","shaka.hls.HlsParser.RAW_FORMATS_","shaka.hls.HlsParser.AUDIO_EXTENSIONS_TO_MIME_TYPES_","shaka.hls.HlsParser.VIDEO_EXTENSIONS_TO_MIME_TYPES_","shaka.hls.HlsParser.TEXT_EXTENSIONS_TO_MIME_TYPES_","widevineDrmParser_","VALID_METHODS","parsedData","EVENT","makeResponse","responseURL","responseText","progressUpdated","shaka.net.HttpFetchPlugin.Headers_","controller","shaka.net.HttpFetchPlugin.AbortController_","abortStatus","canceled","timedOut","timeoutMs","request_","fetch","ReadableStream","arrayBuffer","lastLoaded","contentLengthRaw","contentLength","shaka.net.HttpFetchPlugin.fetch_","shaka.net.HttpFetchPlugin.ReadableStream_","getReader","readObj","read","done","enqueue","shaka.net.HttpPluginUtils.makeResponse","shaka.net.HttpFetchPlugin.request_","signal","credentials","timer","isSupported","AbortController","shaka.net.HttpFetchPlugin","shaka.net.HttpFetchPlugin.isSupported","shaka.net.HttpFetchPlugin.parse","Headers","xhr","shaka.net.HttpXHRPlugin.Xhr_","open","responseType","withCredentials","onabort","xhr.onabort","onload","xhr.onload","headerLines","getAllResponseHeaders","onerror","xhr.onerror","ontimeout","xhr.ontimeout","onprogress","xhr.onprogress","lengthComputable","setRequestHeader","shaka.net.NetworkingEngine.PluginPriority.PREFERRED","shaka.net.HttpXHRPlugin","shaka.net.HttpXHRPlugin.parse","XMLHttpRequest","actualDownloaded_","estimatedDownloaded_","estimatedTotal_","pending_","nextId_","groups_","abortCallbacks_","onProgress_","this.onProgress_","onInitData_","this.onInitData_","estimator_","shaka.offline.DownloadProgressEstimator","abortAll","queue","estimatedByteLength","isInitSegment","onDownloaded","fetchSegment_","abortCallback","shaka.util.Error.Category.STORAGE","shaka.util.Pssh","transaction","storeName","transaction_","store_","objectStore","promise_","transaction.onabort","transaction.onerror","oncomplete","transaction.oncomplete","forEachEntry","req","openCursor","onsuccess","req.onsuccess","cursor","connection_","startReadWriteOperation","store","shaka.offline.indexeddb.DBOperation","stopTracking_","segmentStore","manifestStore","shaka.offline.indexeddb.DBConnection","segmentStore_","manifestStore_","shaka.util.Error.Code.NEW_KEY_OPERATION_NOT_SUPPORTED","onRemove","get_","missing","request.onsuccess","shaka.util.Error.Code.KEY_NOT_FOUND","mechanisms_","getCell","mechanismName","cellName","mechanism","shaka.util.Error.Code.MISSING_STORAGE_CELL","cell","getCells","register","shaka.offline.StorageMuxer.registry_.set","shaka.net.NetworkingEngine.PluginPriority.FALLBACK","actual","shaka.offline.DownloadManager","hasFixedKeySpace","addSegments","removeSegments","getSegments","rawSegments","convertSegmentData","addManifests","updateManifestExpiration","newExpiration","put","removeManifests","getManifests","rawManifests","convertManifest","getAllManifests","old","shaka.offline.indexeddb.BaseStorageCell.prototype","shaka.offline.indexeddb.EmeSessionStorageCell","getAll","shaka.offline.indexeddb.StorageMechanism.SESSION_ID_STORE","sessionIds","shaka.offline.StorageMuxer","destroys","mech","initPromises","unregister","shaka.offline.StorageMuxer.registry_.delete","shaka.offline.StorageMuxer.register","shaka.offline.StorageMuxer.registry_","shaka.offline.indexeddb.BaseStorageCell.apply","fillMissingVariants_","nextId","variantId","shaka.offline.indexeddb.V1StorageCell.fillMissingVariants_","convertStream_","initSegmentKey","initSegmentUri","shaka.offline.indexeddb.V1StorageCell.getKeyFromSegmentUri_","presentationTimeOffset","dataKey","shaka.util.Error.Code.MALFORMED_OFFLINE_URI","sessions_","v5_","v3_","v2_","v1_","db_","type_","mechanism_","cell_","key_","asString_","shaka.offline.OfflineUri","fromManifestDB","manifestDB","streamDB","createVariants","audios","videos","variantMap","fromStreamDB_","fromSegmentDB_","segmentDB","fromInitSegmentDB_","uri_","offlineUri","shaka.offline.OfflineUri.parse","getSegment_","muxer","delete","deleted","bucket","shaka.offline.SessionDeleter.isCompatible_","doDelete_","initForRemoval","licenseUri","removeSession","tasks","isCompatible_","comp","y","converter","shaka.offline.ManifestConverter","appMetadata","shaka.offline.StoredContentUtils.getTracks_","originalManifestUri","getTracks_","getPlayableVariants","shaka.util.StreamUtils.getPlayableVariants","estimateByStreamId_","getEstimate_","bitRate","shaka.util.Error.Code.LOCAL_PLAYER_INSTANCE_REQUIRED","segmentsFromStore_","openOperations_","openDownloadManagers_","initSegmentDbKeyCache_","segmentDbKeyCache_","destroyNetworkingEngine","awaits","dl","getCapabilities_","manifestDb","isVideo","removeFromDRM_","deleteLicenseFor_","net","drmConfig","sessionIdCell","deletedSessionIds","getEmeSessionCell","mechanisms","shaka.util.Error.Code.STORAGE_NOT_SUPPORTED","shaka.offline.Storage.getCapabilities_","shaka.offline.Storage.deleteLicenseFor_","removeFromStorage_","storage","segmentIds","getAllSegmentIds_","shaka.offline.Storage.getAllSegmentIds_","createStream_","downloader","estimator","downloadGroup","forEachSegment_","initSegmentKeyPromise","getInitSegmentDbKey_","streamId","segmentKeyPromise","getSegmentDbKey_","segmentReference","mapKey","getSegmentEstimate","queueWork","ensureNotDestroyed_","requireSupport_","shaka.offline.Storage.support","getAllStreamsFromManifest_","shaka.offline.indexeddb.V1StorageCell","shaka.offline.indexeddb.BaseStorageCell","shaka.offline.indexeddb.V1StorageCell.convertPeriod_","shaka.util.PeriodCombiner.combineDbStreams","creationTime","shaka.offline.indexeddb.V2StorageCell","shaka.offline.indexeddb.V5StorageCell","manifests","indexedDB","shaka.offline.indexeddb.StorageMechanism.DB_NAME","shaka.offline.indexeddb.StorageMechanism.VERSION","open.onsuccess","db","stores","objectStoreNames","contains","shaka.offline.indexeddb.StorageMechanism.V1_MANIFEST_STORE","shaka.offline.indexeddb.StorageMechanism.V1_SEGMENT_STORE","shaka.offline.indexeddb.StorageMechanism.V2_MANIFEST_STORE","shaka.offline.indexeddb.StorageMechanism.V2_SEGMENT_STORE","shaka.offline.indexeddb.StorageMechanism.V3_MANIFEST_STORE","shaka.offline.indexeddb.StorageMechanism.V3_SEGMENT_STORE","shaka.offline.indexeddb.StorageMechanism.V5_MANIFEST_STORE","shaka.offline.indexeddb.StorageMechanism.V5_SEGMENT_STORE","onupgradeneeded","open.onupgradeneeded","storeNames","createObjectStore","autoIncrement","open.onerror","shaka.util.Error.Code.INDEXED_DB_ERROR","erase","del","deleteDatabase","onblocked","del.onblocked","del.onsuccess","del.onerror","shaka.offline.indexeddb.StorageMechanism.deleteAll_","shaka.offline.indexeddb.StorageMechanism","finalManifest","foundSession","shaka.offline.OfflineManifestParser","shaka.offline.OfflineScheme","shaka.offline.OfflineScheme.plugin","abortableStoreOp","storeOp","getParser","activeHandle","drmError","parseManifest","shaka.offline.Storage.getAllStreamsFromManifest_","shaka.util.Error.Code.CANNOT_STORE_LIVE_OFFLINE","initForStorage","usePersistentLicenses","getActive","handle","downloadManifest_","pendingContent","isEncrypted","includesInitData","needsInitData","currentSystemId","fromManifest","shaka.offline.StoredContentUtils.fromManifest","setCallbacks","onProgress","onInitData","audioEncrypted","shaka.offline.Storage.defaultSystemIds_.get","createOfflineManifest_","shaka.offline.StreamBandwidthEstimator","setBitrate_","audioBitRate","shaka.offline.StreamBandwidthEstimator.DEFAULT_AUDIO_BITRATE_","videoBitRate","shaka.offline.StreamBandwidthEstimator.DEFAULT_TEXT_BITRATE_","streamSet","streamDBs","createStreams_","waitToFinish","shaka.util.Error.Code.NO_INIT_DATA_FOR_OFFLINE","shaka.offline.StoredContentUtils.fromManifestDB","startAbortableOperation_","getStoreInProgress","shaka.offline.Storage.prototype","allTracks","chosenTracks","textIds","filterByRestrictions","maxHwResolution","filterByMediaSourceSupport","supported","filterByDrmSupport","validateManifest_","texts","contentUri","nullableUri","removeEmeSessions","removeEmeSessions_","hasRemaining","cells","forEachEmeSessionCell","forEachCell","shaka.offline.Storage","deleteAll","alreadyInitialized","shaka.offline.Storage.defaultSystemIds_","polyfill","newItem","shaka.polyfill.polyfills_","shaka.polyfill.polyfills_.splice","shaka.polyfill.polyfills_.push","shaka.polyfill","shaka.polyfill.register","installAll","eventType","newEvent","Event","createEvent","initEvent","addEventListener_","HTMLInputElement","stubAbort_","MediaSource.prototype.addSourceBuffer","sourceBuffer.abort","supportedConfigurations","shaka.polyfill.PatchedMediaKeysApple.MediaKeySystemAccess","oldMediaKeys","setMedia","onWebkitNeedKey_","RangeError","event2","cfg","newCfg","initDataTypes","ranAnyTests","success","WebKitMediaKeys","checkConfig_","configuration_","unsupportedKeySystemError","DOMException","NOT_SUPPORTED_ERR","nativeMediaKeys_","shaka.polyfill.PatchedMediaKeysApple.onWebkitNeedKey_","webkitSetMediaKeys","nativeMediaKeys","nativeMediaKeySession_","updatePromise_","generateRequestPromise_","shaka.polyfill.PatchedMediaKeysApple.MediaKeyStatusMap","updateKeyStatus_","status_","shaka.polyfill.PatchedMediaKeysMs.MediaKeySystemAccess","onMsNeedKey_","initCustomEvent","normaliseInitData","dedupedInitDatas","shaka.util.Pssh.normaliseInitData","MSMediaKeys","shaka.polyfill.PatchedMediaKeysMs.onMsNeedKey_","msSetMediaKeys","shaka.polyfill.PatchedMediaKeysMs.MediaKeyStatusMap","TypeError","prefixApi_","prefix","shaka.polyfill.PatchedMediaKeysWebkit.prefix_","shaka.polyfill.PatchedMediaKeysWebkit.MediaKeySystemAccess","internalKeySystem_","allowPersistentState","tmpVideo","unsupportedError","keySystem_","media_","newSessions_","sessionMap_","findSession_","onWebkitKeyMessage_","generatePromise_","onWebkitKeyAdded_","onWebkitKeyError_","sessionType","shaka.polyfill.PatchedMediaKeysWebkit.MediaKeyStatusMap","generate_","offlineSessionId","mangledInitData","generateKeyRequestName","shaka.polyfill.PatchedMediaKeysWebkit.prefixApi_","exception2","install","EncryptionSchemePolyfills.install","Document","Element","requestFullscreen","mozRequestFullScreen","msRequestFullscreen","webkitRequestFullscreen","exitFullscreen","mozCancelFullScreen","msExitFullscreen","webkitCancelFullScreen","mozFullScreenElement","msFullscreenElement","webkitCurrentFullScreenElement","webkitFullscreenElement","mozFullScreenEnabled","msFullscreenEnabled","webkitFullscreenEnabled","shaka.polyfill.Fullscreen.proxyEvent_","shaka.polyfill.InputEvent.addEventListener_","patchCastIsTypeSupported_","originalIsTypeSupported","MediaSource.isTypeSupported","pieces","hasCodecs","piece","shaka.polyfill.MediaSource.patchCastIsTypeSupported_","rejectTsContent_","shaka.polyfill.MediaSource.rejectTsContent_","shaka.polyfill.MediaSource.stubAbort_","patchRemovalRange_","originalRemove","SourceBuffer","SourceBuffer.prototype.remove","shaka.polyfill.MediaSource.patchRemovalRange_","rejectCodec_","shaka.polyfill.MediaSource.rejectCodec_","shaka.polyfill.PatchedMediaKeysApple.MediaKeys","shaka.polyfill.PatchedMediaKeysApple.MediaKeySession","WebKitMediaKeyError","MEDIA_KEYERR_OUTPUT","MEDIA_KEYERR_HARDWARECHANGE","fn","shaka.media.DrmEngine.DUMMY_KEY_ID.value","fakeKeyId","entries","HTMLVideoElement","shaka.polyfill.PatchedMediaKeysApple.setMediaKeys","MediaKeys","MediaKeySystemAccess","shaka.polyfill.PatchedMediaKeysApple.requestMediaKeySystemAccess","shaka.polyfill.PatchedMediaKeysMs.MediaKeys","shaka.polyfill.PatchedMediaKeysMs.MediaKeySession","onMsKeyMessage_","onMsKeyAdded_","onMsKeyError_","MSMediaKeyError","MS_MEDIA_KEYERR_OUTPUT","MS_MEDIA_KEYERR_HARDWARECHANGE","shaka.polyfill.PatchedMediaKeysMs.requestMediaKeySystemAccess","shaka.polyfill.PatchedMediaKeysMs.MediaKeySystemAccess.setMediaKeys","shaka.polyfill.PatchedMediaKeysNop.MediaKeys","shaka.polyfill.PatchedMediaKeysNop.MediaKeySystemAccess","shaka.polyfill.PatchedMediaKeysNop.requestMediaKeySystemAccess","shaka.polyfill.PatchedMediaKeysNop.setMediaKeys","shaka.polyfill.PatchedMediaKeysWebkit.MediaKeys","shaka.polyfill.PatchedMediaKeysWebkit.MediaKeySession","MediaKeyError","shaka.polyfill.PatchedMediaKeysWebkit.MediaKeySession.prototype","nextUpdatePromise","licenseString","addKeyName","cancelKeyRequestName","shaka.polyfill.PiPWebkit.PIP_MODE_","webkitPresentationMode","pictureInPictureElement","requestPictureInPicture_","webkitSupportsPresentationMode","webkitSetPresentationMode","exitPictureInPicture_","pipElement","shaka.polyfill.PiPWebkit.INLINE_MODE_","getDisablePictureInPicture_","hasAttribute","setDisablePictureInPicture_","webkit_","webkitDroppedFrameCount","webkitDecodedFrameCount","from3ArgsTextTrackCue_","TextTrackCue","from6ArgsTextTrackCue_","ELEMENT_NODE","leafChildren","shaka.text.TtmlTextParser.getLeafNodes_","parseCue_","cueElement","rateInfo","metadataElements","styles","regionElements","cueRegions","whitespaceTrim","isTextContentEmpty","hasNoTimeAttributes","shaka.text.TtmlTextParser.parseTime_","shaka.util.Error.Code.INVALID_TEXT_CUE","isNonEmptyText","sanitizeTextContent_","shaka.text.TtmlTextParser.sanitizeTextContent_","trimmed","nestedCue","shaka.text.TtmlTextParser.parseCue_","childNode","regionElement","shaka.text.TtmlTextParser.getElementsFromCollection_","regionId","addStyle_","imageElement","shaka.text.TtmlTextParser.getStyleAttribute_","shaka.text.Cue.direction.HORIZONTAL_RIGHT_TO_LEFT","shaka.text.TtmlTextParser.textAlignToPositionAlign_","shaka.text.TtmlTextParser.textAlignToLineAlign_","shaka.text.Cue.textAlign.START","shaka.text.Cue.fontWeight.BOLD","wrapOption","shaka.text.TtmlTextParser.unitValues_","shaka.text.TtmlTextParser.percentValue_","backgroundImageType","backgroundImageEncoding","backgroundImageData","parseFloat","textDecorationRegion","shaka.text.TtmlTextParser.getStyleAttributeFromRegion_","shaka.text.TtmlTextParser.addTextDecoration_","textDecorationElement","shaka.text.TtmlTextParser.getStyleAttributeFromElement_","shaka.text.TtmlTextParser.smpteNs_","addTextDecoration_","decoration","shaka.text.Cue.textDecoration.UNDERLINE","shaka.text.Cue.textDecoration.LINE_THROUGH","shaka.text.Cue.textDecoration.OVERLINE","getStyleAttribute_","getStyleAttributeFromRegion_","regionChildren","shaka.text.TtmlTextParser.styleNs_","shaka.text.TtmlTextParser.getInheritedStyleAttribute_","getStyleAttributeFromElement_","elementAttribute","getInheritedStyleAttribute_","inheritedStyles","styleValue","styleAttributeValue","shaka.text.TtmlTextParser.styleEbuttsNs_","getElementsFromCollection_","attributeName","collection","prefixName","nsName","items","parentNode","attributeValue","parseTime_","shaka.text.TtmlTextParser.timeColonFormatFrames_.test","shaka.text.TtmlTextParser.timeColonFormatFrames_.exec","hours","minutes","frames","subFrameRate","shaka.text.TtmlTextParser.parseTimeFromRegex_","shaka.text.TtmlTextParser.timeColonFormat_","shaka.text.TtmlTextParser.timeColonFormatMilliseconds_.test","shaka.text.TtmlTextParser.timeColonFormatMilliseconds_","shaka.text.TtmlTextParser.timeFramesFormat_.test","shaka.text.TtmlTextParser.timeFramesFormat_.exec","shaka.text.TtmlTextParser.timeTickFormat_.test","shaka.text.TtmlTextParser.timeTickFormat_.exec","tickRate","shaka.text.TtmlTextParser.timeHMSFormat_.test","shaka.text.TtmlTextParser.timeHMSFormat_","parseTimeFromRegex_","frameRateMultiplier","multiplierResults","webkitGenerateKeyRequest","generateKeyRequest","shaka.polyfill.PatchedMediaKeysWebkit.requestMediaKeySystemAccess","shaka.polyfill.PatchedMediaKeysWebkit.setMediaKeys","requestPictureInPicture","exitPictureInPicture","pictureInPictureEnabled","shaka.polyfill.PiPWebkit.requestPictureInPicture_","shaka.polyfill.PiPWebkit.getDisablePictureInPicture_","shaka.polyfill.PiPWebkit.setDisablePictureInPicture_","shaka.polyfill.PiPWebkit.exitPictureInPicture_","shaka.polyfill.PiPWebkit.proxyEvent_","originalPlay","HTMLMediaElement.prototype.play","shaka.polyfill.VideoPlaybackQuality.webkit_","replacement","constructorLength","shaka.polyfill.VTTCue.from3ArgsTextTrackCue_","shaka.polyfill.VTTCue.from6ArgsTextTrackCue_","shaka.text.TtmlTextParser","shaka.util.Error.Code.INVALID_XML","parserError","tt","shaka.text.TtmlTextParser.parameterNs_","spaceStyle","shaka.text.TtmlTextParser.RateInfo_","extent","percentage","globalResults","shaka.text.TtmlTextParser.percentValues_.exec","globalExtent","shaka.text.TtmlTextParser.pixelValues_.exec","globalWidth","globalHeight","shaka.text.CueRegion.units.PX","origin","cueRegion","textNodes","getLeafCues_","shaka.text.TtmlTextParser.getLeafCues_","cellResolutionInfo","shaka.text.TtmlTextParser.percentValues_","shaka.text.TtmlTextParser.pixelValues_","shaka.text.TtmlTextParser.timeColonFormatFrames_","shaka.text.TtmlTextParser.timeFramesFormat_","shaka.text.TtmlTextParser.timeTickFormat_","shaka.text.Cue.lineAlign.CENTER","shaka.text.Cue.positionAlign.CENTER","regions","getRegionById_","regionsWithId","shaka.text.VttTextParser.getRegionById_","regexExpresion","timescale_","assembleCue_","shaka.text.VttTextParser.parseCueSetting","shaka.text.Mp4VttParser.assembleCue_","EmeEncryptionSchemePolyfill.originalRMKSA_","EmeEncryptionSchemePolyfill.probeRMKSA_","probeRMKSA_","assert","EmeEncryptionSchemePolyfill.originalRMKSA_.call","hasEncryptionScheme","EmeEncryptionSchemePolyfill.polyfillRMKSA_","EmeEncryptionSchemePolyfill.polyfillRMKSA_.call","polyfillRMKSA_","supportedScheme","filteredSupportedConfigurations","configuration","filteredVideoCapabilities","filteredAudioCapabilities","clonedConfiguration","guessSupportedScheme","EmeEncryptionSchemePolyfill.filterCapabilities_","EmeEncryptionSchemePolyfillMediaKeySystemAccess","filterCapabilities_","capabilities","McEncryptionSchemePolyfill","mediaCapabilities","McEncryptionSchemePolyfill.originalDecodingInfo_","decodingInfo","McEncryptionSchemePolyfill.probeDecodingInfo_","probeDecodingInfo_","requestedConfiguration","McEncryptionSchemePolyfill.originalDecodingInfo_.call","keySystemConfiguration","keySystemAccess","McEncryptionSchemePolyfill.polyfillDecodingInfo_","McEncryptionSchemePolyfill.polyfillDecodingInfo_.call","polyfillDecodingInfo_","keySystemConfig","audioScheme","videoScheme","notSupportedResult","encryptionScheme","powerEfficient","smooth","mksa","mksa_","firstAudioCapability","firstCapability","EmeEncryptionSchemePolyfill.install","shaka.text.Mp4TtmlParser","sawSTPP","shaka.util.Error.Code.INVALID_MP4_TTML","sawMDAT","shaka.text.VttTextParser","shaka.util.Error.Code.INVALID_TEXT_HEADER","cueTimeMatch","mpegTimeMatch","cueTime","shaka.text.VttTextParser.parseTime_","mpegTime","rolloverSeconds","shaka.text.VttTextParser.TS_ROLLOVER_","shaka.text.VttTextParser.MPEG_TIMESCALE_","shaka.text.CueRegion.units.LINES","shaka.text.CueRegion.scrollMode.UP","expect","timeOffset","shaka.text.Mp4VttParser","sawWVTT","shaka.util.Error.Code.INVALID_MP4_VTT","rawPayload","baseTime","presentations","sawTFDT","sawTRUN","defaultDuration","sampleCount","samples","sampleSize","presentation","totalSize","payloadType","shaka.text.Mp4VttParser.parseVTTC_","EmeEncryptionSchemePolyfill","McEncryptionSchemePolyfill.install","EncryptionSchemePolyfills","module","exports"],"mappings":";;;AA6hBE,IAAA,EAAA,EAAA,UAAA,IAAA,WAAA,IAAA,EAAA,oBAAA,OAAA,OAAA,EAAA,EAAA,GAAA,GAAA,SAAA,EAAA,EAAA,GCtgBF,IAAA,ECI4B,SAAQ,EAAC,GACnC,IAAI,EAAQ,EACL,OAAQ,WACb,OAAA,EAAY,EAAM,OACT,CACL,MAAM,EACN,MAAO,EAAM,MAGR,CAAC,MAAM,ICDpB,IAAAA,EAC4D,mBAAlC,OAAc,iBACpC,OAAO,eACP,SAAS,EAAQ,EAAU,GACzB,OAAI,GAAU,MAAM,WAEE,GAAW,OAAO,UAWxC,GAAA,EAAO,GAAY,EAAW,MAdO,ICiD3C,IAAAC,EAtDoB,SAAS,GACvB,EAAkB,CAKpB,iBALoB,YAKa,WASjC,EAEA,iBAhBoB,GAgBS,EAE7B,iBAlBoB,MAkBO,KAE3B,iBApBoB,GAoBS,GAE1B,IAAA,IAAI,EAAI,EAAG,EAAI,EAAgB,SAAU,EAAG,CAC/C,IAAI,EAAc,EAAgB,GAO9B,GAAA,GAAe,EAAY,MAAW,KACxC,OAT6C,EAqBzC,MAAM,MAAU,6BAUTC,CAAkB,MCChB,SAAQ,EAAC,EAAQ,GAClC,GAAK,EAoBmE,EAAA,CAGxE,IAFA,IAAI,EAAMD,EACN,EAlByB,EAkBV,MAAM,KAChB,EAAI,EAAG,EAAI,EAAM,OAAS,EAAG,IAAK,CACzC,IAAI,EAAM,EAAM,GACZ,KAAE,KAAF,GAAe,MAAA,EACnB,EAAM,EAAI,IAIR,EA1BiC,EAyBjC,EAAO,EADP,EAAW,EAAM,EAAM,OAAS,OAGxB,GAAgB,MAAR,GACpBD,EACI,EAAK,EAAU,CAAC,cAAc,EAAM,UAAU,EAAM,MAAO,KC8BrC,SAAQ,EAAC,GASM,OARrC,EAAW,CAAC,KAAM,IAKb,OAAO,UAAY,WAC1B,OADqC,MANE,EC1HpB,SAAQ,EAAC,GAE9B,IAAI,EAAoC,oBAApC,QAAmD,OAAO,UACvC,EAAU,OAAO,UACjC,OAAA,EAAmB,EAAiB,KAAK,GLcZ,CAAC,KAAMG,EKbM,ICNvB,SAAQ,EAAC,GACnC,KAAI,aAAA,OAAJ,CAGS,EAAA,EAAA,GCAT,IAAA,IAAI,EACA,EAAM,KACD,EAAI,EAAS,QAAQ,MAC5B,EAAI,KAAK,EAAE,OAEb,EAAO,EDRP,OAD6C,EFI/CC,EAAiB,SAAU,SAAS,GAQhB,SAAQ,EAAC,EAAI,GAE7B,KAAK,EAAqB,EAM1B,EACI,KAAM,cACN,CAAC,cAAc,EAAM,UAAU,EAAM,MAAO,IAjBlD,GAAI,EAAM,OAsBV,EAAA,EAAY,UAAU,SAAW,WAC/B,OAAA,KAAY,GAOV,IAAA,EAAU,EAiBP,OATc,SAAQ,EAAC,GAC5B,GAAI,gBAAJ,EACE,MAAU,IAAA,UAAU,+BAEtB,OAAY,IAAA,EAdM,kBAeG,GAAmB,IAAM,IAAO,IACjD,MAaR,EAAiB,kBAAmB,SAAS,GAC3C,GAAI,EAAM,OAEN,EAAA,EAAiB,OAAO,mBAM5B,IAAA,IAA0B,EAAa,uHAAA,MAAA,KAS9B,EAAI,EAAG,EAAI,EAAW,OAAQ,IAAK,CAC1C,IAAI,EAAkCH,EAAe,EAAW,IAChE,mBAAA,GACsD,mBAA3C,EAAc,UAAU,IACjCD,EAAuB,EAAc,UAAW,EAAgB,CAC9D,cAAc,EACd,UAAU,EAKV,MAAO,WACL,OAAO,EAA0BG,EAA0B,UAKnE,OAnCiD,II7DnD,ICoByB,EDpBzBE,EACmD,mBAAxB,OAAc,OACrC,OAAO,OACP,SAAS,GAEI,SAAQ,KAEZ,OADP,EAAK,UAAY,EACN,IAAA,GCcyC,GAAA,mBAAhC,OAAc,eACpC,EAAA,OAAA,mBAFqB,CAGrB,IAAA,EAxByC,EAAA,CAC3C,IACI,EAAI,GACJ,IACF,EAAE,UAHI,CAAC,IAAG,GAIV,EAAO,EAAE,GAAT,MAAA,EACA,MAAO,KAGT,GAAO,EAeL,EAAA,EAAA,SAAA,EAAA,GAAA,GAAA,EAAA,UAAA,EAAA,EAAA,YAAA,EAAA,MAAA,IAAA,UAAA,EAAA,sBAAA,OAAA,GAAA,KAHJ,IAAAC,EAAyB,ECMN,SAAQ,EAAC,EAAW,GAGjCA,GAFJ,EAAU,UAAYD,EAAqB,EAAW,WACrC,EAAU,UAAU,YAAc,EAC/CC,EAIFA,EAAe,EAAW,QAIrB,IAAA,IAAI,KAAT,EACE,GAAS,aAAL,EAIJ,GAAI,OAAO,iBAAkB,CAC3B,IAAI,EAAa,OAAO,yBAAyB,EAAY,GAC7D,GACE,OAAO,eAAe,EAAW,EAAG,QAItC,EAAU,GAAK,EAAW,GAKhC,EAAU,GAAc,EAAW,UCiDT,SAAQ,IAQlC,KAAK,GAAa,EASlB,KAAK,EAAoB,KAQzB,KAAK,OAAc,EASnB,KAAK,EAAc,EAqBnB,KAAK,EAXL,KAAK,EAAgB,EA4CrB,KAAK,EAvBL,KAAK,EAAoB,KAkCkB,SAAQ,EAAR,GAC3C,GAAI,EAAK,EACP,MAAU,IAAA,UAAU,gCAEtB,EAAK,GAAa,EAgDyB,SAAQ,EAAR,EAAS,GACpD,EAAK,EAAoB,CAAC,GAAW,EAAG,IAAa,GA1BrD,EAAK,EA2BL,EA3BwB,GA2BxB,EA3B8C,EAoEJ,SAAQ,EAAR,EAAS,EAAO,GAEnD,OADP,EAAK,EAAc,EACZ,CAAC,MAAO,GAgD+B,SAAQ,EAAR,GAC9C,EAAK,EAAc,EAYuC,SAAQ,EAAR,EACxD,EAAc,GAChB,EAAK,EAAgB,EACC,MAAlB,IACF,EAAK,EAAkB,GAY2B,SAAQ,EAAR,GACpD,EAAK,EAAgB,EACrB,EAAK,ECvWC,EDmX4C,SAAQ,EAAR,EAChD,GACF,EAAK,EAAc,EACnB,EAAK,EAAgC,EAYe,SAAQ,EAAR,GAEpD,EAAK,EAAyC,EAC5B,IAAA,EACoC,EAAK,EAClD,GAEF,OADP,EAAK,EAAoB,KALA,EAmB6B,SAAQ,EAAR,GAGpD,EAAK,EAAmB,CAAC,EAAK,GAOhC,EAAK,EAAoC,EACzC,EAAK,EAAwC,EAaS,SAAQ,EAAR,EACpD,GAiDY,IAAI,EAIb,EAAK,EAAkB,OAAuB,GAAG,IACpC,EAAmB,EAAK,EACtC,EAAK,GAAqB,GAExB,EAAiB,GACZ,EAvRN,EAuRM,EAvRa,GAuRb,EAvRmC,EAyTb,MAA3B,EAAiB,GACjB,EAAK,EAAkB,EAAiB,GAC1C,EAAK,EAAc,EAAiB,EACpC,EAAK,EAAoB,MAEzB,EAAK,EAAc,EAAK,EAG1B,EAAK,EAAc,EAoFK,SAAQ,EAAC,GAMnC,KAAK,EAAW,IAAIC,EAOpB,KAAK,EAAW,EAkFkC,SAAQ,EAAR,EAChD,EAAQ,EAAO,GACjB,IACgB,IAAI,EAAS,EAAO,KACG,EAAK,EAAS,EAC/C,GAtoBF,KAuoB8C,aAvoB9C,QAGJ,MAAU,IAAA,UAAU,mBAooB8B,EApoBA,qBAqoBhD,IAAK,EAAO,KAEV,OAAO,EADF,EAxgBJ,GAAa,EAygBP,EAIS,IAAA,EAAc,EAAO,MACvC,MAAO,GAGP,OAAO,EAFF,EAAS,EAAoB,KAClC,EAAA,EAAK,EAAgB,GACd,EAAA,GAIF,OAFP,EAAK,EAAS,EAAoB,KAClC,EAAW,KAAK,EAAK,EAAU,GACxB,EAAA,GAWuC,SAAQ,EAAR,GAC9C,KAAO,EAAK,EAAS,GACnB,IACgB,IAAI,EAAa,EAAK,EAAS,EAAK,GAC9C,GAAA,EAEF,OAAO,EADF,EAriBN,GAAa,EAsiBL,CAAC,MAAO,EAAW,MAAO,MAAM,GAEzC,MAAO,GACP,EAAK,EAAS,OAAc,EAC5B,EAAA,EAAK,EAAgB,GAKrB,GADJ,EAAK,EA9iBA,GAAa,EA+iBd,EAAK,EAAS,EAAmB,CAG/B,GAFc,EAAmB,EAAK,EAAS,EACnD,EAAK,EAAS,EAAoB,KAC9B,EAAiB,GACnB,MAAA,EAAuB,GAEzB,MAAO,CAAC,MAAO,EAAP,OAAgC,MAAM,GAEhD,MAAO,CAAC,WAAyB,EAAY,MAAM,GAetB,SAAQ,EAAC,GAEtC,KAAK,KAAO,SAAS,GACZ,OA5IT,EA4IS,EA5IJ,GACL,EAAS,EAAS,EAChB,EAAO,EA0IA,EAAA,EAzIE,EAAS,EAAkB,KAyIhB,EAAb,EAzI+C,EAAS,IAyIxD,EAvIJ,EAAS,EAuIQ,GAtItB,EAAO,EAsIE,IADuB,GAKhC,KAAA,MAAa,SAAS,GACb,OApGT,EAoGS,EApGJ,GACL,EAAS,EAAS,EAChB,EAAO,EAkGA,EAAA,EAjGE,EAAS,EAAd,MAiGiB,EAAd,EAhGE,EAAS,IAEpB,EA8FS,EA9FJ,EA8FkB,GA7FvB,EAAO,EA6FE,IADwB,GAKjC,KAAA,OAAc,SAAS,GACrB,OApI0C,SAAA,EAAS,GACrD,EAAA,EAAK,GACa,IAAA,EAAmB,EAAK,EAAS,EAC/C,OAAA,EAOK,EAAA,EAJC,WAAA,EAA+B,EAAA,OACA,SAAS,GACP,MAAO,CAAC,MAAO,EAAG,MAAM,IAEvB,EAAO,EAAK,EAA/C,SAET,EAAK,EAAL,OAAqB,GACd,EAAA,IAuHE,CAAA,EAAe,IAIxB,KAAK,OAAO,UAAY,WACtB,OADiC,MAkBD,SAAQ,EAAC,EAAW,GACxC,IAAI,EACd,IAAIC,EAA6B,IAAIC,EAA0B,IAa5D,OAJP,GAA8B,EAAU,WACcH,EAChD,EAAQ,EAAU,WAbuC,EE9uBnB,SAAQ,EAAC,GACrD,OAlEqC,SAAS,GAC9C,SAA6B,EAAC,GAC5B,OAAO,EAAU,KAAK,GAGxB,SAA6B,EAAC,GAC5B,OAAO,EAAA,MAAgB,GAGzB,OAAW,IAAA,QAAQ,SAAS,EAAS,IACnC,SAA8B,EAA4B,GACpD,EAAO,KACT,EAAQ,EAAO,OAIf,QAAQ,QAAQ,EAAO,OAClB,KAAK,EAAsB,GAC3B,KAAK,EAAuB,GAIrC,CAAsB,EAAU,UA4C3B,CACH,IAAIE,EACA,IAAIC,EACA,KC9FC,SAAQ,EAAC,EAAK,GAC3B,OAAO,OAAO,UAAU,eAAe,KAAK,EAAK,GCS5B,SAAQ,EAAC,EAAO,EAAU,GAC3C,aAAJ,SACE,EAAoC,OAAO,IAE7C,IAAA,IAAI,EAAM,EAAM,OACP,EAAI,EAAG,EAAI,EAAK,IAAK,CAC5B,IAAI,EAAQ,EAAM,GACd,GAAA,EAAS,KAAK,EAAS,EAAO,EAAG,GAAQ,MAAO,CAAC,EAAG,EAAG,GAAG,GAEhE,MAAO,CAAC,GAAD,EAAQ,QAAG,GCbQ,SAAQ,EAAC,EAAO,GAEtC,aAAJ,SAAqC,GAAQ,IACzC,IAAA,EAAI,EACJ,GAAO,EACP,EAAO,CACT,KAAM,WAGJ,IAAK,GAAQ,EAAI,EAAM,OAAQ,CAC7B,IAAI,EAAQ,IACL,MAAA,CAAC,MAAO,EAAU,EAAO,EAAM,IAAS,MAAM,GAGhD,OADP,GAAO,EACA,CAAC,MAAM,EAAM,WAAO,KAIxB,OADP,EAAK,OAAO,UAAY,WAAa,OAAF,GAjBkB,ECH7B,SAAQ,EAAC,EAAS,EAAK,GAC/C,GAAe,MAAX,EACF,MAAU,IAAA,UACN,yCAA2C,EAC3C,kCAEN,GAAI,aAAJ,OACE,MAAU,IAAA,UACN,sCAAwC,EACxC,qCAEN,OAAA,EAAiB,GNyOnBF,EAA0B,UAAU,EAAQ,SAAS,GACnD,KAAK,EAAc,GAyBrBA,EAA0B,UAA1B,OAA6C,SAAS,GACpD,KAAK,EAAoB,CAAC,OAA8B,GACxD,KAAK,EAAc,KAAK,GAoE1BA,EAA0B,UAAU,EAAS,SAAS,GACpD,KAAK,EAAc,GOzVrBH,EAAiB,UAMb,SAAS,GA+HW,SAAQ,EAAC,GAE7B,KAAK,EArBI,EA4BT,KAAK,OAAU,EAOf,KAAK,EAAsB,GAM3B,KAAK,GAAsB,EAEvB,IAAA,EAAmB,KAAK,IACxB,IACF,EAAS,EAAiB,QAAS,EAAiB,QACpD,MAAO,GACP,EAAiB,OAAO,IAvI5B,SAAsB,IAQpB,KAAK,EAAS,KAwahB,SAAyB,EAAC,GACxB,OAAA,aAAA,EACS,EAEA,IAAI,EAAgB,SAAS,GAClC,EAAQ,KA9bd,GAAI,EACF,OA+BF,EAAA,EAAc,UAAU,EAAe,SAAS,GAC9C,GAAmB,MAAf,KAAK,EAAgB,CAEvB,KAAK,EAAS,GACV,IAAA,EAAO,KACX,KAAK,EAAqB,WAAa,EAAK,MAE9C,KAAK,EAAO,KAAK,IAMf,IAAA,EAAmBH,EAAe,WAStC,EAAc,UAAU,EAAuB,SAAS,GACtD,EAAiB,EAAG,IAQtB,EAAc,UAAU,EAAgB,WACtC,KAAO,KAAK,GAAU,KAAK,EAAO,QAAQ,CACxC,IAA+B,EAAiB,KAAK,EAGrD,KAAK,EAAS,GACT,IAAA,IAAI,EAAI,EAAG,EAAI,EAAe,SAAU,EAAG,CAC9C,IAAI,EAA+B,EAAe,GAClD,EAAe,GAAK,KAChB,IACF,IACA,MAAO,GACP,KAAK,EAAY,KAMvB,KAAK,EAAS,MAOhB,EAAc,UAAU,EAAc,SAAS,GAC7C,KAAK,EAAqB,WAAa,MAAA,KAuEzC,EAAgB,UAAU,EAA0B,WAQlD,SAAsB,EAAC,GACrB,OAAe,SAAW,GACnB,IACH,GAAgB,EAChB,EAAO,KAAK,EAAa,KAX/B,IAAI,EAAc,KACd,GAAgB,EAcb,MAAA,CACL,QAAS,EAAc,KAAK,GAC5B,OAAQ,EAAc,KAAK,KAS/B,EAAgB,UAAU,EAAa,SAAS,GAC9C,GAAI,IAAU,KACZ,KAAK,EAAQ,IAAI,UAAU,4CAClB,GAAA,aAAJ,EACL,KAAK,EAAsD,OADtD,CAoCgB,EACvB,cAAA,GACE,IAAK,SACH,IAAA,EAAgB,MArCA,EAqChB,MAAA,EACG,IAAA,WACH,GAAO,EAAP,MAAA,EAEA,QAAA,GAAO,EAzCA,EACT,KAAK,EAAgD,GAErD,KAAK,EAAS,KAUlB,EAAgB,UAAU,EAA0B,SAAS,GAC3D,IAAI,OAAa,EAEb,IACF,EAAa,EAAI,KACjB,MAAO,GAAO,YACd,KAAK,EAAQ,GAGU,mBAAzB,EACE,KAAK,EAAsB,EAAsC,GAEjE,KAAK,EAAS,IA0BlB,EAAgB,UAAU,EAAU,SAAS,GAC3C,KAAK,EA7IK,EA6I0B,IAStC,EAAgB,UAAU,EAAW,SAAS,GAC5C,KAAK,EA1JM,EA0J0B,IAUvC,EAAgB,UAAU,EAAU,SAAS,EAAc,GACzD,GAxKS,GAwKL,KAAK,EACP,MAAM,MACF,iBAAmB,EAAe,KAAO,EACzC,sCAAwC,KAAK,GAEnD,KAAK,EAAS,EACd,KAAK,EAAU,EACf,IAAI,KAAK,GACP,KAAK,IAEP,KAAK,KAGP,EAAgB,UAAU,EAAmC,WAC3D,IAAI,EAAO,KACX,EAAiB,WACf,GAAI,EAAK,IAA6B,CAEpC,IAAI,EAAgBA,EAAe,aACnC,IAAA,GACE,EAAc,MAAM,EAAK,KAG5B,IAWL,EAAgB,UAAU,EAA4B,WACpD,GAAI,KAAK,EACP,OAAO,EAEL,IAAA,EAAoBA,EAAe,YACnC,EAAcA,EAAe,MAC7B,EAAsBA,EAAe,cACN,YAAA,IAAnC,IAKA,mBAAA,EACE,EACI,IAAI,EAAkB,qBAAsB,CAAC,YAAY,IAC7B,mBAA3B,EAGL,EAAQ,IAAI,EAAY,qBAAsB,CAAC,YAAY,KAG3D,EAAQA,EAAe,SAAY,YAAY,gBACzC,gBACF,sBAA0C,GACrB,EAAM,GAEjC,EAAM,QAAU,KAChB,EAAM,OAAS,KAAK,EAEb,EAAoB,KAG7B,EAAgB,UAAU,EAA6B,WACrD,GAAgC,MAA5B,KAAK,EAA6B,CACpC,IAAK,IAAI,EAAI,EAAG,EAAI,KAAK,EAAoB,SAAU,EACrD,EAAc,EAAa,KAAK,EAAoB,IAEtD,KAAK,EAAsB,OAS3B,IAAA,EAAgB,IAAI,EA4KjB,OArKP,EAAgB,UAAU,EAAuB,SAAS,GACxD,IAAI,EAAU,KAAK,IAGnB,EAAQ,GAAiB,EAAQ,QAAS,EAAQ,SAYpD,EAAgB,UAAU,EAAwB,SAC9C,EAAY,GACd,IAAI,EAAU,KAAK,IAGf,IACF,EAAW,KAAK,EAAU,EAAQ,QAAS,EAAQ,QACnD,MAAO,GACP,EAAQ,OAAO,KAKnB,EAAgB,UAAU,KAAO,SAAS,EAAa,GAOrD,SAAuB,EAAC,EAAQ,GAG9B,MAAqB,mBAArB,EACS,SAAS,GACd,IACE,EAAa,EAAO,IACpB,MAAO,GACP,EAAY,KAIT,EAlBX,IAAI,EACA,EACA,EAAe,IAAI,EAAgB,SAAS,EAAS,GACvD,EAAe,EACf,EAAc,IAqBT,OAHP,KAAK,GACD,EAAe,EAAa,GAC5B,EAAe,EAAY,IAzBkC,GA8BnE,EAAgB,UAAhB,MAAkC,SAAS,GACzC,OAAO,KAAK,UAAK,EAAW,IAI9B,EAAgB,UAAU,GAAmB,SACzC,EAAa,GAEf,SAAiB,IACf,OAAQ,EAAY,GAClB,KAjUO,EAkUL,EAAY,EAAY,GAE1B,MAjUM,KAAA,EAkUJ,EAAW,EAAY,GAEzB,MACE,QAAA,MAAM,MAAU,qBAAuB,EAAY,IAVzD,IAA4B,EAAc,KAa1C,MAAI,KAAK,EAEP,EAAc,EAAa,GAE3B,KAAK,EAAoB,KAAK,GAEhC,KAAK,GAAsB,GAa7B,EAAgB,QAAa,EAG7B,EAAgB,OAAY,SAAS,GACnC,OAAW,IAAA,EAAgB,SAAS,EAAS,GAC3C,EAAO,MAKX,EAAgB,KAAU,SAAS,GACjC,OAAW,IAAA,EAAgB,SAAS,EAAS,GAG3C,IAFA,IAAwB,EACpBS,EAAqB,GACW,EAAU,EAAS,QACjD,EAAQ,KACT,EAAU,EAAS,OAOtB,EAAiB,EAAQ,OAAO,GAAiB,EAAS,MAMhE,EAAgB,IAAS,SAAS,GAChC,IAAwB,EAAWA,EAAqB,GACzB,EAAU,EAAS,OAE9C,OAAJ,EAAY,KACH,EAAiB,IAEjB,IAAI,EAAgB,SAAS,EAAY,GAI9C,SAAoB,EAAC,GACnB,OAAe,SAAC,GACd,EAAa,GAAK,EAElB,KADA,GAEE,EAAW,IARjB,IAAI,EAAe,GACf,EAAkB,EAapB,GAAA,EAAa,UAAK,GAClB,IAMA,EAAiB,EAAQ,OACpB,GACG,EAAY,EAAa,OAAS,GAAI,GAC9C,EAAU,EAAS,cACX,EAAQ,SA3gBE,ICN5BN,EAAiB,UAMb,SAAS,GA6GW,SAAQ,EAAC,GAIzB,GAFJ,KAAK,GAAO,GAAU,KAAK,SAAW,GAAI,WAEtC,EAAc,CACZ,EAAOM,EAAqB,GAChC,IAAA,IAAI,IACK,EAAQ,EAAK,QAAQ,MACxB,EAAO,EAAM,MACjB,KAAK,IAAwB,EAAK,GAA2B,EAAK,KAzFxE,SAA0B,KAO1B,SAAmB,EAAC,GAClB,IAAI,SACJ,EAAiB,MAAA,WAAT,GAA6B,OAAR,GAA0B,aAAT,EAOhD,SAAe,EAAC,GACd,IAAKC,EAAa,EAAQ,GAAO,CAC/B,IAAI,EAAM,IAAI,EAMd,EAAuB,EAAQ,EAAM,CAAC,MAAO,KASjD,SAAc,EAAC,GAOb,IAAI,EAAO,OAAO,GAClB,IACE,OAAO,GAAQ,SAAS,GACtB,OAAI,aAAJ,EAGM,GAAA,OAAO,aAAa,IACtB,EAAO,GAEF,EAAK,MAvDlB,GAlBF,WACE,IAAK,IAAkB,OAAO,KAAM,OAAO,EACvC,IACF,IAAI,EAAI,OAAO,KAAK,IAChB,EAAI,OAAO,KAAK,IAChB,EAAM,IACN,EAAe,CAAC,CAAC,EAAG,GAAI,CAAC,EAAG,KACd,OAAA,GAAd,EAAI,IAAI,IAAyB,GAAd,EAAI,IAAI,KAC/B,EAAA,OAAW,GACX,EAAI,IAAI,EAAG,IACH,EAAI,IAAI,IAAoB,GAAd,EAAI,IAAI,IAC9B,MAAO,GACP,OAAO,GAZX,GAkBsB,OAGtB,EAAI,IAAA,EAAO,kBAAoB,KAAK,SAyDpC,EAAM,UACN,EAAM,qBACN,EAAM,QAKF,IAAA,EAAQ,EA0EL,OAxCP,EAAgB,UAAU,IAAM,SAAS,EAAK,GAC5C,IAAK,EAAW,GACd,MAAM,MAAU,uBAGd,GADJ,EAAO,IACFA,EAAa,EAAK,GAQrB,MAAM,MAAU,qBAAuB,GAGlC,OADP,EAAI,GAAM,KAAK,GAAO,EAf6B,MAoBrD,EAAgB,UAAU,IAAM,SAAS,GACvC,OAAO,EAAW,IAAQA,EAAa,EAAK,GAAQ,EAAI,GAAM,KAAK,QACf,GAItD,EAAgB,UAAU,IAAM,SAAS,GACvC,OAAO,EAAW,IAAQA,EAAa,EAAK,IACxCA,EAAa,EAAI,GAAO,KAAK,IAInC,EAAgB,UAAhB,OAAmC,SAAS,GAC1C,SAAK,EAAW,IAASA,EAAa,EAAK,IACtCA,EAAa,EAAI,GAAO,KAAK,YAGpB,EAAI,GAAM,KAAK,IAjKL,ICgB5B,EAAiB,MAMb,SAAS,GA+PM,SAAQ,IACvB,IAAI,EAAoD,GACxD,OACA,EADK,GAAW,EAAK,KAAO,EAAK,KAAO,EA1BvB,SAAQ,EAAC,EAAK,GAC/B,IAAI,EAAQ,EAAI,EACTC,OAAA,EAA0B,WAC/B,GAAI,EAAO,CACT,KAAO,EAAM,MAAQ,EAAI,GACvB,EAAQ,EAAM,GAEhB,KAAO,EAAM,MAAQ,EAAM,MAEzB,OAAO,EADC,EAAM,KACP,CAAC,MAAM,EAAO,MAAO,EAAK,IAEnC,EAAQ,KAEV,MAAO,CAAC,MAAM,EAAM,WAAO,KApCX,SAAQ,EAAC,EAAK,GAkE5B,IAAA,EAjEW,UAkEH,EAAZ,UAAI,GAA4B,YAAR,EAEjB,EAAM,IApEE,GAyEb,EAAO,EAAM,IAzEA,IAqEP,EAAK,MAAQ,EACjB,EAAM,IAtEK,EAsEI,IAMnB,EAAO,KA5EQ,EACX,IAAA,EAAO,EAAI,EAAM,GACjB,GAAA,GAAQD,EAAa,EAAI,EAAO,GAClC,IAAK,IAAI,EAAQ,EAAG,EAAQ,EAAK,OAAQ,IAAS,CAChD,IAAI,EAAQ,EAAK,GACZ,GAAA,GAAQ,GAAO,EAAM,KAAQ,EAAM,KAAQ,IAAQ,EAAM,IAC5D,MAAO,CAAC,GAAI,EAAI,KAAM,EAAM,MAAO,EAAO,EAAO,GAIvD,MAAO,CAAC,GAAI,EAAI,KAAM,EAAM,OAArB,EAAgC,OAAO,GA9J9B,SAAQ,EAAC,GAarB,GAXJ,KAAK,EAAQ,GAGb,KAAK,EAAQ,IAMb,KAAK,KAAO,EAER,EAAc,CACZ,EAAOD,EAAqB,GAChC,IAAA,IAAI,IACK,EAAQ,EAAK,QAAQ,MACxB,EACoD,EAAO,MAC/D,KAAK,IAAwB,EAAK,GAA2B,EAAK,KArCtE,GApCF,WACE,IACK,GACmB,mBAFxB,IAGK,EAAU,UAAU,SACC,mBAAtB,OAAc,KAChB,OAAO,EAGL,IAEF,IAAI,EAAM,OAAO,KAAK,CAAC,EAAG,IACtB,EAAM,IAAI,EAAUA,EAAqB,CAAC,CAAC,EAAK,QAChC,GAAA,KAAhB,EAAI,IAAI,IAA2B,GAAZ,EAAI,MAAa,EAAI,IAAI,CAAC,EAAG,KACpD,EAAI,IAAI,CAAC,EAAG,GAAI,MAAQ,GAAmB,GAAZ,EAAI,KACrC,OAAO,EAEoB,IAAA,EAAO,EAAI,UACpC,EAAO,EAAK,OACZ,OAAA,EAAK,MAAQ,EAAK,MAAM,IAAM,GAAwB,KAAjB,EAAK,MAAM,OAGpD,EAAO,EAAK,QACH,MAA2B,GAAnB,EAAK,MAAM,GAAG,GACV,KAAjB,EAAK,MAAM,KAAc,EAAK,OAAO,MAIzC,MAAO,GACP,OAAO,GA7BX,GAoCsB,OAItB,EAAI,IAAA,EAAQ,IAAI,QAwChB,EAAY,UAAU,IAAM,SAAS,EAAK,GAGpC,IAAA,EAAI,EAAc,KADtB,EAAc,IAAR,EAAY,EAAI,GAoBf,OAlBP,EAAO,OACL,EAAE,KAAQ,KAAK,EAAM,EAAE,IAAM,IAE/B,EAAO,EAaL,EAAE,EAAM,MAAQ,GAZhB,EAAE,EAAQ,CACR,KAAM,KAAK,EACX,GAAU,KAAK,EAAM,GACrB,KAAM,KAAK,EACX,IAAK,EACL,MAAO,GAET,EAAE,KAAK,KAAK,EAAE,GACd,KAAK,EAAM,GAAS,KAAO,EAAE,EAC7B,KAAK,EAAM,GAAW,EAAE,EACxB,KAAK,QAlBwC,MA2BjD,EAAY,UAAZ,OAA+B,SAAS,GAElC,UADA,EAAI,EAAc,KAAM,IACtB,IAAS,EAAE,QACf,EAAE,KAAK,OAAO,EAAE,MAAO,GAClB,EAAE,KAAK,eAAe,KAAK,EAAM,EAAE,IACxC,EAAE,EAAM,GAAS,KAAO,EAAE,EAAM,KAChC,EAAE,EAAM,KAAK,GAAW,EAAE,EAAM,GAChC,EAAE,EAAM,KAAO,KACf,KAAK,QACE,IAOX,EAAY,UAAU,MAAQ,WAC5B,KAAK,EAAQ,GACb,KAAK,EAAQ,KAAK,EAAM,GAAW,IACnC,KAAK,KAAO,GAKd,EAAY,UAAU,IAAM,SAAS,GACnC,QAAU,EAAc,KAAM,GAAK,GAKrC,EAAY,UAAU,IAAM,SAAS,GAGnC,OAFI,EAAQ,EAAc,KAAM,GAAK,IAGb,EAAM,OAKhC,EAAY,UAAU,QAAU,WAC9B,OAAO,EAAa,KAA2C,SACtB,GACvC,MAAQ,CAAC,EAAM,IAAK,EAAM,UAM9B,EAAY,UAAU,KAAO,WAC3B,OAAO,EAAa,KAA2B,SACN,GACvC,OAAA,EAAa,OAMjB,EAAY,UAAU,OAAS,WAC7B,OAAO,EAAa,KAA6B,SACR,GACvC,OAAA,EAAa,SAMjB,EAAY,UAAU,QAAU,SAAS,EAAU,GAGjD,IAFA,IACI,EADA,EAAO,KAAK,YAEP,EAAO,EAAK,QAAQ,MACvB,EAAQ,EAAK,MACjB,EAAS,KACa,EACI,EAAM,GACR,EAAM,GAC1B,OAKS,EAAa,UAAW,OAAO,UAC5C,EAAY,UAAU,QAuEtB,IAAA,EAAW,EAuBR,OAjSe,IC7BxB,EAAiB,MAMb,SAAS,GAyDO,SAAQ,EAAC,GAGrB,GADJ,KAAK,EAAO,IAAI,IACZ,EAAc,CACZ,EAAOA,EAAqB,GAChC,IAAA,IAAI,IACK,EAAQ,EAAK,QAAQ,MAE5B,KAAK,IAD8C,EAAO,OAO9D,KAAK,KAAO,KAAK,EAAK,KA5BtB,OApCF,WACE,IACK,GACmB,mBAFxB,IAGK,EAAU,UAAU,SACC,mBAAtB,OAAc,KAChB,OAAO,EAGL,IAEF,IAAI,EAAQ,OAAO,KAAK,CAAC,EAAG,IACxB,EAAM,IAAI,EAAUA,EAAqB,CAAC,KAC1C,IAAC,EAAI,IAAI,IAAsB,GAAZ,EAAI,MAAa,EAAI,IAAI,IAAU,GAC1C,GAAZ,EAAI,MAAa,EAAI,IAAI,CAAC,EAAG,KAAO,GAAmB,GAAZ,EAAI,KACjD,OAAO,EAEL,IAAA,EAAO,EAAI,UACX,EAAO,EAAK,OACZ,OAAA,EAAK,MAAQ,EAAK,MAAM,IAAM,GAAS,EAAK,MAAM,IAAM,MAG5D,EAAO,EAAK,QACH,MAAQ,EAAK,MAAM,IAAM,GAA4B,GAAnB,EAAK,MAAM,GAAG,GACrD,EAAK,MAAM,IAAM,EAAK,MAAM,IAGzB,EAAK,OAAO,MACnB,MAAO,GACP,OAAO,GA7BX,GAqEA,GAAA,EAAY,UAAU,IAAM,SAAS,GAK5B,OAHP,EAAkB,IAAV,EAAc,EAAI,EAC1B,KAAK,EAAK,IAAI,EAAO,GACrB,KAAK,KAAO,KAAK,EAAK,KAJoB,MAU5C,EAAY,UAAZ,OAA+B,SAAS,GAG/B,OAFH,EAAS,KAAK,EAAL,OAAiB,GAC9B,KAAK,KAAO,KAAK,EAAK,KAFuB,GAQ/C,EAAY,UAAU,MAAQ,WAC5B,KAAK,EAAK,QACV,KAAK,KAAO,GAKd,EAAY,UAAU,IAAM,SAAS,GACnC,OAAO,KAAK,EAAK,IAAI,IAKvB,EAAY,UAAU,QAAU,WAC9B,OAAO,KAAK,EAAK,WAKnB,EAAY,UAAU,OAAS,WAC7B,OAAO,KAAK,EAAK,UAKnB,EAAY,UAAU,KAAO,EAAY,UAAU,OAGlC,EAAa,UAAW,OAAO,UAC5C,EAAY,UAAU,OAI1B,EAAY,UAAU,QAAU,SAAS,EAAU,GACjD,IAAI,EAAM,KACV,KAAK,EAAK,QAAQ,SAAS,GACzB,OAAO,EAAS,KAAuB,EAAc,EAAO,EAAO,MAlIjD,KCTxBN,EAAiB,4BAA6B,SAAS,GACrD,OAAA,GAae,SAAS,EAAU,GAChC,OAAO,EAAqB,KAAM,EAAU,GAAa,KCf7D,EAAiB,4BAA6B,SAAS,GACrD,OAAA,GASe,SAAS,GACtB,OAAO,KAAK,KACR,SAAS,GAEP,OADc,QAAQ,QAAQ,KACf,KAAK,WAAc,OAAF,KAElC,SAAS,GAEP,OADc,QAAQ,QAAQ,KACf,KAAK,WAAc,MAAA,SClB5CA,EAAiB,uBAAwB,SAAS,GAChD,OAAA,GAQe,WACb,OAAO,EAA0B,KAAM,SAAS,GAAK,OAAF,OCXvD,EAAiB,YAAa,SAAS,GACrC,OAAA,GAee,SAAS,EAAM,GAC5B,OAAA,IAAa,EAEM,IAAT,GAAgB,EAAI,GAAS,EAA2B,EAGxD,GAAS,GAAU,GAAU,KCrB3C,EAAiB,2BAA4B,SAAS,GACpD,OAAA,GAce,SAAS,EAAe,GACrC,IAAI,EAAQ,KACZ,aAAA,SACE,EAAoC,OAAO,IAEzC,IAAA,EAAM,EAAM,OACZ,EAAI,GAAiB,EACjB,IAAA,EAAJ,IACF,EAAI,KAAK,IAAI,EAAI,EAAK,IAEjB,EAAI,EAAK,IAAK,CACnB,IAAI,EAAU,EAAM,GAChB,GAAA,IAAY,GAAiB,OAAO,GAAG,EAAS,GAClD,OAAO,EAGX,OAAO,KC/BXA,EAAiB,4BAA6B,SAAS,GACrD,OAAA,GAYe,SAAS,EAAc,GAGpC,OAAA,IADaS,EAAwB,KAAM,EAAc,YAC3C,QAAQ,EAAc,GAAgB,MCZxD,EAAiB,yBAA0B,SAAS,GAClD,OAAA,GAUe,WACb,OAAO,EAA0B,KAAM,SAAS,EAAG,GAAK,OAAF,OCjB1D,EAAiB,aAAc,SAAS,GACtC,OAAA,GAoBe,SAAS,EAAW,EAAW,GAC5C,EAAyB,MAAb,EAAoB,EAAY,SAAS,GAAK,OAAF,GACpD,IAAA,EAAS,GAET,EAAoC,oBAApC,QAAmD,OAAO,UACvC,EAAW,OAAO,UACV,GAAA,mBAA/B,EAA2C,CACzC,EAAY,EAAiB,KAAK,GAElC,IAAA,IAAI,EAAI,IACC,EAAO,EAAU,QAAQ,MAChC,EAAO,KACH,EAAU,KAAuB,EAAc,EAAK,MAAO,WAG7D,IAAA,EAAM,EAAU,OACX,EAAI,EAAG,EAAI,EAAK,IACvB,EAAO,KACH,EAAU,KAAuB,EAAc,EAAU,GAAI,IAG9D,OArBkD,KCpB7D,EAAiB,uBAAwB,SAAS,GAChD,OAAA,GAae,SAAS,EAAU,GAChC,OAAO,EAAqB,KAAM,EAAU,GAAa,MChB7D,EAAiB,YAAa,SAAS,GACrC,OAAA,GAUe,SAAS,GACtB,OAAO,KAAK,IAAI,GAAK,KAAK,OCQ9BC,IAAAA,EAC4D,mBAAxB,OAAc,OAC9C,OAAO,OAOP,SAAS,EAAQ,GACf,IAAK,IAAI,EAAI,EAAG,EAAI,UAAU,OAAQ,IAAK,CACzC,IAAI,EAAS,UAAU,GAClB,GAAA,EACL,IAAK,IAAI,KAAT,EACMH,EAAa,EAAQ,KAAM,EAAO,GAAO,EAAO,IAGxD,OARyB,GCxB/B,EAAiB,gBAAiB,SAAS,GACzC,OAAA,GAAeG,ICLjB,EAAiB,gBAAiB,SAAS,GACzC,OAAA,GAWa,SAAS,GACpB,IACS,EADL,EAAS,GACJ,IAAA,KAAT,EACMH,EAAa,EAAK,IACpB,EAAO,KAAK,EAAI,IAGb,OAPkB,KCZ7B,EAAiB,8BAA+B,SAAS,GACvD,OAAA,GAYe,SAAS,EAAc,GAUpC,IARA,IAAI,EAASE,EAAwB,KAAM,EAAc,cAErD,EAAS,EAAO,OAChB,EAAY,EAAa,OACzB,EAAI,KAAK,IACT,EACA,KAAK,IAA2C,EAAhB,EAAmB,EAAO,SAC1D,EAAI,EACD,EAAI,GAAa,EAAI,GAC1B,GAAI,EAAO,MAAQ,EAAa,KAAM,OAAO,EAExC,OAAP,GAAY,KpCChBE,IAAAA,EAMI,MAGAC,KA4yDgB,SAAQ,EAACC,EAAYC,GAjvDvC,IAUSC,EAVLC,EAmvDAH,EAnvDaI,MAAM,KACnBC,EAA0BP,EAKxB,EAAM,KAAZ,QAAmD,IAAzB,EAAWQ,YACnCD,EAAIC,WAAW,OAASH,EAAM,IAG3B,KAAUA,EAAMI,SAAWL,EAAOC,EAAMK,UACtCL,EAAMI,aAAqBE,IAwuDlBR,EAttDZI,EADSA,EAAIH,IAASG,EAAIH,KAAUQ,OAAOC,UAAUT,GAC/CG,EAAIH,GAEJG,EAAIH,GAAQ,GALhBG,EAAIH,GAytDMD,EqCh1DhBW,SAAW,EAACC,GAOV,KAAKC,EAASC,KAAKC,IAAID,KAAKE,IAAI,IAAOJ,GAMvC,KAAKK,EAHL,KAAKC,EAAY,EAYnBC,SAAM,EAANA,EAAOC,EAAQC,GACb,IAAMC,EAAWR,KAAKS,IAAI,EAAKV,EAAQO,GACjCI,EAAcH,GAAS,EAAIC,GAAYA,EAAW,EAAKJ,EAExD,MAAMM,KACT,EAAKN,EAAYM,EACjB,EAAKP,GAAgBG,GAQzBK,SAAW,EAAXA,GAEE,OAAA,EAAYP,GADO,EAAIJ,KAAKS,IAAI,EAAKV,EAAQ,EAAKI,ICvCpDN,SAAW,IAMT,KAAKe,EAAQ,IAAIC,EAAe,GAOhC,KAAKC,EAAQ,IAAID,EAAe,GAMhC,KAAKE,EAAgB,ECtBb,SAAA,KAOVC,SAAkB,KAQlBC,SAAiB,KA0BjBC,SAAY,KDsCZC,EAAA,UAAA,qBAAAC,SAAqBC,GACnB,OAAA,MAAI,KAAKN,EACAM,EAKFrB,KAAKsB,IAAIX,EAAA,KAAKC,GAAqBD,EAAA,KAAKG,KC+BnD,IAAAS,EAAkC,IAAIC,IAKlCC,GAAAA,EAAOC,SAAWD,EAAOC,QAAQxB,IAAIyB,KAAM,CAE7C,IAAA,EAAoB,GAApBC,GAAoB,EA3BbC,GA6BoBH,QAAQR,MAAMS,KAAKD,SAF1B,EA1BXI,GA6BoBJ,QAAQK,KAAKJ,KAAKD,SAH3B,EAzBdM,GA6BoBN,QAAQO,KAAKN,KAAKD,SAJxB,EAxBbQ,GA6BoBR,QAAQxB,IAAIyB,KAAKD,SALxB,EAvBhBS,GA6BoBT,QAAQU,MAAMT,KAAKD,SANvB,EAtBhBW,GA6BoBX,QAAQU,MAAMT,KAAKD,SAPvB,GAWpB,EAAuBE,EArCdE,GAsCT,EAAwBF,EAvCjBC,GC5FPS,SAAU,EAACC,EAAUC,GAEnB,IADA,IAAMC,EAAQ,GACd,EAAA/D,EAAgB6D,GAAhB,EAAA,EAAA,QAAA,EAAA,KAAA,EAAA,EAAA,OACEE,EAAMC,KAAKF,EADb,EAAAG,QAGOF,OALqB,EA+D9BG,IAAAC,GAAAD,SAAa,EAACE,GACP,IAAIC,EADQC,OAAA,EAAA,EAAA,SAAA,GAAA,OAAA,GAAA,EAAA,IACRD,EAAI,GADI,GAAA,EAAA,EACjB,EAAoBD,EAClB,EAAA,EAAMC,EAAN,GADF,EAAA,EAAA,IAAyB,IAAzB,EAAA,EAAA,OAiBFE,GAAAC,SAAiB,EAACX,GAIhB,IAAIQ,EACAI,EACAC,EACJ,EAAA,EAAWC,EAPeL,OAAA,EAAA,EAAA,SAAA,GAAA,OAAA,GAAA,EAAA,IAItBD,GAGJ,EADIK,EADAD,OAAOzD,EAEX,EAAAhB,EAAmB6D,GAAnB,EAAA,EAAA,QAP0B,GAAA,EAAA,EAO1B,EAAA,MAQA,GAAIQ,EAAJ,EAAA,EAAA,GAGE,EAAA,EAAM,CAACA,EAAAA,EAAGI,GAAAA,EAAMC,KAAAA,EAAMC,UAAM3D,GAA5B,IAXF,EAAA,EAAA,MACE,GAAIqD,EACF,EAAA,EAAM,CAACA,EAAAA,EAAGK,KAAAA,EAAMD,GAAAA,EAAME,KAAAA,GAAtB,GADF,EAAA,EAAA,KAGAN,IACA,EAAOK,EACP,EAAOC,EANT,EAAA,EAAA,OAAA,EAAA,EAAA,OC9FqB,SAAA,MAUvBC,SAAY,GAACC,EAAMC,GAEjB,IAAKD,IAASC,EACZ,OAAO,EAEL,IAACD,IAASC,GAGVD,EAAKE,YAAcD,EAAKC,WAC1B,OAAO,EAKLC,GAAAA,GAAkCH,IAC9BG,GAAkCF,KACrCD,EAAKI,YAAc,KAAOH,EAAKG,YAAc,GAChD,OAAO,EAGT,IAAA,IAAMC,EAASC,GAA+BN,GACxCO,EAASD,GAA+BL,GAC9C,EAAA9E,EAAgBmE,GAA2BU,EAAKE,aAAhD,EAAA,EAAA,QAAA,EAAA,KAAA,EAAA,EAAA,OACE,GAAIG,EADKb,EAAX,EAAA,QACmBe,EAAOf,GACtB,OAAO,EAGJ,OAAA,EAYTgB,SAA4B,GAACC,GAC3B,OAAA,aAAA,YACSA,EAEAA,EAAKC,OAahBC,SAAoB,GAACF,GACnB,OAAA,aAAA,YACSA,EAEgB,GAAnBA,EAAKL,YAAmBK,EAAKP,YAAcO,EAAKC,OAAOR,WAElDO,EAAKC,OAKP,IAAIE,WAAWH,GAAMC,OAiBhCG,SAAc,GAACC,EAAMC,EAAY9E,GACxB+E,OAAA,GAA6BF,OADjB,IAAAC,EAAS,EAATA,EAAY9E,OAAA,IAAAA,EAASgF,EAAAA,EAAThF,EAC2B2E,YAa5DM,SAAiB,GAACR,EAAQK,EAAY9E,GAC7B+E,OAAA,GAA6BN,OADZ,IAAAK,EAAS,EAATA,EAAY9E,OAAA,IAAAA,EAASgF,EAAAA,EAAThF,EACwBkF,UAY9DC,SAAY,GAACN,EAAMC,EAAQ9E,EAAQoF,GAGjC,IAAMC,GAAWR,EAAKV,YAAc,GAAKU,EAAKZ,WAMvC,OAHDqB,EAAQ9E,KAAK+E,IAAI,EAAG/E,KAAKsB,KADb+C,EAAKV,YAAc,GAAKW,EACGO,IAGlCD,IAAAA,EARIlB,GAA6CW,GAQpCS,EADZ9E,KAAKsB,IAAIwD,EAAQ9E,KAAK+E,IAAIvF,EAAQ,GAAIqF,GACbC,GCxGvCjF,SAAW,GAACmF,EAAUC,EAAUC,EAASC,GAAH,IAAA,IAAY,EAAZ,GAAA,EAAA,EAAA,EAAA,UAAA,SAAA,EAAY,EAAZ,EAAA,GAAA,UAAA,GAKpC,KAAKH,SAAWA,EAKhB,KAAKC,SAAWA,EAKhB,KAAKC,KAAOA,EAKZ,KAAKb,KApB2Cc,EAyBhD,KAAKC,SAAU,EDnDnBC,EAAA,yBAAAC,IzCm2DE,GyCvvDOC,WAAAC,GzCuvDP,GyCrwDOD,QAAA1B,GzCqwDP,GyCjyDO0B,cAAAE,GzCiyDP,GyCz1DOF,MAAAG,GC2FPC,GAAA,UAAA,SAAAC,WACE,MAAO,oBAAsBC,KAAKC,UAAU,KAAM,KAAM,OAnF5D,EAAA,mBAAAH,I1Cg1DE,G0CvuDFJ,SAA4BQ,CAQ1BA,YAAeA,EAOfA,SAAYA,G1CwtDZ,G0ChtDFR,SAA4BS,CAE1BA,QAAWA,EAGXA,KAAQA,EAGRA,MAASA,EAGTA,SAAYA,EAGZA,UAAaA,EAGbA,IAAOA,EAGPA,OAAUA,EAGVA,KAAQA,EAGRA,QAAWA,EAGXA,IAAOA,I1CmrDP,G0C3qDFT,KAAwBU,CAKtBA,mBAAsBA,IAYtBA,gBAAmBA,KAQnBA,WAAcA,KAQdA,QAAWA,KAMXA,mBAAsBA,KAQtBA,qBAAwBA,KAMxBA,sBAAyBA,KAMzBA,mBAAsBA,KAMtBA,wBAA2BA,KAM3BA,mBAAsBA,KAItBA,oBAAuBA,IAGvBA,iBAAoBA,KAQpBA,0BAA6BA,KAG7BA,aAAgBA,KAOhBA,YAAeA,KAOfA,iBAAoBA,KAKpBA,gBAAmBA,KAQnBA,iCAAoCA,KAOpCA,0BAA6BA,IAO7BA,oBAAuBA,KAMvBA,cAAiBA,KAMjBA,6BAAgCA,KAMhCA,wBAA2BA,KAM3BA,2BAA8BA,KAG9BA,4BAA+BA,KAM/BA,0BAA6BA,KAM7BA,iCAAoCA,KAMpCA,6BAAgCA,KAMhCA,0BAA6BA,KAO7BA,8BAAiCA,KAMjCA,yCAA4CA,KAM5CA,8BAAiCA,KAMjCA,8BAAiCA,KAMjCA,6BAAgCA,KAShCA,YAAeA,KASfA,qBAAwBA,KAKxBA,mBAAsBA,KAatBA,8BAAiCA,IAMjCA,iBAAoBA,KAMpBA,qBAAwBA,KAGxBA,0BAA6BA,KAG7BA,kBAAqBA,KAKrBA,uBAA0BA,KAG1BA,2BAA8BA,KAG9BA,uBAA0BA,KAM1BA,0BAA6BA,KAG7BA,oCAAuCA,KAGvCA,yBAA4BA,KAmB5BA,2BAA8BA,KAS9BA,4BAA+BA,KAM/BA,gBAAmBA,KAKnBA,+BAAkCA,KAOlCA,iCAAoCA,KAQpCA,uCAA0CA,KAM1CA,8BAAiCA,KAQjCA,iCAAoCA,KAOpCA,+BAAkCA,KAOlCA,yBAA4BA,KAM5BA,2BAA8BA,KAM9BA,6BAAgCA,KAKhCA,+BAAkCA,KAKlCA,uBAA0BA,KAS1BA,uCAA0CA,KAe1CA,+BAAkCA,KAKlCA,wCAA2CA,KAK3CA,qCAAwCA,KAMxCA,yBAA4BA,KAG5BA,YAAeA,KAMfA,yBAA4BA,KAM5BA,gCAAmCA,KAMnCA,uBAA0BA,KAc1BA,uCAA0CA,KAO1CA,0BAA6BA,IAc7BA,wCAA2CA,KAO3CA,qBAAwBA,KAQxBA,0BAA6BA,KAO7BA,2BAA8BA,KAM9BA,yBAA4BA,KAU5BA,mCAAsCA,KAOtCA,uBAA0BA,KAQ1BA,0BAA6BA,KAQ7BA,mCAAsCA,KAStCA,wBAA2BA,KAK3BA,wBAA2BA,KAM3BA,QAAWA,KAMXA,4BAA+BA,KAM/BA,0BAA6BA,KAO7BA,iBAAoBA,IAMpBA,kBAAqBA,KAOrBA,iBAAoBA,KAKpBA,iBAAoBA,KASpBA,qBAAwBA,IAKxBA,kBAAqBA,KAKrBA,gBAAmBA,KAOnBA,sBAAyBA,KAMzBA,sBAAyBA,KAMzBA,0BAA6BA,KAO7BA,8BAAiCA,KAUjCA,sBAAyBA,IAUzBA,iBAAoBA,KAMpBA,6BAAgCA,KAMhCA,yBAA4BA,KAM5BA,sBAAyBA,KAOzBA,0BAA6BA,KAU7BA,yBAA4BA,KAO5BA,+BAAkCA,KASlCA,gCAAmCA,KAKnCA,cAAiBA,KAKjBA,qBAAwBA,KAKxBA,mBAAsBA,IAMtBA,8BAAiCA,MAKjCA,mBAAsBA,MAMtBA,8BAAiCA,MAOjCA,iCAAoCA,OCh3BtC,IAAAC,GAA0B,kHC3BfC,SAAQ,GAACC,GAElB,IAAIC,EACJ,aAAA,IACEC,GAAAA,KAAeF,EAmPLG,IAlPVC,KAgSGC,GAhScL,EAqRPK,GApRVC,KA4TGC,GA5TYP,EAiTLO,GAhTVC,GAAAA,KAAaR,EA6UHS,IA5UVC,KA2XGC,GA3XUX,EAgXHW,GA/WVC,GAAAA,KAAkBZ,EA4bRa,EA5b2BC,SACrCC,KA8cGC,GA9cchB,EAmcPgB,IAlcDhB,IAAQC,EAAyBgB,OAAOjB,GDoE3CkB,MAAMpB,MChEZI,GAAAA,KAAeD,EDoCTkB,ICpCoD,IAAI,GAC9Df,KAqRGC,GAAqBe,GArRPnB,EDoCRoB,ICpCsD,IAC/Df,KAiTGC,GAAmBa,GAjTPnB,EDoCTqB,ICpCoD,IAiTD,GAhTzDd,GAAAA,KAAaP,EDoCTsB,ICnCJb,KAgXGC,GAAiBS,GAhXPnB,EDoCTuB,ICpCkD,IAgXD,GA/WrDZ,GAAAA,KAAkBX,EDoCRwB,ICpCuD,IAAI,GACrEV,KAmcGC,GAAqBI,GAncPnB,EDoCTyB,ICpCsD,KAE9D,KAAKb,EAAa,IAAIc,GAAmB,MA0Od,SAAQ,GAARC,EAASC,EAAWC,GACjD,EAAK3B,GAAU2B,EAASV,GAAwBS,GAAW,GACvDA,EAIJ,EAAS1B,KACP,EAAKA,GAAU,EAAKA,GAAQ4B,QAAQ,KAAM,KAqFjBC,SAAQ,GAARA,EAASC,GACpC,GAAIA,EAAS,CAEPC,GADJD,EAAUE,OAAOF,GACbC,MAAMD,IAAsB,EAAVA,EACpB,MAAM,MAAM,mBAAqBA,GAEnC,EAAKxB,GAAQwB,OAEb,EAAKxB,GAAQ,KA0DiB2B,SAAQ,GAARA,EAASC,EAAWP,GAChDO,aAAJ,GACE,EAAKxB,EAAawB,GAEbP,IAGHO,EAAYC,GAA6BD,EACAE,KAE3C,EAAK1B,EAAa,IAAIc,GAAmBU,IAyHnBjB,SAAQ,GAACoB,EAAKC,GAEtC,OAAA,EAIOA,EAAmBC,UAAUF,GAAOG,mBAAmBH,GAHrD,GAmBoBF,SAAQ,GAACM,EAAeC,EACnDC,GACF,OAAA,MAAIF,GACEG,EAAUC,UAAUJ,GACpBb,QAAQc,EAAOI,IACfH,IAGFC,EAAyCA,EA2BlBhB,QAAQ,uBAAwB,QAzBlDgB,GAEF,KAUcE,SAAQ,GAACC,GAEvB,MAAA,MADHC,EAAID,EAAGE,WAAW,KACF,EAAK,IAAK5D,SAAS,KAAW,GAAJ2D,GAAS3D,SAAS,KA/iBlE,EAAA,GAAA,WAAA6D,GAA6B,GAQ7B,EAAAhD,GAA+B,GAQ/B,EAAAE,GAA6B,GAQ7B,EAAAE,GAA2B,KAQ3B,EAAAE,GAA2B,GAgB3B,EAAAK,GAA+B,GAO/B,EAAAxB,SAA8B8D,WAC5B,IAAIC,EAAM,GAENC,EAASC,KA4JDtD,GAtJRuD,GALJ,GACEH,EAAIjH,KAAKgG,GACLkB,EAAQG,IAA0C,GAAO,KAG3DD,EAASE,KAsNDrD,GArNA,CACVgD,EAAIjH,KAAK,MAELuH,IAAAA,EAAWC,KAqLLzD,GApLV,GACEkD,EAAIjH,KAAKgG,GACLuB,EAAUF,IAA0C,GAAO,KAGjE,EAAIrH,KAAoCyH,mBAAmBL,GAgflC3B,QAAQ,uBAAwB,QA7ezD,OADIiC,EAAOC,KAuODxD,KArOR8C,EAAIjH,KAAK,IAAK2E,OAAO+C,IA2BlBT,OAvBHW,EAAOC,KAqQCxD,MAnQNyD,KAuNQ7D,IAvN8B,KAAlB2D,EAAKG,OAAO,IAClCd,EAAIjH,KAAK,KAEXiH,EAAIjH,KAAKgG,GACL4B,EACkB,KAAlBA,EAAKG,OAAO,GACRC,GACAC,IACJ,MAGFC,EAAQC,KAoTA5D,EAAWrB,aAlTrB+D,EAAIjH,KAAK,IAAKkI,IAGZE,EAAWC,KAwUH3D,KAtUVuC,EAAIjH,KAAK,IAAKgG,GACVoC,EAAUE,KAET,EAAIC,KAAK,KAqBlB,EAAAC,QAA6BC,SAASC,GAEpC,IAAIC,EAAc,KAAKnE,QACvB,SAAImE,EAAY9E,KAEd8E,EAAc,IAAIlF,IAMhBmF,IAAAA,IAAaF,EAwGH7E,GAtGd,EACED,GAAA+E,EAAsBD,EA0EZ7E,IAxEV+E,IAAaF,EAgID3E,GA7Hd,EACE4E,EAkHG5E,GAlHqB2E,EAuGd3E,GArGV6E,IAAaF,EAuJDzE,GApJd,EACE0E,EAyIG1E,GAzImByE,EA8HZzE,GA5HV2E,EAqLmB,MArLNF,EAqLHvE,GAlLRyD,IAAAA,EAAOc,EA0LCrE,GAzLRuE,GAAAA,EACF1E,GAAAyE,EAAoBD,EAoJVvE,SAlJVyE,GAAAA,IAAaF,EA0MDrE,GAzMI,CAEd,GAAsB,KAAlBuD,EAAKG,OAAO,GAEd,GAAID,KAqII7D,KArIiB4E,KAqMjBxE,GAnMNuD,EAAO,IAAMA,MACR,CAEL,IAAIkB,EAAiBH,EA4KjBtE,GA5KuC0E,YAAY,MACvD,GAAID,IACFlB,EAAOe,EA0KLtE,GA1K2B2E,OAAO,EAAGF,EAAiB,GAAKlB,GAqSvE,GAAY,MAjS0BA,GAiSV,KAjSUA,EAkSpC,EAAO,QAEwB,IAA1B,GApS+BA,EAoStBqB,QAAQ,QAAjB,GApS+BrB,EAqStBqB,QAAQ,MADjB,CAODC,EAA4C,GA3SZtB,EA2SXmB,YAAY,IAAK,GACtCI,EA5SgCvB,EA4ShBjL,MAAM,KAC1B,IAAA,IAAIsK,EAAM,GAEDmC,EAAM,EAAGA,EAAMD,EAASrM,QAAU,CACzC,IAAIuM,EAAUF,EAASC,KAEvB,KAAIC,EACEH,GAAgBE,GAAOD,EAASrM,QAClCmK,EAAIjH,KAAK,IAES,MAAXqJ,IACQ,EAAbpC,EAAInK,QAA4B,GAAdmK,EAAInK,QAAyB,IAAVmK,EAAI,KAC3CA,EAAIqC,MAEFJ,GAAgBE,GAAOD,EAASrM,QAClCmK,EAAIjH,KAAK,MAGXiH,EAAIjH,KAAKqJ,GACTH,GAAe,GAInB,EAAOjC,EAAIsB,KAAK,MA/SXI,OAhBHC,EACFD,EA4KGtE,GA5KiBuD,EAEpBgB,EA2LoC,KA3LvBF,EA2LHnE,EAAWrB,WAxLvB,EACEoB,GAAAqE,EAAyBD,EAwOfnE,EAxO0CC,SAEpDoE,IAAaF,EAmQDhE,GAhQd,IACEiE,EAqPGjE,GArPqBgE,EA0OdhE,IA9SqC,GA+EnD,EAAAF,MAA2B+E,WACzB,OAAW9F,IAAAA,GAAS,OAsXtB,IAAA4D,GAA2C,YAS3CY,GAAuC,UAQvCD,GAAuC,SAQvC/B,GAAgC,UAQhCqC,GAAmC,KAkBd,SAAQ,GAACJ,GAM5B,KAAKsB,EAAgBtB,GAAS,KCjsB9B/K,SAAW,GAACsM,EAAOC,GACjB,KAAKC,EAASF,EACd,KAAKG,EAASF,ECqChBG,SAAuB,GAAQC,EAAMC,GAMjBC,IAAAA,EAAAA,IAAIC,GC+BeR,ED/BgBO,GEnBvDE,EFcmBC,GEVqBC,EAAAA,EAAKA,EHRrCC,EGQYC,EHRMV,EAASW,EAAMX,GGQuB,GAA5CU,EHTMX,EAASY,EAAMZ,GAGlBU,GGUQ,EAAKG,EAAa,EAAKC,GAC3C,EAAKL,EAAiBE,EFWHR,EAAMC,GAUpCS,SAAiB,GAACE,EAAgBC,EAAgBb,EAAMC,GAItDa,EAAqB,CACnBd,EACA,6CACAa,EACA,gCACAD,EACA,4BACAX,GACAxB,KAAK,MAUTkC,SAAiB,GAACC,EAAgBC,EAAgBb,EAAMC,GActDc,EAVqB,CACnBf,EACA,8CACAa,EACA,0BACAD,EACA,4BACAX,GACAxB,KAAK,MFopBX,EAAA,GAAA,WAAAuC,GAAuC,KAQvC,EAAAC,GAAsC,KAkBtC,EAAAC,IAAmCC,SAASC,EAAKrN,GA7D/C,IA8DAsN,KA9DUL,KA8DVK,KA7DOL,GAAU,GA6DjBK,KA5DOJ,GAAS,EA4DhBI,KA1DW3B,GAEP,IADA,IAAI4B,EAyDRD,KAzDqB3B,EAAc7M,MAAM,KAC5B0D,EAAI,EAAGA,EAAI+K,EAAMtO,OAAQuD,IAAK,CACrC,IAAIgL,EAAgBD,EAAM/K,GAAG4I,QAAQ,KAEjCpL,EAAQ,KACS,GAAA,GAAjBwN,EAAoB,CACtB,IAAAvB,EAAOsB,EAAM/K,GAAGiL,UAAU,EAAGD,GAC7B,EAAQD,EAAM/K,GAAGiL,UAAUD,EAAgB,QAE3C,EAAOD,EAAM/K,GAEf,EAAOgG,mBAAmByD,EAAKrE,QAAQ,MAAO,MAC9C,EAAQ5H,GAAS,GACjB,KAAKmN,IAAIlB,EAAMzD,mBAAmBxI,EAAM4H,QAAQ,MAAO,OAuDtD,OATP,KAAK+D,EAAgB,MAEjB+B,EAAS,KAAKT,GAAQU,eAAeN,IAAQ,KAAKJ,GAAQI,MAE5D,KAAKJ,GAAQI,GAAQK,EAAS,IAEhC,EAAOvL,KAAKnC,GAEZ,KAAKkN,KAXiD,MAoBxD,EAAA7H,SAAwCuI,WACtC,GAAI,KAAKjC,EACP,OAAA,KAAYA,EAGV,IAAC,KAAKsB,GACR,MAAO,GAGLY,IAEKR,EAFLQ,EAAK,GAEAR,IAAAA,KAAT,KAAqBJ,GAGnB,IAFA,IAAIa,EAAalE,mBAAmByD,GAChChF,EAAM,KAAK4E,GAAQI,GACdU,EAAI,EAAGA,EAAI1F,EAAIpJ,OAAQ8O,IAAK,CACnC,IAAIC,EAAQF,EAGZ,KAAIzF,EAAI0F,KACNC,GAAS,IAAMpE,mBAAmBvB,EAAI0F,KAExC,EAAG5L,KAAK6L,GAIZ,OAAA,KAAYrC,EAAgBkC,EAAGnD,KAAK,MAgBtC,EAAA/D,MAAqCsH,WACnC,IAAIC,EAAK,IAAI1G,GAET,GADJ,EAAGmE,EAAgB,KAAKA,EACpB,KAAKsB,GAAS,CAChB,IACSI,EADLc,EAAW,GACNd,IAAAA,KAAT,KAAqBJ,GACnBkB,EAASd,GAAO,KAAKJ,GAAQI,GAAKe,SAEpC,EAAGnB,GAAUkB,EACb,EAAGjB,GAAS,KAAKA,GAEnB,OAX8C,GCzyB9Cd,GAAA,UAAA,SAAA/G,WACE,MAAO,IAAM,KAAKyG,EAAS,IAAM,KAAKC,GC4E1C,IAAAO,GAA4B,KCjF1B+B,SAAqB,GAACC,EAAK1P,GACzB,OAAO,EAAIwP,OAAOxP,GAcpB2P,SAAW,MAWXC,SAAgB,GAACxO,GACf,OAAA,MAAOA,EAWTyO,SAAkB,GAACC,GAGjB,IAAMC,EAAMvP,OAAOwP,OAAOF,EAAQrP,WAAaD,OAAOC,WAKlD,IACF,IAAAwP,EAAMH,EAAQI,KAAKH,GAInB,IACEI,GACI,0BACA,uCACJF,EAAMF,GAER,MAAOK,GAGPD,GACI,0BACA,uCAEJF,EAAM,IADiDH,EAGzD,OA5B0B,EEzD5BO,SAAkB,GAACC,EAAUC,GAE3B,GAA2B,GAAvBA,EAAalQ,OACf,OAGF,EAAMmQ,IAAAA,EAAiBD,EAAapN,IAAI,SAAC8D,GAAQ,OAAID,IAAAA,GAASC,KAGvDqJ,OAAA,EAASnN,IAAI,SAAC8D,GAAQ,OAAID,IAAAA,GAASC,KACrC9D,IAAI,SAACsN,GAAS,OAAA,EAAetN,IAAI,SAACS,GAAM,OAAA,EAAKmI,QAAQnI,OACrD8M,OAAOC,GAA2B,IAClCxN,IAAI,SAAC8D,GAAQ,OAAA,EAAIR,aAWxBmK,SAAoB,GAACC,EAAWC,GAC9B,MAAO,CACLD,UAAWA,EACXE,iBAAkB,GAClBC,+BAA+B,EAC/BC,yBAAyB,EACzBC,gBAAiB,GACjBC,gBAAiB,GACjBC,kBAAmB,KACnBN,SAAUA,GAAY,GACtBO,OAAQ,IAAIhP,KASlB,IAAAiP,GAA6C,CAC3CC,GAAOA,QACPC,GAAOA,QACPC,EAAMA,OACNC,GAAOA,QACPC,GAAaA,eClDbjR,SAAW,KACT,IAAIkR,EACAC,EAkBEC,EAPUC,IAAIC,QAAS,SAACjG,EAASkG,GACrCL,EAAiB7F,EACjB,EAAgBkG,IASXH,OAHP,EAAc/F,QAAU6F,EACxB,EAAcK,OAASJ,EAtBX,ECDdnR,SAAW,GAACwR,GAEV,KAAKC,EAAOD,EAGZ,KAAKE,OAAS7R,ECJO,SAAA,MAQvB8R,SAAe,GAACnN,GACd,IAAKA,EACH,MAAO,GAKT,MAFIoN,EAAQ5N,GAA+BQ,IAEjC,IAA0B,KAAZoN,EAAM,IAA0B,KAAZA,EAAM,KAChDA,EAAQA,EAAMC,SAAS,IAInBC,EAAOC,GAAoCH,GAK3CI,EAAUC,OAAOH,GAInB,IACF,OAAO,mBAAmBE,GAC1B,MAAOtC,GACP,MAAU5J,IAAAA,GVqGFoM,EAaJC,EAyHQC,OUxNhBC,SAAgB,GAAC7N,EAAM8N,EAAcC,GACnC,IAAK/N,EACH,MAAO,GAGL,IAAC+N,GAAkC,GAAvB/N,EAAKZ,WAAa,EAEhC,MAAUkC,IAAAA,GV2EFoM,EAaJC,EAyHQC,MU3Md,IAAMzS,EAASQ,KAAKqS,MAAMhO,EAAKZ,WAAa,GACtC6O,EAAM,IAAIC,YAAY/S,GACtBgT,EAAWhN,GAAkCnB,GACnD,IAAA,IAAA,GAAA,EAAA3F,EAAgBmE,GAA2BrD,KAA3C,QAAA,EAAA,KAAA,EAAA,EAAA,OACE8S,EADSvP,EAAX,EAAA,OACWyP,EAASC,UAAc,EAAJ1P,EAAOoP,GAE9BP,OAAA,GAAoCU,GAY7CI,SAA0B,GAACrO,GAgBTsO,SAAA,EAAC5P,GAEf,OAAA,EAAaU,YAAcV,GAAkB,IAAZ0O,EAAM1O,IAA0B,KAAZ0O,EAAM1O,GAhB7D,IAAKsB,EACH,MAAO,GAGHoN,IAAAA,EAAQ5N,GAA+BQ,GAC7B,GAAA,KAAZoN,EAAM,IAA0B,KAAZA,EAAM,IAA0B,KAAZA,EAAM,GAChD,OAAO,GAAqBA,GACP,GAAA,KAAZA,EAAM,IAA0B,KAAZA,EAAM,GACnC,OAAO,GACHA,EAAMC,SAAS,IAAwB,GACtB,GAAA,KAAZD,EAAM,IAA0B,KAAZA,EAAM,GACnC,OAAO,GAAsBA,EAAMC,SAAS,IAAwB,GAUtD,GAAA,GAAZD,EAAM,IAAuB,GAAZA,EAAM,GACzB,OAAO,GAAsBpN,GAA0B,GAClC,GAAA,GAAZoN,EAAM,IAAuB,GAAZA,EAAM,GAChC,OAAO,GAAsBpN,GAA0B,GAC9CsO,GAAAA,EAAQ,IAAMA,EAAQ,IAAMA,EAAQ,IAAMA,EAAQ,GAC3D,OAAO,GAAqBtO,GAGxB,MAAIsB,IAAAA,GVoBAoM,EAaJC,EAsHqBY,MUzI7BC,SAAa,GAACC,GAMN3J,EAAUgB,mBAAmB2I,GAM7BnB,IAAAA,EAAOoB,SAAS5J,GAEhB6J,EAAS,IAAI7O,WAAWwN,EAAKnS,QAEnC,IAAA,IAAA,GAAA,EAAAd,EAD0BuE,GACQ0O,KAAlC,QAAA,EAAA,KAAA,EAAA,EAAA,OACEqB,GADS,EAAX,EAAA,OAAYjQ,GAAG,EAAAK,KACIoG,WAAW,GAEvB/D,OAAA,GAAqCuN,GAY9CC,SAAc,GAACH,EAAKX,GAIlB,IAHA,IAAMa,EAAS,IAAIE,YAAyB,EAAbJ,EAAItT,QAC7BwE,EAAO,IAAIU,SAASsO,GAE1B,EAAAtU,EAD0BuE,GACQ6P,IAAlC,EAAA,EAAA,QAAA,EAAA,KAAA,EAAA,EAAA,OAAW,EAAX,EAAA,MAEE9O,EAAKmP,UAA8B,EAFzB,EAAApQ,EAAG,EAAAK,KACMoG,WAAW,GACe2I,GAExCa,OARyB,EAsBlCI,SAAmB,GAAC3Q,GAClB,OAAO,GAAyClC,OAAzC,CAAiDkC,GFxJ1D4Q,GAAA,UAAA,QAAAnI,aAIAkG,GAAA,UAAA,OAAAA,aCzBAkC,GAAA,UAAA,MAAA/S,WAOS,OANYb,MAAf,KAAK6R,IAEP,KAAKA,EAA2B,KAAKD,KAIvC,KAAYC,GCfhBlM,EAAA,yBAAAkO,IpD61DE,GoDhqDOhO,kBAAPiO,WACEC,GD1KKD,OAAS9T,GnDy0DhB,GoD/rDO6F,QAAAmO,GpD+rDP,GoD9tDOnO,OAAAoO,GpD8tDP,GoD3wDOpO,oBAAAqO,GpD2wDP,GoD1yDOrO,UAAAsO,GpD0yDP,GoDr1DOtO,SAAAuO,GA4LTC,IAAAA,GAA2C,IAAIT,GAAgB,WAEnCU,SAAA,EAACC,GACzB,IAGE,IAAMhQ,EAAS,IAAIE,WAAW8P,GAQV,OAApB,EAFY5M,OAAO+L,aAAac,MAAM,KAAMjQ,GAEjCzE,OACX,MAAO0B,GACP,OAAO,GAQX,IAAA,IAAA,EAAA,CAAS+S,GAAO,OAAkB,EAAPA,EAAAA,IAA3B,EAAA,CAAA,GAASA,EAAAA,KAA4BA,IAAQ,EAC3C,GAAID,EAAkBC,EAAAA,IACpB,OAAO,SAAA,GAAA,OAAA,SAAChQ,GAEN,IADA,IAAImL,EAAM,GACDrM,EAAI,EAAGA,EAAIkB,EAAOzE,OAAQuD,GAAKkR,EAAAA,GAOtC7E,GAAO/H,OAAO+L,aAAac,MAAM,KANhBjQ,EAAOyN,SAAS3O,EAAGA,EAAIkR,EAAAA,KAQnC7E,OAXU,GAAZ,CAAA,GAgBJ,OA1C4D,OCtMxC,SAAA,MAuB3B+E,SAAuB,GAAC9P,GAGf+P,OAFDC,EAAQzC,GACV/N,GAA+BQ,IAC5B,KAAKgQ,GAYdC,SAAe,GAACjQ,EAAMkQ,GACpBA,EAAsB7U,MAAX6U,GAA+BA,EACpCC,IAAAA,EAASC,GAA4CpQ,GACtD8D,QAAQ,MAAO,KAAKA,QAAQ,MAAO,KACjCoM,OAAA,EAAUC,EAASA,EAAOrM,QAAQ,QAAS,IAUpDuM,SAAiB,GAAC5B,GAGhB,IAAMuB,EAAQ5S,EAAOkT,KAAK7B,EAAI3K,QAAQ,KAAM,KAAKA,QAAQ,KAAM,MACzD6K,EAAS,IAAI7O,WAAWkQ,EAAM7U,QAEpC,IAAA,IAAA,GAAA,EAAAd,EAD0BuE,GACQoR,KAAlC,QAAA,EAAA,KAAA,EAAA,EAAA,OACErB,GADS,EAAX,EAAA,OAAYjQ,GAAG,EAAAK,KACIoG,WAAW,GAEvBwJ,OATc,EAmBvB4B,SAAc,GAAC9B,GAGb,IAFA,IAAMmB,EAAOnB,EAAItT,OAAS,EACpB8S,EAAM,IAAInO,WAAW8P,GAC3B,GAAA,EAAAvV,EAAgBmE,GAA2BoR,KAA3C,QAAA,EAAA,KAAA,EAAA,EAAA,OACE3B,EADSvP,EAAX,EAAA,OACWtB,EAAOoT,SAAS/B,EAAIpH,OAAW,EAAJ3I,EAAO,GAAI,IAE1CuP,OANW,EAgBpBwC,SAAY,GAACzQ,GACX,IAAMiO,EAAMzO,GAA+BQ,GACvC0Q,EAAM,GACV,IAAA,IAAA,GAAA,EAAArW,EAAkB4T,IAAlB,QAAA,EAAA,KAAA,EAAA,EAAA,OAEsB,IADpB/R,GADOA,EAAT,EAAA,OACgBqF,SAAS,KACbpG,SACRe,EAAQ,IAAMA,GAEhBwU,GAAOxU,EAEFwU,OAVU,EAoBnBpG,SAAa,GAAIxJ,GAAH,IAAA,IAAY,EAAZ,GAAA,EAAA,EAAA,EAAA,UAAA,SAAA,EAAY,EAAZ,GAAA,UAAA,GACR6P,IAAAA,EAAc,EAClB,EAAAtW,EAFwByG,GAExB,IAAA,EAAA,EAAA,QAAA,EAAA,KAAA,EAAA,EAAA,OACE6P,GADF,EAAA1C,MACqB7O,WAKrB,IAFMuP,EAAS,IAAI7O,WAAW6Q,GAC1B1Q,EAAS,EACb,GAAA,EAAA5F,EARwByG,IAQxB,QAAA,EAAA,KAAA,EAAA,EAAA,OAAWmN,EAAX,EAAA,MACEU,EAAOiC,IAAIpR,GAA+ByO,GAAMhO,GAChDA,GAAUgO,EAAI7O,WAETuP,OAZiB,ECtG1BnT,SAAW,KAAG,IAAA,EAAA,KAEZ,KAAKqV,EAAiB,IAAIC,MAAMC,IAAIC,WAAW,CAC7C,wBAA0B,IAI5B,KAAKC,EAAmB,KAGxB,KAAKC,EAAkB,GAGvB,KAAKC,EAAY,GAGjB,KAAKC,EAAY,GAGjB,KAAKC,GAAiB,EAEtB,KAAKR,EAAeS,GAAG,OAAQ,SAAC5J,GAAY6J,EAiJvCJ,EAjJ0DzJ,EAiJtC8J,SACzB,EAAKJ,EAlJ0D1J,EAkJtC+J,SACzB,EAAKP,EAAgB7S,KACjBqT,GApJ2DhK,EAoJjBiK,YApJiBjK,EAoJI1H,SAlJnE,KAAK6Q,EAAeS,GAAG,OAAQ,WA4J/B,IAAMM,EAAS,CACb5R,KAAM6R,GAAA,MAAAC,GAAAC,EA7J6BC,EA6Jad,IAChDM,SA9JmCQ,EA8JpBb,EACfM,SA/JmCO,EA+JpBZ,GAGjB,EAAKH,EAAiBpK,QAAQ+K,GAC9B,EAAKP,GAAiB,IAhJjB,SAAW,GAACY,EAAUC,GAG3B,IAAK9U,EAAO0T,OAwBiD,QAxBdmB,EAwB/BE,cAAcnX,MAAM,KAAK,GAAGA,MAAM,KAAK,GAvBrD,OAAO,EAGLkX,GAAAA,EACF,OAAO,YAAYE,gBACfC,GAA2BH,EAAaD,IAKxCK,IAAAA,EAAYD,GLZb/F,QKY2D2F,GAC1DM,EAAYF,GLdbhG,QKc2D4F,GACzDO,OAAA,YAAYJ,gBAAgBE,IAC/BE,YAAYJ,gBAAgBG,GAoBlCE,SAAsB,GAACP,EAAaQ,GAElC,IAAIC,EAAcD,EAAW5O,QAAQ,QAAS,OAC9C,SAAIoO,IACFS,EAAcA,EAAY7O,QAAQ,QAAS,UASvCb,IAAAA,EAAQ,2BAA2B2P,KAAKD,GAC1C1P,GAAAA,EAAO,CACT,IAAI4P,EAAiB,QAEfC,EAAU7P,EAAM,GAYhB8P,EAAQ7O,OAAOjB,EAAM,IAG3B,GAde,MAAX6P,EACFD,EAAkB,OACE,MAAXC,EACTD,EAAkB,OAIlBA,EAAkB,SAODE,GAAS,GAAGxR,SAAS,IACxC,IAA2B,GAARwR,GAAaxR,SAAS,IAEzC,EAAcoR,EAAY7O,QAAQb,EAAM,GAAI4P,GAG9C,OAtC8C,ECnFhDrX,SAAW,GAACwX,GAEV,KAAKC,EAAUD,EAGf,KAAKE,EAAiB,KCCxB1X,SAAW,GAACwX,GAOV,KAAKC,EAAUD,EAGf,KAAKG,EAAU,KCVjB3X,SAAW,GAAC4X,EAAYC,GAItB,IAAMC,EA0GC,CACLC,YAAa,EACbC,UAAW,IACXC,cAAe,EACfC,WAAY,GACZC,QAAS,GAzGX,KAAKC,EAA0C,MAA1BR,EAAWG,YAC5BD,EAASC,YAAcH,EAAWG,YAQtC,KAAKM,EAAsC,MAAxBT,EAAWI,UAC1BF,EAASE,UAAYJ,EAAWI,UAQpC,KAAKM,EAAwC,MAAzBV,EAAWM,WAC3BJ,EAASI,WAAaN,EAAWM,WAQrC,KAAKK,EAA8C,MAA5BX,EAAWK,cAC9BH,EAASG,cAAgBL,EAAWK,cAMxC,KAAKO,EAAe,EAGpB,KAAKC,EAAqB,KAAKJ,GAG/B,KAAKK,OAlDiB,IAAAb,GAAAA,KA2DpB,KAAKW,EAAe,GAQlBG,SAAO,GAAPA,GAYJ,IAAMC,EAYAC,EAxBQC,OAAA,EAAA,SAAA,GAAA,GAAA,GAAA,EAAA,EAAA,CACd,GADc,EACLN,GADK,EACgBJ,EAC5B,CAAA,IAFY,EAEHM,EAGD,MAAI5S,IAAAA,GfwDJoM,EA4BF6G,EAwFYC,MejLNC,EA8ETT,EAAe,EA9ENS,EA+ETR,EA/ESQ,EA+EiBZ,EAhET,OAHhBO,EAZQ,EAYcJ,EAC5B,EAAKA,IAEiB,GAAlBI,EAEF,EAAA,UAOF,EAxBc,EAyBLH,GA4CO,GANqB,EAAhBtY,KAAK+Y,SAAkB,GA/D9B,EAyBoBZ,GAElC,EAAA,EAAM,IAAIhH,QAAQ,SAACjG,GAgEnB,IADkB8N,GA9DuB9N,GA+DnC+N,EA/DoBP,EA+DE,OAhE5B,IA3Bc,EAgCTJ,GAhCS,EAgCkBF,EAhClB,EAAA,KC3DhBvY,SAAW,GAACqR,EAASgI,GAEnB,KAAKhI,QAAUA,EAGf,KAAKiI,EAAWD,EAGhB,KAAKE,GAAW,EASlBC,SAAa,GAACnY,GACZ,OAAWoY,IAAAA,GACPnI,QAAQC,OAAOlQ,GACf,WAAM,OAAA,QAAQgK,YAQpBqO,SAAc,KACZ,IAAMC,EAAIrI,QAAQC,OASX,IAAIzL,GhBkFDoM,EA4BF6G,EAomBWa,OgBvtBZ,OADP,EAAA,MAAQ,cACGH,IAAAA,GAA8BE,EAAG,WAAM,OAAA,QAAQtO,YAkB5DwO,SAAgB,GAACnZ,GACf,OAAW+Y,IAAAA,GACPnI,QAAQjG,QAAQ3K,GAChB,WAAM,OAAA,QAAQ2K,YAWpByO,SAAmB,GAACzI,GAClB,OAAWoI,IAAAA,GACPpI,EAGA,WAAM,OAAA,EAAA,MAAc,gBAmBnB,SAAG,GAAC0I,GACT,OAAWN,IAAAA,GACPnI,QAAQtC,IAAI+K,EAAWtX,IAAI,SAACuX,GAAO3I,OAAAA,EAAGA,WACtC,WAAM,OAAA,QAAQrC,IAAI+K,EAAWtX,IAAI,SAACuX,GAAO,OAAA,EAAGC,aCzGlDja,SAAW,GAACka,EAAMC,GAEXpM,IAAAA,IAAMA,KAFKoM,OAAA,IAAAA,EAAO,GAAPA,EAGdra,OAAOsa,eAAe,KAAMrM,EAAK,CAC/BrN,MAAOyZ,EAAKpM,GACZsM,UAAU,EACVC,YAAY,IAchB,KAAKC,iBAHL,KAAKC,WAHL,KAAKC,SAAU,EAef,KAAKC,UAAY9Y,EAAO+Y,aAAe/Y,EAAO+Y,YAAYC,IACtDhZ,EAAO+Y,YAAYC,MAAQC,KAAKD,MAGpC,KAAKV,KAAOA,EAGZ,KAAKY,WAAY,EAMjB,KAAKC,OAHL,KAAKC,cAAgB,KAUrB,KAAKC,GAAU,ECxDjBjb,SAAW,KAET,KAAKkb,EAAO,GCOdlb,SAAW,KAIT,KAAKmb,GAAa,IAAIC,GAMtB,KAAKC,GAAiB,KCbxBC,SAAkB,GAACC,GACjB,IAAMC,EAAc,IAAI7Z,IAoDjB0F,OAjDOA,SAAA,EAAC0B,GACb,cAAA,GACE,IAAK,YACL,IAAK,UACL,IAAK,SACL,IAAK,SACL,IAAK,SACL,IAAK,WACH,OAEF,EAUE,QAAA,IARKA,GAODA,EAAI3E,QAAU2E,EAAI3E,OAAOpE,aAAeqT,YAE1C,OAGF,EAAImI,GAAAA,EAAYC,IAAI1S,GAClB,OAGF,KAAM2S,IAAAA,EAAU3S,EAAI/I,aAAe2b,MAC/B5S,GAAAA,EAAI/I,aAAeF,SAAW4b,EAChC,OAGFF,KAAA,EAAY3N,IAAI9E,GACVwG,IAEK5C,EAFL4C,EAAMmM,EAAU,GAAK,GAEhB/O,IAAAA,KAAX,EACE4C,EAAI5C,GAAQtF,EAAM0B,EAAI4D,IAQjB4C,OAHP,IACEA,EAAI5P,OAASoJ,EAAIpJ,QA1CvB,GAgDK,CAAM4b,GAWfK,SAAyB,GAACC,GACxB,IACWC,EADLzU,EAAyB,GACpByU,IAAAA,KAAX,EACEzU,EAAMyU,GAAKD,EAASC,GAEfzU,OAL2B,EC5DpC0U,SAAoB,GAACC,EAAGC,GAEtB,QAAiB,iBAAjB,GACiB,iBADjB,IAC6BxT,MAAMuT,KAAMvT,MAAMwT,KAGxCD,IAAMC,EAUfC,SAAa,GAACtZ,EAAOuZ,GACnB,IAAMC,EAAQxZ,EAAMkJ,QAAQqQ,IAC5B,EAAIC,GACFxZ,EAAMyZ,OAAOD,EAAO,GAgCxBE,SAAsB,GAACN,EAAGC,EAAGM,GAIvBP,GAHCO,IACHA,EAAYC,IAEVR,EAAErc,QAAUsc,EAAEtc,OAChB,OAAO,EAGH8c,EAAOR,EAAES,QACf,IAAA,IAAA,EAAA,GAAA,GAAA,EAAA7d,EAAmBmd,IAAnB,QAAA,EAAA,KAAA,EAAA,CAAA,GAAWzY,EAAAA,IAAX,EAAA,EAAA,OAAsB,CAET,GAFFA,EAAAA,GAAX,EAAA,OAEE,IADMoZ,EAAMF,EAAKG,UAAU,SAAA,GAAA,OAAA,SAACxP,GAAU,OAAA,EAAU7J,EAAAA,GAAM6J,IAA3B,CAAA,KAEzB,OAAO,EAIT,EAAKuP,GAAOF,EAAKA,EAAK9c,OAAS,GAC/B,EAAKwM,MAGP,OAAA,GAAOsQ,EAAK9c,OAad8D,SAAY,GAACuY,EAAGC,EAAGM,GAIbP,GAHCO,IACHA,EAAYC,IAEVR,EAAErc,QAAUsc,EAAEtc,OAChB,OAAO,EAGJ,IAAA,IAAIuD,EAAI,EAAGA,EAAI8Y,EAAErc,OAAQuD,IAC5B,IAAKqZ,EAAUP,EAAE9Y,GAAI+Y,EAAE/Y,IACrB,OAAO,EAGJ,OAAA,ECvGTlD,SAAW,KAET,KAAK6c,EAAc,GASrBC,SAAM,GAANA,EAAOC,GACL,EAAKF,EAAYha,KAAKka,EAAA,QAAkB,WACtCC,GAFc,EAEoBH,EAAaE,MCmBnD/c,SAAW,GAACid,GACVC,GAAA,KAAA,MAGA,KAAKC,GAAa,EAGlB,KAAKC,EAAoB,IAAIC,GAG7B,KAAKC,EAAkB,IAAI3b,IAG3B,KAAK4b,EAAmB,IAAI5b,IAG5B,KAAK6b,EAAqBP,GAAqB,KAe1C,SAAc,GAAClT,EAAQ0T,EAAQC,GAGpCA,EACIA,GAAYC,GACVC,IAAAA,EAAWC,GAAoC9T,KAChD6T,GAAYF,GAAYE,EAASF,YACpCG,GAAoC9T,GAAU,CAC5C2T,SAAUA,EACVD,GAAQA,IAiGP,SAAW,GAACK,EAAMC,GACvB,MAAO,CACLD,KAAMA,EACNE,OAAQ,MACRC,KAAM,KACNC,QAAS,GACTC,2BAA2B,EAC3BC,gBAAiBL,EACjBM,mBAAoB,KACpBC,UAAW,MAuWf,SAAW,KAET,KAAKC,EAAe,EA2CtB,SAAW,GAAClN,EAASgI,EAASmF,GAC5BC,GAAA,KAAA,KAAMpN,EAASgI,GAGf,KAAKqF,EAAkBF,EZzkB3BhZ,EAAA,6BAAA8Q,IrD+1DE,GqDpvDO5Q,OAAAwQ,GrDovDP,GqDxwDOxQ,MAAAiZ,GrDwwDP,GqDxxDOjZ,QAAAkZ,GrDwxDP,GqD3yDOlZ,WAAAmZ,GrD2yDP,GqDzzDOnZ,SAAAoZ,GrDyzDP,GqDx0DOpZ,iBAAAkP,GrDw0DP,GqDt1DOlP,MAAPjC,SAAaC,EAAMC,GAIVkC,OAHP4J,GACIhM,mCACAA,oDACGA,GAA6BC,EAAMC,ICqB5Cob,GAAA,UAAA,QAAAC,WAGS1N,OAFP,KAAK+D,EAAe4J,UACpB,KAAK5J,EAAiB,KACf,QAAQhK,WCrBjB6T,GAAA,UAAA,EAAA9F,SAAU+F,GAAgB,IAAA,EAAA,KAGxB,KAAKC,OAIDC,IAAAA,GAAQ,EACRC,EAAY,KAkBT,OAhBP,KAAK5H,EAAiB6H,WACpB3d,EAAO4d,aAAaF,GACpB,GAAQ,GAYV,EAAY1d,EAAO6d,WANJjI,WACT6H,GACF,EAAK5H,KAI8C,IAAjB0H,GAxBd,MAiC1BC,GAAA,UAAA,KAAAA,WACM,KAAK1H,IACP,KAAKA,IACL,KAAKA,EAAiB,OC1B1ByB,GAAA,UAAA,GAAAuG,WAIS,OAHP,KAAKN,OACL,KAAK3H,IAFG,MAeV2B,GAAA,UAAA,EAAAA,SAAUuG,GAAS,IAAA,EAAA,KAOV,OANP,KAAKP,OAEL,KAAKzH,EAAU,IAAIuH,GAAuB,WACxC,EAAKzH,MACJ2B,EAAUuG,GALI,MAiBnBC,GAAA,UAAA,GAAAA,SAAUD,GAAS,IAAA,EAAA,KAUV,OATP,KAAKP,OAEL,KAAKzH,EAAU,IAAIuH,GAAuB,WAGxC,EAAKvH,EAAQyB,EAAUuG,GACvB,EAAKlI,MACJ2B,EAAUuG,GARI,MAmBnBP,GAAA,UAAA,KAAAA,WACM,KAAKzH,IACP,KAAKA,EAAQyH,OACb,KAAKzH,EAAU,OAjFrB,EAAA,mBAAAwB,IxDg2DE,GwDlxDA0G,UAAAna,KAAAyT,GAAA,UAAA0G,KxDkxDA,GwDryDAA,UAAAna,UAAAyT,GAAA,UAAA0G,GxDqyDA,GwDtzDAA,UAAAna,UAAAyT,GAAA,UAAA0G,ExDszDA,GwDr0DAA,UAAAna,QAAAyT,GAAA,UAAA0G,GEkEApG,GAAA,UAAA,MAAAQ,WAES,OADP,KAAKV,GAAW,EACT,KAAKD,KAoBdG,GAAA,UAAAqG,QAAAA,SAAQC,GAEC,OADP,KAAK1O,QAAQ2O,KAAK,WAAW,OAAA,GAAQ,IAAO,WAAO,OAAA,GAAQ,KAD5C,MAuBjBC,GAAA,UAAA,EAAAA,SAAMC,EAAWC,GAUMC,SAAA,EAACC,GACpB,OAAO,SAAC3f,GACN,GAAI,EAAK6Y,GAAY8G,EAInBC,EAAW/O,OAAOgP,OAJpB,CAQA,IAAMC,EAAKH,EAAYH,EAAYC,EACnC,EASAlG,EA0BC,SAAmBwG,EAAU/f,EAAO4f,GACzC,IACE,IAAM/Q,EAAMkR,EAAS/f,GAEjB6O,OAAAA,GAAOA,EAAI8B,SAAW9B,EAAI0K,OAK5B,EAAW5O,QAAQkE,EAAI8B,SAIhB,WAAM,OAAA,EAAI4I,WAGjB,EAAW5O,QAAQkE,GAGZ,WAAM,OAAA,QAAQlE,QAAQkE,GAAKyQ,KAAK,aAAU,gBAEnD,MAAOU,GAIP,OADA,EAAWnP,OAAOmP,GACX,WAAM,OAAA,QAAQrV,YAnDXsV,CACJH,EAAI9f,EAAO4f,IARAD,EAAYC,EAAWjV,QAAUiV,EAAW/O,QACpD7Q,KAnBCuZ,SAAA,IAEH,OADPqG,EAAW/O,OAAOgP,GACX,EAAKtG,QAPU,IAAA,EAAA,KAClBqG,EAAa,IAAI9M,GACjB+M,EAtFC,IAAIza,GhBkFDoM,EA4BF6G,EAomBWa,MgB1lBZ,OAFP,KAAKvI,QAAQ2O,KAAKI,GAAa,GAAOA,GAAa,IAExC3G,IAAAA,GACP6G,EAGA,WAAM,OAAA,OAhLd9a,EAAA,gCAAAiU,I1D81DE,G0DttDAoG,UAAAna,MAAA+T,GAAA,UAAAoG,E1DstDA,G0D7uDAA,U1D6uDA,Q0D7uDApG,GAAA,U1D6uDA,QAAA,G0DvvDO/T,IAAAkb,G1DuvDP,G0DnwDAf,UAAAna,MAAA+T,GAAA,UAAAoG,M1DmwDA,G0D/wDOna,aAAAmb,G1D+wDP,G0D7xDOnb,UAAAob,G1D6xDP,G0DpzDOpb,QAAAqb,G1DozDP,G0D/zDOrb,OAAAsb,GC2BPC,GAAA,UAAA,eAAAC,WACM,KAAK1G,aACP,KAAKD,kBAAmB,IAS5B4G,GAAA,UAAA,yBAAAA,WACE,KAAKlG,GAAU,GAQjBmG,GAAA,UAAA,gBAAAA,aAlFF,EAAA,uBAAAH,ICSE7F,GAAA,UAAA,KAAAvY,SAAKkL,EAAKrN,GACJ,KAAKwa,EAAK7M,eAAeN,GAC3B,KAAKmN,EAAKnN,GAAKlL,KAAKnC,GAEpB,KAAKwa,EAAKnN,GAAO,CAACrN,IAUtB2gB,GAAA,UAAA,IAAAA,SAAItT,GAIF,OAHMuT,EAAO,KAAKpG,EAAKnN,IAGTuT,EAAK5E,QAAU,MAsB/BR,GAAA,UAAA,OAAAA,SAAOnO,EAAKrN,GACJqN,KAAN,KAAkBmN,IAGlB,KAAKA,EAAKnN,GAAO,KAAKmN,EAAKnN,GAAKwT,OAAO,SAACre,GAAM,OAAA,GAAKxC,MCvBrD8gB,GAAA,UAAA,iBAAAC,SAAiBvH,EAAMwH,GACrB,KAAKvG,GAAWtY,KAAKqX,EAAMwH,IAc7BC,GAAA,UAAA,oBAAAA,SAAoBzH,EAAMwH,GACxB,KAAKvG,GAAWe,OAAOhC,EAAMwH,IAW/BE,GAAA,UAAA,cAAAA,SAAcC,GAUZ,IAJA,IAAMC,EAAY,KAAK3G,GAAWkG,IAAIQ,EAAM3H,OAAS,GAIrD,GAAA,EAAArb,EAAuBijB,IAAvB,QAAA,EAAA,KAAA,EAAA,EAAA,OAAkC,CAAvBJ,EAAX,EAAA,MAEE,EAAM3G,OAAS,KAAKM,GACpB,EAAML,cAAgB,KAAKK,GAEvB,IAGEqG,EAASK,YACXL,EAASK,YAAYF,GAGrBH,EAASlS,KAAK,KAAMqS,GAEtB,MAAOnB,IAST,GAAImB,EAAM5G,EACR,MAIJ,OAAA,EAAaV,kBG3Ef8C,GAAA,UAAA,QAAA2B,WAEE,IADA,IAAMgD,EAAU,GAChB,EAAAnjB,EAAiB,KAAKge,GAAtB,EAAA,EAAA,QAAA,EAAA,KAAA,EAAA,EAAA,QAAW7C,EAAX,EAAA,OAGK3I,QAAH,MAAiB,cAGjB2Q,EAAQnf,KAAKmX,EAAGC,SAIX3I,OADP,KAAKuL,EAAc,GACZ,QAAQ7N,IAAIgT,ICJoBC,EAA3CC,GAA2CV,KAoEzCW,EAAAA,GAAAA,WAAAA,GAAAA,SAAsBZ,GACpB,KAAKjE,EAAgBzP,IAAI0T,IAS3Ba,EAAAA,GAAAA,SAAwBb,GACtB,KAAKjE,EAAL,OAA4BiE,IAQ9Bc,EAAAA,GAAAA,WACE,KAAK/E,EAAgBgF,SAUvBC,EAAAA,GAAAA,SAAuBhB,GACrB,KAAKhE,EAAiB1P,IAAI0T,IAS5BiB,EAAAA,GAAAA,SAAyBjB,GACvB,KAAKhE,EAAL,OAA6BgE,IAQ/BkB,EAAAA,GAAAA,WACE,KAAKlF,EAAiB+E,SA0CxBI,EAAA1D,QAAAA,WAIS,OAHP,KAAK7B,GAAa,EAClB,KAAKG,EAAgBgF,QACrB,KAAK/E,EAAiB+E,QACf,KAAKlF,EAAkB4B,WAWhC2D,EAAAA,QAAAA,SAAQzI,EAAMyI,GAAS,IAAA,EAAA,KAEfnE,EACF,IAAIoE,GAGJ,GAAA,KAAKzF,EAAY,CACnB,IAAMxD,EAAIrI,QAAQC,OAAO,IAAIzL,GvBxErBoM,EA4BF6G,EAomBWa,OuBjjBV,OADP,EAAA,MAAQ,cACGiJ,IAAAA,GACPlJ,EAAG,WAAM,OAAA,QAAQtO,WAAWmT,GAYlCmE,EAAQ3E,OAAS2E,EAAQ3E,QAAU,MACnC,EAAQE,QAAUyE,EAAQzE,SAAW,GACrC,EAAQE,gBAAkBuE,EAAQvE,gBAC9B0E,GAAwBH,EAAQvE,iBRjH7B,CACLrG,YAAa,EACbC,UAAW,IACXC,cAAe,EACfC,WAAY,GACZC,QAAS,GQ8GX,EAAQ2F,KAAOgF,GAAwBH,EAAQ7E,MAIzCiF,IAAAA,GADAC,EA2DR,SAAAC,EAAe/I,EAAMyI,GAGnB,IAFA,IAAIO,EAAkBpC,QAAwCjhB,GAE9D,EAAA,GAAA,GAAA,EAAAhB,EAA4B,EAAKye,IAAjC,QAAA,EAAA,KAAA,EAAA,CAAA,GAAW6F,EAAAA,IAAX,EAAA,EAAA,OAAWA,EAAAA,GAAX,EAAA,MAEED,EAAkBA,EAAgBjD,EAAM,SAAA,GAAA,OAAA,WAS/BkD,OARHR,EAAQ1E,OAMV0E,EAAQ1E,KAAOrY,GAAqC+c,EAAQ1E,OAEvD,EAAAkF,GAAcjJ,EAAMyI,IATW,CAAA,IAenCO,OAAA,EAAgBjD,OAAMpgB,EAAW,SAAC6P,GACvC,GAAIA,aAAJ,IvB4ciBkK,MuB3cblK,EAAErK,KAEJ,MAAA,EAGF,MAAUS,IAAAA,GvB1LFoM,EAUDkR,EAkFaC,KuBiG4B3T,KAzFnBuT,CAAAA,KAAoB/I,EAAMyI,IACT1C,EAC5C,WAAM,OA2HZqD,SAAK,EAALA,EAAMpJ,EAAMyI,EAASY,EAASnH,EAAOoH,EAAWhF,GAC9C,IAAMjY,EAAM,IAAID,GAASqc,EAAQ7E,KAAK1B,IAClCrS,EAASxD,ErBhFHG,GqBkFN+c,GAAc,EAClB,IAEE1Z,EAwJK2Z,SAASC,SAnJd5Z,EAASA,EAAO2S,MAAM,GAAb,GAGTjW,GAAAF,EAAcwD,GACd4Y,EAAQ7E,KAAK1B,GAAS7V,EAAIR,YAM5B,EAASgE,EAAO4M,cAGV8G,IAAAA,GADApe,EAASwe,GAAoC9T,IAC3B1K,EAAOoe,GAAS,KACpC,IAACA,EACH,OAAO,GACH,IAAI3X,GvB7PAoM,EAUDkR,EAwCWQ,IuB+MVrd,IASNsd,IAAAA,EAFAhD,OAAAiD,GAA2CnL,GAAA4K,IAGRtD,EAAM,WAC3C,OA3CkE,EA2CzD9C,EACA,MAGT,EAActC,KAAKD,MAGZ,EAAO+H,EAAQ7E,KAAK1B,GACvBuG,EACAzI,EAEA,SAAC6J,EAAMvP,EAAOwP,GAtDgD,EAuDnDxG,GAAsBtD,GAAQ+J,KAvDqB,EAwDrDzG,EAAmBuG,EAAMvP,GAC9BiP,GAAc,EACdjF,EA+HLD,EA/HmCyF,QAGrC/D,EAAM,SAACiE,GAIuBC,OAHRtkB,MAAnBqkB,EAASE,SACXF,EAASE,OAASvJ,KAAKD,MAAQiJ,GAEFM,CAC7BD,SAAUA,EACVT,GAAaA,IAId,SAACpiB,GACF,GAxEkE,EAwEzD8b,EACP,OAAO,KAGL9b,GAAAA,aAAJ,GAAuC,CACrC,GvBkVeuY,MuBlVXvY,EAAMgE,KAER,MAAA,EACK,GvB7LS2T,MuB6LL3X,EAAMgE,KAEf,MAAA,EAGF,GvB7TSgf,GuB6TLhjB,EAAM8D,SAAmD,CAC3D,IAAM0c,EAAQ,IAAIZ,GAAqB,QAAS,CAAC,MAAS5f,IAKnDiiB,OAJP,EAAK1B,cAAcC,GAGnB,GAASzF,EAAQ,GAAKuG,EAAQ7E,KAAKne,OAC5B,EA3FuD2jB,EA4F1DpJ,EAAMyI,EAASY,EAASnH,EAAO/a,EAAOmd,IAK9C,MAAA,IApHK,CAxGG8F,EAA2BpK,EAAMyI,EAqG3BY,IAAIgB,GArGuB5B,EAsG/BvE,iBAAkC,GAChChC,EAEsC,KAzGAoC,KAC9CgG,EAA0BzB,EAAiB9C,EAC7C,SAACkE,GACC,OAuORM,SAAAA,EAAgBvK,EAAMiK,GAEpB,IADA,IAAIjB,EAAkBpC,QAAwCjhB,GAC9D,EAAA,GAAA,GAAA,EAAAhB,EAA6B,EAAK0e,IAAlC,QAAA,EAAA,KAAA,EAAA,CAAA,GAAWmH,EAAAA,IAAX,EAAA,EAAA,OAAWA,EAAAA,GAAX,EAAA,MAEExB,EAAkBA,EAAgBjD,EAAM,SAAA,GAAA,OAAA,WACtC,IAAM0E,EAAOR,EAAuBD,SAK7BQ,OAJP,EAASlgB,OAEPmgB,EAAKngB,KAAOoB,GAAqC+e,EAAKngB,OAEjD,EAAAkgB,GAAexK,EAAMyK,IANU,CAAA,IAWnCzB,OAAA,EAAgBjD,EAAM,WAC3B,OADiC,GAEhC,SAACvQ,GAMF,IAAIvK,EvBvWI+M,EuBwWJxC,GAAAA,aAAJ,GAAmC,CACjC,GvBuRekK,MuBvRXlK,EAAErK,KAEJ,MAAA,EAGFF,EAAWuK,EAAEvK,SAGf,MAAUW,IAAAA,GACNX,EvBxWGie,EAwFcwB,KuBkR4BlV,KA3Q7C,CAAA+U,EAAqBvK,EAAMiK,KAG3BU,EAAyBhK,KAAKD,MAChCkK,EAAkB,EACtB,EAAuBzT,QAAQ2O,KAAK,WAClC8E,EAAkBjK,KAAKD,MAAQiK,GAC9B,cAECE,IAAAA,EAA0B,EAC9B,EAAiB1T,QAAQ2O,KAAK,WAC5B+E,EAA0BlK,KAAKD,OAC9B,cAEGZ,IAAAA,EAAKwK,EAAwBvE,EAAM,SAACkE,GACxC,IAAMa,EAAmBnK,KAAKD,MAAQmK,EAChCb,EAAWC,EAAuBD,SASjCA,OARP,EAASE,QAAUU,EACnB,EAASV,QAAUY,EACnB,EAA4BvB,KACxB,EAAKjG,GACJ0G,EAASe,WACV/K,GAAQ+J,IACV,EAAKzG,EAAmB0G,EAASE,OAAQF,EAAS1f,KAAKZ,YATU,GAYlE,SAAC8L,GASIA,MALFA,IAEFA,EAAEvK,SvBzII+M,GuB4IR,IAUKgT,OAJDA,EACF,IAAIrC,GACA7I,EAAG3I,QAAS,WAAM,OAAA,EAAG4I,SAASuE,GACtC,GAAA,KAAKpB,EAAyB8H,GApFT,GA/KzB1f,EAAA,6BAAA0c,IjEs0DE,GiEvpDArC,UAAAna,QAAAwc,GAAA,UAAArC,QjEupDA,GiEtqDAA,UAAAna,QAAAwc,GAAA,UAAArC,QjEsqDA,GiEvrDOna,YAAAyf,GjEurDP,GiEnsDOzf,uBAAP0f,WACE,MRxCO,CACLrN,YAAa,EACbC,UAAW,IACXC,cAAe,EACfC,WAAY,GACZC,QAAS,IzDquDb,GiEjtDA0H,UAAAna,wBAAAwc,GAAA,UAAArC,GjEitDA,GiE1tDAA,UAAAna,yBAAAwc,GAAA,UAAArC,GjE0tDA,GiEpuDAA,UAAAna,uBAAAwc,GAAA,UAAArC,GjEouDA,GiE/uDAA,UAAAna,uBAAAwc,GAAA,UAAArC,GjE+uDA,GiExvDAA,UAAAna,wBAAAwc,GAAA,UAAArC,GjEwvDA,GiElwDAA,UAAAna,sBAAAwc,GAAA,UAAArC,GjEkwDA,GiE7wDOna,iBAAP2f,SAAwBtb,UACf8T,GAAoC9T,IjE4wD7C,GiEjyDOrE,eAAA4f,GAsdTpD,GAAAxc,uBAAAkd,GAiCcX,EADdY,GACcpJ,IjE0yCZ,GiE3yCF/T,eAAAmd,GAwCE,IAAA,GAAW,EjEmwCX,GiErwCFnd,YAAyC6f,CACvCA,SAAYA,EACZA,QAAWA,GACXA,QAAWA,EACXA,IAAOA,EACPA,OAAUA,GAeV,IAAA,GAAe,EjEivCf,GiEpvCF7f,eAA4C8f,CAC1CA,SAAYA,EACZA,UAAaA,EACbA,YAAeA,IAsBjB3H,IAAAA,GAAsC,GC/nBpC7d,SAAW,GAACygB,GAEV,KAAKtD,GAAa,EAGlB,KAAKsI,EAAiB,IAAIjS,GAG1B,KAAKkS,EAAajF,EAwCpB,SAAkB,GAAlBkF,EAAmBtkB,GACjB,GAAI,EAAK8b,EAAY,CACnB,GAAI9b,aAAJ,IxB4tBgBukB,MwB3tBZvkB,EAAMgE,KACR,MAAA,EAEF,MASSS,IAAAA,GxBmEDoM,EA4BF6G,EAgnBU6M,KwBxtB0BvkB,ICxD9CrB,SAAW,KAKT,KAAK6lB,EAAc,IAAIzK,GAgIzB,SAAW,GAACL,EAAQb,EAAMwH,EAAUoE,GAElC,KAAK/K,OAASA,EAGd,KAAKb,KAAOA,EAGZ,KAAKwH,SAAWA,EAGhB,KAAKoE,EA8BA,SAAgB/K,EAAQra,GAC7B,GAAab,MAATa,EACF,OAAO,EACkB,GAAA,kBAApB,EACL,OAMA,EAAMqlB,IAAAA,EAAU,IAAIpkB,IAAI,CAAC,UAAW,YAOhCqkB,OANS,OAAOC,KAAKvlB,GAAO6gB,OAAO,SAACzF,GAAM,OAACiK,EAAQtK,IAAIK,KAwB/DoK,SAA0BnL,GAExB,IAAIoL,EAAWC,GACCvmB,GAAAA,MAAZsmB,EAAuB,CACzBA,GAAW,EACP,IACF,IAAML,EAAU,GAIVO,EAAO,CACXhF,IAAKA,WAEI,OADP8E,GAAW,GACJ,IAGX,OAAO/L,eAAe0L,EAAS,UAAWO,GAC1C,OAAOjM,eAAe0L,EAAS,UAAWO,GAEpC7W,EAAOA,aACb,EAAOiS,iBAAiB,OAAQjS,EAAMsW,GACtC,EAAOnE,oBAAoB,OAAQnS,EAAMsW,GACzC,MAAOpW,GACPyW,GAAW,EAEbC,GAAmDD,EAErD,OAAA,IAAmB,EA7CbA,CAAoDpL,GAE/Cra,EAEAA,EAAM,UAAc,EAlD3B4lB,CAAiDvL,EAAQ+K,GAE7D,KAAK/K,OAAO0G,iBAAiBvH,EAAMwH,EAAU,KAAKoE,GDnHpDS,GAAA,UAAA,QAAAvH,WAAU,IAAA,EAAA,KACJ,OAAA,KAAK7B,EACP,KAAYsI,GAKd,KAAKtI,GAAa,EAEX,KAAKuI,IAAa1F,KACrB,WAAQ,EAAKyF,EAAepa,WAC5B,WAAQ,EAAKoa,EAAepa,eC7BlCmb,EAAAA,GAAAA,WAAAA,QAAAA,WACE,KAAKC,KACL,KAAKZ,EAAc,MAerBa,EAAAA,EAAAA,SAAO3L,EAAQb,EAAMwH,EAAUoE,GACxB,KAAKD,IAIJc,EACF,IAAIC,GAAiC7L,EAAQb,EAAMwH,EAAUoE,GACjE,KAAKD,EAAYhjB,KAAKqX,EAAMyM,KAgB9BE,EAAAA,GAAAA,SAAW9L,EAAQb,EAAMwH,EAAUoE,GAAS,IAAA,EAAA,KAQ1C,KAAKY,EAAO3L,EAAQb,EANP4M,SAAA,EAACjF,GAEZ,EAAKkF,GAAShM,EAAQb,EAAM4M,GAE5B,EAASjF,IAEqBiE,IAWlCiB,EAAAA,GAAAA,SAAShM,EAAQb,EAAMwH,GACrB,GAAK,KAAKmE,EAMV,IAFA,IAAMvE,EAAO,KAAKuE,EAAYxE,IAAInH,IAAS,GAE3C,GAAA,EAAArb,EAAsByiB,IAAtB,QAAA,EAAA,KAAA,EAAA,EAAA,QAAWqF,EAAX,EAAA,OACc5L,QAAUA,GAChB2G,GAAYiF,EAAQjF,UAAaA,IACnCiF,EAAQI,KACR,KAAKlB,EAAY3J,OAAOhC,EAAMyM,KAWtCF,EAAAA,GAAAA,WACE,GAAK,KAAKZ,EAAV,CAIaA,IPrEF9X,EOqEE8X,EAAAA,KAAKA,EPtEZvE,EAAO,GACFvT,IAAAA,KAAX,EAAuBmN,EACrBoG,EAAKze,KAAL,MAAAye,EAAA/K,EAAa,EAAK2E,EAAKnN,KOsEzB,IAAA,GAAA,EAAAlP,EPpEOyiB,IOoEP,QAAA,EAAA,KAAA,EAAA,EAAA,OAAA,EAAAqF,MACUI,KPhDV,KOmDKlB,EPnDA3K,EAAO,KOxDhB,EAAA,0BAAA8L,InE61DE,GmE7vDAnH,UAAAna,UAAAshB,GAAA,UAAAnH,GnE6vDA,GmEnxDAA,UAAAna,SAAAshB,GAAA,UAAAnH,GnEmxDA,GmEtyDAA,UAAAna,WAAAshB,GAAA,UAAAnH,GnEsyDA,GmE7zDAA,UAAAna,OAAAshB,GAAA,UAAAnH,EnE6zDA,GmE90DAA,UAAAna,QAAAshB,GAAA,UAAAnH,QA6IA+G,GAAA,UAAA,GAAAG,WAEE,KAAKhM,OAAO4G,oBAAoB,KAAKzH,KAAM,KAAKwH,SAAU,KAAKoE,GAG/D,KAAKpE,SADL,KAAK3G,OAAS,KAEd,KAAK+K,GAAU,GAgFnB,IAAAM,QAAmDvmB,ECpPxB,SAAA,MASzBonB,SAA0B,GAAC7W,GAKb7J,OAAAA,IAAID,GAJV4gB,EAAYnT,GAA2C3D,IxBgVnDtJ,GwBrTZqgB,SAAwB,GAAC/W,EAAUgX,EAAWC,GAoCnBC,SAAA,EAAC1kB,GACX+C,GAAkC4hB,GAE1CC,UAAU/iB,EADD7B,EAAMgB,YAC8B,GAClD,GAAU,EARV,EAAgBwR,IAAIpR,GASbpB,GAToD6B,GAC3D,GAQO7B,EARSgB,WAhClB,IAAKyjB,IAASA,EAAKzjB,WACjB,MAAUkC,IAAAA,G1BgGFoM,EAyBLuV,EAolBwBC,M0BlsB7B,IAAIC,EAEFA,EADF,iBAAA,EAEM9T,GAA+BuT,GAA+B,GAEjDA,EAKbQ,EACF/T,GAFEgU,EAAS9T,GAA2C3D,IAEK,GAEzDmX,IAAAA,EAAkB,IAAIjjB,WACxB,GAAKsjB,EAAMhkB,WAAa+jB,EAAe/jB,WAAayjB,EAAKzjB,YAEzDa,EAAS,EAqBN8iB,OANP,EAAiBK,GACjB,EAAiBD,GACjB,EAAiBN,GA9CiC,ECtCpDS,SAAY,GAACzoB,GAEX,IADA,IAAMoD,EAAM,IAAIslB,IAChB,EAAAlpB,EAAkBiB,OAAOmmB,KAAK5mB,IAA9B,EAAA,EAAA,QAAA,EAAA,KAAA,EAAA,EAAA,OAAW0O,EAAX,EAAA,MACEtL,EAAI2S,IAAIrH,EAAK1O,EAAO0O,IAGftL,OANY,EAerBulB,SAAe,GAACvlB,GACd,IAAM4M,EAAM,GAKLA,OAJP,EAAI4Y,QAAQ,SAACvnB,EAAOqN,GAClBsB,EAAItB,GAAOrN,IAHM,EAkBrB4b,SAAsB,GAAC4L,EAAMC,GAC3B,IAAKD,IAASC,EACL,OAAA,EACED,GAAAA,IAASC,GAETA,IAASD,EAClB,OAAO,EAGLA,GAAAA,EAAK9T,MAAQ+T,EAAK/T,KACpB,OAAO,EAVwB,IAAA,IAajC,EAAAvV,EAAyBqpB,GAAzB,EAAA,EAAA,QAAA,EAAA,KAAA,EAAA,EAAA,OAA+B,CAApB,IAAA,EAAArpB,EAAX,EAAA,OACM,GADMkP,EAAD,EAAA,OAAA,MAAMhF,EAAN,EAAA,OAAA,OACJof,EAAK1M,IAAI1N,GACZ,OAAO,EAILqa,IADEA,EAAOD,EAAK9G,IAAItT,KACVhF,GAAgBlJ,MAARuoB,EAClB,OAAO,EAGX,OAAO,EC9DY,SAAA,MASrBC,SAAkB,GAAC5R,EAAU6R,GAC3B,IAAIC,EAAe9R,EAIZ8R,OAHP,IACEA,GAAgB,aAAeD,EAAS,KAHP,EAwDrCE,SAAqB,GAACC,GAGd1Y,IAAAA,GAFAxQ,EAAQkpB,EAAYjpB,MAAM,MAEb,GAMZ,OAJP,EAAM2M,MAIC,CAAC4D,EAHQxQ,EAAM6L,KAAK,MFhE/B5F,EAAA,2BAAAkjB,IpE+1DE,GoE1zDOhjB,kBAAAijB,GpE0zDP,GoEt1DOjjB,oBAAAkjB,GEwET,IAAAC,IAAiD,IAAId,KAChD3S,IAAI,SAAU,UACdA,IAAI,YAAa,aACjBA,IAAI,YAAa,WACjBA,IAAI,QAAS,SACbA,IAAI,SAAU,UACdA,IAAI,gBAAiB,YClFxB0T,SAA0B,KASxB,SAAA,EALY9R,cAKPA,YAAYJ,iBAanBmS,SAAwB,GAACtS,GAEvB,MAAsC,IADxBuS,KACDC,YAAYxS,GA+C3ByS,SAAc,KACZ,OAAO,GAAuC,SAuEhDC,SAAc,KACZ,QAASC,UAAUC,QAAUD,UAAUC,OAAOC,SAAS,WAC3CC,KAiBdC,SAAoB,KAElB,IAAKC,KACH,OAKF,KAAIhiB,IAAAA,EAAQ2hB,UAAUM,UAAUjiB,MAAM,kBAClCA,OAAJ,EACSuN,SAASvN,EAAM,GAAgB,KAKxCA,EAAQ2hB,UAAUM,UAAUjiB,MAAM,sBAEzBuN,SAASvN,EAAM,GAAgB,IAGjC,KAuCTkiB,SAAyB,GAAC5b,GAExB,OADkBqb,UAAUM,WAAa,IACxBJ,SAASvb,GAc5B6b,SAAsB,KAEpB,OAAIC,KAIJ,KACEC,GAAiC,IAAI3Q,GAAiB,WACpD0Q,GAA+B,SAInCA,GACEE,SAASC,qBAAqB,SAAS,IACvCD,SAASC,qBAAqB,SAAS,MAGvCH,GACEE,SAASE,cAAc,UAG3B,GAA+B7Q,EAAyB,GArBjC,IA2B3B,IAAA0Q,GAA4C,KAG5CD,GAA0C,KC9PxC7pB,SAAW,GAACkqB,EAAiBC,GAA0B,IAAA,EAAA,KAA1B,OAAA,IAAAA,EAAuB,EAAvBA,EAE3B,KAAKC,EAAmBF,EAGxB,KAAKG,EAAkB,IAAI1oB,IAM3B,KAAK2oB,EAHL,KAAKC,EAAa,KAMlB,KAAKC,GAAe,EAGpB,KAAKC,EAAsB,EAG3B,KAAKC,EAAkB,KAGvB,KAAKC,EAAgB,IAAI3D,GAMzB,KAAK4D,EAAkB,IAAI7C,IAG3B,KAAK8C,EAAqB,GAG1B,KAAKC,EAAqB,IAAItX,GAG9B,KAAKuX,EAAU,KAGf,KAAKC,EAAWC,SAACC,GACf,EAAKJ,EAAmBvZ,OAAO2Z,GAC/B,EAAgB/K,QAAQ+K,IAU1B,KAAKC,GAAoB,IAAIpD,IAQ7B,KAAKqD,EAA6B,IAAIrD,IAGtC,KAAKsD,EACD,IAAIlS,GAAiB,WAAM,OAi2CjCmS,SAAAA,GACE,IAAMC,EAAa,EAAKJ,GAClBK,EAAY,EAAKJ,EAGvB,EAAU9I,QACV,EAAW2F,QAAQ,SAACwD,EAAQC,GAAU,OAAA,EAAUtW,IAAIsW,EAAOD,MAIrDE,EAAWhQ,MAAMiQ,KAAKJ,EAAUpd,WACVzO,QACTgsB,EAASE,MAAM,SAACJ,GAAW,MAAU,WAAVA,KAG5C,EAAKT,EAAS,IAAIllB,G9B5zCVoM,EAyBLuV,EA8kBIqE,O8B2tBT,EAAK1B,EAAiB2B,GAAYC,GAA6BR,IAt3ChC,CAAAF,KAG/B,KAAKW,GAAyB,EAG9B,KAAKC,EAAyB,GAG9B,KAAKC,GAAuB,EAG5B,KAAKC,EAAmB,IAAIjT,GAAiB,WAqnD/CkT,IAAAA,GAAAA,EApnDIA,GAqnDGzB,EAAgB3C,QAAQ,SAAChS,EAAUqW,GACtC,IAAMC,EAAUtW,EAASuW,GACrBC,EAAUH,EAAQI,WAClB,MAAMD,KACRA,EAAU9nB,EAAAA,GAGZ,GAAe4nB,IARD,EASPnC,EAAiBuC,oBAAoBL,EAAQhO,UAAWmO,GAC7DxW,EAASuW,GAAgBC,OA7nD1B7M,GAAyBuK,GAI5B,KAAKW,EAAL,MADa7b,cAIb,KAAK2d,EAAa,IAAIrG,GAAqB,WAAM,OAc7CsG,EAd6CA,EAc/B,EAAA,SAAA,GAAA,OAAA,EAAA,GAAA,KAAA,EAmBlB,OAhBA,EAAKlC,EAAcnE,UAHD,EAIbmE,EAAgB,KAJH,EAQbG,EAAmBvZ,SARN,EAYb6a,EAAiBhN,OAZJ,EAabgN,EAAmB,KAbN,EAebf,EAAgBjM,OAfH,EAgBbiM,EAAkB,KAGvB,EAAA,EAAMyB,GAnBYA,GAmBlB,GAnBkB,KAAA,EAsBlB,IAtBkB,EAsBTxC,EAAT,CAAA,EAAA,EAAA,GAAA,MAII,OADE,EAAA,EAAA,GACF,EAAA,EA1Bc,EA0BHA,EAAOyC,aAAa,MAA/B,GA1Bc,KAAA,EAyBZ,EAAA,EAAA,GAzBY,MAAA,KAAA,EA2BP1rB,EAAAA,GA3BO,KAAA,EAAA,EA+BXipB,EAAS,KA/BE,KAAA,EAAA,EAmCbI,EAAkB,KAnCL,EAoCbL,EAAgB/H,QApCH,EAqCbiI,EAAa,KArCA,EAsCbM,EAAqB,GAtCR,EAuCbE,EAAU,KAvCG,EAwCbC,EAAWC,aAxCE,EAyCbb,EAAmB,KAzCN,EAAA,MAAd,IAAAyC,IAyFNG,SAAe,GAAfA,EAAgBC,EAAUC,GAIjBC,OAHP,EAAKtC,EAAqBqC,EAC1B,EAAKjB,EAAoD,EAA3BiB,EAAkBvtB,OAEzC,GAAAwtB,EAAWF,GA0DpBE,SAAK,GAALA,EAAMF,GAQJ,IAAMG,EA0oBRC,SAAAA,GAEwB,GAAA,IADhBC,EAAYC,GAA0B,EAAKxC,EAAQuC,YAC3ClZ,KACZ,OAKF,KAAM6R,IAAAA,EAAO,GACPtV,EAAS,GAEf,EAAUsX,QAAQ,SAACuF,EAAQC,GACzB,IAAM/B,EAAQ9M,GAAwB6O,GAChC1f,EAAM6Q,GAAwB4O,GAC9BE,EAAS,CACbC,IAAK,MACLC,IAAK9O,GAAyB4M,GAAO,GACrC5P,EAAGgD,GAAyB/Q,GAAK,IAGnC,EAAKlL,KAAK6qB,GACV,EAAO7qB,KAAK6qB,EAAOE,OAIfC,EAAU7nB,KAAKC,UADN6nB,CAAC7H,KAAMA,IAMhB8H,IAAAA,EAAc/nB,KAAKC,UAAU,CAAC,KAAQ0K,IAKrC,OAFDqd,EAAY,CAAC,CAAC5d,SADhBpM,GAA+B8P,GAAmBia,IACdE,aAAc,WAE/C,CACL9d,UAAW,kBACXE,iBAAkB,gCAAkCzO,EAAO2S,KAAKsZ,GAChEvd,+BAA+B,EAC/BC,yBAAyB,EACzBC,gBAAiB,GACjBC,gBAAiB,GACjBC,kBAAmB,KACnBN,SAAU4d,EACVrd,OAAQ,IAAIhP,IAAIgP,IAtrBM0c,CAAAA,GACpBD,GAAAA,EACF,IADmB,IACnB,EAAAvuB,EAAsBouB,GAAtB,EAAA,EAAA,QAAA,EAAA,KAAA,EAAA,EAAA,QAAWiB,EAAX,EAAA,OACcC,QACVD,EAAQC,MAAMC,SAAW,CAAChB,IAExBc,EAAQG,QACVH,EAAQG,MAAMD,SAAW,CAAChB,IA4BhC,KAvBMkB,EAAarB,EAASsB,KAAK,SAACL,GAIhC,SAAA,EAHYC,OAASD,EAAQC,MAAMC,SAASzuB,QAGxCuuB,EAAQG,OAASH,EAAQG,MAAMD,SAASzuB,YA+8ChD6uB,SAAuBvB,EAAUwB,GAC/B,IAAML,EAAW,GAEjB,EAAWnG,QAAQ,SAAC1hB,EAAK4J,GACvBie,EAASvrB,KAAK,CACZsN,UAAWA,EACXE,iBAAkB9J,EAClB+J,+BAA+B,EAC/BC,yBAAyB,EACzBC,gBAAiB,GACjBC,gBAAiB,GACjBC,kBAAmB,KACnBN,SAAU,GACVO,OAAQ,IAAIhP,QAb2B,IAAA,IAiB3C,EAAA9C,EAAsBouB,GAAtB,EAAA,EAAA,QAAA,EAAA,KAAA,EAAA,EAAA,QAAWiB,EAAX,EAAA,OACcC,QACVD,EAAQC,MAAMC,SAAWA,GAEvBF,EAAQG,QACVH,EAAQG,MAAMD,SAAWA,GAt9C3BM,CAAsCzB,EADhC0B,EAAUpB,GAA0B,EAAKxC,EAAQ4D,UAKzD,GAAA,EAAA9vB,EAAsBouB,IAAtB,QAAA,EAAA,KAAA,EAAA,EAAA,OAIE,IAAA,IAAA,GAAA,EAAApuB,IAJSqvB,EAAX,EAAA,OACgCC,MAAQD,EAAQC,MAAMC,SAAW,IAEhCtf,OADTof,EAAQG,MAAQH,EAAQG,MAAMD,SAAW,MAE/D,QAAA,EAAA,KAAA,EAAA,EAAA,OACEQ,GADF,EAAAxsB,MAGMmrB,GAA0B,EAAKxC,EAAQ4D,SACvCpB,GAA0B,EAAKxC,EAAQ8D,UAAY,KAWvD,OANEC,EAmUR,SAAAC,EAAmC9B,GAMjC,IADA,IAAM+B,EAAa,IAAIrtB,IACvB,EAAA9C,EAAsBouB,GAAtB,EAAA,EAAA,QAAA,EAAA,KAAA,EAAA,EAAA,OAAgC,CAI9B,IAAA,EAAApuB,IAJSqvB,EAAX,EAAA,OACgCC,MAAQD,EAAQC,MAAMC,SAAW,IAEhCtf,OADTof,EAAQG,MAAQH,EAAQG,MAAMD,SAAW,KAE/D,IAAA,EAAA,EAAA,QAAA,EAAA,KAAA,EAAA,EAAA,OACEY,EAAWnhB,IADb,EAAAzL,OAMF,IAAA,EAAAvD,EAAmBmwB,GAAnB,EAAA,EAAA,QAAA,EAAA,KAAA,EAAA,EAAA,OACEJ,GADF,EAAAxsB,MAGMmrB,GAA0B,EAAKxC,EAAQ4D,SACvCpB,GAA0B,EAAKxC,EAAQ8D,UAAY,KAGnDI,EACF,EAAKhD,EAAyB,WAAa,WACzCiD,IAAAA,EACF,EAAKjD,EAAyB,CAAC,sBAAwB,CAAC,aAK5D,IAHMkD,EAAU,IAAIpH,IAGpB,EAAAlpB,EAAmBmwB,GAAnB,EAAA,EAAA,QAAA,EAAA,KAAA,EAAA,EAAA,OAAW5sB,EAAX,EAAA,MAeE+sB,EAAQ/Z,IAAIhT,EAAK+N,UAdFif,CAEbC,kBAAmB,GACnBC,kBAAmB,GACnBC,sBAAuB,WACvBN,gBAAiBA,EACjBC,aAAcA,EACdM,MAAOptB,EAAK+N,UAGP,SAAc,KAQvB,IAAA,EAAAtR,EAAsBouB,GAAtB,EAAA,EAAA,QAAA,EAAA,KAAA,EAAA,EAAA,OAOE,IAPSiB,EAAX,EAAA,MAOE,EAAArvB,EAAqB,CALPqvB,EAAQG,MAERH,EAAQC,QAGtB,EAAA,EAAA,QAAA,EAAA,KAAA,EAAA,EAAA,OACE,GADSsB,EAAX,EAAA,MACE,CAIA,IAAMhZ,EAAWiZ,GAAuCD,GACpDE,EAAmB,KAEvB,QAAIF,EAAOnH,OAAO3R,eACd4S,OAIFoG,EAAmBD,GAAuCD,EACtD,SAGN,IAAA,EAAA5wB,EAAmB4wB,EAAOrB,UAA1B,IAAA,EAAA,EAAA,QAAA,EAAA,KAAA,EAAA,EAAA,OAAoC,CAApC,IAAWhsB,EAAX,EAAA,OACQgtB,EAASD,EAAQ9N,IAAIjf,EAAK+N,YAOzB,SAAYtN,KAAKT,GAExB,EAASkO,gCACP8e,EAAOG,sBAAwB,YAEjC,EAAShf,0BACP6e,EAAOH,gBAAkB,YAOrBW,IAAAA,EAAa,CACjBC,YALIA,EvBlrBP/e,SuBkrBqB2e,EAAOvV,KACvB9X,EAAKoO,gBAAkBpO,EAAKqO,kBAIJ,GAC1BiG,YAAaD,GAGf,SAAIgZ,EAAOvV,KACTkV,EAAOC,kBAAkBxsB,KAAK+sB,GAE9BR,EAAOE,kBAAkBzsB,KAAK+sB,GAKhC,IAEQE,EAAqB,CACzBD,WAAYA,GAAc,GAC1BnZ,YAAaiZ,GvBvsBlB7e,SuB0sBO2e,EAAOvV,KACTkV,EAAOC,kBAAkBxsB,KAAKitB,GAE9BV,EAAOE,kBAAkBzsB,KAAKitB,KAOxC,OA7H2C,EAlUvCf,CAAAA,EAAwC9B,IAKpB7Y,MAMlBuF,EAAIoW,GAAAA,EAAqBjB,GAYxB,EAAanV,EAAIA,EAAA,MAAQ,gBAfvB,EADF6Q,GAAe,EACblZ,QAAQjG,WAiFb,SAAoB,GAApB2kB,GAAuBlX,OAAA,EAAA,SAAA,GAAA,GAAA,GAAA,EAAA,EAI3B,OAJ2B,EAIlByR,GAJkB,EAKlBG,GALkB,EAMlBA,EAAgBha,mBANE,EAOlBga,EAAgBha,kBAAkB/Q,QACrC,EAAA,EAAA,GACgB,EAAA,EATK,EASM4qB,EAAWyF,qBATjB,EAUdtF,EAAgBha,mBADP,IALtB,EAAA,EAAA,GAJ2B,GAAA,GAAA,EAAA,EAQrB,OAAA,EAAA,EAAA,GASI,MAAI5K,IAAAA,G9BzSJoM,EAyBLuV,EAmhBuBwI,K8BpQjBvP,EAAAA,GAKOwP,WAkDpBC,SAAY,GAAZA,GAIE,IAFA,IAAMnC,GACD,EAAKtD,EAAkB,EAAKA,EAAgBta,SAAW,KAAO,GACnE,EAAAvR,EAA+BmvB,GAA/B,EAAA,EAAA,QAAA,EAAA,KAAA,EAAA,EAAA,OACEoC,GAAAA,GADSC,EAAX,EAAA,OAEuBpC,aAAcoC,EAAiBjgB,UAItD,IAAA,GAAA,EAAAvR,EAAwB,EAAKgsB,IAA7B,QAAA,EAAA,KAAA,EAAA,EAAA,OACEyF,GAAAA,EADF,EAAAhS,OAUO,OAJP,EAAe3e,QAAW,EAAKkrB,EAAmBlrB,QAChD,EAAKmrB,EAAmBzf,UAG1B,EAAYyf,EAUdsF,SAAW,GAAXA,EAAYnC,EAAc7d,GAMxB,IADA,IAAMmgB,EAAY,EAAK3F,EAAgBxc,SACvC,GAAA,EAAAvP,EAAuB0xB,IAAvB,QAAA,EAAA,KAAA,EAAA,EAAA,OAIE,GAAI1qB,GAA6BuK,EAJnC,EAAA6F,MAIsD7F,YDta/CogB,GAAuC,WCya1C,QA0gBNC,SAAAA,EAAwBxC,EAAc7d,GAEpC,IAGI,IAAAkc,EAFE,EAAKL,EAEG,EAAK1B,EAAWmG,cAAc,sBAG9B,EAAKnG,EAAWmG,gBAE5B,MAAOhQ,GAAW,YAClB,EAAKsK,EAAS,IAAIllB,G9B/5BVoM,EAyBLuV,EAyhBqBkJ,K8BiXpBjQ,EAAUwP,UAIhB,EAAKvF,EAAcjE,EAAO4F,EAAS,UAE7B,SAACzK,GArBuC+O,EAqHpCtG,GArHoCsG,EA0HjC7F,EAAQ8F,gCA1HyBD,EA2HjCtG,EAAOwG,SA3H0BF,EA2HVzE,EA3HUyE,EA0GvC1E,EAAuBrpB,KArFUgf,GAuFtCkP,GA5G4CH,EAqBN/O,KACxC,EAAK8I,EAAcjE,EAAO4F,EAAS,oBAC/B,SAACzK,GAAU,OAAA,GAvB+BmP,EAuBLnP,KAQzC,EAAK+I,EAAgBxV,IAAIkX,EANRrW,CACf7F,SAAUA,EACV6gB,QAAQ,EACRzE,GAAe7nB,EAAAA,EACfusB,GAAe,OAIb,IACF9gB,EAAW,EAAK2a,EAAQ5D,kBACpB/W,EAAU6d,EAAc,EAAKvD,GACjC,MAAOrpB,GAAO,OACV8vB,EAAa9vB,EACjB,aAAA,KACE8vB,EAAa,IAAIrrB,G9B37BXoM,EAyBLuV,EA0lBsB2J,K8B4UnB/vB,SAEN,EAAK2pB,EAASmG,GAIZ,EAAKpG,EAAQsG,oBACHvS,GAAoC1O,GAIlD,EAAQkhB,gBAAgBrD,EAAc7d,GAAtC,MAAsD,SAAC/O,GACrD,IAvD4C,EAuDnCurB,EN1jCCzP,EM0jCV,CAvD4C,EA4DvCyN,EAAL,OAA4B0B,GAItBiF,IAAAA,EAAYlwB,EAAM,UAGpBkwB,GAAAA,GAAaA,EAAUC,WAAY,CACrC,IAAAC,EAAWF,EAAUC,WACrB,EAAIC,IACFA,GAAYtxB,KAAKS,IAAI,EAAG,KAE1B,EAAW,KAAO6wB,EAAS1rB,SAAS,IAxEM,EA2EvCilB,EAAS,IAAIllB,G9B/9BVoM,EAyBLuV,EAmiB+BiK,K8Bua9BrwB,EAAM6uB,QAAS7uB,EAAOowB,OArlB5B,CAAAhB,EAA6BxC,EAAc7d,GAW7CD,SAAgB,GAACwhB,GACf,OAAO,EAAUA,EAAQxhB,UAAY,GAUvCyhB,SAAW,GAAXA,EAAYlb,GAMV,GD1fI0S,UAAUM,UAAUjiB,MAAM,UC2f5B,OAAO,EAKL8hB,GAFJ,EAAc7S,EAAYC,cAEtB4S,MACA7S,EAAY4S,SAAS,iBAAkB,CAKzC,IAAMuI,EAAWnb,EAAYpO,QAAQ,OAAQ,QACtC,OAAA,EAAK+hB,EAAgB5O,IAAI/E,IACzB,EAAK2T,EAAgB5O,IAAIoW,GAGlC,OAAO,EAAKxH,EAAgB5O,IAAI/E,GAQlCob,SAAa,GAAbA,GAKSnW,OAHDoW,EAAMC,EADNC,EAAW,EAAKrH,EAAgB3E,OACS,SAACiM,GAAM5T,OAAAA,EAAEA,YAGjD,MAAMsN,KAAKmG,GA+LpBI,SAAuB,GAAC1C,EAAQ2C,GAC9B,IAAMC,EAAeC,GAAiC7C,EAAOhZ,SACzD2b,GAAiB3C,EAAOnH,QACxBiK,OAAA,GAAmCF,GAG9Bxb,GAAuC4Y,EAAOvV,KAAMmY,GAEtDA,EAUHtC,SAAe,GAAfA,EAAgBjB,GAAoB,IAUxC,EAAA,EAAWM,EASPoD,EAOJ,EAAA,EAAWC,EACT,EAAA,EAAWtiB,EACHif,EAoCFsD,EACAC,EACAC,EAEN,EAAA,EAAWC,EAIX,EAAWA,EAmBLC,EAUCpS,EArG+B5H,OAAA,EAAA,SAAA,GAAA,OAAA,EAAA,GAAA,KAAA,EACxC,GAA+B,GAA3BgW,EAAmB1a,MAAa0a,EAAmBrT,IAAI,IACzD,MAAU3V,IAAAA,G9B3pBFoM,EAyBLuV,EA+esBsL,K8B2J3B,IAAA,EAAAl0B,EAAqBiwB,EAAmB1gB,UAAxC,EAAA,EAAA,QAAA,EAAA,KAAA,EAAA,EAAA,OACyC,IAD9BghB,EAAX,EAAA,OACaC,kBAAkB1vB,eACpByvB,EAAOC,kBAEuB,GAAnCD,EAAOE,kBAAkB3vB,eACpByvB,EAAOE,kBAWlB,EAAAzwB,EAAsC,EAAC,GAAM,IAA7C,EAAA,EAAA,OA1BwC,KAAA,EA0BxC,GAAA,EAAA,KAAA,CAAA,EAAA,EAAA,GAAA,MAAW4zB,EAAX,EAAA,MACE,EAAA5zB,EAAwBiwB,EAAmB7I,QAA3C,EAAA,EAAA,OA3BsC,KAAA,EA2BtC,GAAA,EAAA,KAAA,CAAA,EAAA,EAAA,GAAA,MAMM+M,GANK7iB,EAAX,EAAA,MACE,EAAe2e,EAAmBzN,IAAIlR,GAEbif,EAAO,SAAYb,KAAK,SAACnsB,GAChD,QAASA,EAAKiO,oBAEQoiB,EAAyB,CAC/C,EAAA,EAAA,GAD+C,MAM3C,OAFF,EAAA,EAAA,GAEE,EAAA,EAAMrJ,UAAU6J,4BAA4B9iB,EAAW,CAACif,IAAxD,IAvC8B,KAAA,GAsClCoD,EACI,EAAA,EACJ,EAAA,EAAA,GAxCkC,MAAA,KAAA,EAyC3BnxB,EAAAA,GAzC2B,KAAA,EA0CpCskB,GA1CoC,EA0C/BiH,GA1C+B,KAAA,EA2BtC,EAAA,EAAA,OAAA,EAAA,EAAA,GA3BsC,MAAA,KAAA,EA4CtC,GAAI4F,EAAsB,CACxB,EAAA,EAAA,GADwB,MAlB5B,EAAA,EAAA,OAAA,EAAA,EAAA,GA1BwC,MAAA,KAAA,EAiDxC,IAAKA,EACH,MAAU1sB,IAAAA,G9B3sBFoM,EAyBLuV,EA6foCyL,M8BuMvC,IAbFvN,GAvDwC,EAuDnCiH,GAED,EAAA,EAAA,IAIF,EAAKvC,EAAgB/H,QAGrB,EAAmBkQ,EAAqBW,mBACxC,EAAkBT,EAAWrD,mBAAqB,GAClD,EAAkBqD,EAAWpD,mBAAqB,GAElD,EAAAzwB,EAAkB8zB,GAAlB,EAAA,EAAA,QAAA,EAAA,KAAA,EAAA,EAAA,OAAWE,EAAX,EAAA,MApEsC,EAqE/BxI,EAAgBxc,IAAIglB,EAAInc,YAAYC,eAG3C,IAAA,EAAA9X,EAAkB+zB,GAAlB,EAAA,EAAA,QAAA,EAAA,KAAA,EAAA,EAAA,OAAWC,EAAX,EAAA,MAxEsC,EAyE/BxI,EAAgBxc,IAAIglB,EAAInc,YAAYC,eAUvC,GAJJ,EAAK+T,EA06BT0I,SAAyBjjB,EAAWif,GAElC,IAAMiE,EAAiB,GAGjBC,EAAc,GAGdtF,EAAY,GAGZrd,EAAS,IAAIhP,IAuBZ,OAwBT4xB,SACInF,EAAUiF,EAAgBC,EAAatF,EAAWrd,GAapD,IAAA,IAAA,EAAA,GAAA,GAAA,EAAA9R,EAAsBuvB,IAAtB,QAAA,EAAA,KAAA,EAAA,CAAA,GAAWuD,EAAAA,IAAX,EAAA,EAAA,OAAgC,CAiB1BA,GAjBKA,EAAAA,GAAX,EAAA,MAEO,EAAerI,SAASqI,EAAAA,GAAQthB,mBACnCgjB,EAAexwB,KAAK8uB,EAAAA,GAAQthB,kBAI9B,EAAIshB,GAAQjhB,oBACI4iB,EAAY/E,KACtB,SAAA,GAAA,OAAA,SAAClH,GAAS,OAAA,GACNA,EAAMsK,EAAAA,GAAQjhB,oBADlB,CAAA,KAGF4iB,EAAYzwB,KAAK8uB,EAAAA,GAAQjhB,oBAKzBihB,EAAAA,GAAQvhB,SAAU,CACpB,EAAA,GADoB,IAAA,IACpB,EAAAvR,EAA+B8yB,EAAAA,GAAQvhB,UAAvC,EAAA,EAAA,QAAA,EAAA,KAAA,EAAA,CAAA,GAAWigB,EAAAA,IAAX,EAAA,EAAA,OAAWA,EAAAA,GAAX,EAAA,MACgBrC,EAAUO,KACpB,SAAA,GAAA,OAAA,SAACne,GACiCigB,IAAAA,EAAAA,EAAAA,GAAVjgB,SA9BhC,EAAMsb,OA8B0Btb,EA9Bfsb,OAASzP,EAAEyP,QA8BItb,EAzBvB6d,cAAgBhS,EAAEgS,cACxBpoB,GAwB6BuK,EAxBEA,SAAU6L,EAAE7L,WAuBtC,CAAA,KAGF4d,EAAUnrB,KAAKwtB,EAAAA,IAKrB,GAAIsB,EAAAA,GAAQhhB,OACV,IAAA,EAAA9R,EAAoB8yB,EAAAA,GAAQhhB,QAA5B,EAAA,EAAA,QAAA,EAAA,KAAA,EAAA,EAAA,OACEA,EAAO9C,IADT,EAAA6d,QAvFJ,CACI0D,EAAO,SAAaiE,EAAgBC,EAAatF,EAAWrd,GAmBzD,CACLR,UAAAA,EACAE,iBAAkBgjB,EAAe,GACjC/iB,8BAAyD,YAJ7B8e,EAAOG,sBAKnChf,wBAAoD,YAA1B6e,EAAOH,gBACjCze,iBAVE4e,EAAOC,kBAAoBD,EAAOC,kBAAkB,GAAGQ,WAAa,KAUlC,GACpCpf,iBATE2e,EAAOE,kBAAoBF,EAAOE,kBAAkB,GAAGO,WAAa,KASlC,GACpCnf,kBAAmB4iB,EAAY,GAC/BljB,SAAU4d,EACVrd,OAAAA,GAr9BuB6iB,CACnBhB,EAAqBriB,UACrB2e,EAAmBzN,IAAImR,EAAqBriB,aAjFV,EAmF5Bua,EAAgBra,iBACxB,MAAUvK,IAAAA,G9B7uBJoM,EAyBLuV,EAmkBoBgM,K8B6De,EAwF3B/I,EAAgBva,WAGT,OAAA,EAAA,EAAMqiB,EAAqBkB,kBAA3B,IA3FoB,KAAA,GAmGtC,OAAA,EARkB,EAAA,EAClB/N,GA5FsC,EA4FjCiH,GA5FiC,EAgGjCrC,EAAauI,EAhGoB,EAiGjCtI,GAAe,EAEpB,EAAA,EAAMwF,GAnGgCA,GAmGtC,IAnGsC,KAAA,GAoGtCrK,GApGsC,EAoGjCiH,GA3CH,EAAA,EAAA,GAzDoC,MAAA,KAAA,GA2GlClM,GANGA,EAAAA,EAAAA,GACP,GAtGsC,EAsGjCkM,EAA8BlM,GAGnC,EAAKgK,EAAkB,KACvB,EAAKL,EAAgB/H,QACjB5B,aAAJ,GACE,MAAA,EAIF,MAAU5a,IAAAA,G9BzwBFoM,EAyBLuV,EAogBiBkM,K8BgPhBjT,EAAUwP,YAgEZI,SAAmB,GAAnBA,EAAoBhS,GACxB,IAAIgO,EAKIjrB,EAeF4U,EASE2d,EAsBCvyB,EApD0ByX,OAAA,EAAA,SAAA,GAAA,OAAA,EAAA,GAAA,KAAA,EAEnC,IAEEwT,EAJiC,EAIlB/B,EAAWmG,cAAc,sBACxC,MAAOhQ,GAOP,OAAA,EANc,IAAI5a,G9Bn1BVoM,EAyBLuV,EAyhBqBkJ,K8BqSpBjQ,EAAUwP,SAVmB,EAW5BlF,EAAS3pB,GACd,EAAA,OAAOiQ,QAAQC,OAAOlQ,IAkBN,OA9BiB,EAe9BspB,EAAcjE,EAAO4F,EAAS,UAE7B,SAACzK,GAjB4B+O,EA4LzBtG,GA5LyBsG,EAiMtB7F,EAAQ8F,gCAjMcD,EAkMtBtG,EAAOwG,SAlMeF,EAkMCzE,EAlMDyE,EAiL5B1E,EAAuBrpB,KAhKUgf,GAkKtCkP,GAnLiCH,EAiBK/O,KACxC,EAAK8I,EAAcjE,EAAO4F,EAAS,oBAC/B,SAACzK,GAAU,OAAA,GAnBoBmP,EAmBMnP,KAEzC,EAAiB,CACfzR,SAAU,KACV6gB,QAAQ,EACRzE,GAAe7nB,EAAAA,EACfusB,GAAe,MAEjB,EAAKtG,EAAgBxV,IAAIkX,EAASrW,GAE9B,EAAA,EAAA,GACc,EAAA,EAAMqW,EAAQuH,KAAKvV,GAAnB,GA9BiB,KAAA,EAkC7B,OAJEsV,EAAU,EAAA,EAChB,GA/BiC,EA+B5BhH,GAGAgH,GAYL,EAAS3C,QAAS,EACd,GA/C6B6C,IAAA,EAgD1BhJ,EAAmBzf,UAG1B,EAAA,OAAOihB,KAhBL,EAAK1B,EAAL,OAA4B0B,GAnCG,EAqC1BtB,EAAS,IAAIllB,G9Bl3BZoM,EAyBLuV,EAwkBoBsM,O8BqRrB,EAAA,OAAOziB,QAAQjG,YAzCgB,KAAA,EAoD1BhK,EAAAA,EAAAA,GACPskB,GArDiC,EAqD5BiH,EAA8BvrB,GArDF,EAuD5BupB,EAAL,OAA4B0B,GAvDK,EAyD5BtB,EAAS,IAAIllB,G9Bt4BVoM,EAyBLuV,EAyhBqBkJ,K8BwVpBtvB,EAAM6uB,UA7DuB,KAAA,EA+DnC,OAAA,EAAA,OAAO5e,QAAQjG,cAiGjB2oB,SAA+B,GAAC5jB,EAAU6d,EAAc0D,GAQ/CvhB,MAPa,OAAhB6d,IACI5G,EAAOsK,EAAQjhB,kBAGrBN,EAAWuY,GACPvY,EAHEgX,EACFwB,GAA6CxY,GAExBiX,IANoC,EA0C3D0J,SAAmB,GAAnBA,EAAoBlP,GAExB,IAAMyK,EASArW,EAEFge,EACEC,EAQAvR,EAaAwR,EAEFjQ,EAIK7iB,EAID+yB,EA0BC/yB,EAED+yB,EAYFC,EArFyB,EAAA,SAAA,GAAA,OAAA,EAAA,GAAA,KAAA,EAwClB,OAAA,EAtCGxS,EAAM9G,OAFS,EAMtBgQ,EAAQsG,oBACHvS,GAAoC+C,EAAMqO,SAIlDja,EAXyB,EAWT2U,EAAgBvJ,IAAIiL,GAEtC2H,EAb2B,EAahBvJ,EAAgBra,iBACzB6jB,EAdyB,EAetBnJ,EAAQ8D,SAfc,EAeAnE,EAAgBva,WACtB,6BAArB0R,EAAMyS,aAA8CJ,GACpDA,EAAeK,0BACjBN,EAAMC,EAAeK,0BAIjB5R,EAAUwC,GACZ,CAAC8O,GAvB0B,EAuBflJ,EAAQ3M,kBAChBH,KAAO4D,EAAMqO,QACrBvN,EAAQ3E,OAAS,OACjB2E,EAAQtE,mBAAqBwD,EAAMyS,YACnC3R,EAAQrE,UAAYgO,EAAQhO,UAGU,2BA9BP,EA8BtBoM,EAAgBva,WACa,4BA/BP,EA+BtBua,EAAgBva,WAiF3BqkB,SAAwB7R,GAwBtB,IAAM8R,EAAMzgB,GACR2O,EAAQ1E,MAA0B,GAAqB,GACtDwW,GAAAA,EAAInL,SAAS,uBAAlB,CA1B+B,IAAA,IAwC/B,EAAAzqB,GAJM61B,GAAM,IAAIC,WAAYC,gBAAgBH,EAAK,oBAG7BzK,qBAAqB,eACzC,EAAA,EAAA,QAAA,EAAA,KAAA,EAAA,EAAA,OAAW6K,EAAX,EAAA,MAIElS,EAAQzE,QAHK2W,EAAO7K,qBAAqB,QAAQ,GAG5B8K,aAFPD,EAAO7K,qBAAqB,SAAS,GAET8K,YAQ5C,EAAQ7W,KAAOY,GAJG6V,EAAI1K,qBAAqB,aAAa,GAIO8K,kBApB7D,EAAQ5W,QAAQ,gBAAkB,0BAhHlCsW,CAA6B7R,GAGzBwR,EAAmBtZ,KAAKD,MAG1B,EAAA,EAAA,GAES,EAAA,EAxCkB,EAuCZwP,EAAiB2K,GAAUpS,QPxmBrCqS,EOwmB0DrS,GAC5CtR,QAAV,GAxCkB,KAAA,EAwC7B6S,EAAW,EAAA,EAFT,EAAA,EAAA,GAtC2B,MAAA,KAAA,EAsD7B,OAAA,EAbO7iB,EAAAA,GAID+yB,EAAW,IAAItuB,G9BpkCboM,EAyBLuV,EA0iBmBwN,K8BqgBlB5zB,GAjDyB,EAkDxB2pB,EAASoJ,GACVne,GAAYA,EAASib,IACvBjb,EAASib,GAAc3f,OAAO6iB,GAEhC,EAAA,SAtD6B,KAAA,EAwD/B,OAxD+B,EAwDtBxH,EN9rCGzP,EM+rCV,EAAA,UAGF,EAAKsN,IAAwB5P,KAAKD,MAAQuZ,GAAoB,IAE9D,EAASpJ,EAAQsG,oBACHvS,GAAoCoF,EAAS1f,MAKvD,EAAA,EAAA,GAEF,EAAA,EAAM8nB,EAAQ4I,OAAOhR,EAAS1f,MAA9B,IAtE6B,KAAA,EAoE3B,EAAA,EAAA,GApE2B,MAAA,KAAA,EAkF7B,OAAA,EAXOnD,EAAAA,GAED+yB,EAAW,IAAItuB,G9BhmCboM,EAyBLuV,EAkjBsB0N,K8ByhBrB9zB,EAAM6uB,SA7EmB,EA8ExBlF,EAASoJ,GACVne,GAAYA,EAASib,IACvBjb,EAASib,GAAc3f,OAAO6iB,GAEhC,EAAA,SAlF6B,KAAA,EAqFzBC,EAAc,IAAIpT,GAAqB,oBArFd,EAsF1BmJ,EAAiBgL,QAAQf,GAE1Bpe,IACEA,EAASib,IACXjb,EAASib,GAAc7lB,UAKX,IAAI8N,GAAiB,WACjClD,EAASgb,QAAS,EACd,GAjGuB6C,IAAA,EAkGpBhJ,EAAmBzf,YAItB+N,EACaic,KAvGU,EAAA,MA4KjCrE,SAAoB,GAApBA,EAAqBnP,GACnB,IAAMyK,EAA0CzK,EAAM9G,OAGhDua,EAAQ,EAAK1K,EAAgBvJ,IAAIiL,GAEnCiJ,GAAiB,EAErB,EAH6BC,YAGhBvN,QAAQ,SAACwD,EAAQC,GAK5B,GAAoB,iBAApB,EAA8B,CAC5B,IAAM+J,EAAM/J,EACZ,EAAoCD,EACpC,EAA+BgK,EAajC,GAAsC,2BA7Bd,EA6Bf/K,EAAgBva,WACD,IAApBub,EAAM9nB,aDpyCL4sB,GAAuC,aA5B1CpH,UAAUM,UAAUjiB,MAAM,YCi0CsC,CAG1DiuB,IAAAA,GADA/iB,EAAWhN,GAAkC+lB,IAC5BiK,UAAU,GAAa,GACxCC,EAAQjjB,EAASC,UAAU,GAAa,GACxCijB,EAAQljB,EAASC,UAAU,GAAa,GAE9C,EAAS4U,UAAU,EAAGkO,GAAiB,GACvC,EAASpiB,UAAU,EAAGsiB,GAAiB,GACvC,EAAStiB,UAAU,EAAGuiB,GAAiB,GAQH,2BAhDd,EAgDfnL,EAAgBva,WACX,kBAAVsb,IACFA,EAAS,UAGX,kBAAIA,IACF6J,EAAMrE,QAAS,GAWjB,WAAIxF,IACF8J,GAAiB,GAGb9H,EAAW9O,GAAiC+M,GAElD,EAAKP,GAAkB/V,IAAIqY,EAAUhC,KAMjCqK,IAAAA,EAAoBxJ,EAAQI,WAAa7R,KAAKD,OAC5B,EAApBkb,GAA0BP,GAAsC,IAApBO,IAG1CR,IAAUA,EAAMpE,KAElB,EAAKtG,EAAL,OAA4B0B,GAC5BA,EAAQyJ,QAAR,MAAsB,eAIrB,GAAAjC,KAML,EAAKhJ,EAAmBzf,UAOxB,EAAKggB,EAAgBjS,EACF4c,KAgKflJ,SAAkB,GAAlBA,GAEJ,IAAMmJ,EAFmBnd,OAAA,EAAA,SAAA,GAMzB,OAJMmd,EAAeta,MAAMiQ,KAFF,EAEYhB,EAAgB3E,QACrD,EAAK2E,EAAgBtI,QAGrB,EAAA,EAAMhR,QAAQtC,IAAIinB,EAAaxzB,IAAI,SAAO6pB,GAAY,OAAA,EAAA,SAAA,GAAA,OAAA,GAAA,EAAA,GAGhD,EAAA,EAAA,GACF,EAAA,GA7BcA,EA6BWA,EA7BF,EAAA,SAAA,GAAA,OAAA,GAAA,EAAA,GASzB,EANc,IAAIhb,QAAQ,SAACjG,EAASkG,GAEpC,IADkB4H,GAAiB5H,GAC7B6H,EAAU8c,MAGd,EAAA,EAAA,GACF,EAAA,EAAM5kB,QAAQ6kB,KAAK,CACjB7kB,QAAQtC,IAAI,CAACsd,EAAQyJ,QAASzJ,EAAQ8J,SACtCje,IAFF,IATyB,GAAA,EAAA,EAQvB,EAAA,EAAA,IAKKzI,EAAAA,QAbkB,EAAA,OA6BvB,IAJkD,GAAA,EAAA,EAGhD,EAAA,EAAA,IAEKrO,EAAAA,QAL2C,EAAA,IAzBlDg1B,IAAc/J,EAGZnU,OAsBN,KAoBFme,SAAe,GAAfA,EAAgBpI,GAEd,IAAMG,EAAQH,EAAQG,MAEhBF,EAAQD,EAAQC,MAElBE,GAAAA,GAASA,EAAMkI,UAAW,CAC5B,IAAMC,EAAmB9G,GAAuCrB,GAC5D,IAACuD,GAAAA,EAAiB4E,GACpB,OAAO,EAIX,GAAIrI,GAASA,EAAMoI,YAEZ3E,GAAAA,EADC6E,EAAmB/G,GAAuCvB,IAE9D,OAAO,EAILhe,IAAAA,EAAYumB,GAAgC,EAAKhM,GAM7B,OAA1B,IAFM0D,GAFgBD,EAAQA,EAAMC,SAAW,IAEhBtf,OADTuf,EAAQA,EAAMD,SAAW,KAG/BzuB,QACZyuB,EAASG,KAAK,SAACoD,GAAY,OAAA,EAAQxhB,WAAaA,IA6BtDwmB,SAAwB,GAACC,EAAOC,GAC9B,IAAKD,EAAMj3B,OACT,OAEF,EAAI,IAACk3B,EAAMl3B,OACT,OAKF,EAFA,IAAA,IAAMm3B,EAAa,GAEnB,EAAAj4B,EAAmB+3B,GAAnB,EAAA,EAAA,QAAA,EAAA,KAAA,EAAA,EAAA,OAA0B,CAAfG,EAAX,EAAA,MAA0B,IAAA,IACxB,EAAAl4B,EAAmBg4B,GAAnB,EAAA,EAAA,QAAA,EAAA,KAAA,EAAA,EAAA,OAIE,GAJSG,EAAX,EAAA,MAIMD,EAAK5mB,WAAa6mB,EAAK7mB,UAAW,CAGpC,GADA,GADIC,EAAW,IACKtB,OAAOioB,EAAK3mB,UAAY,KACxBtB,OAAOkoB,EAAK5mB,UAAY,IACtCO,IAAAA,EAASomB,EAAKpmB,QAAUqmB,EAAKrmB,OAC/B,IAAIhP,IAAI4U,EAAIwgB,EAAKpmB,QAAT,OAAA4F,EAAoBygB,EAAKrmB,UACjComB,EAAKpmB,QAAUqmB,EAAKrmB,OAcxB,EAAW9N,KAbOo0B,CAChB9mB,UAAW4mB,EAAK5mB,UAChBE,iBAAkB0mB,EAAK1mB,kBAAoB2mB,EAAK3mB,iBAChDC,8BAA+BymB,EAAKzmB,+BAChC0mB,EAAK1mB,8BACTC,wBAAyBwmB,EAAKxmB,yBAC1BymB,EAAKzmB,wBACTE,gBAAiBsmB,EAAKtmB,iBAAmBumB,EAAKvmB,gBAC9CD,gBAAiBumB,EAAKvmB,iBAAmBwmB,EAAKxmB,gBAC9CE,kBAAmBqmB,EAAKrmB,mBAAqBsmB,EAAKtmB,kBAClDN,SAAAA,EACAO,OAAAA,IAlBkC,OA0B1C,OAzCqC,EAqEvCmjB,SAAqB,GAArBA,GAESoD,OhCztDTrL,SAAanpB,EAAUy0B,GACrB,IAD2B,IAC3B,EAAAt4B,EAAgB6D,GAAhB,EAAA,EAAA,QAAA,EAAA,KAAA,EAAA,EAAA,OACE,IAAKy0B,EADP,EAAAr0B,OAEI,OAAO,EAGJ,OAAA,EgCmtDA,CADDytB,EAAY,EAAK3F,EAAgBxc,SACM,SAAC5J,GAASysB,OAAAA,EAAKA,SAyK9DmG,SAA6B,GAACzF,EAAShD,EAAS0I,IACzC1F,EAAQxhB,WAqBY,mBAArBwhB,EAAQxhB,WAAkCwhB,EAAQthB,mBAI3Cse,EAAQva,OAGXkjB,EAAS3I,EAAQtN,IAAIsQ,EAAQxhB,YAAc,GACjDwhB,EAAQthB,iBAAmBinB,GAM7B,EAAa3mB,SACXghB,EAAQhhB,OAAS,IAAIhP,MAGjBuyB,EAAiBmD,EAAgBhW,IAAIsQ,EAAQxhB,cAE5CwhB,EAAQrhB,gCACXqhB,EAAQrhB,8BACJ4jB,EAAe5jB,+BAGhBqhB,EAAQphB,0BACXohB,EAAQphB,wBACJ2jB,EAAe3jB,yBAGhBohB,EAAQlhB,kBACXkhB,EAAQlhB,gBAAkByjB,EAAezjB,iBAGtCkhB,EAAQnhB,kBACXmhB,EAAQnhB,gBAAkB0jB,EAAe1jB,iBAGtCmhB,EAAQjhB,oBACXihB,EAAQjhB,kBAAoBwjB,EAAexjB,oBAW/C,EAAW6mB,MAAQ31B,EAAO21B,KAAKC,cACJ,2BAArB7F,EAAQxhB,YACVwhB,EAAQxhB,UAAY,6BAh3D1BsnB,GAAA,UAAA,QAAAzY,WACE,OAAO,KAAK4N,EAAW5N,WA4DzByY,GAAA,UAAA,UAAAC,SAAUtI,GACR,KAAKrE,EAAUqE,GA2LXqI,GAAA,UAAA,GAAAE,SAAOxJ,GAAO,IA+CV3N,EA/CU,EAAA,KAAA1H,OAAA,EAAA,SAAA,GAAA,GAAA,GAAA,EAAA,EAClB,OAAK,EAAKyR,GAmBV,EAAKD,EAAS6D,EAEd,EAAKxD,EAAc9D,GAAW,EAAKyD,EAAQ,OAAQ,WAirCnD,IADQ,IACR,EAAAzrB,EAjrCyD+4B,EAirChC1L,GAAzB,EAAA,EAAA,QAAA,EAAA,KAAA,EAAA,EAAA,OACE6E,GAlrCuD6G,EAirCzD,EAAA/V,OAIA,EAAKsK,GAAuB,EAC5B,EAAKD,EAAyB,KArrC9B,0CAAA,EAAoD5B,GAClD,EAAKK,EAAcjE,EAAO,EAAK4D,EAC3B,+CACA,WAAM,OAAA,GAAAwC,KAaZ,EAAA,EAVmB,EAAKxC,EAAOyC,aAAa,EAAKxC,GAClC,MAAmB,SAAC7J,GAEjC,OAAO,QAAQnP,OAAO,IAAIzL,G9B9PlBoM,EAyBLuV,EA4gBsBoQ,K8BnSrBnX,EAAUwP,YAGhB,KA5BE,EAAKvF,EAAc9D,GAAWsH,EAAO,YAAa,WAChD,EAAKnD,EAAS,IAAIllB,G9B1OZoM,EAyBLuV,EA0jB+BqQ,S8BpWlC,EAAA,UAuBFnS,GAAA,EAAKiH,GAEL,GAAAuD,GACA,EAAUzF,EAAgBta,SAASzQ,QAC9B,EAAKkrB,EAAmBlrB,SAGrB6gB,EAAKA,SAAC9Q,GAAM,OAAA,GAAA0gB,EACd1gB,EAAEue,aAAcjqB,GAA+B0L,EAAEU,YACrD,EAAKua,EAAcjE,EAAO,EAAK4D,EAAQ,YAAa9J,IAjDpC,EAAA,MAiPpBiX,GAAA,UAAA,GAAAM,WAKE,IAHA,IAAIt2B,EAAMkD,EAAAA,EAEJstB,EAAW,KAAKrH,EAAgB3E,OACtC,GAAA,EAAApnB,EAAsBozB,IAAtB,QAAA,EAAA,KAAA,EAAA,EAAA,OAAW3F,EAAX,EAAA,MACO7jB,MAAM6jB,EAAQI,cACjBjrB,EAAMtB,KAAKsB,IAAIA,EAAK6qB,EAAQI,aAIzBjrB,OAXO,GAs8ClB,IAAAy0B,GAAuC,EASvCb,GAA8C,EAQ9CW,GAA8C,GAQ9CgC,GAAqC,IAAIvkB,GACrC,WAAM,OAAA,GAAqC,IAAInP,WAAW,CAAC,OCthE7DtE,SAAW,KAET,KAAKi4B,EAAoB,IAAI3iB,MAAMC,IAAI2iB,cAGvC,KAAKC,EAAiB,GAMtB,KAAKC,EAAc,GAuDS,SAAA,MCvE9BC,SAAgB,GAACpc,GAKf,OAJKA,GAIW,GAAZA,EAAEtc,QAAuC,KAAxBsc,EAAEhZ,IAAI,GAAKgZ,EAAEhX,MAAM,GAC/B,KAEFgX,EAAEtc,OAASsc,EAAEhZ,IAAIgZ,EAAEtc,OAAS,GAAK,KAe1C24B,SAAiB,GAACrc,EAAG8H,EAAMwU,GACrB,OADqBA,OAAA,IAAAA,EAAgB,EAAhBA,KACpBtc,IAAMA,EAAEtc,QAIG,GAAZsc,EAAEtc,QAAuC,KAAxBsc,EAAEhZ,IAAI,GAAKgZ,EAAEhX,MAAM,IAIpC8e,EAAO9H,EAAEhZ,IAAIgZ,EAAEtc,OAAS,KAKpBokB,EAAOwU,GAAiBtc,EAAEhX,MAAM,GAe1CuzB,SAAsB,GAACvc,EAAG8H,GAKxB,IAJK9H,IAAMA,EAAEtc,QAIG,GAAZsc,EAAEtc,QAAuC,KAAxBsc,EAAEhZ,IAAI,GAAKgZ,EAAEhX,MAAM,GACtC,OAWF,EADA,IAAA,IAAIkO,EAAS,EACb,EAAAtU,EAA2B45B,GAA4Cxc,IAAvE,EAAA,EAAA,QAAA,EAAA,KAAA,EAAA,EAAA,OAA2E,CAAhE,IAAA,EAAX,EAAA,MAAYhX,EAAA,EAAA,OAAOhC,EAAA,EAAA,KACP8gB,IACR5Q,GAAUlQ,EAAM9C,KAAK+E,IAAID,EAAO8e,IAIpC,OAvB8B,EAsEhC2U,SAAsB,GAACzc,GACrB,IAAKA,EACH,MAAO,GAET,IAAA,IAAM1M,EAAM,GACZ,EAAA1Q,EAAgBmE,GAA2BiZ,EAAEtc,SAA7C,EAAA,EAAA,QAAA,EAAA,KAAA,EAAA,EAAA,OAAWuD,EAAX,EAAA,MACEqM,EAAI1M,KAAK,CAACoC,MAAOgX,EAAEhX,MAAM/B,GAAID,IAAKgZ,EAAEhZ,IAAIC,KAEnCqM,OARiB,EClJ1BvP,SAAW,GAAC24B,EAAWC,EAASC,GAO9B,KAAKF,UAAYA,EAMjB,KAAKG,UAAYC,GAMjB,KAAKH,QAAUA,EAMf,KAAKC,QAAUA,EAMf,KAAKG,OAAS,IAAIC,GAMlB,KAAKC,SAAW,KAMhB,KAAKC,cAAgBC,GAMrB,KAAKhlB,KAAO,EAMZ,KAAKilB,UAAYC,GAMjB,KAAKC,YAAcC,GAMnB,KAAKC,mBAAqBC,GAM1B,KAAKC,KAAO,KAMZ,KAAKC,WAAa,GAOlB,KAAKC,UAAYC,GAOjB,KAAKC,aAAeC,GA8BpB,KAAKC,SANL,KAAKC,OANL,KAAKC,gBANL,KAAKC,gBANL,KAAKC,MAAQ,GA8Bb,KAAKC,WAAaC,GAMlB,KAAKC,UAAYC,GAkBjB,KAAKC,YANL,KAAKC,cANL,KAAKC,WAAa,GAkBlB,KAAKC,QAAU,EAMf,KAAKC,eAAiB,GAMtB,KAAKC,UAAW,EAMhB,KAAKC,GAAK,GAMV,KAAKC,WAAa,GAMlB,KAAKC,QAAS,EAMd,KAAKC,eAAiB,CACpBC,QAAS,GACTC,KAAM,IAiCH,SAAK,GAACC,EAAMC,GAKjB,GAAID,EAAK3C,WAAa4C,EAAK5C,WAAa2C,EAAK1C,SAAW2C,EAAK3C,SAC3D0C,EAAKzC,SAAW0C,EAAK1C,QACrB,OAAO,EAEJ/c,IAAAA,IAAMA,KAAX,EACE,GAAS,aAALA,GAAyB,WAALA,GAAuB,WAALA,EAEnC,GAAS,cAALA,GAIL,IAAC0f,GACDF,EAAKL,WAAYM,EAAKN,WAAYQ,IACpC,OAAO,OAEK,GAAA,UAAL3f,GAAsB,kBAALA,GAC1B,IAAK4f,IAAMA,KAAM,EAAK5f,GAChBwf,GAAAA,EAAKxf,GAAG4f,IAAOH,EAAKzf,GAAG4f,GACzB,OAAO,OAGF/f,GAAAA,MAAMD,QAAQ4f,EAAKxf,KACxB,IAAC0f,GAA4BF,EAAKxf,GAAIyf,EAAKzf,IAC7C,OAAO,OAGLwf,GAAAA,EAAKxf,IAAMyf,EAAKzf,GAClB,OAAO,EAKN,OAAA,EF7NT6f,GAAA,UAAA,KAAAC,SAAKp3B,GACH,IAAMq3B,EAAQvmB,MAAMC,IAAIsmB,MAElBC,EAAY93B,GAA+BQ,GACjD,KAAK2zB,EAAiB0D,EAAME,cAAcD,GAC1C,KAAK1D,EAAcyD,EAAMG,UAAUF,GACnC,KAAK7D,EAAkB2D,QAMzBK,GAAA,UAAA,EAAAA,SAAUz3B,EAAM03B,GACd,IAAMC,EAAen4B,GAA+BQ,IAC9C43B,EAAa,KAAKnE,EAAkBoE,MACtCF,EAAc,KAAKhE,EAAgB,KAAKC,KAC1BgE,EAAWpmB,UAC3BkmB,EAAWE,EAAWpmB,UAKxB,KAAKiiB,EAAkBqE,uBAMzBC,GAAA,UAAA,EAAAA,WACE,KAAKtE,EAAkBuE,sBAwBzBC,GAAA,UAAA,KAAAb,aAKAK,GAAA,UAAA,EAAAA,aAKAM,GAAA,UAAA,EAAAA,aEiGAG,GAAA,UAAA,MAAAr1B,WACE,IAEWyU,EAFLzU,EAAQ,IAAIq1B,GAAe,EAAG,EAAG,IAE5B5gB,IAAAA,KAAX,KACEzU,EAAMyU,GAAK,KAAKA,GAKZzU,EAAMyU,IAAMzU,EAAMyU,GAAG9b,aAAe2b,QACtCtU,EAAMyU,GAA2BzU,EAAMyU,GAAIY,SAIxCrV,OAdD,GApNV7B,EAAA,iBAAAk3B,IA8RE,IAAA,GAAQ,O3EokDR,G2ExkDFh3B,cAA+Bi3B,CAC7BA,KAAQA,YACRA,MAASA,aACTA,OAAUA,SACVA,KAAQA,IAWR,IAAA,GAAU,SAHZC,GAA2B,CACzB,KAAQ,OACR,MAAS,QACT,OAAU,GACV,MAAS,QACT,IAAO,O3EujDP,G2E5jDFl3B,UAAAk3B,GAmBE,IAAA,GAAS,QAHXC,GAA8B,CAC5B,OAAU,SACV,OAAU,SACV,MAAS,I3EyiDT,G2E5iDFn3B,aAAAm3B,GAYE,IAAA,GAA4B,M3EgiD5B,G2EjiDFn3B,UAA2Bo3B,CACzBA,yBAA4BA,GAC5BA,yBAA4BA,OAS5B,IAAA,GAA4B,gB3EshD5B,G2EvhDFp3B,YAA6Bq3B,CAC3BA,yBAA4BA,GAC5BA,uBAA0BA,cAC1BA,uBAA0BA,eAS1B,IAAA,GAAe,E3E2gDf,G2E5gDFr3B,mBAAoCs3B,CAClCA,YAAeA,GACfA,WAAcA,GAUd,IAAA,GAAS,QAFXC,GAA2B,CACzB,OAAU,SACV,MAAS,GACT,IAAO,O3E+/CP,G2ElgDFv3B,UAAAu3B,GAcE,IAAA,GAAU,I3Eo/CV,G2Er/CFv3B,WAA4Bw3B,CAC1BA,OAAUA,GACVA,KAAQA,KASR,IAAA,GAAU,SADZC,GAA2B,CACzB,OAAU,GACV,OAAU,SACV,QAAW,WAqBX,SAAW,KAOT,KAAKnC,GAAK,GAwBV,KAAKoC,cANL,KAAKC,cANL,KAAKC,gBANL,KAAKC,gBAAkB,EA8BvB,KAAKC,OANL,KAAKC,MAAQ,IAwBb,KAAKC,oBANL,KAAKC,WANL,KAAKC,YAAcC,GAkBnB,KAAKC,OAASC,G3Eg5ChB,G2E3+CFr4B,UAAAy3B,G3E2+CE,G2Eh+CFz3B,eAAgCs4B,CAC9BA,UAAaA,YACbA,aAAgBA,cAChBA,SAAYA,YASdx4B,EAAA,uBAAAyzB,IA+EE,IAAA,GAAc,E3Eq4Cd,G2Ev4CFvzB,MAA6Bu4B,CAC3BA,GAAMA,EACNA,WAAcA,GACdA,MAASA,GAST,IAAA,GAAQ,GC/dRj+B,SAAW,GAACk+B,GAEV,KAAKC,EAAU,KAGf,KAAKC,EAAaF,EAMlB,KAAKG,EAHL,KAAKC,EAAmB,EAMxB,KAAKC,EAAmB55B,EAAAA,EAMxB,KAAK65B,EAHL,KAAKC,EAAe,KAMpB,KAAKC,EAA2B,GAYhC,KAAKC,EAAqB,IAAI5W,IAwBhCnR,SAAsB,GAACH,GAKrB,SAJI,GAAiCA,IAIjC7U,EAAO0T,ONyBgCspB,uBMxBvCnoB,GAiPNooB,SAA4B,GAA5BA,EACIC,EAAgBnG,EAAWC,EAASmG,GAKtC,IAJA,IAAMC,EAAkBrG,EAAY,IAAMC,EAEpCqG,EAAc,IAAIlX,IAExB,GAAA,EAAAlpB,EAAsBigC,IAAtB,QAAA,EAAA,KAAA,EAAA,EAAA,OAAsC,CAAtC,IAAWI,EAAX,EAAA,MACQlE,EAAKkE,EAAQzP,OACd,EAAYhU,IAAIuf,IACnBiE,EAAY7pB,IAAI4lB,EAAI,IAAIjT,KAErB,EAAY1G,IAAI2Z,GAAIvf,IAAIujB,IAC3BC,EAAY5d,IAAI2Z,GAAI5lB,IAAI4pB,EAAiB,IAK3C,EAAQrG,WAAaoG,EACrB,EAAQnG,SAAWmG,EAKnB,EAFYpG,WAAa,EAAK0F,GAC1Ba,EAAQvG,UAAY,EAAK4F,IAKvBY,EAAM,IAAIzC,GACZwC,EAAQvG,UAAWuG,EAAQtG,QAASsG,EAAQE,MAChDH,EAAY5d,IAAI2Z,GAAI3Z,IAAI2d,GAAiBn8B,KAAKs8B,GAC1CnE,GAAM,EAAK0D,GACb,EAAKN,EAAWiB,OAAO,CAACF,KAI5B,IAAA,GAAA,EAAAtgC,EAAiBogC,EAAYhZ,SAA7B,QAAA,EAAA,KAAA,EAAA,EAAA,OAIE,IAJS+U,EAAX,EAAA,MACO,EAAK2D,EAAmBljB,IAAIuf,IAC/B,EAAK2D,EAAmBvpB,IAAI4lB,EAAI,IAAIjT,KAEtC,GAAA,EAAAlpB,EAA8BogC,EAAY5d,IAAI2Z,GAAI/U,SAAlD,QAAA,EAAA,KAAA,EAAA,EAAA,OAAW+Y,EAAX,EAAA,MACQM,EAAOL,EAAY5d,IAAI2Z,GAAI3Z,IAAI2d,GACrC,EAAKL,EAAmBtd,IAAI2Z,GAAI5lB,IAAI4pB,EAAiBM,GAKvD,EAAKb,EADkB,MAArB,EAAKA,EACat+B,KAAK+E,IAAIyzB,EAAW,EAAK0F,GAEzBl+B,KAAKsB,IACrB,EAAKg9B,EAAct+B,KAAK+E,IAAIyzB,EAAW,EAAK0F,IAGlD,EAAKG,EAAar+B,KAAK+E,IACnB,EAAKs5B,EAAYr+B,KAAKsB,IAAIm3B,EAAS,EAAK2F,I5Em/C9C,G2E53CF74B,WAAkC65B,CAChCA,KAAQA,GACRA,GAAMA,MCnZNC,GAAA,UAAA,QAAAxgB,WAKS1N,OAHP,KAAK8sB,EADL,KAAKD,EAAU,KAEf,KAAKQ,EAAmBrc,QAEjB,QAAQjX,WA8FXm0B,GAAA,UAAA,OAAAtjB,SAAOyc,EAAWC,GAAS,IAAA,EAAA,KAAA9f,OAAA,EAAA,SAAA,GAAA,GAAA,GAAA,EAAA,EAE/B,OAAA,EAAA,EAAMxH,QAAQjG,UAAd,IAEI,EAAK+yB,IAAc,EAAKA,EAAWliB,OAAOyc,EAAWC,IAC9B,MAArB,EAAK6F,GASH7F,GAAW,EAAK6F,GAAgB9F,GAAa,EAAK6F,IAE3C7F,GAAa,EAAK8F,GAClB7F,GAAW,EAAK4F,EAEzB,EAAKC,EAAe,EAAKD,EAAa,KAC7B7F,GAAa,EAAK8F,GAClB7F,EAAU,EAAK4F,EAExB,EAAKC,EAAe7F,EACXD,EAAY,EAAK8F,GACjB7F,GAAW,EAAK4F,IAEzB,EAAKA,EAAa7F,IA3BO,EAAA,MAlLnCnzB,EAAA,wBAAAg6B,I5E41DE,G4E7wDA3f,UAAAna,QAAA85B,GAAA,UAAA3f,Q5E6wDA,G4EvyDOna,iBAAP+5B,SAAwBhpB,UACfipB,GAAiCjpB,I5EsyD1C,G4E/yDO/Q,eAAPi6B,SAAsBlpB,EAAUgH,GAC9BiiB,GAAiCjpB,GAAYgH,GAyVjDiiB,IAAAA,GAAmC,GC5WjC1/B,SAAW,GAACmuB,EAAOyR,EAAqBC,EACpCC,GAAY,IAAA,EAAA,KAEd,KAAKxV,EAAS6D,EAGd,KAAK4R,EAAiBF,EAItB,KAAKG,EAAiB,GAGtB,KAAKC,EAAc,KAMnB,KAAKC,EAAcJ,GAJIK,aAUvB,KAAKC,EAAU,GAGf,KAAKzV,EAAgB,IAAI3D,GAGzB,KAAKqZ,EAAe,GAGpB,KAAKC,EAAiBV,EAGtB,KAAKW,EAAmB,IAAI/sB,GAG5B,KAAKgtB,EAkBPC,SAAAA,EAAkB9mB,GAChB,IAAM+mB,EAAc,IAAI1pB,YAWjB0pB,OARP,EAAK/V,EAAc9D,GACf6Z,EAAa,aAAc,WAsB/BC,IAAIC,gBA3BeC,EA2BMC,GACzB,EAAEz1B,YApBF,EAAKy1B,EAAOC,GAA8CL,GAE1D,EAAKpW,EAAO0W,IAAM,EAAKF,EAVJ,EAlBCL,CAAAA,KAAuB,KAAKF,GAGhD,KAAK3T,EAAa,IAAIrG,GAAqB,WAAM,OAmI7C,SAAA0a,GAGJ,IAAMjf,EAEKtL,EAEHwqB,EACAC,EAWN,EAAA,EAYSzqB,EA/BMoC,OAAA,EAAA,SAAA,GAAA,GAAA,GAAA,EAAA,EAAA,CAKNpC,IAAAA,KAFLsL,EAAU,GAEhB,EAA+Boe,EAc7B,IAZMc,EAPS,EAOAd,EAAQ1pB,GACjByqB,EAAaD,EAAE,GARN,EAWVd,EAAQ1pB,GAAewqB,EAAExkB,MAAM,EAAG,GAGnCykB,GACFnf,EAAQnf,KAAKs+B,EAAWxnB,EAAX,MAAmBynB,KAIlC,EAAAviC,EAAmBqiC,EAAExkB,MAAM,IAA3B,EAAA,EAAA,QAAA,EAAA,KAAA,EAAA,EAAA,OAAA,EAAA,MACO/C,EAAEpI,OX5JJ,IAAIzL,GxBmEDoM,EA4BF6G,EAgnBU6M,UmCnjBAvkB,IAWPqV,IAAAA,KAPX,EAASupB,GACPje,EAAQnf,KAzBO,EAyBGo9B,EAAYjhB,WAEhC,EAAS+gB,GACP/d,EAAQnf,KA5BO,EA4BGk9B,EAAe/gB,WAGnC,EAA+BqhB,EAC7Bre,EAAQnf,KAhCO,EAgCGw9B,EAAa3pB,GAAasI,WAI9C,OAAA,EAAA,EAAM1N,QAAQtC,IAAIgT,GAAlB,GApCiB,EAqCR2I,IArCQ,EAsCVA,EAAcnE,UAtCJ,EAuCVmE,EAAgB,MAGvB,EAASL,IA1CQ,EA4CVA,EAAO+W,gBAAgB,OA5Cb,EA6CV/W,EAAOuJ,OA7CG,EA8CVvJ,EAAS,MAGhB,EAAKkW,EAAe,KACpB,EAAKP,EAAc,KACnB,EAAKF,EAAiB,KACtB,EAAKC,EAAiB,GACtB,EAAKK,EAAe,GACpB,EAAKC,EAAiB,KAQtB,EAAKF,EAAU,GA9DE,EAAA,KAnIgC,CAAAa,KAGjD,KAAKH,EAAO,GAiDdQ,SAAwB,GAAC7R,GACvB,IAAMlH,EAAe+J,GACjB7C,EAAOhZ,SAAUgZ,EAAOnH,QACtBiZ,EP/GRC,SAAuB/R,GACrB,IAAMgS,EAAa,CAAChS,EAAOhZ,UAUpBgrB,OAPP,GAAmBxZ,QAAQ,SAACyZ,EAASC,GACnC,IAAMjhC,EAAQ+uB,EAAOkS,GACrB,GACEF,EAAW5+B,KAAK6+B,EAAU,KAAOhhC,EAAQ,OAItC,EAAW0K,KAAK,KOoGEw2B,CAAqCnS,GACvDoS,OAAA,GAAsCtZ,IACzCvR,YAAYJ,gBAAgB2qB,IAC5BhP,GAAmChK,EAAckH,EAAOvV,MAwM9D,SAAU,GAAV4nB,EAAWrrB,GACJ,EAAKwpB,IACR,EAAKA,EAAc,IAAIT,GAAsB,EAAKO,IDnOpD,uBCqO4BtpB,IAA5B,EAAKwpB,ED9NA9B,EAAU4D,GAHCrC,GCiOYjpB,KAO9BurB,SAAK,GAALA,GACE,OAAO,EAAKxB,GAA+C,SAAhC,EAAKA,EAAayB,WAS/CC,SAAW,GAAXA,EAAYxrB,GAEV,G5BhTI3F,Q4BgTA2F,EACK,IAAA,EAAA,EAAA,EDtHG+nB,OFpOZ,IAAA,EG4VO,GAAA,EAAA,KH5VS,GAAZxiB,EAAEtc,QAAuC,KAAxBsc,EAAEhZ,IAAI,GAAKgZ,EAAEhX,MAAM,GAC/B,KAGO,GAAZgX,EAAEtc,QAA4B,EAAbsc,EAAEhX,MAAM,GACpB,EAEFgX,EAAEtc,OAASsc,EAAEhX,MAAM,GAAK,KGkV/B,OAFuB,EAezBozB,SAAS,GAATA,EAAU3hB,GAER,M5B/TI3F,Q4B+TA2F,EACK,EAAKupB,ED7HFzB,EC+HL2D,GACHC,GAAAA,EAAkB1rB,IA2ExB,SAAY,GAAZ0rB,EAAa1rB,GACX,IACE,OAAO,EAAKspB,EAAetpB,GAAa2rB,SACxC,MAAO3hB,GAOP,OAPkB,MAyBhB4hB,SAAY,GAAZA,EAAa5rB,EAAalS,EAAMm0B,EAAWC,EAAS2J,GACxD,IAAMC,EAKEC,EASEC,EAOAC,EAtBiE7pB,OAAA,EAAA,SAAA,GAAA,OAAA,GAAA,EAAA,EAGvEpC,IAFE8rB,EAAc5xB,IAEWG,EAC7B,EAAA,EDtWE,SAAAuxB,EAAal+B,EAAQu0B,EAAWC,GAkBpC,IAAM7U,EAOA6e,EAEAC,EA3BuC/pB,OAAA,EAAA,SAAA,GAAA,OAAA,GAAA,EAAA,EAK7C,EAAA,EAAMxH,QAAQjG,UAAd,GAL6C,EAQnC8yB,GARmC,EAQlBC,EAIV,MAAbzF,GAAgC,MAAXC,GACvB,EAAKuF,EAAQ2E,UAAU9+B,GAA+BI,IACtD,EAAA,WAIF,EAAa,CACX2+B,YAnB2C,EAmBzBzE,EAClB0E,aAAcrK,EACdsK,WAAYrK,GAId,EAzB6C,EAyBxBuF,EAAQ+E,WACzBl/B,GAA+BI,GAAS2f,GAC5C,EAAqB6e,EAAQrhB,OAAO,SAAC4d,GACnC,OAAA,EAAWxG,WA5BgC,EA4Bd0F,GACzBc,EAAIxG,UA7BmC,EA6BlB4F,IAG3B,EAAKH,EAAWiB,OAAOwD,GAOvB,MAvC6C,EAuCpCpE,IAvCoC,EAwCtCA,EAAet+B,KAAK+E,IAAIyzB,EAxCc,EAwCE0F,IAW/C,EAAKG,EAAar+B,KAAKsB,IAAIm3B,EAnDkB,EAmDJ2F,QAnDI,EAAA,IAS3C,EAAA,WC6VM+D,CAJmE,EAI9DrC,EAAyBz7B,EAAMm0B,EAAWC,GAArD,GAJyE,EAK3DyH,EAAa3pB,GAEvB,EAAA,EvB9VRysB,SAAAA,EAAS3+B,GAGP,EAAKqR,GAAiB,EACtB,EAAKJ,EAAmB,IAAIjC,GAC5B,EAAKkC,EAAkB,GACvB,EAAKC,EAAY,GACjB,EAAKC,EAAY,GAEXwtB,IAAAA,EAAYp/B,GAA+BQ,GAe1C,OAdP,EAAK6Q,EAAexS,KAAKugC,GACzB,EAAK/tB,EAAeguB,QAOpB,EAASxtB,GACP,EAAKJ,EAAiBlE,OAAO,IAAIzL,GZjBzBoM,EAgBHoxB,EAwQaC,OYlQpB,EAAY9tB,EuBsUA0tB,CAP+D,EAO1D9C,EAAa3pB,GAAsBlS,GAA9C,KAsBC,GAAyB5C,EAAO0T,QA7BoC,EA8B/D2qB,GACR6B,GA/BuEA,EA+BvD,YAID,MAAbnJ,GAAgC,MAAXC,EAnCgD,EAoClE0H,EAAe1E,KAAKp3B,GApC8C,EAsClE87B,EAAerE,EAAUz3B,EAAM,SAACwR,GAC/BA,EAASrW,QAGXk/B,GA1CmE,EA0C9DoB,EACDjqB,EAAU2iB,EAAWC,EA3C0C,EAyC9DoH,EAAewC,EAAY3xB,IAAO6xB,oBAU7C,EAAA,EAAMc,GAnDmEA,EAoDrE9sB,EACA,WArDqE+sB,EAoPtEzD,EA/LoBtpB,GA+LQ4rB,aA/LK99B,KAFpC,KA7CMi+B,EACF,EAAA,EAGJ,EAAUxC,GACR6B,GAXuEA,EAWvD,YAGlB,EAAmB7rB,WACXysB,EAfiE,EAgB9D1C,EAAetpB,GAAagsB,gBAhBkC,EAiBlExC,EAAYuC,EAAexsB,SAAUysB,EAAiB9J,IAI7D,EAAmB5iB,UAAYysB,EAAezsB,SAASrW,SAC/CgjC,EAtBiE,EAuBlE3C,EAAewC,EAAY3xB,IAAO6xB,gBACvC7D,GAxBuE,EAwBlEoB,EACDwC,EAAezsB,SAAU2iB,EAAWC,EAAS+J,IAEnD,EAAA,EAAMa,GA3BmEA,EA4BrE9sB,EAAa,WA5BwD+sB,EAoPtEzD,EAxNiCtpB,GAwNL4rB,aAxNkBG,EAAej+B,QADhE,MAmCJk/B,SAA0B,GAA1BA,EAA2B1I,GAEzB,IAAM2I,EAAqBtL,GAAAA,E5B5etBxnB,U4B4e+C,GD/PtD6yB,SAAAA,EAA2B1I,EAAI4I,GAGvB3E,GAFN,EAAKP,EAA2B1D,EAE1BiE,EAAc,EAAKN,EAAmBtd,IAAI2Z,GAE9C,IADe,IACf,EAAAn8B,EAA8BogC,EAAYhZ,QAA1C,EAAA,EAAA,QAAA,EAAA,KAAA,EAAA,EAAA,QAEQqZ,EAAOL,EAAY5d,IAF3B,EAAA2d,OAGOzd,OAAO,SAACsiB,GAAM,OAAA,EAAEjL,SAAWgL,MAE9B,EAAKxF,EAAWiB,OAAOC,GCsP7B,CAAA,EAAKW,EAAuCjF,EAAI2I,GAgC5C,SAAK,GAALrhB,EAAM5L,GAAaoC,OAAA,EAAA,SAAA,GAEnBpC,OAAJ,GADoB9F,GACWG,EAFR,EAGXkvB,EAGV,EAAA,EANqB,EAMVA,EAAY/jB,OAAO,EAAGvX,EAAAA,GAAjC,GAFE,EAAA,SAKF,EAAA,EAAM6+B,GATeA,EAUjB9sB,EACA,WAAmCotB,IAAAA,EAXlBA,EAWuBA,EAAaA,SAmJ3D,GAAIlL,EAGFmL,GAjKqBC,EAWEttB,GAXFstB,EAsKlBhE,EA3JoBtpB,GA2JQwF,OA3JKyc,EA2JaC,KA7JjD,KA+QJ,SAAY,GAAZmL,EAAartB,GACX,IAAMqG,EAAY,EAAKqjB,EAAQ1pB,GAAa,GAE5C,IAKAqG,EAAUpD,EAAEtO,UACZ44B,GAAAA,EAAmBvtB,IAWrB8sB,SAAiB,GAAjBA,EAAkB9sB,EAAazR,GAYtB8X,OAXP4I,GAAA,EAAKiH,GAEC7P,EAAY,CAChB9X,MAAOA,EACP0U,EAAG,IAAInG,IAET,EAAK4sB,EAAQ1pB,GAAa7T,KAAKka,GAE/B,GAAI,EAAKqjB,EAAQ1pB,GAAa/W,QAC5BukC,GAAAA,EAAqBxtB,GAEvB,EAAiBiD,EAWbwqB,SAAyB,GAAzBA,EAA0BC,GAI9B,IAAMC,EAKN,EAAW3tB,EAEHqG,EA8DKrG,EAzEsBoC,OAAA,EAAA,SAAA,GAAA,OAAA,EAAA,GAAA,KAAA,EASxBpC,IAAAA,KARXiP,GADmC,EAC9BiH,GAGL,EAAmB,GAKnB,EAAA,GAAA,EAA+BoT,EACvBsE,EAAAA,GAAQ,IAAI9wB,GACZuJ,EAAY,CAChB9X,MAAOA,SAAAA,GAAAA,OAAA,WAAM,OAAA,EAAAq/B,GAAMj5B,WAAZpG,CAAAA,GACP0U,EAAG2qB,EAAAA,IAb4B,EAgB5BlE,EAAQ1pB,GAAa7T,KAAKka,GAC/BsnB,EAAWxhC,KAAKyhC,EAAAA,IAEwB,GAnBP,EAmBxBlE,EAAQ1pB,GAAa/W,QAC5Bod,EAAU9X,QAXd,EAAA,CAAA,GACQq/B,EAAAA,IAiBN,OADE,EAAA,EAAA,GACF,EAAA,EAAMhzB,QAAQtC,IAAIq1B,GAAlB,GA3BiC,KAAA,EA0B/B,EAAA,EAAA,GA1B+B,MAAA,KAAA,EAkDjC,MAtBOhjC,EAAAA,GA5B0B,KAAA,EA+DnC,IACE+iC,IACA,MAAO1jB,GACP,MAAU5a,IAAAA,GnC3zBFoM,EAgBHoxB,EAiPuBiB,KmC8jBxB7jB,GAPN,QAUE,IAAWhK,KAAX,EAA+BspB,EAC7BiE,GA1E+BA,EA0EZvtB,GA1EY,EAAA,MAoFrCutB,SAAa,GAAbA,EAAcvtB,GAEZ,EAAK0pB,EAAQ1pB,GAAa9W,QAC1B,GAAAskC,EAAqBxtB,GAQvBwtB,SAAe,GAAfA,EAAgBxtB,GAEd,IAAMlT,EAAO,EAAK48B,EAAQ1pB,GAAa,GACnClT,GAAAA,EACF,IACEA,EAAKyB,QACL,MAAOyb,GACe,sBAAlBA,EAAU/T,KACZnJ,EAAKmW,EAAEpI,OAAO,IAAIzL,GnCh2BdoM,EAgBHoxB,EAmQekB,KmCilBZ9tB,IAEJlT,EAAKmW,EAAEpI,OAAO,IAAIzL,GnCt2BdoM,EAgBHoxB,EAiPuBiB,KmCymBpB7jB,IAENujB,GAAAA,EAAmBvtB,KA5yBzBsI,EAAAA,GAAAA,WAAAA,QAAAA,WACE,OAAO,KAAK4N,EAAW5N,WA4FnBylB,EAAA7I,KAAAA,SAAK8I,EAAeC,GAAiB,IACnCnC,EAIN,EAAA,EAAA,EACQ/S,EAKFhZ,EAWImuB,EAtB+B,EAAA,KAAA9rB,OAAA,EAAA,SAAA,GAAA,GAAA,GAAA,EAAA,EAGzC,OAAA,EAFoBlI,GAEpB,EAAA,EAAM,EAAK2vB,EAAX,GAEA,IAAA,EAAA,GAAA,EAAA1hC,EAA0B6lC,EAAcze,QAAxC,EAAA,EAAA,QAAA,EAAA,KAAA,EAAA,CAAA,GAAWvP,EAAAA,IAAX,EAAA,EAAA,OAAWA,EAAAA,GAAX,EAAA,MACQ+Y,EAASiV,EAAcrjB,IAAI3K,EAAAA,IAK7BD,EAAW6b,GACX7C,EAAOhZ,SAAUgZ,EAAOnH,QACxB5R,EAAAA,IAAe8rB,EAAYzxB,EAC7B+wB,GAAAA,EAAgBrrB,KAEXkuB,GAAoB3tB,YAAYJ,gBAAgBH,KACjD8b,GAAmC9b,EAAUC,EAAAA,MAC/C,EAAK2pB,EAAa3pB,EAAAA,IAAe,IAAIqI,GACrCtI,EACII,GAAuCH,EAAAA,GAAaD,IAEpDmuB,EAAe,EAAKpE,EAAaqE,gBAAgBpuB,GACvD,EAAKkU,EAAcjE,EACfke,EAAc,QACd,SAAA,GAAA,OAAA,WAAM5Z,EAmgBSoV,EAngBK1pB,EAAAA,IAmgBgB,GAKlCiD,EAAEpI,OAAO,IAAIzL,GnC9rBboM,EAgBHoxB,EA2OwBwB,KmCrEjB9Z,EAugBIV,EAAOjpB,MAvgBX2pB,EAugBwBV,EAAOjpB,MAAMgE,KAAO,KAvgBlD,CAAA,IACJ,EAAKslB,EAAcjE,EACfke,EAAc,YACd,SAAA,GAAA,OAAA,WAAM,OAAA,GAAAb,EAAkBrtB,EAAAA,KAAxB,CAAA,IACJ,EAAKspB,EAAetpB,EAAAA,IAAekuB,EACnC,EAAKxE,EAAQ1pB,EAAAA,IAAe,IA9BS,EAAA,MA8H3C+tB,EAAA/L,GAAAA,WAIE,IAAMt2B,EAAO,CACX2iC,MAAOtM,GAA+B,KAAKnO,EAAO+X,UAClDhU,MAAOoK,GACH2J,GAAAA,K5BxXDtxB,U4ByXHqd,MAAOsK,GACH2J,GAAAA,K5B3XDvxB,U4B4XHuuB,KAAM,IAGJ,GAAA,KAAKa,EAAa,CACpB,IAAMh7B,EAAQ,KAAKg7B,EDnMTxB,ECoMJx7B,EAAM,KAAKg9B,ED5LPzB,EC8LV,MAAIv5B,GAAwB,MAAPhC,GACnBb,EAAKg9B,KAAKv8B,KAAK,CAACoC,MAAOA,EAAOhC,IAAKA,IAGvC,OArBgB,GAsIZwhC,EAAAvoB,OAAAA,SAAOxF,EAAaiiB,EAAWC,GAAS,IAAA,EAAA,KAAA9f,OAAA,EAAA,SAAA,GAMxCpC,OAAJ,GADoB9F,GACWG,EAC7B,EAAA,EAAM,EAAKkvB,EAAY/jB,OAAOyc,EAAWC,GAAzC,GAEA,EAAA,EAAM4K,GAAAA,EACF9sB,EACA,WAA2CkiB,GAAXD,EA2KpCoL,GA3KUC,EAAattB,GAAbstB,EAgLPhE,EAhLoBtpB,GAgLQwF,OAhLKyc,EAAWC,KAF/C,MAyCE6L,EAAApB,MAAAA,SAAM3sB,GAAa,IAAA,EAAA,KAAAoC,OAAA,EAAA,SAAA,GAInBpC,OAAJ,GADoB9F,GACWG,EAE7B,EAAA,SAEF,EAAA,EAAMyyB,GAAAA,EACF9sB,EACA,WAAMsuB,EAyKL1a,EAAO2a,aAAe,KAG3B,GA5KUD,EAAYtuB,KAFtB,MAwDI+tB,EAAAS,YAAAA,SAAYC,GAAQ,IAAA,EAAA,KAAArsB,OAAA,EAAA,SAAA,GACxB,OAAA,EAAA,EAAMqrB,GAAAA,EAA+B,WAG/BnC,GAAAA,KAKAmD,EACF,EAAK3E,EAAa0E,YAAYC,GAE9B,EAAK3E,EAAa0E,iBAXtB,MAyBIE,EAAAA,GAAAA,SAAYtB,GAAU,IAAA,EAAA,KAAAhrB,OAAA,EAAA,SAAA,GAM1B,OAAA,EAAA,EAAMqrB,GAAAA,EAA+B,WACnC,EAAK3D,EAAasD,SAAWA,IAD/B,MAUFuB,EAAAA,YAAAA,WACE,OAAA,KAAY7E,EAAasD,UAsV7B,IAAA/C,GAAgDn/B,EAAO++B,IAAI2E,gBC7+BzDC,SAA4B,GAACC,EAASC,GAWuBD,OAN3DA,EAAUE,GAAwBF,GAClC,EAAUE,GAAwBD,GA6VfhE,EAAOjiC,MAAM,KAnVP,IAHkCimC,EAsVjCjmC,MAAM,KAnViB,GAwBnDmmC,SAAiB,GAACC,EAAgBC,GAKhCD,EAAiBF,GAAwBE,GACzC,EAAgBF,GAAwBG,GAKlCC,IAAAA,EAC+BF,EA+SXpmC,MAAM,KA7S1BumC,EAC+BF,EA4SXrmC,MAAM,KA1SzBsmC,OAAA,EAAyB,IAAMC,EAAwB,IACpB,GAAnCD,EAAyBnmC,QACS,GAAlComC,EAAwBpmC,OAyBjCqmC,SAAkB,GAACC,EAASC,GAK1BD,EAAUP,GAAwBO,GAClC,EAAUP,GAAwBQ,GAK5BC,IAAAA,EAAqDF,EAoQjCzmC,MAAM,KAlQ1B4mC,EAAqDF,EAkQjC1mC,MAAM,KAhQG,OAAnC,GAAO2mC,EAAkBxmC,QACU,GAA5BymC,EAAkBzmC,QAClBwmC,EAAkB,IAAMC,EAAkB,GAkBnDC,SAAgB,GAACC,GAGf,IAAM7E,EAAa6E,EAAO9mC,MAAM,KAiBzB,OAbH+mC,EAAW9E,EAAW,IAAM,GAC5BzI,EAASyI,EAAW,IAAM,GAI9B,EAAW8E,EAAS5vB,cACpB,EAAW6vB,GAAsBnlB,IAAIklB,IAAaA,GAKlDvN,EAASA,EAAOyN,eAGTF,EAAW,IAAMvN,EACjBuN,EAgCTG,SAAkB,GAAC3rB,EAAQ4rB,GAOrBA,OAJJ5rB,EAAS2qB,GAAwB3qB,IACjC,EAAY2qB,GAAwBiB,KAGnB5rB,EACR,EAIL6rB,GAAyBD,EAAW5rB,GAC/B,EAIL8rB,GAA0BF,EAAW5rB,GAChC,EAIL6rB,GAAyB7rB,EAAQ4rB,GAC5B,EAIF,EA4DTG,SAA0B,GAAC5Y,GAUzB,OAAA,EAAYqY,SACHb,GAAwBxX,EAAQqY,UAGrCrY,EAAQG,OAASH,EAAQG,MAAMkY,SAC1Bb,GAAwBxX,EAAQG,MAAMkY,UAG3CrY,EAAQC,OAASD,EAAQC,MAAMoY,SAC1Bb,GAAwBxX,EAAQC,MAAMoY,UAIxC,MAWTQ,SAAwB,GAAChsB,EAAQisB,GAO/B,IAHA,IAAMC,EAAavB,GAAwB3qB,GAErCmsB,EAAkB,IAAIvlC,IAC5B,EAAA9C,EAAqBmoC,GAArB,EAAA,EAAA,QAAA,EAAA,KAAA,EAAA,EAAA,OACEE,EAAgBr5B,IAAI63B,GADtB,EAAAyB,QAOA,IAAA,GAAA,EAAAtoC,EAAqBqoC,IAArB,QAAA,EAAA,KAAA,EAAA,EAAA,OACE,IADSC,EAAX,EAAA,QACgBF,EACZ,OAOJ,EAAA,IAAA,GAAA,EAAApoC,EAAqBqoC,IAArB,QAAA,EAAA,KAAA,EAAA,EAAA,OACE,GAAIN,GADKO,EAAX,EAAA,MACuCF,GACnC,OAOJ,EAAA,IAAA,GAAA,EAAApoC,EAAqBqoC,IAArB,QAAA,EAAA,KAAA,EAAA,EAAA,OACE,GAAIL,GADKM,EAAX,EAAA,MACwCF,GACpC,OAOJ,EAAA,IAAA,GAAA,EAAApoC,EAAqBqoC,IAArB,QAAA,EAAA,KAAA,EAAA,EAAA,OACE,GAAIN,GAAyBK,EADpBE,EAAX,EAAA,OAEI,OAKJ,EAAO,OAhDqC,KAmFhD,IAAAC,GAAmC,IAAIrf,IAAI,CACzC,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MACpE,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MACpE,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MACpE,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MACpE,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MACpE,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MACpE,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MACpE,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MACpE,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MACpE,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MACpE,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MACpE,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MACpE,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MACpE,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MACpE,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MACpE,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MACpE,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MACpE,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MACpE,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MACpE,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MACpE,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MACpE,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MACpE,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MACpE,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MACpE,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MACpE,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MACpE,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MACpE,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MACpE,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MACpE,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MACpE,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MACpE,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MACpE,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MACpE,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MACpE,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MACpE,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MACpE,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MACpE,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MACpE,CAAC,MAAO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","file":"shaka-player.compiled.688e139c.js","sourceRoot":"..","sourcesContent":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,"/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.offline.OfflineManifestParser');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.media.ManifestParser');\ngoog.require('shaka.offline.ManifestConverter');\ngoog.require('shaka.offline.OfflineUri');\ngoog.require('shaka.offline.StorageMuxer');\ngoog.require('shaka.util.Error');\n\n\n/**\n * @summary Creates a new offline manifest parser.\n * @implements {shaka.extern.ManifestParser}\n */\nshaka.offline.OfflineManifestParser = class {\n  constructor() {\n    /** @private {shaka.offline.OfflineUri} */\n    this.uri_ = null;\n  }\n\n  /** @override */\n  configure(config) {\n    // No-op\n  }\n\n  /** @override */\n  async start(uriString, playerInterface) {\n    /** @type {shaka.offline.OfflineUri} */\n    const uri = shaka.offline.OfflineUri.parse(uriString);\n    this.uri_ = uri;\n\n    if (uri == null || !uri.isManifest()) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.NETWORK,\n          shaka.util.Error.Code.MALFORMED_OFFLINE_URI,\n          uriString);\n    }\n\n    /** @type {!shaka.offline.StorageMuxer} */\n    const muxer = new shaka.offline.StorageMuxer();\n\n    try {\n      await muxer.init();\n\n      const cell = await muxer.getCell(uri.mechanism(), uri.cell());\n\n      const manifests = await cell.getManifests([uri.key()]);\n      const manifest = manifests[0];\n\n      const converter = new shaka.offline.ManifestConverter(\n          uri.mechanism(), uri.cell());\n\n      const finalManifest = converter.fromManifestDB(manifest);\n      playerInterface.makeTextStreamsForClosedCaptions(finalManifest);\n      return finalManifest;\n    } finally {\n      await muxer.destroy();\n    }\n  }\n\n  /** @override */\n  stop() {\n    return Promise.resolve();\n  }\n\n  /** @override */\n  update() {\n    // No-op\n  }\n\n  /** @override */\n  async onExpirationUpdated(sessionId, expiration) {\n    goog.asserts.assert(\n        this.uri_,\n        'Should not get update event before start has been called');\n\n    /** @type {!shaka.offline.OfflineUri} */\n    const uri = this.uri_;\n\n    /** @type {!shaka.offline.StorageMuxer} */\n    const muxer = new shaka.offline.StorageMuxer();\n\n    try {\n      await muxer.init();\n\n      const cell = await muxer.getCell(uri.mechanism(), uri.cell());\n\n      const manifests = await cell.getManifests([uri.key()]);\n      const manifest = manifests[0];\n\n      const foundSession = manifest.sessionIds.includes(sessionId);\n      const newExpiration = manifest.expiration == undefined ||\n                        manifest.expiration > expiration;\n\n      if (foundSession && newExpiration) {\n        shaka.log.debug('Updating expiration for stored content');\n        await cell.updateManifestExpiration(uri.key(), expiration);\n      }\n    } catch (e) {\n      // Ignore errors with update.\n      shaka.log.error('There was an error updating', uri, e);\n    } finally {\n      await muxer.destroy();\n    }\n  }\n};\n\n\nshaka.media.ManifestParser.registerParserByMime(\n    'application/x-offline-manifest',\n    () => new shaka.offline.OfflineManifestParser());\n",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,"/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.abr.Ewma');\n\ngoog.require('goog.asserts');\n\n\n/**\n * @summary\n * This class computes an exponentionally-weighted moving average.\n */\nshaka.abr.Ewma = class {\n  /**\n   * @param {number} halfLife The quantity of prior samples (by weight) used\n   *   when creating a new estimate.  Those prior samples make up half of the\n   *   new estimate.\n   */\n  constructor(halfLife) {\n    goog.asserts.assert(halfLife > 0, 'expected halfLife to be positive');\n\n    /**\n     * Larger values of alpha expire historical data more slowly.\n     * @private {number}\n     */\n    this.alpha_ = Math.exp(Math.log(0.5) / halfLife);\n\n    /** @private {number} */\n    this.estimate_ = 0;\n\n    /** @private {number} */\n    this.totalWeight_ = 0;\n  }\n\n  /**\n   * Takes a sample.\n   *\n   * @param {number} weight\n   * @param {number} value\n   */\n  sample(weight, value) {\n    const adjAlpha = Math.pow(this.alpha_, weight);\n    const newEstimate = value * (1 - adjAlpha) + adjAlpha * this.estimate_;\n\n    if (!isNaN(newEstimate)) {\n      this.estimate_ = newEstimate;\n      this.totalWeight_ += weight;\n    }\n  }\n\n\n  /**\n   * @return {number}\n   */\n  getEstimate() {\n    const zeroFactor = 1 - Math.pow(this.alpha_, this.totalWeight_);\n    return this.estimate_ / zeroFactor;\n  }\n};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.abr.EwmaBandwidthEstimator');\n\ngoog.require('shaka.abr.Ewma');\n\n\n/**\n * @summary\n * This class tracks bandwidth samples and estimates available bandwidth.\n * Based on the minimum of two exponentially-weighted moving averages with\n * different half-lives.\n *\n */\nshaka.abr.EwmaBandwidthEstimator = class {\n  constructor() {\n    /**\n     * A fast-moving average.\n     * Half of the estimate is based on the last 2 seconds of sample history.\n     * @private {!shaka.abr.Ewma}\n     */\n    this.fast_ = new shaka.abr.Ewma(2);\n\n    /**\n     * A slow-moving average.\n     * Half of the estimate is based on the last 5 seconds of sample history.\n     * @private {!shaka.abr.Ewma}\n     */\n    this.slow_ = new shaka.abr.Ewma(5);\n\n    /**\n     * Number of bytes sampled.\n     * @private {number}\n     */\n    this.bytesSampled_ = 0;\n\n\n    /**\n     * Minimum number of bytes sampled before we trust the estimate.  If we have\n     * not sampled much data, our estimate may not be accurate enough to trust.\n     * If bytesSampled_ is less than minTotalBytes_, we use defaultEstimate_.\n     * This specific value is based on experimentation.\n     *\n     * @private {number}\n     * @const\n     */\n    this.minTotalBytes_ = 128e3;  // 128kB\n\n    /**\n     * Minimum number of bytes, under which samples are discarded.  Our models\n     * do not include latency information, so connection startup time (time to\n     * first byte) is considered part of the download time.  Because of this, we\n     * should ignore very small downloads which would cause our estimate to be\n     * too low.\n     * This specific value is based on experimentation.\n     *\n     * @private {number}\n     * @const\n     */\n    this.minBytes_ = 16e3;  // 16kB\n  }\n\n  /**\n   * Takes a bandwidth sample.\n   *\n   * @param {number} durationMs The amount of time, in milliseconds, for a\n   *   particular request.\n   * @param {number} numBytes The total number of bytes transferred in that\n   *   request.\n   */\n  sample(\n      durationMs, numBytes) {\n    if (numBytes < this.minBytes_) {\n      return;\n    }\n\n    const bandwidth = 8000 * numBytes / durationMs;\n    const weight = durationMs / 1000;\n\n    this.bytesSampled_ += numBytes;\n    this.fast_.sample(weight, bandwidth);\n    this.slow_.sample(weight, bandwidth);\n  }\n\n\n  /**\n   * Gets the current bandwidth estimate.\n   *\n   * @param {number} defaultEstimate\n   * @return {number} The bandwidth estimate in bits per second.\n   */\n  getBandwidthEstimate(defaultEstimate) {\n    if (this.bytesSampled_ < this.minTotalBytes_) {\n      return defaultEstimate;\n    }\n\n    // Take the minimum of these two estimates.  This should have the effect\n    // of adapting down quickly, but up more slowly.\n    return Math.min(this.fast_.getEstimate(), this.slow_.getEstimate());\n  }\n\n\n  /**\n   * @return {boolean} True if there is enough data to produce a meaningful\n   *   estimate.\n   */\n  hasGoodEstimate() {\n    return this.bytesSampled_ >= this.minTotalBytes_;\n  }\n};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.log');\n\ngoog.require('goog.asserts');\n\n/**\n * @summary\n * A console logging framework which is compiled out for deployment.  This is\n * only available when using the uncompiled version.\n * @exportDoc\n */\nshaka.log = class {\n  /**\n   * This always logs to the console, even in Release mode.  This should only be\n   * used for deprecation messages and things the app should never ignore.\n   *\n   * @param {...*} args\n   */\n  static alwaysError(...args) {}\n\n  /**\n   * This always logs to the console, even in Release mode.  This should only be\n   * used for deprecation messages and things the app should never ignore.\n   *\n   * @param {...*} args\n   */\n  static alwaysWarn(...args) {}\n\n  /**\n   * This always logs to the console, even in Release mode.  This should only be\n   * used for deprecation messages and things the app should never ignore.\n   *\n   * @param {string} id\n   * @param {...*} args\n   */\n  static warnOnce(id, ...args) {\n    if (shaka.log.oneTimeWarningIssued_.has(id)) {\n      return;\n    }\n\n    shaka.log.oneTimeWarningIssued_.add(id);\n    shaka.log.alwaysWarn(...args);\n  }\n\n  /**\n   * This log is for when an error occurs.  This should always be accompanied\n   * with an error event, thrown exception, or rejected Promise.  Logs are\n   * disabled in Release mode, so there should be other methods of detecting the\n   * error.\n   *\n   * @param {...*} args\n   */\n  static error(...args) {}\n\n  /**\n   * This log is for possible errors or things that may be surprising to a user.\n   * For example, if we work around unusual or bad content, we should warn that\n   * they should fix their content.  Deprecation messages and messages the app\n   * shouldn't ignore should use alwaysWarn instead.\n   *\n   * @param {...*} args\n   */\n  static warning(...args) {}\n\n  /**\n   * This log is for messages to the user about what is happening.  For example,\n   * when we update a manifest or install a polyfill.\n   *\n   * @param {...*} args\n   */\n  static info(...args) {}\n\n  /**\n   * This log is to aid *users* in debugging their content.  This should be for\n   * logs about the content and what we do with it.  For example, when we change\n   * streams or what we are choosing.\n   *\n   * @param {...*} args\n   */\n  static debug(...args) {}\n\n  /**\n   * This log is for debugging Shaka Player itself.  This may be logs about\n   * internal states or events.  This may also be for more verbose logs about\n   * content, such as for segment appends.\n   *\n   * @param {...*} args\n   */\n  static v1(...args) {}\n\n  /**\n   * This log is for tracing and debugging Shaka Player.  These logs will happen\n   * a lot, for example, logging every segment append or every update check.\n   * These are mostly used for tracking which calls happen through the code.\n   *\n   * @param {...*} args\n   */\n  static v2(...args) {}\n};\n\n\n/**\n * Log levels.\n * @enum {number}\n * @exportDoc\n */\nshaka.log.Level = {\n  NONE: 0,\n  ERROR: 1,\n  WARNING: 2,\n  INFO: 3,\n  DEBUG: 4,\n  V1: 5,\n  V2: 6,\n};\n\n\n/**\n * @define {number} the maximum log level.\n */\nshaka.log.MAX_LOG_LEVEL = 3;\n\n\n/**\n * A Set to indicate which one-time warnings have been issued.\n *\n * @private {!Set.<string>}\n */\nshaka.log.oneTimeWarningIssued_ = new Set();\n\n\n// IE8 has no console unless it is opened in advance.\n// IE9 console methods are not Functions and have no bind.\nif (window.console && window.console.log.bind) {\n  /** @private {!Object.<shaka.log.Level, function(...*)>} */\n  shaka.log.logMap_ = {\n    /* eslint-disable no-restricted-syntax */\n    [shaka.log.Level.ERROR]: console.error.bind(console),\n    [shaka.log.Level.WARNING]: console.warn.bind(console),\n    [shaka.log.Level.INFO]: console.info.bind(console),\n    [shaka.log.Level.DEBUG]: console.log.bind(console),\n    [shaka.log.Level.V1]: console.debug.bind(console),\n    [shaka.log.Level.V2]: console.debug.bind(console),\n    /* eslint-enable no-restricted-syntax */\n  };\n\n  shaka.log.alwaysWarn = shaka.log.logMap_[shaka.log.Level.WARNING];\n  shaka.log.alwaysError = shaka.log.logMap_[shaka.log.Level.ERROR];\n\n  if (goog.DEBUG) {\n    // Since we don't want to export shaka.log in production builds, we don't\n    // use the @export annotation.  But the module wrapper (used in debug builds\n    // since v2.5.11) hides anything non-exported.  This is a debug-only,\n    // API-based export to make sure logging is available in debug builds.\n    goog.exportSymbol('shaka.log', shaka.log);\n\n    /** @type {number} */\n    shaka.log.currentLevel;\n\n    /**\n     * Change the log level.  Useful for debugging in uncompiled mode.\n     *\n     * @param {number} level\n     * @exportDoc\n     */\n    shaka.log.setLevel = (level) => {\n      const getLog = (curLevel) => {\n        if (curLevel <= level) {\n          goog.asserts.assert(\n              shaka.log.logMap_[curLevel], 'Unexpected log level');\n          return shaka.log.logMap_[curLevel];\n        } else {\n          return () => {};\n        }\n      };\n\n      shaka.log.currentLevel = level;\n      shaka.log.error = getLog(shaka.log.Level.ERROR);\n      shaka.log.warning = getLog(shaka.log.Level.WARNING);\n      shaka.log.info = getLog(shaka.log.Level.INFO);\n      shaka.log.debug = getLog(shaka.log.Level.DEBUG);\n      shaka.log.v1 = getLog(shaka.log.Level.V1);\n      shaka.log.v2 = getLog(shaka.log.Level.V2);\n    };\n\n    shaka.log.setLevel(shaka.log.MAX_LOG_LEVEL);\n  } else {\n    if (shaka.log.MAX_LOG_LEVEL >= shaka.log.Level.ERROR) {\n      shaka.log.error = shaka.log.logMap_[shaka.log.Level.ERROR];\n    }\n    if (shaka.log.MAX_LOG_LEVEL >= shaka.log.Level.WARNING) {\n      shaka.log.warning = shaka.log.logMap_[shaka.log.Level.WARNING];\n    }\n    if (shaka.log.MAX_LOG_LEVEL >= shaka.log.Level.INFO) {\n      shaka.log.info = shaka.log.logMap_[shaka.log.Level.INFO];\n    }\n    if (shaka.log.MAX_LOG_LEVEL >= shaka.log.Level.DEBUG) {\n      shaka.log.debug = shaka.log.logMap_[shaka.log.Level.DEBUG];\n    }\n    if (shaka.log.MAX_LOG_LEVEL >= shaka.log.Level.V1) {\n      shaka.log.v1 = shaka.log.logMap_[shaka.log.Level.V1];\n    }\n    if (shaka.log.MAX_LOG_LEVEL >= shaka.log.Level.V2) {\n      shaka.log.v2 = shaka.log.logMap_[shaka.log.Level.V2];\n    }\n  }\n}\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.util.Iterables');\n\n\n/**\n * Recreations of Array-like functions so that they work on any iterable\n * type.\n * @final\n */\nshaka.util.Iterables = class {\n  /**\n   * @param {!Iterable.<FROM>} iterable\n   * @param {function(FROM):TO} mapping\n   * @return {!Iterable.<TO>}\n   * @template FROM,TO\n   */\n  static map(iterable, mapping) {\n    const array = [];\n    for (const x of iterable) {\n      array.push(mapping(x));\n    }\n    return array;\n  }\n\n  /**\n   * @param {!Iterable.<T>} iterable\n   * @param {function(T):boolean} test\n   * @return {boolean}\n   * @template T\n   */\n  static every(iterable, test) {\n    for (const x of iterable) {\n      if (!test(x)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * @param {!Iterable.<T>} iterable\n   * @param {function(T):boolean} test\n   * @return {boolean}\n   * @template T\n   */\n  static some(iterable, test) {\n    for (const x of iterable) {\n      if (test(x)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Iterate over an iterable object and return only the items that |filter|\n   * returns true for.\n   *\n   * @param {!Iterable.<T>} iterable\n   * @param {function(T):boolean} filter\n   * @return {!Array.<T>}\n   * @template T\n   */\n  static filter(iterable, filter) {\n    const out = [];\n    for (const x of iterable) {\n      if (filter(x)) {\n        out.push(x);\n      }\n    }\n    return out;\n  }\n\n  /**\n   * Returns an iterable that contains numbers in the range [0, end).\n   *\n   * @param {number} end The exclusive end of the list.\n   * @return {!Iterable.<number>}\n   */\n  static* range(end) {\n    for (let i = 0; i < end; i++) {\n      yield i;\n    }\n  }\n\n  /**\n   * Iterates over an iterable object and includes additional info about each\n   * item:\n   * - The zero-based index of the element.\n   * - The next item in the list, if it exists.\n   * - The previous item in the list, if it exists.\n   *\n   * @param {!Iterable.<T>} iterable\n   * @return {!Iterable.<\n   *     {i: number, item: T, prev: (T|undefined), next: (T|undefined)}>}\n   * @template T\n   */\n  static* enumerate(iterable) {\n    // Since we want the \"next\" item, we need to skip the first item and return\n    // elements one in the past.  So as we iterate, we are getting the \"next\"\n    // element and yielding the one from the previous iteration.\n    let i = -1;\n    let prev = undefined;\n    let item = undefined;\n    for (const next of iterable) {\n      if (i >= 0) {\n        yield {i, item, prev, next};\n      }\n      i++;\n      prev = item;\n      item = next;\n    }\n    if (i != -1) {\n      // If it's still -1, there were no items.  Otherwise we need to yield\n      // the last item.\n      yield {i, prev, item, next: undefined};\n    }\n  }\n};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.util.BufferUtils');\n\ngoog.require('shaka.util.Iterables');\n\n\n/**\n * @summary A set of BufferSource utility functions.\n * @export\n */\nshaka.util.BufferUtils = class {\n  /**\n   * Compare two buffers for equality.  For buffers of different types, this\n   * compares the underlying buffers as binary data.\n   *\n   * @param {?BufferSource} arr1\n   * @param {?BufferSource} arr2\n   * @return {boolean}\n   * @export\n   */\n  static equal(arr1, arr2) {\n    const BufferUtils = shaka.util.BufferUtils;\n    if (!arr1 && !arr2) {\n      return true;\n    }\n    if (!arr1 || !arr2) {\n      return false;\n    }\n    if (arr1.byteLength != arr2.byteLength) {\n      return false;\n    }\n\n    // Quickly check if these are views of the same buffer.  An ArrayBuffer can\n    // be passed but doesn't have a byteOffset field, so default to 0.\n    if (BufferUtils.unsafeGetArrayBuffer_(arr1) ==\n            BufferUtils.unsafeGetArrayBuffer_(arr2) &&\n        (arr1.byteOffset || 0) == (arr2.byteOffset || 0)) {\n      return true;\n    }\n\n    const uint8A = shaka.util.BufferUtils.toUint8(arr1);\n    const uint8B = shaka.util.BufferUtils.toUint8(arr2);\n    for (const i of shaka.util.Iterables.range(arr1.byteLength)) {\n      if (uint8A[i] != uint8B[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Gets the underlying ArrayBuffer of the given view.  The caller needs to\n   * ensure it uses the \"byteOffset\" and \"byteLength\" fields of the view to\n   * only use the same \"view\" of the data.\n   *\n   * @param {BufferSource} view\n   * @return {!ArrayBuffer}\n   * @private\n   */\n  static unsafeGetArrayBuffer_(view) {\n    if (view instanceof ArrayBuffer) {\n      return view;\n    } else {\n      return view.buffer;\n    }\n  }\n\n  /**\n   * Gets an ArrayBuffer that contains the data from the given TypedArray.  Note\n   * this will allocate a new ArrayBuffer if the object is a partial view of\n   * the data.\n   *\n   * @param {!BufferSource} view\n   * @return {!ArrayBuffer}\n   * @export\n   */\n  static toArrayBuffer(view) {\n    if (view instanceof ArrayBuffer) {\n      return view;\n    } else {\n      if (view.byteOffset == 0 && view.byteLength == view.buffer.byteLength) {\n        // This is a TypedArray over the whole buffer.\n        return view.buffer;\n      }\n      // This is a \"view\" on the buffer.  Create a new buffer that only contains\n      // the data.  Note that since this isn't an ArrayBuffer, the \"new\" call\n      // will allocate a new buffer to hold the copy.\n      return new Uint8Array(view).buffer;\n    }\n  }\n\n  /**\n   * Creates a new Uint8Array view on the same buffer.  This clamps the values\n   * to be within the same view (i.e. you can't use this to move past the end\n   * of the view, even if the underlying buffer is larger).  However, you can\n   * pass a negative offset to access the data before the view.\n   *\n   * @param {BufferSource} data\n   * @param {number=} offset The offset from the beginning of this data's view\n   *   to start the new view at.\n   * @param {number=} length The byte length of the new view.\n   * @return {!Uint8Array}\n   * @export\n   */\n  static toUint8(data, offset = 0, length = Infinity) {\n    return shaka.util.BufferUtils.view_(data, offset, length, Uint8Array);\n  }\n\n  /**\n   * Creates a DataView over the given buffer.\n   *\n   * @see toUint8\n   * @param {BufferSource} buffer\n   * @param {number=} offset\n   * @param {number=} length\n   * @return {!DataView}\n   * @export\n   */\n  static toDataView(buffer, offset = 0, length = Infinity) {\n    return shaka.util.BufferUtils.view_(buffer, offset, length, DataView);\n  }\n\n  /**\n   * @param {BufferSource} data\n   * @param {number} offset\n   * @param {number} length\n   * @param {function(new:T, ArrayBuffer, number, number)} Type\n   * @return {!T}\n   * @template T\n   * @private\n   */\n  static view_(data, offset, length, Type) {\n    const buffer = shaka.util.BufferUtils.unsafeGetArrayBuffer_(data);\n    // Absolute end of the |data| view within |buffer|.\n    const dataEnd = (data.byteOffset || 0) + data.byteLength;\n    // Absolute start of the result within |buffer|.\n    const rawStart = (data.byteOffset || 0) + offset;\n    const start = Math.max(0, Math.min(rawStart, dataEnd));\n    // Absolute end of the result within |buffer|.\n    const end = Math.min(start + Math.max(length, 0), dataEnd);\n    return new Type(buffer, start, end - start);\n  }\n};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.util.Error');\n\n\n/**\n * @summary\n * Describes an error that happened.\n *\n * @description\n * This uses numerical codes to describe\n * which error happened.\n *\n * Some error are caused by errors from the browser.  In these cases, the error\n * object is provided as part of the <code>data</code> field.  System codes come\n * from the browser and may or may not be documented.  Here are some places\n * where the errors may be documented:\n * <ul>\n *   <li><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/MediaError\">MediaError</a>\n *   <li><a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Status\">HTTP Codes</a>\n *   <li>\n *     <a href=\"https://docs.microsoft.com/en-us/windows/win32/wmdm/error-codes\">PlayReady errors</a>\n *     or\n *     <a href=\"https://github.com/tpn/winsdk-10/blob/master/Include/10.0.16299.0/winrt/Windows.Media.Protection.PlayReadyErrors.h\">more PlayReady errors</a>\n * </ul>\n *\n * @export\n * @implements {shaka.extern.Error}\n * @extends {Error}\n */\nshaka.util.Error = class {\n  /**\n   * @param {shaka.util.Error.Severity} severity\n   * @param {shaka.util.Error.Category} category\n   * @param {shaka.util.Error.Code} code\n   * @param {...*} varArgs\n   */\n  constructor(severity, category, code, ...varArgs) {\n    /**\n     * @override\n     * @exportInterface\n     */\n    this.severity = severity;\n    /**\n     * @override\n     * @exportInterface\n     */\n    this.category = category;\n    /**\n     * @override\n     * @exportInterface\n     */\n    this.code = code;\n    /**\n     * @override\n     * @exportInterface\n     */\n    this.data = varArgs;\n    /**\n     * @override\n     * @exportInterface\n     */\n    this.handled = false;\n\n    // This improves the formatting of Errors in failure messages in the tests.\n    if (goog.DEBUG) {\n      let categoryName = 'UNKNOWN';\n      let codeName = 'UNKNOWN';\n\n      for (const k in shaka.util.Error.Category) {\n        if (shaka.util.Error.Category[k] == this.category) {\n          categoryName = k;\n        }\n      }\n      for (const k in shaka.util.Error.Code) {\n        if (shaka.util.Error.Code[k] == this.code) {\n          codeName = k;\n        }\n      }\n\n      /**\n       * A human-readable version of the category and code.\n       * <i>(Only available in uncompiled mode.)</i>\n       *\n       * @const {string}\n       * @exportDoc\n       */\n      this.message = 'Shaka Error ' + categoryName + '.' + codeName +\n                     ' (' + this.data.toString() + ')';\n\n      if (shaka.util.Error.createStack) {\n        try {\n          throw new Error(this.message);\n        } catch (e) {\n          /**\n           * A stack-trace showing where the error occurred.\n           * <i>(Only available in uncompiled mode.)</i>\n           *\n           * @const {string}\n           * @exportDoc\n           */\n          this.stack = e.stack;\n        }\n      }\n    }\n  }\n\n\n  /**\n   * @return {string}\n   * @override\n   */\n  toString() {\n    return 'shaka.util.Error ' + JSON.stringify(this, null, '  ');\n  }\n};\n\n\nif (goog.DEBUG) {\n  /**\n   * If true, create a stack trace in Error objects.\n   *\n   * Only available in uncompiled mode, and disabled in tests to avoid issues\n   * with karma-jasmine.  See comments in test/test/boot.js for details.\n   *\n   * @type {boolean}\n   */\n  shaka.util.Error.createStack = true;\n}\n\n\n/**\n * @enum {number}\n * @export\n */\nshaka.util.Error.Severity = {\n  /**\n   * An error occurred, but the Player is attempting to recover from the error.\n   *\n   * If the Player cannot ultimately recover, it still may not throw a CRITICAL\n   * error.  For example, retrying for a media segment will never result in\n   * a CRITICAL error (the Player will just retry forever).\n   */\n  'RECOVERABLE': 1,\n\n  /**\n   * A critical error that the library cannot recover from.  These usually cause\n   * the Player to stop loading or updating.  A new manifest must be loaded\n   * to reset the library.\n   */\n  'CRITICAL': 2,\n};\n\n\n/**\n * @enum {number}\n * @export\n */\nshaka.util.Error.Category = {\n  /** Errors from the network stack. */\n  'NETWORK': 1,\n\n  /** Errors parsing text streams. */\n  'TEXT': 2,\n\n  /** Errors parsing or processing audio or video streams. */\n  'MEDIA': 3,\n\n  /** Errors parsing the Manifest. */\n  'MANIFEST': 4,\n\n  /** Errors related to streaming. */\n  'STREAMING': 5,\n\n  /** Errors related to DRM. */\n  'DRM': 6,\n\n  /** Miscellaneous errors from the player. */\n  'PLAYER': 7,\n\n  /** Errors related to cast. */\n  'CAST': 8,\n\n  /** Errors in the database storage (offline). */\n  'STORAGE': 9,\n\n  /** Errors related to ad insertion. */\n  'ADS': 10,\n};\n\n\n/**\n * @enum {number}\n * @export\n */\nshaka.util.Error.Code = {\n  /**\n   * A network request was made using an unsupported URI scheme.\n   * <br> error.data[0] is the URI.\n   */\n  'UNSUPPORTED_SCHEME': 1000,\n\n  /**\n   * An HTTP network request returned an HTTP status that indicated a failure.\n   * <br> error.data[0] is the URI.\n   * <br> error.data[1] is the status code.\n   * <br> error.data[2] is the response text, or null if the response could not\n   *   be interpretted as text.\n   * <br> error.data[3] is the map of response headers.\n   * <br> error.data[4] is the NetworkingEngine.RequestType of the request,\n   *   if one was provided.\n   */\n  'BAD_HTTP_STATUS': 1001,\n\n  /**\n   * An HTTP network request failed with an error, but not from the server.\n   * <br> error.data[0] is the URI.\n   * <br> error.data[1] is the original error.\n   * <br> error.data[2] is the NetworkingEngine.RequestType of the request.\n   */\n  'HTTP_ERROR': 1002,\n\n  /**\n   * A network request timed out.\n   * <br> error.data[0] is the URI.\n   * <br> error.data[1] is the NetworkingEngine.RequestType of the request,\n   *   if one was provided.\n   */\n  'TIMEOUT': 1003,\n\n  /**\n   * A network request was made with a malformed data URI.\n   * <br> error.data[0] is the URI.\n   */\n  'MALFORMED_DATA_URI': 1004,\n\n  // RETIRED: 'UNKNOWN_DATA_URI_ENCODING': 1005,\n\n  /**\n   * A request filter threw an error.\n   * <br> error.data[0] is the original error.\n   */\n  'REQUEST_FILTER_ERROR': 1006,\n\n  /**\n   * A response filter threw an error.\n   * <br> error.data[0] is the original error.\n   */\n  'RESPONSE_FILTER_ERROR': 1007,\n\n  /**\n   * A testing network request was made with a malformed URI.\n   * This error is only used by unit and integration tests.\n   */\n  'MALFORMED_TEST_URI': 1008,\n\n  /**\n   * An unexpected network request was made to the FakeNetworkingEngine.\n   * This error is only used by unit and integration tests.\n   */\n  'UNEXPECTED_TEST_REQUEST': 1009,\n\n  /**\n   * The number of retry attempts have run out.\n   * This is an internal error and shouldn't be propagated.\n   */\n  'ATTEMPTS_EXHAUSTED': 1010,\n\n\n  /** The text parser failed to parse a text stream due to an invalid header. */\n  'INVALID_TEXT_HEADER': 2000,\n\n  /** The text parser failed to parse a text stream due to an invalid cue. */\n  'INVALID_TEXT_CUE': 2001,\n\n  // RETIRED: 'INVALID_TEXT_SETTINGS': 2002,\n\n  /**\n   * Was unable to detect the encoding of the response text.  Suggest adding\n   * byte-order-markings to the response data.\n   */\n  'UNABLE_TO_DETECT_ENCODING': 2003,\n\n  /** The response data contains invalid Unicode character encoding. */\n  'BAD_ENCODING': 2004,\n\n  /**\n   * The XML parser failed to parse an xml stream, or the XML lacks mandatory\n   * elements for TTML.\n   * <br> error.data[0] is extra context, if available.\n   */\n  'INVALID_XML': 2005,\n\n  // RETIRED: 'INVALID_TTML': 2006,\n\n  /**\n   * MP4 segment does not contain TTML.\n   */\n  'INVALID_MP4_TTML': 2007,\n\n  /**\n   * MP4 segment does not contain VTT.\n   */\n  'INVALID_MP4_VTT': 2008,\n\n  /**\n   * When examining media in advance, we were unable to extract the cue time.\n   * This should only be possible with HLS, where we do not have explicit\n   * segment start times.\n   * <br> error.data[0] is the underlying exception or Error object.\n   */\n  'UNABLE_TO_EXTRACT_CUE_START_TIME': 2009,\n\n\n  /**\n   * Some component tried to read past the end of a buffer.  The segment index,\n   * init segment, or PSSH may be malformed.\n   */\n  'BUFFER_READ_OUT_OF_BOUNDS': 3000,\n\n  /**\n   * Some component tried to parse an integer that was too large to fit in a\n   * JavaScript number without rounding error.  JavaScript can only natively\n   * represent integers up to 53 bits.\n   */\n  'JS_INTEGER_OVERFLOW': 3001,\n\n  /**\n   * The EBML parser used to parse the WebM container encountered an integer,\n   * ID, or other field larger than the maximum supported by the parser.\n   */\n  'EBML_OVERFLOW': 3002,\n\n  /**\n   * The EBML parser used to parse the WebM container encountered a floating-\n   * point field of a size not supported by the parser.\n   */\n  'EBML_BAD_FLOATING_POINT_SIZE': 3003,\n\n  /**\n   * The MP4 SIDX parser found the wrong box type.\n   * Either the segment index range is incorrect or the data is corrupt.\n   */\n  'MP4_SIDX_WRONG_BOX_TYPE': 3004,\n\n  /**\n   * The MP4 SIDX parser encountered an invalid timescale.\n   * The segment index data may be corrupt.\n   */\n  'MP4_SIDX_INVALID_TIMESCALE': 3005,\n\n  /** The MP4 SIDX parser encountered a type of SIDX that is not supported. */\n  'MP4_SIDX_TYPE_NOT_SUPPORTED': 3006,\n\n  /**\n   * The WebM Cues parser was unable to locate the Cues element.\n   * The segment index data may be corrupt.\n   */\n  'WEBM_CUES_ELEMENT_MISSING': 3007,\n\n  /**\n   * The WebM header parser was unable to locate the Ebml element.\n   * The init segment data may be corrupt.\n   */\n  'WEBM_EBML_HEADER_ELEMENT_MISSING': 3008,\n\n  /**\n   * The WebM header parser was unable to locate the Segment element.\n   * The init segment data may be corrupt.\n   */\n  'WEBM_SEGMENT_ELEMENT_MISSING': 3009,\n\n  /**\n   * The WebM header parser was unable to locate the Info element.\n   * The init segment data may be corrupt.\n   */\n  'WEBM_INFO_ELEMENT_MISSING': 3010,\n\n  /**\n   * The WebM header parser was unable to locate the Duration element.\n   * The init segment data may be corrupt or may have been incorrectly encoded.\n   * Shaka requires a duration in WebM DASH content.\n   */\n  'WEBM_DURATION_ELEMENT_MISSING': 3011,\n\n  /**\n   * The WebM Cues parser was unable to locate the Cue Track Positions element.\n   * The segment index data may be corrupt.\n   */\n  'WEBM_CUE_TRACK_POSITIONS_ELEMENT_MISSING': 3012,\n\n  /**\n   * The WebM Cues parser was unable to locate the Cue Time element.\n   * The segment index data may be corrupt.\n   */\n  'WEBM_CUE_TIME_ELEMENT_MISSING': 3013,\n\n  /**\n   * A MediaSource operation failed.\n   * <br> error.data[0] is a MediaError code from the video element.\n   */\n  'MEDIA_SOURCE_OPERATION_FAILED': 3014,\n\n  /**\n   * A MediaSource operation threw an exception.\n   * <br> error.data[0] is the exception that was thrown.\n   */\n  'MEDIA_SOURCE_OPERATION_THREW': 3015,\n\n  /**\n   * The video element reported an error.\n   * <br> error.data[0] is a MediaError code from the video element.\n   * <br> On Edge & IE, error.data[1] is a Microsoft extended error code in hex.\n   * <br> On Chrome, error.data[2] is a string with details on the error.\n   * <br> See top of file for links to browser error codes.\n   */\n  'VIDEO_ERROR': 3016,\n\n  /**\n   * A MediaSource operation threw QuotaExceededError and recovery failed. The\n   * content cannot be played correctly because the segments are too large for\n   * the browser/platform. This may occur when attempting to play very high\n   * quality, very high bitrate content on low-end devices.\n   * <br> error.data[0] is the type of content which caused the error.\n   */\n  'QUOTA_EXCEEDED_ERROR': 3017,\n\n  /**\n   * Mux.js did not invoke the callback signifying successful transmuxing.\n   */\n  'TRANSMUXING_FAILED': 3018,\n\n\n  /**\n   * The Player was unable to guess the manifest type based on file extension\n   * or MIME type.  To fix, try one of the following:\n   * <br><ul>\n   *   <li>Rename the manifest so that the URI ends in a well-known extension.\n   *   <li>Configure the server to send a recognizable Content-Type header.\n   *   <li>Configure the server to accept a HEAD request for the manifest.\n   * </ul>\n   * <br> error.data[0] is the manifest URI.\n   */\n  'UNABLE_TO_GUESS_MANIFEST_TYPE': 4000,\n\n  /**\n   * The DASH Manifest contained invalid XML markup.\n   * <br> error.data[0] is the URI associated with the XML.\n   */\n  'DASH_INVALID_XML': 4001,\n\n  /**\n   * The DASH Manifest contained a Representation with insufficient segment\n   * information.\n   */\n  'DASH_NO_SEGMENT_INFO': 4002,\n\n  /** The DASH Manifest contained an AdaptationSet with no Representations. */\n  'DASH_EMPTY_ADAPTATION_SET': 4003,\n\n  /** The DASH Manifest contained an Period with no AdaptationSets. */\n  'DASH_EMPTY_PERIOD': 4004,\n\n  /**\n   * The DASH Manifest does not specify an init segment with a WebM container.\n   */\n  'DASH_WEBM_MISSING_INIT': 4005,\n\n  /** The DASH Manifest contained an unsupported container format. */\n  'DASH_UNSUPPORTED_CONTAINER': 4006,\n\n  /** The embedded PSSH data has invalid encoding. */\n  'DASH_PSSH_BAD_ENCODING': 4007,\n\n  /**\n   * There is an AdaptationSet whose Representations do not have any common\n   * key-systems.\n   */\n  'DASH_NO_COMMON_KEY_SYSTEM': 4008,\n\n  /** Having multiple key IDs per Representation is not supported. */\n  'DASH_MULTIPLE_KEY_IDS_NOT_SUPPORTED': 4009,\n\n  /** The DASH Manifest specifies conflicting key IDs. */\n  'DASH_CONFLICTING_KEY_IDS': 4010,\n\n  // RETIRED: 'UNPLAYABLE_PERIOD': 4011,\n\n  /**\n   * There exist some streams that could be decoded, but restrictions imposed\n   * by the application or the key system prevent us from playing.  This may\n   * happen under the following conditions:\n   * <ul>\n   *   <li>The application has given restrictions to the Player that restrict\n   *       at least one content type completely (e.g. no playable audio).\n   *   <li>The manifest specifies different keys than were given to us from the\n   *       license server.\n   *   <li>The key system has imposed output restrictions that cannot be met\n   *       (such as HDCP) and there are no unrestricted alternatives.\n   * </ul>\n   * <br> error.data[0] is a {@link shaka.extern.RestrictionInfo} object\n   * describing the kinds of restrictions that caused this error.\n   */\n  'RESTRICTIONS_CANNOT_BE_MET': 4012,\n\n  // RETIRED: 'INTERNAL_ERROR_KEY_STATUS': 4013,\n\n  // RETIRED: 'NO_PERIODS': 4014,\n\n  /**\n   * HLS playlist doesn't start with a mandory #EXTM3U tag.\n   */\n  'HLS_PLAYLIST_HEADER_MISSING': 4015,\n\n  /**\n   * HLS tag has an invalid name that doesn't start with '#EXT'\n   * <br> error.data[0] is the invalid tag.\n   */\n  'INVALID_HLS_TAG': 4016,\n\n  /**\n   * HLS playlist has both Master and Media/Segment tags.\n   */\n  'HLS_INVALID_PLAYLIST_HIERARCHY': 4017,\n\n  /**\n   * A Representation has an id that is the same as another Representation in\n   * the same Period.  This makes manifest updates impossible since we cannot\n   * map the updated Representation to the old one.\n   */\n  'DASH_DUPLICATE_REPRESENTATION_ID': 4018,\n\n  // RETIRED: 'HLS_MEDIA_INIT_SECTION_INFO_MISSING': 4019,\n\n  /**\n   * HLS manifest has several #EXT-X-MAP tags. We can only\n   * support one at the moment.\n   */\n  'HLS_MULTIPLE_MEDIA_INIT_SECTIONS_FOUND': 4020,\n\n  /**\n   * HLS parser was unable to guess mime type of a stream.\n   * <br> error.data[0] is the stream file's extension.\n   */\n  'HLS_COULD_NOT_GUESS_MIME_TYPE': 4021,\n\n  /**\n   * No Master Playlist has been provided. Master playlist provides\n   * vital information about the streams (like codecs) that is\n   * required for MediaSource. We don't support directly providing\n   * a Media Playlist.\n   */\n  'HLS_MASTER_PLAYLIST_NOT_PROVIDED': 4022,\n\n  /**\n   * One of the required attributes was not provided, so the\n   * HLS manifest is invalid.\n   * <br> error.data[0] is the missing attribute's name.\n   */\n  'HLS_REQUIRED_ATTRIBUTE_MISSING': 4023,\n\n  /**\n   * One of the required tags was not provided, so the\n   * HLS manifest is invalid.\n   * <br> error.data[0] is the missing tag's name.\n   */\n  'HLS_REQUIRED_TAG_MISSING': 4024,\n\n  /**\n   * The HLS parser was unable to guess codecs of a stream.\n   * <br> error.data[0] is the list of all codecs for the variant.\n   */\n  'HLS_COULD_NOT_GUESS_CODECS': 4025,\n\n  /**\n   * The HLS parser has encountered encrypted content with unsupported\n   * KEYFORMAT attributes.\n   */\n  'HLS_KEYFORMATS_NOT_SUPPORTED': 4026,\n\n  /**\n   * The manifest parser only supports xlink links with xlink:actuate=\"onLoad\".\n   */\n  'DASH_UNSUPPORTED_XLINK_ACTUATE': 4027,\n\n  /**\n   * The manifest parser has hit its depth limit on xlink link chains.\n   */\n  'DASH_XLINK_DEPTH_LIMIT': 4028,\n\n  // RETIRED: 'HLS_LIVE_CONTENT_NOT_SUPPORTED': 4029,\n\n  /**\n   * The HLS parser was unable to parse segment start time from the media.\n   * <br> error.data[0] is the failed media playlist URI.\n   * <br> error.data[1] is the failed media segment URI (if any).\n   */\n  'HLS_COULD_NOT_PARSE_SEGMENT_START_TIME': 4030,\n\n  // RETIRED: 'HLS_MEDIA_SEQUENCE_REQUIRED_IN_LIVE_STREAMS': 4031,\n\n  /**\n   * The content container or codecs are not supported by this browser. For\n   * example, this could happen if the content is WebM, but your browser does\n   * not support the WebM container, or if the content uses HEVC, but your\n   * browser does not support the HEVC codec.  This can also occur for\n   * multicodec or multicontainer manifests if none of the codecs or containers\n   * are supported by the browser.\n   *\n   * To see what your browser supports, you can check the JSON data dumped by\n   * http://support.shaka-player-demo.appspot.com/\n   */\n  'CONTENT_UNSUPPORTED_BY_BROWSER': 4032,\n\n  /**\n   * External text tracks cannot be added to live streams.\n   */\n  'CANNOT_ADD_EXTERNAL_TEXT_TO_LIVE_STREAM': 4033,\n\n  /**\n   * We do not support AES-128 encryption with HLS yet.\n   */\n  'HLS_AES_128_ENCRYPTION_NOT_SUPPORTED': 4034,\n\n  /**\n   * An internal error code that should never be seen by applications, thrown\n   * to force the HLS parser to skip an unsupported stream.\n   */\n  'HLS_INTERNAL_SKIP_STREAM': 4035,\n\n  /** The Manifest contained no Variants. */\n  'NO_VARIANTS': 4036,\n\n  /**\n   * We failed to find matching streams across DASH Periods, and the\n   * period-flattening aglorithm introduced in v3.0 has failed.\n   */\n  'PERIOD_FLATTENING_FAILED': 4037,\n\n  /**\n   * We failed to find matching streams across DASH Periods due to inconsistent\n   * DRM systems across periods.\n   */\n  'INCONSISTENT_DRM_ACROSS_PERIODS': 4038,\n\n  /**\n   * The HLS manifest refers to an undeclared variables.\n   * <br> error.data[0] is the variable undeclared.\n   */\n  'HLS_VARIABLE_NOT_FOUND': 4039,\n\n\n  // RETIRED: 'INCONSISTENT_BUFFER_STATE': 5000,\n  // RETIRED: 'INVALID_SEGMENT_INDEX': 5001,\n  // RETIRED: 'SEGMENT_DOES_NOT_EXIST': 5002,\n  // RETIRED: 'CANNOT_SATISFY_BYTE_LIMIT': 5003,\n  // RETIRED: 'BAD_SEGMENT': 5004,\n  // RETIRED: 'INVALID_STREAMS_CHOSEN': 5005,\n\n  /**\n   * This would only happen if StreamingEngine were not started correctly, and\n   * should not be seen in production.\n   */\n  'STREAMING_ENGINE_STARTUP_INVALID_STATE': 5006,\n\n\n  /**\n   * The manifest indicated protected content, but the manifest parser was\n   * unable to determine what key systems should be used.\n   */\n  'NO_RECOGNIZED_KEY_SYSTEMS': 6000,\n\n  /**\n   * None of the requested key system configurations are available.  This may\n   * happen under the following conditions:\n   * <ul>\n   *   <li> The key system is not supported.\n   *   <li> The key system does not support the features requested (e.g.\n   *        persistent state).\n   *   <li> A user prompt was shown and the user denied access.\n   *   <li> The key system is not available from unsecure contexts. (i.e.\n            requires HTTPS) See https://bit.ly/2K9X1nY\n   * </ul>\n   */\n  'REQUESTED_KEY_SYSTEM_CONFIG_UNAVAILABLE': 6001,\n\n  /**\n   * The browser found one of the requested key systems, but it failed to\n   * create an instance of the CDM for some unknown reason.\n   * <br> error.data[0] is an error message string from the browser.\n   */\n  'FAILED_TO_CREATE_CDM': 6002,\n\n  /**\n   * The browser found one of the requested key systems and created an instance\n   * of the CDM, but it failed to attach the CDM to the video for some unknown\n   * reason.\n   * <br> error.data[0] is an error message string from the browser.\n   */\n  'FAILED_TO_ATTACH_TO_VIDEO': 6003,\n\n  /**\n   * The CDM rejected the server certificate supplied by the application.\n   * The certificate may be malformed or in an unsupported format.\n   * <br> error.data[0] is an error message string from the browser.\n   */\n  'INVALID_SERVER_CERTIFICATE': 6004,\n\n  /**\n   * The CDM refused to create a session for some unknown reason.\n   * <br> error.data[0] is an error message string from the browser.\n   */\n  'FAILED_TO_CREATE_SESSION': 6005,\n\n  /**\n   * The CDM was unable to generate a license request for the init data it was\n   * given.  The init data may be malformed or in an unsupported format.\n   * <br> error.data[0] is an error message string from the browser.\n   * <br> error.data[1] is the error object from the browser.\n   * <br> error.data[2] is a string with the extended error code, if available.\n   * <br> See top of file for links to browser error codes.\n   */\n  'FAILED_TO_GENERATE_LICENSE_REQUEST': 6006,\n\n  /**\n   * The license request failed.  This could be a timeout, a network failure, or\n   * a rejection by the server.\n   * <br> error.data[0] is a shaka.util.Error from the networking engine.\n   */\n  'LICENSE_REQUEST_FAILED': 6007,\n\n  /**\n   * The license response was rejected by the CDM.  The server's response may be\n   * invalid or malformed for this CDM.\n   * <br> error.data[0] is an error message string from the browser.\n   * <br> See top of file for links to browser error codes.\n   */\n  'LICENSE_RESPONSE_REJECTED': 6008,\n\n  // RETIRED: 'NO_LICENSE_SERVER_SPECIFIED': 6009,\n\n  /**\n   * The manifest does not specify any DRM info, but the content is encrypted.\n   * Either the manifest or the manifest parser are broken.\n   */\n  'ENCRYPTED_CONTENT_WITHOUT_DRM_INFO': 6010,\n\n  // RETIRED: 'WRONG_KEYS': 6011,\n\n  /**\n   * No license server was given for the key system signaled by the manifest.\n   * A license server URI is required for every key system.\n   * <br> error.data[0] is the key system identifier.\n   */\n  'NO_LICENSE_SERVER_GIVEN': 6012,\n\n  /**\n   * A required offline session was removed.  The content is not playable.\n   */\n  'OFFLINE_SESSION_REMOVED': 6013,\n\n  /**\n   * The license has expired.  This is triggered when all keys in the key\n   * status map have a status of 'expired'.\n   */\n  'EXPIRED': 6014,\n\n  /**\n   * A server certificate wasn't given when it is required.  FairPlay requires\n   * setting an explicit server certificate in the configuration.\n   */\n  'SERVER_CERTIFICATE_REQUIRED': 6015,\n\n  /**\n   * An error was thrown while executing the init data transformation.\n   * <br> error.data[0] is the original error.\n   */\n  'INIT_DATA_TRANSFORM_ERROR': 6016,\n\n\n  /**\n   * The call to Player.load() was interrupted by a call to Player.unload()\n   * or another call to Player.load().\n   */\n  'LOAD_INTERRUPTED': 7000,\n\n  /**\n   * An internal error which indicates that an operation was aborted.  This\n   * should not be seen by applications.\n   */\n  'OPERATION_ABORTED': 7001,\n\n  /**\n   * The call to Player.load() failed because the Player does not have a video\n   * element.  The video element must either be provided to the constructor or\n   * to Player.attach() before Player.load() is called.\n   */\n  'NO_VIDEO_ELEMENT': 7002,\n\n  /**\n   * The operation failed because the object has been destroyed.\n   */\n  'OBJECT_DESTROYED': 7003,\n\n\n  /**\n   * The Cast API is unavailable.  This may be because of one of the following:\n   *  1. The browser may not have Cast support\n   *  2. The browser may be missing a necessary Cast extension\n   *  3. The Cast sender library may not be loaded in your app\n   */\n  'CAST_API_UNAVAILABLE': 8000,\n\n  /**\n   * No cast receivers are available at this time.\n   */\n  'NO_CAST_RECEIVERS': 8001,\n\n  /**\n   * The library is already casting.\n   */\n  'ALREADY_CASTING': 8002,\n\n  /**\n   * A Cast SDK error that we did not explicitly plan for has occurred.\n   * Check data[0] and refer to the Cast SDK documentation for details.\n   * <br> error.data[0] is an error object from the Cast SDK.\n   */\n  'UNEXPECTED_CAST_ERROR': 8003,\n\n  /**\n   * The cast operation was canceled by the user.\n   * <br> error.data[0] is an error object from the Cast SDK.\n   */\n  'CAST_CANCELED_BY_USER': 8004,\n\n  /**\n   * The cast connection timed out.\n   * <br> error.data[0] is an error object from the Cast SDK.\n   */\n  'CAST_CONNECTION_TIMED_OUT': 8005,\n\n  /**\n   * The requested receiver app ID does not exist or is unavailable.\n   * Check the requested app ID for typos.\n   * <br> error.data[0] is an error object from the Cast SDK.\n   */\n  'CAST_RECEIVER_APP_UNAVAILABLE': 8006,\n\n\n  // RETIRED: CAST_RECEIVER_APP_ID_MISSING': 8007,\n\n\n  /**\n   * Offline storage is not supported on this browser; it is required for\n   * offline support.\n   */\n  'STORAGE_NOT_SUPPORTED': 9000,\n\n  /**\n   * An unknown error occurred in the IndexedDB.\n   * <br> On Firefox, one common source for UnknownError calls is reverting\n   * Firefox to an old version. This makes the IndexedDB storage inaccessible\n   * for older versions. The only way to fix this is to delete the storage\n   * data in your profile. See https://mzl.la/2yCGWCm\n   * <br> error.data[0] is the error object.\n   */\n  'INDEXED_DB_ERROR': 9001,\n\n  /**\n   * The storage operation was aborted.  Deprecated in favor of more general\n   * OPERATION_ABORTED.\n   */\n  'DEPRECATED_OPERATION_ABORTED': 9002,\n\n  /**\n   * The specified item was not found in the IndexedDB.\n   * <br> error.data[0] is the offline URI.\n   */\n  'REQUESTED_ITEM_NOT_FOUND': 9003,\n\n  /**\n   * A network request was made with a malformed offline URI.\n   * <br> error.data[0] is the URI.\n   */\n  'MALFORMED_OFFLINE_URI': 9004,\n\n  /**\n   * The specified content is live or in-progress.\n   * Live and in-progress streams cannot be stored offline.\n   * <br> error.data[0] is the URI.\n   */\n  'CANNOT_STORE_LIVE_OFFLINE': 9005,\n\n  // RETIRED: 'STORE_ALREADY_IN_PROGRESS': 9006,\n\n  /**\n   * There was no init data available for offline storage.  This happens when\n   * there is no init data in the manifest nor could we find any in the\n   * segments.  We currently only support searching MP4 init segments for init\n   * data.\n   */\n  'NO_INIT_DATA_FOR_OFFLINE': 9007,\n\n  /**\n   * shaka.offline.Storage was constructed with a Player proxy instead of a\n   * local player instance.  To fix this, use Player directly with Storage\n   * instead of the results of CastProxy.prototype.getPlayer().\n   */\n  'LOCAL_PLAYER_INSTANCE_REQUIRED': 9008,\n\n  // RETIRED/MOVED TO 4000's: 'CONTENT_UNSUPPORTED_BY_BROWSER': 9009,\n\n  // RETIRED: 'UNSUPPORTED_UPGRADE_REQUEST': 9010,\n\n  /**\n   * The storage cell does not allow new operations that require new keys.\n   */\n  'NEW_KEY_OPERATION_NOT_SUPPORTED': 9011,\n\n  /**\n   * A key was not found in a storage cell.\n   */\n  'KEY_NOT_FOUND': 9012,\n\n  /**\n   * A storage cell was not found.\n   */\n  'MISSING_STORAGE_CELL': 9013,\n\n  /**\n   * CS IMA SDK, required for ad insertion, has not been included on the page.\n   */\n  'CS_IMA_SDK_MISSING': 10000,\n\n  /**\n   * Client Side Ad Manager needs to be initialized to enable Client Side\n   * Ad Insertion. Call adManager.initClientSide() to do it.\n   */\n  'CS_AD_MANAGER_NOT_INITIALIZED': 10001,\n\n  /**\n   * SS IMA SDK, required for ad insertion, has not been included on the page.\n   */\n  'SS_IMA_SDK_MISSING': 10002,\n\n  /**\n   * Server Side Ad Manager needs to be initialized to enable Server Side\n   * Ad Insertion. Call adManager.initServerSide() to do it.\n   */\n  'SS_AD_MANAGER_NOT_INITIALIZED': 10003,\n\n  /**\n   * A new DAI steam was requested before the previous request had been\n   * resolved. Only one stream request at a time is supported. Please wait\n   * for the previous request to complete before initiating a new one.\n   */\n  'CURRENT_DAI_REQUEST_NOT_FINISHED': 10004,\n};\n","/*! @license\n * Copyright 2008 The Closure Library Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Simple utilities for splitting URI strings.\n *\n * Uses features of RFC 3986 for parsing/formatting URIs:\n *   http://www.ietf.org/rfc/rfc3986.txt\n *\n * @author gboyer@google.com (Garrett Boyer) - The \"lightened\" design.\n * @author msamuel@google.com (Mike Samuel) - Domain knowledge and regexes.\n */\n\ngoog.provide('goog.uri.utils');\ngoog.provide('goog.uri.utils.ComponentIndex');\n\n\n/**\n * A regular expression for breaking a URI into its component parts.\n *\n * {@link http://www.ietf.org/rfc/rfc3986.txt} says in Appendix B\n * As the \"first-match-wins\" algorithm is identical to the \"greedy\"\n * disambiguation method used by POSIX regular expressions, it is natural and\n * commonplace to use a regular expression for parsing the potential five\n * components of a URI reference.\n *\n * The following line is the regular expression for breaking-down a\n * well-formed URI reference into its components.\n *\n * <pre>\n * ^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?\n *  12            3  4          5       6  7        8 9\n * </pre>\n *\n * The numbers in the second line above are only to assist readability; they\n * indicate the reference points for each subexpression (i.e., each paired\n * parenthesis). We refer to the value matched for subexpression <n> as $<n>.\n * For example, matching the above expression to\n * <pre>\n *     http://www.ics.uci.edu/pub/ietf/uri/#Related\n * </pre>\n * results in the following subexpression matches:\n * <pre>\n *    $1 = http:\n *    $2 = http\n *    $3 = //www.ics.uci.edu\n *    $4 = www.ics.uci.edu\n *    $5 = /pub/ietf/uri/\n *    $6 = <undefined>\n *    $7 = <undefined>\n *    $8 = #Related\n *    $9 = Related\n * </pre>\n * where <undefined> indicates that the component is not present, as is the\n * case for the query component in the above example. Therefore, we can\n * determine the value of the five components as\n * <pre>\n *    scheme    = $2\n *    authority = $4\n *    path      = $5\n *    query     = $7\n *    fragment  = $9\n * </pre>\n *\n * The regular expression has been modified slightly to expose the\n * userInfo, domain, and port separately from the authority.\n * The modified version yields\n * <pre>\n *    $1 = http              scheme\n *    $2 = <undefined>       userInfo -\\\n *    $3 = www.ics.uci.edu   domain     | authority\n *    $4 = <undefined>       port     -/\n *    $5 = /pub/ietf/uri/    path\n *    $6 = <undefined>       query without ?\n *    $7 = Related           fragment without #\n * </pre>\n * @type {!RegExp}\n * @private\n */\ngoog.uri.utils.splitRe_ = new RegExp(\n    '^' +\n    '(?:' +\n        '([^:/?#.]+)' +                  // scheme - ignore special characters\n                                         // used by other URL parts such as :,\n                                         // ?, /, #, and .\n    ':)?' +\n    '(?://' +\n        '(?:([^/?#]*)@)?' +              // userInfo\n        '([^/#?]*?)' +                   // domain\n        '(?::([0-9]+))?' +               // port\n        '(?=[/#?]|$)' +                  // authority-terminating character\n    ')?' +\n    '([^?#]+)?' +                        // path\n    '(?:\\\\?([^#]*))?' +                  // query\n    '(?:#(.*))?' +                       // fragment\n    '$');\n\n\n/**\n * The index of each URI component in the return value of goog.uri.utils.split.\n * @enum {number}\n */\ngoog.uri.utils.ComponentIndex = {\n  SCHEME: 1,\n  USER_INFO: 2,\n  DOMAIN: 3,\n  PORT: 4,\n  PATH: 5,\n  QUERY_DATA: 6,\n  FRAGMENT: 7\n};\n\n\n/**\n * Splits a URI into its component parts.\n *\n * Each component can be accessed via the component indices; for example:\n * <pre>\n * goog.uri.utils.split(someStr)[goog.uri.utils.CompontentIndex.QUERY_DATA];\n * </pre>\n *\n * @param {string} uri The URI string to examine.\n * @return {!Array.<string|undefined>} Each component still URI-encoded.\n *     Each component that is present will contain the encoded value, whereas\n *     components that are not present will be undefined or empty, depending\n *     on the browser's regular expression implementation.  Never null, since\n *     arbitrary strings may still look like path names.\n */\ngoog.uri.utils.split = function(uri) {\n  // See @return comment -- never null.\n  return /** @type {!Array.<string|undefined>} */ (\n      uri.match(goog.uri.utils.splitRe_));\n};\n","/*! @license\n * Copyright 2006 The Closure Library Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Class for parsing and formatting URIs.\n *\n * Use new goog.Uri(string) to parse a URI string.\n *\n * e.g: <code>var myUri = new goog.Uri(window.location);</code>\n *\n * Implements RFC 3986 for parsing/formatting URIs.\n * http://www.ietf.org/rfc/rfc3986.txt\n *\n * Some changes have been made to the interface (more like .NETs), though the\n * internal representation is now of un-encoded parts, this will change the\n * behavior slightly.\n *\n */\n\ngoog.provide('goog.Uri');\ngoog.provide('goog.Uri.QueryData');\n\ngoog.require('goog.asserts');\ngoog.require('goog.uri.utils');\ngoog.require('goog.uri.utils.ComponentIndex');\n\n\n\n/**\n * This class contains setters and getters for the parts of the URI.\n * The <code>getXyz</code>/<code>setXyz</code> methods return the decoded part\n * -- so<code>new goog.Uri('/foo%20bar').getPath()</code> will return the\n * decoded path, <code>/foo bar</code>.\n *\n * Reserved characters (see RFC 3986 section 2.2) can be present in\n * their percent-encoded form in scheme, domain, and path URI components and\n * will not be auto-decoded. For example:\n * <code>new goog.Uri('rel%61tive/path%2fto/resource').getPath()</code> will\n * return <code>relative/path%2fto/resource</code>.\n *\n * The constructor accepts an optional unparsed, raw URI string.  The parser\n * is relaxed, so special characters that aren't escaped but don't cause\n * ambiguities will not cause parse failures.\n *\n * All setters return <code>this</code> and so may be chained, a la\n * <code>new goog.Uri('/foo').setFragment('part').toString()</code>.\n *\n * @param {*=} uri Optional string URI to parse, or if a goog.Uri is\n *        passed, a clone is created.\n *\n * @constructor\n */\ngoog.Uri = function(uri) {\n  // Parse in the uri string\n  var m;\n  if (uri instanceof goog.Uri) {\n    this.setScheme(uri.getScheme());\n    this.setUserInfo(uri.getUserInfo());\n    this.setDomain(uri.getDomain());\n    this.setPort(uri.getPort());\n    this.setPath(uri.getPath());\n    this.setQueryData(uri.getQueryData().clone());\n    this.setFragment(uri.getFragment());\n  } else if (uri && (m = goog.uri.utils.split(String(uri)))) {\n    // Set the parts -- decoding as we do so.\n    // COMPATABILITY NOTE - In IE, unmatched fields may be empty strings,\n    // whereas in other browsers they will be undefined.\n    this.setScheme(m[goog.uri.utils.ComponentIndex.SCHEME] || '', true);\n    this.setUserInfo(m[goog.uri.utils.ComponentIndex.USER_INFO] || '', true);\n    this.setDomain(m[goog.uri.utils.ComponentIndex.DOMAIN] || '', true);\n    this.setPort(m[goog.uri.utils.ComponentIndex.PORT]);\n    this.setPath(m[goog.uri.utils.ComponentIndex.PATH] || '', true);\n    this.setQueryData(m[goog.uri.utils.ComponentIndex.QUERY_DATA] || '', true);\n    this.setFragment(m[goog.uri.utils.ComponentIndex.FRAGMENT] || '', true);\n  } else {\n    this.queryData_ = new goog.Uri.QueryData(null, null);\n  }\n};\n\n\n/**\n * Scheme such as \"http\".\n * @type {string}\n * @private\n */\ngoog.Uri.prototype.scheme_ = '';\n\n\n/**\n * User credentials in the form \"username:password\".\n * @type {string}\n * @private\n */\ngoog.Uri.prototype.userInfo_ = '';\n\n\n/**\n * Domain part, e.g. \"www.google.com\".\n * @type {string}\n * @private\n */\ngoog.Uri.prototype.domain_ = '';\n\n\n/**\n * Port, e.g. 8080.\n * @type {?number}\n * @private\n */\ngoog.Uri.prototype.port_ = null;\n\n\n/**\n * Path, e.g. \"/tests/img.png\".\n * @type {string}\n * @private\n */\ngoog.Uri.prototype.path_ = '';\n\n\n/**\n * Object representing query data.\n * @type {!goog.Uri.QueryData}\n * @private\n */\ngoog.Uri.prototype.queryData_;\n\n\n/**\n * The fragment without the #.\n * @type {string}\n * @private\n */\ngoog.Uri.prototype.fragment_ = '';\n\n\n/**\n * @return {string} The string form of the url.\n * @override\n */\ngoog.Uri.prototype.toString = function() {\n  var out = [];\n\n  var scheme = this.getScheme();\n  if (scheme) {\n    out.push(goog.Uri.encodeSpecialChars_(\n        scheme, goog.Uri.reDisallowedInSchemeOrUserInfo_, true), ':');\n  }\n\n  var domain = this.getDomain();\n  if (domain) {\n    out.push('//');\n\n    var userInfo = this.getUserInfo();\n    if (userInfo) {\n      out.push(goog.Uri.encodeSpecialChars_(\n          userInfo, goog.Uri.reDisallowedInSchemeOrUserInfo_, true), '@');\n    }\n\n    out.push(goog.Uri.removeDoubleEncoding_(encodeURIComponent(domain)));\n\n    var port = this.getPort();\n    if (port != null) {\n      out.push(':', String(port));\n    }\n  }\n\n  var path = this.getPath();\n  if (path) {\n    if (this.hasDomain() && path.charAt(0) != '/') {\n      out.push('/');\n    }\n    out.push(goog.Uri.encodeSpecialChars_(\n        path,\n        path.charAt(0) == '/' ?\n            goog.Uri.reDisallowedInAbsolutePath_ :\n            goog.Uri.reDisallowedInRelativePath_,\n        true));\n  }\n\n  var query = this.getEncodedQuery();\n  if (query) {\n    out.push('?', query);\n  }\n\n  var fragment = this.getFragment();\n  if (fragment) {\n    out.push('#', goog.Uri.encodeSpecialChars_(\n        fragment, goog.Uri.reDisallowedInFragment_));\n  }\n  return out.join('');\n};\n\n\n/**\n * Resolves the given relative URI (a goog.Uri object), using the URI\n * represented by this instance as the base URI.\n *\n * There are several kinds of relative URIs:<br>\n * 1. foo - replaces the last part of the path, the whole query and fragment<br>\n * 2. /foo - replaces the the path, the query and fragment<br>\n * 3. //foo - replaces everything from the domain on.  foo is a domain name<br>\n * 4. ?foo - replace the query and fragment<br>\n * 5. #foo - replace the fragment only\n *\n * Additionally, if relative URI has a non-empty path, all \"..\" and \".\"\n * segments will be resolved, as described in RFC 3986.\n *\n * @param {goog.Uri} relativeUri The relative URI to resolve.\n * @return {!goog.Uri} The resolved URI.\n */\ngoog.Uri.prototype.resolve = function(relativeUri) {\n\n  var absoluteUri = this.clone();\n  if (absoluteUri.scheme_ === 'data') {\n    // Cannot have a relative URI to a data URI.\n    absoluteUri = new goog.Uri();\n  }\n\n  // we satisfy these conditions by looking for the first part of relativeUri\n  // that is not blank and applying defaults to the rest\n\n  var overridden = relativeUri.hasScheme();\n\n  if (overridden) {\n    absoluteUri.setScheme(relativeUri.getScheme());\n  } else {\n    overridden = relativeUri.hasUserInfo();\n  }\n\n  if (overridden) {\n    absoluteUri.setUserInfo(relativeUri.getUserInfo());\n  } else {\n    overridden = relativeUri.hasDomain();\n  }\n\n  if (overridden) {\n    absoluteUri.setDomain(relativeUri.getDomain());\n  } else {\n    overridden = relativeUri.hasPort();\n  }\n\n  var path = relativeUri.getPath();\n  if (overridden) {\n    absoluteUri.setPort(relativeUri.getPort());\n  } else {\n    overridden = relativeUri.hasPath();\n    if (overridden) {\n      // resolve path properly\n      if (path.charAt(0) != '/') {\n        // path is relative\n        if (this.hasDomain() && !this.hasPath()) {\n          // RFC 3986, section 5.2.3, case 1\n          path = '/' + path;\n        } else {\n          // RFC 3986, section 5.2.3, case 2\n          var lastSlashIndex = absoluteUri.getPath().lastIndexOf('/');\n          if (lastSlashIndex != -1) {\n            path = absoluteUri.getPath().substr(0, lastSlashIndex + 1) + path;\n          }\n        }\n      }\n      path = goog.Uri.removeDotSegments(path);\n    }\n  }\n\n  if (overridden) {\n    absoluteUri.setPath(path);\n  } else {\n    overridden = relativeUri.hasQuery();\n  }\n\n  if (overridden) {\n    absoluteUri.setQueryData(relativeUri.getQueryData().clone());\n  } else {\n    overridden = relativeUri.hasFragment();\n  }\n\n  if (overridden) {\n    absoluteUri.setFragment(relativeUri.getFragment());\n  }\n\n  return absoluteUri;\n};\n\n\n/**\n * Clones the URI instance.\n * @return {!goog.Uri} New instance of the URI object.\n */\ngoog.Uri.prototype.clone = function() {\n  return new goog.Uri(this);\n};\n\n\n/**\n * @return {string} The encoded scheme/protocol for the URI.\n */\ngoog.Uri.prototype.getScheme = function() {\n  return this.scheme_;\n};\n\n\n/**\n * Sets the scheme/protocol.\n * @param {string} newScheme New scheme value.\n * @param {boolean=} decode Optional param for whether to decode new value.\n * @return {!goog.Uri} Reference to this URI object.\n */\ngoog.Uri.prototype.setScheme = function(newScheme, decode) {\n  this.scheme_ = decode ? goog.Uri.decodeOrEmpty_(newScheme, true) :\n      newScheme;\n\n  // remove an : at the end of the scheme so somebody can pass in\n  // window.location.protocol\n  if (this.scheme_) {\n    this.scheme_ = this.scheme_.replace(/:$/, '');\n  }\n  return this;\n};\n\n\n/**\n * @return {boolean} Whether the scheme has been set.\n */\ngoog.Uri.prototype.hasScheme = function() {\n  return !!this.scheme_;\n};\n\n\n/**\n * @return {string} The decoded user info.\n */\ngoog.Uri.prototype.getUserInfo = function() {\n  return this.userInfo_;\n};\n\n\n/**\n * Sets the userInfo.\n * @param {string} newUserInfo New userInfo value.\n * @param {boolean=} decode Optional param for whether to decode new value.\n * @return {!goog.Uri} Reference to this URI object.\n */\ngoog.Uri.prototype.setUserInfo = function(newUserInfo, decode) {\n  this.userInfo_ = decode ? goog.Uri.decodeOrEmpty_(newUserInfo) :\n                   newUserInfo;\n  return this;\n};\n\n\n/**\n * @return {boolean} Whether the user info has been set.\n */\ngoog.Uri.prototype.hasUserInfo = function() {\n  return !!this.userInfo_;\n};\n\n\n/**\n * @return {string} The decoded domain.\n */\ngoog.Uri.prototype.getDomain = function() {\n  return this.domain_;\n};\n\n\n/**\n * Sets the domain.\n * @param {string} newDomain New domain value.\n * @param {boolean=} decode Optional param for whether to decode new value.\n * @return {!goog.Uri} Reference to this URI object.\n */\ngoog.Uri.prototype.setDomain = function(newDomain, decode) {\n  this.domain_ = decode ? goog.Uri.decodeOrEmpty_(newDomain, true) :\n      newDomain;\n  return this;\n};\n\n\n/**\n * @return {boolean} Whether the domain has been set.\n */\ngoog.Uri.prototype.hasDomain = function() {\n  return !!this.domain_;\n};\n\n\n/**\n * @return {?number} The port number.\n */\ngoog.Uri.prototype.getPort = function() {\n  return this.port_;\n};\n\n\n/**\n * Sets the port number.\n * @param {*} newPort Port number. Will be explicitly casted to a number.\n * @return {!goog.Uri} Reference to this URI object.\n */\ngoog.Uri.prototype.setPort = function(newPort) {\n  if (newPort) {\n    newPort = Number(newPort);\n    if (isNaN(newPort) || newPort < 0) {\n      throw Error('Bad port number ' + newPort);\n    }\n    this.port_ = newPort;\n  } else {\n    this.port_ = null;\n  }\n\n  return this;\n};\n\n\n/**\n * @return {boolean} Whether the port has been set.\n */\ngoog.Uri.prototype.hasPort = function() {\n  return this.port_ != null;\n};\n\n\n/**\n  * @return {string} The decoded path.\n */\ngoog.Uri.prototype.getPath = function() {\n  return this.path_;\n};\n\n\n/**\n * Sets the path.\n * @param {string} newPath New path value.\n * @param {boolean=} decode Optional param for whether to decode new value.\n * @return {!goog.Uri} Reference to this URI object.\n */\ngoog.Uri.prototype.setPath = function(newPath, decode) {\n  this.path_ = decode ? goog.Uri.decodeOrEmpty_(newPath, true) : newPath;\n  return this;\n};\n\n\n/**\n * @return {boolean} Whether the path has been set.\n */\ngoog.Uri.prototype.hasPath = function() {\n  return !!this.path_;\n};\n\n\n/**\n * @return {boolean} Whether the query string has been set.\n */\ngoog.Uri.prototype.hasQuery = function() {\n  return this.queryData_.toString() !== '';\n};\n\n\n/**\n * Sets the query data.\n * @param {goog.Uri.QueryData|string|undefined} queryData QueryData object.\n * @param {boolean=} decode Optional param for whether to decode new value.\n *     Applies only if queryData is a string.\n * @return {!goog.Uri} Reference to this URI object.\n */\ngoog.Uri.prototype.setQueryData = function(queryData, decode) {\n  if (queryData instanceof goog.Uri.QueryData) {\n    this.queryData_ = queryData;\n  } else {\n    if (!decode) {\n      // QueryData accepts encoded query string, so encode it if\n      // decode flag is not true.\n      queryData = goog.Uri.encodeSpecialChars_(queryData,\n                                               goog.Uri.reDisallowedInQuery_);\n    }\n    this.queryData_ = new goog.Uri.QueryData(queryData, null);\n  }\n\n  return this;\n};\n\n\n/**\n * @return {string} The encoded URI query, not including the ?.\n */\ngoog.Uri.prototype.getEncodedQuery = function() {\n  return this.queryData_.toString();\n};\n\n\n/**\n * @return {string} The decoded URI query, not including the ?.\n */\ngoog.Uri.prototype.getDecodedQuery = function() {\n  return this.queryData_.toDecodedString();\n};\n\n\n/**\n * Returns the query data.\n * @return {!goog.Uri.QueryData} QueryData object.\n */\ngoog.Uri.prototype.getQueryData = function() {\n  return this.queryData_;\n};\n\n\n/**\n * @return {string} The URI fragment, not including the #.\n */\ngoog.Uri.prototype.getFragment = function() {\n  return this.fragment_;\n};\n\n\n/**\n * Sets the URI fragment.\n * @param {string} newFragment New fragment value.\n * @param {boolean=} decode Optional param for whether to decode new value.\n * @return {!goog.Uri} Reference to this URI object.\n */\ngoog.Uri.prototype.setFragment = function(newFragment, decode) {\n  this.fragment_ = decode ? goog.Uri.decodeOrEmpty_(newFragment) :\n                   newFragment;\n  return this;\n};\n\n\n/**\n * @return {boolean} Whether the URI has a fragment set.\n */\ngoog.Uri.prototype.hasFragment = function() {\n  return !!this.fragment_;\n};\n\n\n//==============================================================================\n// Static members\n//==============================================================================\n\n\n/**\n * Removes dot segments in given path component, as described in\n * RFC 3986, section 5.2.4.\n *\n * @param {string} path A non-empty path component.\n * @return {string} Path component with removed dot segments.\n */\ngoog.Uri.removeDotSegments = function(path) {\n  if (path == '..' || path == '.') {\n    return '';\n\n  } else if (path.indexOf('./') == -1 &&\n             path.indexOf('/.') == -1) {\n    // This optimization detects uris which do not contain dot-segments,\n    // and as a consequence do not require any processing.\n    return path;\n\n  } else {\n    var leadingSlash = (path.lastIndexOf('/', 0) == 0);\n    var segments = path.split('/');\n    var out = [];\n\n    for (var pos = 0; pos < segments.length; ) {\n      var segment = segments[pos++];\n\n      if (segment == '.') {\n        if (leadingSlash && pos == segments.length) {\n          out.push('');\n        }\n      } else if (segment == '..') {\n        if (out.length > 1 || out.length == 1 && out[0] != '') {\n          out.pop();\n        }\n        if (leadingSlash && pos == segments.length) {\n          out.push('');\n        }\n      } else {\n        out.push(segment);\n        leadingSlash = true;\n      }\n    }\n\n    return out.join('/');\n  }\n};\n\n\n/**\n * Decodes a value or returns the empty string if it isn't defined or empty.\n * @param {string|undefined} val Value to decode.\n * @param {boolean=} preserveReserved If true, restricted characters will\n *     not be decoded.\n * @return {string} Decoded value.\n * @private\n */\ngoog.Uri.decodeOrEmpty_ = function(val, preserveReserved) {\n  // Don't use UrlDecode() here because val is not a query parameter.\n  if (!val) {\n    return '';\n  }\n\n  return preserveReserved ? decodeURI(val) : decodeURIComponent(val);\n};\n\n\n/**\n * If unescapedPart is non null, then escapes any characters in it that aren't\n * valid characters in a url and also escapes any special characters that\n * appear in extra.\n *\n * @param {(?string|undefined)} unescapedPart The string to encode.\n * @param {RegExp} extra A character set of characters in [\\01-\\177].\n * @param {boolean=} removeDoubleEncoding If true, remove double percent\n *     encoding.\n * @return {?string} null iff unescapedPart == null.\n * @private\n */\ngoog.Uri.encodeSpecialChars_ = function(unescapedPart, extra,\n    removeDoubleEncoding) {\n  if (unescapedPart != null) {\n    var encoded = encodeURI(unescapedPart).\n        replace(extra, goog.Uri.encodeChar_);\n    if (removeDoubleEncoding) {\n      // encodeURI double-escapes %XX sequences used to represent restricted\n      // characters in some URI components, remove the double escaping here.\n      encoded = goog.Uri.removeDoubleEncoding_(encoded);\n    }\n    return encoded;\n  }\n  return null;\n};\n\n\n/**\n * Converts a character in [\\01-\\177] to its unicode character equivalent.\n * @param {string} ch One character string.\n * @return {string} Encoded string.\n * @private\n */\ngoog.Uri.encodeChar_ = function(ch) {\n  var n = ch.charCodeAt(0);\n  return '%' + ((n >> 4) & 0xf).toString(16) + (n & 0xf).toString(16);\n};\n\n\n/**\n * Removes double percent-encoding from a string.\n * @param  {string} doubleEncodedString String\n * @return {string} String with double encoding removed.\n * @private\n */\ngoog.Uri.removeDoubleEncoding_ = function(doubleEncodedString) {\n  return doubleEncodedString.replace(/%25([0-9a-fA-F]{2})/g, '%$1');\n};\n\n\n/**\n * Regular expression for characters that are disallowed in the scheme or\n * userInfo part of the URI.\n * @type {RegExp}\n * @private\n */\ngoog.Uri.reDisallowedInSchemeOrUserInfo_ = /[#\\/\\?@]/g;\n\n\n/**\n * Regular expression for characters that are disallowed in a relative path.\n * Colon is included due to RFC 3986 3.3.\n * @type {RegExp}\n * @private\n */\ngoog.Uri.reDisallowedInRelativePath_ = /[\\#\\?:]/g;\n\n\n/**\n * Regular expression for characters that are disallowed in an absolute path.\n * @type {RegExp}\n * @private\n */\ngoog.Uri.reDisallowedInAbsolutePath_ = /[\\#\\?]/g;\n\n\n/**\n * Regular expression for characters that are disallowed in the query.\n * @type {RegExp}\n * @private\n */\ngoog.Uri.reDisallowedInQuery_ = /[\\#\\?@]/g;\n\n\n/**\n * Regular expression for characters that are disallowed in the fragment.\n * @type {RegExp}\n * @private\n */\ngoog.Uri.reDisallowedInFragment_ = /#/g;\n\n\n\n/**\n * Class used to represent URI query parameters.  It is essentially a hash of\n * name-value pairs, though a name can be present more than once.\n *\n * Has the same interface as the collections in goog.structs.\n *\n * @param {?string=} query Optional encoded query string to parse into\n *     the object.\n * @param {goog.Uri=} uri Optional uri object that should have its\n *     cache invalidated when this object updates. Deprecated -- this\n *     is no longer required.\n * @constructor\n * @final\n */\ngoog.Uri.QueryData = function(query, uri) {\n  /**\n   * Encoded query string, or null if it requires computing from the key map.\n   * @type {?string}\n   * @private\n   */\n  this.encodedQuery_ = query || null;\n};\n\n\n/**\n * If the underlying key map is not yet initialized, it parses the\n * query string and fills the map with parsed data.\n * @private\n */\ngoog.Uri.QueryData.prototype.ensureKeyMapInitialized_ = function() {\n  if (!this.keyMap_) {\n    this.keyMap_ = {};\n    this.count_ = 0;\n\n    if (this.encodedQuery_) {\n      var pairs = this.encodedQuery_.split('&');\n      for (var i = 0; i < pairs.length; i++) {\n        var indexOfEquals = pairs[i].indexOf('=');\n        var name = null;\n        var value = null;\n        if (indexOfEquals >= 0) {\n          name = pairs[i].substring(0, indexOfEquals);\n          value = pairs[i].substring(indexOfEquals + 1);\n        } else {\n          name = pairs[i];\n        }\n        name = decodeURIComponent(name.replace(/\\+/g, ' '));\n        value = value || '';\n        this.add(name, decodeURIComponent(value.replace(/\\+/g, ' ')));\n      }\n    }\n  }\n};\n\n\n/**\n * The map containing name/value or name/array-of-values pairs.\n * May be null if it requires parsing from the query string.\n *\n * We need to use a Map because we cannot guarantee that the key names will\n * not be problematic for IE.\n *\n * @type {Object.<string, !Array.<string>>}\n * @private\n */\ngoog.Uri.QueryData.prototype.keyMap_ = null;\n\n\n/**\n * The number of params, or null if it requires computing.\n * @type {?number}\n * @private\n */\ngoog.Uri.QueryData.prototype.count_ = null;\n\n\n/**\n * @return {?number} The number of parameters.\n */\ngoog.Uri.QueryData.prototype.getCount = function() {\n  this.ensureKeyMapInitialized_();\n  return this.count_;\n};\n\n\n/**\n * Adds a key value pair.\n * @param {string} key Name.\n * @param {string} value Value.\n * @return {!goog.Uri.QueryData} Instance of this object.\n */\ngoog.Uri.QueryData.prototype.add = function(key, value) {\n  this.ensureKeyMapInitialized_();\n  // Invalidate the cache.\n  this.encodedQuery_ = null;\n\n  var values = this.keyMap_.hasOwnProperty(key) && this.keyMap_[key];\n  if (!values) {\n    this.keyMap_[key] = (values = []);\n  }\n  values.push(value);\n  goog.asserts.assert(this.count_ != null, 'Should not be null.');\n  this.count_++;\n  return this;\n};\n\n\n/**\n * @return {string} Encoded query string.\n * @override\n */\ngoog.Uri.QueryData.prototype.toString = function() {\n  if (this.encodedQuery_) {\n    return this.encodedQuery_;\n  }\n\n  if (!this.keyMap_) {\n    return '';\n  }\n\n  var sb = [];\n\n  for (var key in this.keyMap_) {\n    var encodedKey = encodeURIComponent(key);\n    var val = this.keyMap_[key];\n    for (var j = 0; j < val.length; j++) {\n      var param = encodedKey;\n      // Ensure that null and undefined are encoded into the url as\n      // literal strings.\n      if (val[j] !== '') {\n        param += '=' + encodeURIComponent(val[j]);\n      }\n      sb.push(param);\n    }\n  }\n\n  return this.encodedQuery_ = sb.join('&');\n};\n\n\n/**\n * @return {string} Decoded query string.\n */\ngoog.Uri.QueryData.prototype.toDecodedString = function() {\n  return goog.Uri.decodeOrEmpty_(this.toString());\n};\n\n\n/**\n * Clone the query data instance.\n * @return {!goog.Uri.QueryData} New instance of the QueryData object.\n */\ngoog.Uri.QueryData.prototype.clone = function() {\n  var rv = new goog.Uri.QueryData();\n  rv.encodedQuery_ = this.encodedQuery_;\n  if (this.keyMap_) {\n    var cloneMap = {};\n    for (var key in this.keyMap_) {\n      cloneMap[key] = this.keyMap_[key].concat();\n    }\n    rv.keyMap_ = cloneMap;\n    rv.count_ = this.count_;\n  }\n  return rv;\n};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.deprecate.Version');\n\n/**\n * A class that defines what a library version is within the deprecation\n * system. Within deprecation we only care about the major and minor versions.\n *\n * @final\n */\nshaka.deprecate.Version = class {\n  /**\n   * @param {number} major\n   * @param {number} minor\n   */\n  constructor(major, minor) {\n    this.major_ = major;\n    this.minor_ = minor;\n  }\n\n  /** @return {number} */\n  major() { return this.major_; }\n\n  /** @return {number} */\n  minor() { return this.minor_; }\n\n  /**\n   * Returns:\n   *  - positive if |this| > |other|\n   *  - zero if |this| == |other|\n   *  - negative if |this| < |other|\n   *\n   * @param {!shaka.deprecate.Version} other\n   * @return {number}\n   */\n  compareTo(other) {\n    const majorCheck = this.major_ - other.major_;\n    const minorCheck = this.minor_ - other.minor_;\n\n    return majorCheck || minorCheck;\n  }\n\n  /** @override */\n  toString() {\n    return 'v' + this.major_ + '.' + this.minor_;\n  }\n\n  /**\n   * Parse the major and minor values out of a version string that is assumed\n   * to follow the grammar: \"vMAJOR.MINOR.\". What comes after the last \".\" we\n   * will ignore.\n   *\n   * @param {string} versionString\n   * @return {!shaka.deprecate.Version}\n   */\n  static parse(versionString) {\n    // Make sure to drop the \"v\" from the front. We limit the number of splits\n    // to two as we don't care what happens after the minor version number.\n    // For example: 'a.b.c.d'.split('.', 2) == ['a', 'b']\n    const components = versionString.substring(1).split('.', /* limit= */ 2);\n\n    return new shaka.deprecate.Version(\n        Number(components[0]),\n        Number(components[1]));\n  }\n};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.Deprecate');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.deprecate.Enforcer');\ngoog.require('shaka.deprecate.Version');\ngoog.require('shaka.log');\n\n\n/**\n * |shaka.Deprecate| is the front-end of the deprecation system, allowing for\n * any part of the code to say that \"this block of code should be removed by\n * version X\".\n *\n * @final\n */\nshaka.Deprecate = class {\n  /**\n   * Initialize the system. This must happen before any calls to |enforce|. In\n   * our code base, |shaka.Player| will be the only one to call this (it has the\n   * version string).\n   *\n   * If the |Deprecate| called |Player.version| to initialize itself, it would\n   * mean that |Player| could not use |Deprecate| because it would create a\n   * circular dependency. To work around this, we provide this method so that\n   * |Player| can give us the version without us needing to know about |Player|.\n   *\n   * This will initialize the system to:\n   *  - print warning messages when the feature is scheduled to be removed in a\n   *    later version\n   *  - print errors and fail assertions when the feature should be removed now\n   *\n   * @param {string} versionString\n   */\n  static init(versionString) {\n    goog.asserts.assert(\n        shaka.Deprecate.enforcer_ == null,\n        'Deprecate.init should only be called once.');\n\n    shaka.Deprecate.enforcer_ = new shaka.deprecate.Enforcer(\n        shaka.deprecate.Version.parse(versionString),\n        shaka.Deprecate.onPending_,\n        shaka.Deprecate.onExpired_);\n  }\n\n  /**\n   * Ask the deprecation system to require this feature to be removed by the\n   * given version.\n   *\n   * @param {number} major\n   * @param {string} name\n   * @param {string} description\n   */\n  static deprecateFeature(major, name, description) {\n    const enforcer = shaka.Deprecate.enforcer_;\n    goog.asserts.assert(\n        enforcer,\n        'Missing deprecation enforcer. Was |init| called?');\n\n    const expiresAt = new shaka.deprecate.Version(major, 0);\n    enforcer.enforce(expiresAt, name, description);\n  }\n\n  /**\n   * @param {!shaka.deprecate.Version} libraryVersion\n   * @param {!shaka.deprecate.Version} featureVersion\n   * @param {string} name\n   * @param {string} description\n   * @private\n   */\n  static onPending_(libraryVersion, featureVersion, name, description) {\n    // If we were to pass each value to the log call, it would be printed as\n    // a comma-separated list. To make the print state appear more natural to\n    // the reader, create one string for the message.\n    shaka.log.alwaysWarn([\n      name,\n      'has been deprecated and will be removed in',\n      featureVersion,\n      '. We are currently at version',\n      libraryVersion,\n      '. Additional information:',\n      description,\n    ].join(' '));\n  }\n\n  /**\n   * @param {!shaka.deprecate.Version} libraryVersion\n   * @param {!shaka.deprecate.Version} featureVersion\n   * @param {string} name\n   * @param {string} description\n   * @private\n   */\n  static onExpired_(libraryVersion, featureVersion, name, description) {\n    // If we were to pass each value to the log call, it would be printed as\n    // a comma-separated list. To make the print state appear more natural to\n    // the reader, create one string for the message.\n    const errorMessage = [\n      name,\n      'has been deprecated and has been removed in',\n      featureVersion,\n      '. We are now at version',\n      libraryVersion,\n      '. Additional information:',\n      description,\n    ].join('');\n\n    shaka.log.alwaysError(errorMessage);\n    goog.asserts.assert(false, errorMessage);\n  }\n};\n\n/**\n * The global deprecation enforcer that will be set by the player (because the\n * player knows the version) when it calls |init|. This may appear a little\n * round-about to you, because it is. Since player uses |Deprecate|, it means\n * that |Deprecate| can't depend on Player directly.\n *\n * @private {shaka.deprecate.Enforcer}\n */\nshaka.Deprecate.enforcer_ = null;\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.util.Functional');\n\ngoog.require('shaka.Deprecate');\n\n\n/**\n * @summary A set of functional utility functions.\n */\nshaka.util.Functional = class {\n  /**\n   * Creates a promise chain that calls the given callback for each element in\n   * the array in a catch of a promise.\n   *\n   * e.g.:\n   * Promise.reject().catch(callback(array[0])).catch(callback(array[1]));\n   *\n   * @param {!Array.<ELEM>} array\n   * @param {function(ELEM):!Promise.<RESULT>} callback\n   * @return {!Promise.<RESULT>}\n   * @template ELEM,RESULT\n   */\n  static createFallbackPromiseChain(array, callback) {\n    return array.reduce((promise, elem) => {\n      return promise.catch(() => callback(elem));\n    }, Promise.reject());\n  }\n\n\n  /**\n   * Returns the first array concatenated to the second; used to collapse an\n   * array of arrays into a single array.\n   *\n   * @param {!Array.<T>} all\n   * @param {!Array.<T>} part\n   * @return {!Array.<T>}\n   * @template T\n   */\n  static collapseArrays(all, part) {\n    return all.concat(part);\n  }\n\n  /**\n   * A no-op function that ignores its arguments.  This is used to suppress\n   * unused variable errors.\n   * @param {...*} args\n   */\n  static ignored(...args) {}\n\n\n  /**\n   * A no-op function.  Useful in promise chains.\n   */\n  static noop() {}\n\n\n  /**\n   * Returns if the given value is not null; useful for filtering out null\n   * values.\n   *\n   * @param {T} value\n   * @return {boolean}\n   * @template T\n   */\n  static isNotNull(value) {\n    return value != null;\n  }\n\n  /**\n   * Calls a factory function while allowing it to be a constructor for\n   * reverse-compatibility.\n   *\n   * @param {function():!T} factory\n   * @return {!T}\n   * @template T\n   */\n  static callFactory(factory) {\n    // See https://stackoverflow.com/q/10428603/1208502\n    // eslint-disable-next-line no-restricted-syntax\n    const obj = Object.create(factory.prototype || Object.prototype);\n    // If this is a constructor, call it with our newly created object to\n    // initialize it; if this isn't a constructor, the \"this\" shouldn't be used\n    // since it should be \"undefined\".\n    let ret;\n    try {\n      ret = factory.call(obj);  // eslint-disable-line no-restricted-syntax\n\n      // If it didn't return anything, assume it is a constructor and return our\n      // \"this\" value instead.\n      if (!ret) {\n        shaka.Deprecate.deprecateFeature(4,\n            'Factories requiring new',\n            'Factories should be plain functions');\n        ret = obj;\n      }\n    } catch (e) {\n      // This was an ES6 class, so it threw a TypeError because we didn't use\n      // \"new\".  Fall back to actually using \"new\".\n      shaka.Deprecate.deprecateFeature(4,\n          'Factories requiring new',\n          'Factories should be plain functions');\n      const FactoryAsClass = /** @type {function(new: T)} */(factory);\n      ret = new FactoryAsClass();\n    }\n    return ret;\n  }\n};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.deprecate.Enforcer');\n\ngoog.require('shaka.deprecate.Version');\n\n\n/**\n * The enforcer's job is to call the correct callback when a feature will need\n * to be removed later or removed now.\n *\n * The \"what should be done\" is not part of the enforcer, that must be provided\n * to the enforcer when it is created. This separation was created so that\n * testing and production could be equal users of the enforcer.\n *\n * @final\n */\nshaka.deprecate.Enforcer = class {\n  /**\n   * @param {!shaka.deprecate.Version} libraryVersion\n   * @param {shaka.deprecate.Listener} onPending\n   * @param {shaka.deprecate.Listener} onExpired\n   */\n  constructor(libraryVersion, onPending, onExpired) {\n    /** @private {!shaka.deprecate.Version} */\n    this.libraryVersion_ = libraryVersion;\n\n    /** @private {shaka.deprecate.Listener} */\n    this.onPending_ = onPending;\n    /** @private {shaka.deprecate.Listener} */\n    this.onExpired_ = onExpired;\n  }\n\n  /**\n   * Tell the enforcer that a feature will expire on |expiredOn| and that it\n   * should notify the listeners if it is pending or expired.\n   *\n   * @param {!shaka.deprecate.Version} expiresOn\n   * @param {string} name\n   * @param {string} description\n   */\n  enforce(expiresOn, name, description) {\n    // If the expiration version is larger than the library version\n    // (compareTo > 0), it means the expiration is in the future, and is still\n    // pending.\n    const isPending = expiresOn.compareTo(this.libraryVersion_) > 0;\n\n    // Find the right callback (pending or expired) for this enforcement request\n    // call it to handle this features pending/expired removal.\n    const callback = isPending ? this.onPending_ : this.onExpired_;\n    callback(this.libraryVersion_, expiresOn, name, description);\n  }\n};\n\n/**\n * A callback for listening to deprecation events.\n *\n * Parameters:\n *  libraryVersion: !shaka.deprecate.Version\n *  featureVersion: !shaka.deprecate.Version\n *  name: string\n *  description: string\n *\n * libraryVersion: The current version of the library.\n * featureVersion: The version of the library when the feature should be\n *                 removed.\n * name: The name of the feature that will/should be removed.\n * description: A description of what is changing.\n *\n * @typedef {function(\n *    !shaka.deprecate.Version,\n *    !shaka.deprecate.Version,\n *    string,\n *    string)}\n */\nshaka.deprecate.Listener;\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.util.ManifestParserUtils');\n\ngoog.require('goog.Uri');\ngoog.require('shaka.util.Functional');\n\n\n/**\n * @summary Utility functions for manifest parsing.\n */\nshaka.util.ManifestParserUtils = class {\n  /**\n   * Resolves an array of relative URIs to the given base URIs. This will result\n   * in M*N number of URIs.\n   *\n   * @param {!Array.<string>} baseUris\n   * @param {!Array.<string>} relativeUris\n   * @return {!Array.<string>}\n   */\n  static resolveUris(baseUris, relativeUris) {\n    const Functional = shaka.util.Functional;\n    if (relativeUris.length == 0) {\n      return baseUris;\n    }\n\n    const relativeAsGoog = relativeUris.map((uri) => new goog.Uri(uri));\n    // Resolve each URI relative to each base URI, creating an Array of Arrays.\n    // Then flatten the Arrays into a single Array.\n    return baseUris.map((uri) => new goog.Uri(uri))\n        .map((base) => relativeAsGoog.map((i) => base.resolve(i)))\n        .reduce(Functional.collapseArrays, [])\n        .map((uri) => uri.toString());\n  }\n\n\n  /**\n   * Creates a DrmInfo object from the given info.\n   *\n   * @param {string} keySystem\n   * @param {Array.<shaka.extern.InitDataOverride>} initData\n   * @return {shaka.extern.DrmInfo}\n   */\n  static createDrmInfo(keySystem, initData) {\n    return {\n      keySystem: keySystem,\n      licenseServerUri: '',\n      distinctiveIdentifierRequired: false,\n      persistentStateRequired: false,\n      audioRobustness: '',\n      videoRobustness: '',\n      serverCertificate: null,\n      initData: initData || [],\n      keyIds: new Set(),\n    };\n  }\n};\n\n\n/**\n * @enum {string}\n */\nshaka.util.ManifestParserUtils.ContentType = {\n  VIDEO: 'video',\n  AUDIO: 'audio',\n  TEXT: 'text',\n  IMAGE: 'image',\n  APPLICATION: 'application',\n};\n\n\n/**\n * @enum {string}\n */\nshaka.util.ManifestParserUtils.TextStreamKind = {\n  SUBTITLE: 'subtitle',\n  CLOSED_CAPTION: 'caption',\n};\n\n\n/**\n * Specifies how tolerant the player is of inaccurate segment start times and\n * end times within a manifest. For example, gaps or overlaps between segments\n * in a SegmentTimeline which are greater than or equal to this value will\n * result in a warning message.\n *\n * @const {number}\n */\nshaka.util.ManifestParserUtils.GAP_OVERLAP_TOLERANCE_SECONDS = 1 / 15;\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.util.PublicPromise');\n\n\n/**\n * @summary\n * A utility to create Promises with convenient public resolve and reject\n * methods.\n *\n * @extends {Promise.<T>}\n * @template T\n */\nshaka.util.PublicPromise = class {\n  /**\n   * @return {!Promise.<T>}\n   */\n  constructor() {\n    let resolvePromise;\n    let rejectPromise;\n\n    // Promise.call causes an error.  It seems that inheriting from a native\n    // Promise is not permitted by JavaScript interpreters.\n\n    // The work-around is to construct a Promise object, modify it to look like\n    // the compiler's picture of PublicPromise, then return it.  The caller of\n    // new PublicPromise will receive |promise| instead of |this|, and the\n    // compiler will be aware of the additional properties |resolve| and\n    // |reject|.\n\n    const promise = new Promise(((resolve, reject) => {\n      resolvePromise = resolve;\n      rejectPromise = reject;\n    }));\n\n    // Now cast the Promise object to our subclass PublicPromise so that the\n    // compiler will permit us to attach resolve() and reject() to it.\n    const publicPromise = /** @type {shaka.util.PublicPromise} */(promise);\n    publicPromise.resolve = resolvePromise;\n    publicPromise.reject = rejectPromise;\n\n    return publicPromise;\n  }\n\n\n  /** @param {T=} value */\n  resolve(value) {}\n\n\n  /** @param {*=} reason */\n  reject(reason) {}\n};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.util.Lazy');\n\ngoog.require('goog.asserts');\n\n\n/**\n * @summary\n * This contains a single value that is lazily generated when it is first\n * requested.  This can store any value except \"undefined\".\n *\n * @template T\n */\nshaka.util.Lazy = class {\n  /** @param {function():T} gen */\n  constructor(gen) {\n    /** @private {function():T} */\n    this.gen_ = gen;\n\n    /** @private {T|undefined} */\n    this.value_ = undefined;\n  }\n\n  /** @return {T} */\n  value() {\n    if (this.value_ == undefined) {\n      // Compiler complains about unknown fields without this cast.\n      this.value_ = /** @type {*} */ (this.gen_());\n      goog.asserts.assert(\n          this.value_ != undefined, 'Unable to create lazy value');\n    }\n    return this.value_;\n  }\n\n  /** Resets the value of the lazy function, so it has to be remade. */\n  reset() {\n    this.value_ = undefined;\n  }\n};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.util.StringUtils');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.util.BufferUtils');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.Iterables');\ngoog.require('shaka.util.Lazy');\n\n\n/**\n * @namespace shaka.util.StringUtils\n * @summary A set of string utility functions.\n * @export\n */\nshaka.util.StringUtils = class {\n  /**\n   * Creates a string from the given buffer as UTF-8 encoding.\n   *\n   * @param {?BufferSource} data\n   * @return {string}\n   * @export\n   */\n  static fromUTF8(data) {\n    if (!data) {\n      return '';\n    }\n\n    let uint8 = shaka.util.BufferUtils.toUint8(data);\n    // If present, strip off the UTF-8 BOM.\n    if (uint8[0] == 0xef && uint8[1] == 0xbb && uint8[2] == 0xbf) {\n      uint8 = uint8.subarray(3);\n    }\n\n    // http://stackoverflow.com/a/13691499\n    const utf8 = shaka.util.StringUtils.fromCharCode(uint8);\n    // This converts each character in the string to an escape sequence.  If the\n    // character is in the ASCII range, it is not converted; otherwise it is\n    // converted to a URI escape sequence.\n    // Example: '\\x67\\x35\\xe3\\x82\\xac' -> 'g#%E3%82%AC'\n    const escaped = escape(utf8);\n    // Decode the escaped sequence.  This will interpret UTF-8 sequences into\n    // the correct character.\n    // Example: 'g#%E3%82%AC' -> 'g#'\n    try {\n      return decodeURIComponent(escaped);\n    } catch (e) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL, shaka.util.Error.Category.TEXT,\n          shaka.util.Error.Code.BAD_ENCODING);\n    }\n  }\n\n\n  /**\n   * Creates a string from the given buffer as UTF-16 encoding.\n   *\n   * @param {?BufferSource} data\n   * @param {boolean} littleEndian\n         true to read little endian, false to read big.\n   * @param {boolean=} noThrow true to avoid throwing in cases where we may\n   *     expect invalid input.  If noThrow is true and the data has an odd\n   *     length,it will be truncated.\n   * @return {string}\n   * @export\n   */\n  static fromUTF16(data, littleEndian, noThrow) {\n    if (!data) {\n      return '';\n    }\n\n    if (!noThrow && data.byteLength % 2 != 0) {\n      shaka.log.error('Data has an incorrect length, must be even.');\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL, shaka.util.Error.Category.TEXT,\n          shaka.util.Error.Code.BAD_ENCODING);\n    }\n\n    // Use a DataView to ensure correct endianness.\n    const length = Math.floor(data.byteLength / 2);\n    const arr = new Uint16Array(length);\n    const dataView = shaka.util.BufferUtils.toDataView(data);\n    for (const i of shaka.util.Iterables.range(length)) {\n      arr[i] = dataView.getUint16(i * 2, littleEndian);\n    }\n    return shaka.util.StringUtils.fromCharCode(arr);\n  }\n\n\n  /**\n   * Creates a string from the given buffer, auto-detecting the encoding that is\n   * being used.  If it cannot detect the encoding, it will throw an exception.\n   *\n   * @param {?BufferSource} data\n   * @return {string}\n   * @export\n   */\n  static fromBytesAutoDetect(data) {\n    const StringUtils = shaka.util.StringUtils;\n    if (!data) {\n      return '';\n    }\n\n    const uint8 = shaka.util.BufferUtils.toUint8(data);\n    if (uint8[0] == 0xef && uint8[1] == 0xbb && uint8[2] == 0xbf) {\n      return StringUtils.fromUTF8(uint8);\n    } else if (uint8[0] == 0xfe && uint8[1] == 0xff) {\n      return StringUtils.fromUTF16(\n          uint8.subarray(2), /* littleEndian= */ false);\n    } else if (uint8[0] == 0xff && uint8[1] == 0xfe) {\n      return StringUtils.fromUTF16(uint8.subarray(2), /* littleEndian= */ true);\n    }\n\n    const isAscii = (i) => {\n      // arr[i] >= ' ' && arr[i] <= '~';\n      return uint8.byteLength <= i || (uint8[i] >= 0x20 && uint8[i] <= 0x7e);\n    };\n\n    shaka.log.debug(\n        'Unable to find byte-order-mark, making an educated guess.');\n    if (uint8[0] == 0 && uint8[2] == 0) {\n      return StringUtils.fromUTF16(data, /* littleEndian= */ false);\n    } else if (uint8[1] == 0 && uint8[3] == 0) {\n      return StringUtils.fromUTF16(data, /* littleEndian= */ true);\n    } else if (isAscii(0) && isAscii(1) && isAscii(2) && isAscii(3)) {\n      return StringUtils.fromUTF8(data);\n    }\n\n    throw new shaka.util.Error(\n        shaka.util.Error.Severity.CRITICAL,\n        shaka.util.Error.Category.TEXT,\n        shaka.util.Error.Code.UNABLE_TO_DETECT_ENCODING);\n  }\n\n\n  /**\n   * Creates a ArrayBuffer from the given string, converting to UTF-8 encoding.\n   *\n   * @param {string} str\n   * @return {!ArrayBuffer}\n   * @export\n   */\n  static toUTF8(str) {\n    // http://stackoverflow.com/a/13691499\n    // Converts the given string to a URI encoded string.  If a character falls\n    // in the ASCII range, it is not converted; otherwise it will be converted\n    // to a series of URI escape sequences according to UTF-8.\n    // Example: 'g#' -> 'g#%E3%82%AC'\n    const encoded = encodeURIComponent(str);\n    // Convert each escape sequence individually into a character.  Each escape\n    // sequence is interpreted as a code-point, so if an escape sequence happens\n    // to be part of a multi-byte sequence, each byte will be converted to a\n    // single character.\n    // Example: 'g#%E3%82%AC' -> '\\x67\\x35\\xe3\\x82\\xac'\n    const utf8 = unescape(encoded);\n\n    const result = new Uint8Array(utf8.length);\n    const enumerate = (it) => shaka.util.Iterables.enumerate(it);\n    for (const {i, item} of enumerate(utf8)) {\n      result[i] = item.charCodeAt(0);\n    }\n    return shaka.util.BufferUtils.toArrayBuffer(result);\n  }\n\n\n  /**\n   * Creates a ArrayBuffer from the given string, converting to UTF-16 encoding.\n   *\n   * @param {string} str\n   * @param {boolean} littleEndian\n   * @return {!ArrayBuffer}\n   * @export\n   */\n  static toUTF16(str, littleEndian) {\n    const result = new ArrayBuffer(str.length * 2);\n    const view = new DataView(result);\n    const enumerate = (it) => shaka.util.Iterables.enumerate(it);\n    for (const {i, item} of enumerate(str)) {\n      const value = item.charCodeAt(0);\n      view.setUint16(/* position= */ i * 2, value, littleEndian);\n    }\n    return result;\n  }\n\n\n  /**\n   * Creates a new string from the given array of char codes.\n   *\n   * Using String.fromCharCode.apply is risky because you can trigger stack\n   * errors on very large arrays.  This breaks up the array into several pieces\n   * to avoid this.\n   *\n   * @param {!TypedArray} array\n   * @return {string}\n   */\n  static fromCharCode(array) {\n    return shaka.util.StringUtils.fromCharCodeImpl_.value()(array);\n  }\n\n  /**\n   * Resets the fromCharCode method's implementation.\n   * For debug use.\n   * @export\n   */\n  static resetFromCharCode() {\n    shaka.util.StringUtils.fromCharCodeImpl_.reset();\n  }\n};\n\n\n/** @private {!shaka.util.Lazy.<function(!TypedArray):string>} */\nshaka.util.StringUtils.fromCharCodeImpl_ = new shaka.util.Lazy(() => {\n  /** @param {number} size @return {boolean} */\n  const supportsChunkSize = (size) => {\n    try {\n      // The compiler will complain about suspicious value if this isn't\n      // stored in a variable and used.\n      const buffer = new Uint8Array(size);\n\n      // This can't use the spread operator, or it blows up on Xbox One.\n      // So we use apply() instead, which is normally not allowed.\n      // See issue #2186 for more details.\n      // eslint-disable-next-line no-restricted-syntax\n      const foo = String.fromCharCode.apply(null, buffer);\n      goog.asserts.assert(foo, 'Should get value');\n      return foo.length > 0; // Actually use \"foo\", so it's not compiled out.\n    } catch (error) {\n      return false;\n    }\n  };\n\n  // Different browsers support different chunk sizes; find out the largest\n  // this browser supports so we can use larger chunks on supported browsers\n  // but still support lower-end devices that require small chunks.\n  // 64k is supported on all major desktop browsers.\n  for (let size = 64 * 1024; size > 0; size /= 2) {\n    if (supportsChunkSize(size)) {\n      return (buffer) => {\n        let ret = '';\n        for (let i = 0; i < buffer.length; i += size) {\n          const subArray = buffer.subarray(i, i + size);\n\n          // This can't use the spread operator, or it blows up on Xbox One.\n          // So we use apply() instead, which is normally not allowed.\n          // See issue #2186 for more details.\n          // eslint-disable-next-line no-restricted-syntax\n          ret += String.fromCharCode.apply(null, subArray);  // Issue #2186\n        }\n        return ret;\n      };\n    }\n  }\n  goog.asserts.assert(false, 'Unable to create a fromCharCode method');\n  return null;\n});\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.util.Uint8ArrayUtils');\n\ngoog.require('shaka.Deprecate');\ngoog.require('shaka.util.BufferUtils');\ngoog.require('shaka.util.Iterables');\ngoog.require('shaka.util.StringUtils');\n\n\n// TODO: revisit this when Closure Compiler supports partially-exported classes.\n/**\n * @summary A set of Uint8Array utility functions.\n * @export\n */\nshaka.util.Uint8ArrayUtils = class {\n  /**\n   * Compare two Uint8Arrays for equality.\n   * @param {Uint8Array} arr1\n   * @param {Uint8Array} arr2\n   * @return {boolean}\n   * @deprecated\n   * @export\n   */\n  static equal(arr1, arr2) {\n    shaka.Deprecate.deprecateFeature(4,\n        'shaka.util.Uint8ArrayUtils.equal',\n        'Please use shaka.util.BufferUtils.equal instead.');\n    return shaka.util.BufferUtils.equal(arr1, arr2);\n  }\n\n  /**\n   * Convert a buffer to a base64 string. The output will be standard\n   * alphabet as opposed to base64url safe alphabet.\n   * @param {BufferSource} data\n   * @return {string}\n   * @export\n   */\n  static toStandardBase64(data) {\n    const bytes = shaka.util.StringUtils.fromCharCode(\n        shaka.util.BufferUtils.toUint8(data));\n    return btoa(bytes);\n  }\n\n  /**\n   * Convert a buffer to a base64 string.  The output will always use the\n   * alternate encoding/alphabet also known as \"base64url\".\n   * @param {BufferSource} data\n   * @param {boolean=} padding If true, pad the output with equals signs.\n   *   Defaults to true.\n   * @return {string}\n   * @export\n   */\n  static toBase64(data, padding) {\n    padding = (padding == undefined) ? true : padding;\n    const base64 = shaka.util.Uint8ArrayUtils.toStandardBase64(data)\n        .replace(/\\+/g, '-').replace(/\\//g, '_');\n    return padding ? base64 : base64.replace(/[=]*$/, '');\n  }\n\n  /**\n   * Convert a base64 string to a Uint8Array.  Accepts either the standard\n   * alphabet or the alternate \"base64url\" alphabet.\n   * @param {string} str\n   * @return {!Uint8Array}\n   * @export\n   */\n  static fromBase64(str) {\n    // atob creates a \"raw string\" where each character is interpreted as a\n    // byte.\n    const bytes = window.atob(str.replace(/-/g, '+').replace(/_/g, '/'));\n    const result = new Uint8Array(bytes.length);\n    const enumerate = (it) => shaka.util.Iterables.enumerate(it);\n    for (const {i, item} of enumerate(bytes)) {\n      result[i] = item.charCodeAt(0);\n    }\n    return result;\n  }\n\n\n  /**\n   * Convert a hex string to a Uint8Array.\n   * @param {string} str\n   * @return {!Uint8Array}\n   * @export\n   */\n  static fromHex(str) {\n    const size = str.length / 2;\n    const arr = new Uint8Array(size);\n    for (const i of shaka.util.Iterables.range(size)) {\n      arr[i] = window.parseInt(str.substr(i * 2, 2), 16);\n    }\n    return arr;\n  }\n\n\n  /**\n   * Convert a buffer to a hex string.\n   * @param {BufferSource} data\n   * @return {string}\n   * @export\n   */\n  static toHex(data) {\n    const arr = shaka.util.BufferUtils.toUint8(data);\n    let hex = '';\n    for (let value of arr) {\n      value = value.toString(16);\n      if (value.length == 1) {\n        value = '0' + value;\n      }\n      hex += value;\n    }\n    return hex;\n  }\n\n\n  /**\n   * Concatenate buffers.\n   * @param {...BufferSource} varArgs\n   * @return {!Uint8Array}\n   * @export\n   */\n  static concat(...varArgs) {\n    let totalLength = 0;\n    for (const arr of varArgs) {\n      totalLength += arr.byteLength;\n    }\n\n    const result = new Uint8Array(totalLength);\n    let offset = 0;\n    for (const arr of varArgs) {\n      result.set(shaka.util.BufferUtils.toUint8(arr), offset);\n      offset += arr.byteLength;\n    }\n    return result;\n  }\n};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.media.Transmuxer');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.util.BufferUtils');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.IDestroyable');\ngoog.require('shaka.util.ManifestParserUtils');\ngoog.require('shaka.util.PublicPromise');\ngoog.require('shaka.util.Uint8ArrayUtils');\n\n\n/**\n * Transmuxer provides all operations for transmuxing from Transport\n * Stream to MP4.\n *\n * @implements {shaka.util.IDestroyable}\n */\nshaka.media.Transmuxer = class {\n  constructor() {\n    /** @private {muxjs.mp4.Transmuxer} */\n    this.muxTransmuxer_ = new muxjs.mp4.Transmuxer({\n      'keepOriginalTimestamps': true,\n    });\n\n    /** @private {shaka.util.PublicPromise} */\n    this.transmuxPromise_ = null;\n\n    /** @private {!Array.<!Uint8Array>} */\n    this.transmuxedData_ = [];\n\n    /** @private {!Array.<muxjs.mp4.ClosedCaption>} */\n    this.captions_ = [];\n\n    /** @private {!Array.<muxjs.mp4.Metadata>} */\n    this.metadata_ = [];\n\n    /** @private {boolean} */\n    this.isTransmuxing_ = false;\n\n    this.muxTransmuxer_.on('data', (segment) => this.onTransmuxed_(segment));\n\n    this.muxTransmuxer_.on('done', () => this.onTransmuxDone_());\n  }\n\n  /**\n   * @override\n   */\n  destroy() {\n    this.muxTransmuxer_.dispose();\n    this.muxTransmuxer_ = null;\n    return Promise.resolve();\n  }\n\n\n  /**\n   * Check if the content type is Transport Stream, and if muxjs is loaded.\n   * @param {string} mimeType\n   * @param {string=} contentType\n   * @return {boolean}\n   */\n  static isSupported(mimeType, contentType) {\n    const Transmuxer = shaka.media.Transmuxer;\n\n    if (!window.muxjs || !Transmuxer.isTsContainer(mimeType)) {\n      return false;\n    }\n\n    if (contentType) {\n      return MediaSource.isTypeSupported(\n          Transmuxer.convertTsCodecs(contentType, mimeType));\n    }\n\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n\n    const audioMime = Transmuxer.convertTsCodecs(ContentType.AUDIO, mimeType);\n    const videoMime = Transmuxer.convertTsCodecs(ContentType.VIDEO, mimeType);\n    return MediaSource.isTypeSupported(audioMime) ||\n        MediaSource.isTypeSupported(videoMime);\n  }\n\n\n  /**\n   * Check if the mimetype contains 'mp2t'.\n   * @param {string} mimeType\n   * @return {boolean}\n   */\n  static isTsContainer(mimeType) {\n    return mimeType.toLowerCase().split(';')[0].split('/')[1] == 'mp2t';\n  }\n\n\n  /**\n   * For transport stream, convert its codecs to MP4 codecs.\n   * @param {string} contentType\n   * @param {string} tsMimeType\n   * @return {string}\n   */\n  static convertTsCodecs(contentType, tsMimeType) {\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n    let mp4MimeType = tsMimeType.replace(/mp2t/i, 'mp4');\n    if (contentType == ContentType.AUDIO) {\n      mp4MimeType = mp4MimeType.replace('video', 'audio');\n    }\n\n    // Handle legacy AVC1 codec strings (pre-RFC 6381).\n    // Look for \"avc1.<profile>.<level>\", where profile is:\n    //   66 (baseline => 0x42)\n    //   77 (main => 0x4d)\n    //   100 (high => 0x64)\n    // Reference: https://bit.ly/2K9JI3x\n    const match = /avc1\\.(66|77|100)\\.(\\d+)/.exec(mp4MimeType);\n    if (match) {\n      let newCodecString = 'avc1.';\n\n      const profile = match[1];\n      if (profile == '66') {\n        newCodecString += '4200';\n      } else if (profile == '77') {\n        newCodecString += '4d00';\n      } else {\n        goog.asserts.assert(profile == '100',\n            'Legacy avc1 parsing code out of sync with regex!');\n        newCodecString += '6400';\n      }\n\n      // Convert the level to hex and append to the codec string.\n      const level = Number(match[2]);\n      goog.asserts.assert(level < 256,\n          'Invalid legacy avc1 level number!');\n      newCodecString += (level >> 4).toString(16);\n      newCodecString += (level & 0xf).toString(16);\n\n      mp4MimeType = mp4MimeType.replace(match[0], newCodecString);\n    }\n\n    return mp4MimeType;\n  }\n\n\n  /**\n   * Transmux from Transport stream to MP4, using the mux.js library.\n   * @param {BufferSource} data\n   * @return {!Promise.<{data: !Uint8Array,\n   *                     captions: !Array.<!muxjs.mp4.ClosedCaption>,\n   *                     metadata: !Array.<!Object>}>}\n   */\n  transmux(data) {\n    goog.asserts.assert(!this.isTransmuxing_,\n        'No transmuxing should be in progress.');\n    this.isTransmuxing_ = true;\n    this.transmuxPromise_ = new shaka.util.PublicPromise();\n    this.transmuxedData_ = [];\n    this.captions_ = [];\n    this.metadata_ = [];\n\n    const dataArray = shaka.util.BufferUtils.toUint8(data);\n    this.muxTransmuxer_.push(dataArray);\n    this.muxTransmuxer_.flush();\n\n    // Workaround for https://bit.ly/Shaka1449 mux.js not\n    // emitting 'data' and 'done' events.\n    // mux.js code is synchronous, so if onTransmuxDone_ has\n    // not been called by now, it's not going to be.\n    // Treat it as a transmuxing failure and reject the promise.\n    if (this.isTransmuxing_) {\n      this.transmuxPromise_.reject(new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.MEDIA,\n          shaka.util.Error.Code.TRANSMUXING_FAILED));\n    }\n    return this.transmuxPromise_;\n  }\n\n\n  /**\n   * Handles the 'data' event of the transmuxer.\n   * Extracts the cues from the transmuxed segment, and adds them to an array.\n   * Stores the transmuxed data in another array, to pass it back to\n   * MediaSourceEngine, and append to the source buffer.\n   *\n   * @param {muxjs.mp4.Transmuxer.Segment} segment\n   * @private\n   */\n  onTransmuxed_(segment) {\n    this.captions_ = segment.captions;\n    this.metadata_ = segment.metadata;\n    this.transmuxedData_.push(\n        shaka.util.Uint8ArrayUtils.concat(segment.initSegment, segment.data));\n  }\n\n\n  /**\n   * Handles the 'done' event of the transmuxer.\n   * Resolves the transmux Promise, and returns the transmuxed data.\n   * @private\n   */\n  onTransmuxDone_() {\n    const output = {\n      data: shaka.util.Uint8ArrayUtils.concat(...this.transmuxedData_),\n      captions: this.captions_,\n      metadata: this.metadata_,\n    };\n\n    this.transmuxPromise_.resolve(output);\n    this.isTransmuxing_ = false;\n  }\n};\n\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.util.DelayedTick');\n\n\n/**\n * @summary\n * This class wraps a function so that we can defer executing the function by X\n * seconds.\n *\n * @final\n */\nshaka.util.DelayedTick = class {\n  /**\n   * @param {function()} onTick\n   */\n  constructor(onTick) {\n    /** @private {function()} */\n    this.onTick_ = onTick;\n\n    /** @private {?function()} */\n    this.cancelPending_ = null;\n  }\n\n  /**\n   * Call |onTick| after |delayInSeconds| has elapsed. If there is already a\n   * pending call to |onTick|, the pending call will be canceled.\n   *\n   * @param {number} delayInSeconds\n   * @return {!shaka.util.DelayedTick}\n   */\n  tickAfter(delayInSeconds) {\n    // We only want one timeout set at a time, so make sure no other timeouts\n    // are running.\n    this.stop();\n\n    // We will wrap these values in a function to allow us to cancel the timeout\n    // we are about to create.\n    let alive = true;\n    let timeoutId = null;\n\n    this.cancelPending_ = () => {\n      window.clearTimeout(timeoutId);\n      alive = false;\n    };\n\n    // For some reason, a timeout may still execute after we have cleared it in\n    // our tests. We will wrap the callback so that we can double-check our\n    // |alive| flag.\n    const onTick = () => {\n      if (alive) {\n        this.onTick_();\n      }\n    };\n\n    timeoutId = window.setTimeout(onTick, delayInSeconds * 1000);\n\n    return this;\n  }\n\n  /**\n   * Cancel any pending calls to |onTick|. If there are no pending calls to\n   * |onTick|, this will be a no-op.\n   */\n  stop() {\n    if (this.cancelPending_) {\n      this.cancelPending_();\n      this.cancelPending_ = null;\n    }\n  }\n};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.util.Timer');\n\ngoog.require('shaka.util.DelayedTick');\n\n\n/**\n * A timer allows a single function to be executed at a later time or at\n * regular intervals.\n *\n * @final\n * @export\n */\nshaka.util.Timer = class {\n  /**\n   * Create a new timer. A timer is committed to a single callback function.\n   * While there is no technical reason to do this, it is far easier to\n   * understand and use timers when they are connected to one functional idea.\n   *\n   * @param {function()} onTick\n   */\n  constructor(onTick) {\n    /**\n     * Each time our timer \"does work\", we call that a \"tick\". The name comes\n     * from old analog clocks.\n     *\n     * @private {function()}\n     */\n    this.onTick_ = onTick;\n\n    /** @private {shaka.util.DelayedTick} */\n    this.ticker_ = null;\n  }\n\n  /**\n   * Have the timer call |onTick| now.\n   *\n   * @return {!shaka.util.Timer}\n   * @export\n   */\n  tickNow() {\n    this.stop();\n    this.onTick_();\n\n    return this;\n  }\n\n  /**\n   * Have the timer call |onTick| after |seconds| has elapsed unless |stop| is\n   * called first.\n   *\n   * @param {number} seconds\n   * @return {!shaka.util.Timer}\n   * @export\n   */\n  tickAfter(seconds) {\n    this.stop();\n\n    this.ticker_ = new shaka.util.DelayedTick(() => {\n      this.onTick_();\n    }).tickAfter(seconds);\n\n    return this;\n  }\n\n  /**\n   * Have the timer call |onTick| every |seconds| until |stop| is called.\n   *\n   * @param {number} seconds\n   * @return {!shaka.util.Timer}\n   * @export\n   */\n  tickEvery(seconds) {\n    this.stop();\n\n    this.ticker_ = new shaka.util.DelayedTick(() => {\n      // Schedule the timer again first. |onTick_| could cancel the timer and\n      // rescheduling first simplifies the implementation.\n      this.ticker_.tickAfter(seconds);\n      this.onTick_();\n    }).tickAfter(seconds);\n\n    return this;\n  }\n\n  /**\n   * Stop the timer and clear the previous behaviour. The timer is still usable\n   * after calling |stop|.\n   *\n   * @export\n   */\n  stop() {\n    if (this.ticker_) {\n      this.ticker_.stop();\n      this.ticker_ = null;\n    }\n  }\n};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.net.Backoff');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.Timer');\n\n\n/**\n * Backoff represents delay and backoff state.  This is used by NetworkingEngine\n * for individual requests and by StreamingEngine to retry streaming failures.\n *\n * @final\n */\nshaka.net.Backoff = class {\n  /**\n   * @param {shaka.extern.RetryParameters} parameters\n   * @param {boolean=} autoReset  If true, start at a \"first retry\" state and\n   *   and auto-reset that state when we reach maxAttempts.\n   *   Default set to false.\n   */\n  constructor(parameters, autoReset = false) {\n    // Set defaults as we unpack these, so that individual app-level requests in\n    // NetworkingEngine can be missing parameters.\n\n    const defaults = shaka.net.Backoff.defaultRetryParameters();\n\n    /**\n     * @const\n     * @private {number}\n     */\n    this.maxAttempts_ = (parameters.maxAttempts == null) ?\n        defaults.maxAttempts : parameters.maxAttempts;\n\n    goog.asserts.assert(this.maxAttempts_ >= 1, 'maxAttempts should be >= 1');\n\n    /**\n     * @const\n     * @private {number}\n     */\n    this.baseDelay_ = (parameters.baseDelay == null) ?\n        defaults.baseDelay : parameters.baseDelay;\n\n    goog.asserts.assert(this.baseDelay_ >= 0, 'baseDelay should be >= 0');\n\n    /**\n     * @const\n     * @private {number}\n     */\n    this.fuzzFactor_ = (parameters.fuzzFactor == null) ?\n        defaults.fuzzFactor : parameters.fuzzFactor;\n\n    goog.asserts.assert(this.fuzzFactor_ >= 0, 'fuzzFactor should be >= 0');\n\n    /**\n     * @const\n     * @private {number}\n     */\n    this.backoffFactor_ = (parameters.backoffFactor == null) ?\n        defaults.backoffFactor : parameters.backoffFactor;\n\n    goog.asserts.assert(\n        this.backoffFactor_ >= 0, 'backoffFactor should be >= 0');\n\n    /** @private {number} */\n    this.numAttempts_ = 0;\n\n    /** @private {number} */\n    this.nextUnfuzzedDelay_ = this.baseDelay_;\n\n    /** @private {boolean} */\n    this.autoReset_ = autoReset;\n\n    if (this.autoReset_) {\n      // There is no delay before the first attempt.  In StreamingEngine (the\n      // intended user of auto-reset mode), the first attempt was implied, so we\n      // reset numAttempts to 1.  Therefore maxAttempts (which includes the\n      // first attempt) must be at least 2 for us to see a delay.\n      goog.asserts.assert(this.maxAttempts_ >= 2,\n          'maxAttempts must be >= 2 for autoReset == true');\n      this.numAttempts_ = 1;\n    }\n  }\n\n  /**\n   * @return {!Promise} Resolves when the caller may make an attempt, possibly\n   *   after a delay.  Rejects if no more attempts are allowed.\n   */\n  async attempt() {\n    if (this.numAttempts_ >= this.maxAttempts_) {\n      if (this.autoReset_) {\n        this.reset_();\n      } else {\n        throw new shaka.util.Error(\n            shaka.util.Error.Severity.CRITICAL,\n            shaka.util.Error.Category.PLAYER,\n            shaka.util.Error.Code.ATTEMPTS_EXHAUSTED);\n      }\n    }\n\n    const currentAttempt = this.numAttempts_;\n    this.numAttempts_++;\n\n    if (currentAttempt == 0) {\n      goog.asserts.assert(!this.autoReset_, 'Failed to delay with auto-reset!');\n      return;\n    }\n\n    // We've already tried before, so delay the Promise.\n\n    // Fuzz the delay to avoid tons of clients hitting the server at once\n    // after it recovers from whatever is causing it to fail.\n    const fuzzedDelayMs = shaka.net.Backoff.fuzz_(\n        this.nextUnfuzzedDelay_, this.fuzzFactor_);\n\n    await new Promise((resolve) => {\n      shaka.net.Backoff.defer(fuzzedDelayMs, resolve);\n    });\n\n    // Update delay_ for next time.\n    this.nextUnfuzzedDelay_ *= this.backoffFactor_;\n  }\n\n  /**\n   * Gets a copy of the default retry parameters.\n   *\n   * @return {shaka.extern.RetryParameters}\n   */\n  static defaultRetryParameters() {\n    // Use a function rather than a constant member so the calling code can\n    // modify the values without affecting other call results.\n    return {\n      maxAttempts: 2,\n      baseDelay: 1000,\n      backoffFactor: 2,\n      fuzzFactor: 0.5,\n      timeout: 0,\n    };\n  }\n\n  /**\n   * Fuzz the input value by +/- fuzzFactor.  For example, a fuzzFactor of 0.5\n   * will create a random value that is between 50% and 150% of the input value.\n   *\n   * @param {number} value\n   * @param {number} fuzzFactor\n   * @return {number} The fuzzed value\n   * @private\n   */\n  static fuzz_(value, fuzzFactor) {\n    // A random number between -1 and +1.\n    const negToPosOne = (Math.random() * 2.0) - 1.0;\n\n    // A random number between -fuzzFactor and +fuzzFactor.\n    const negToPosFuzzFactor = negToPosOne * fuzzFactor;\n\n    // The original value, fuzzed by +/- fuzzFactor.\n    return value * (1.0 + negToPosFuzzFactor);\n  }\n\n  /**\n   * Reset state in autoReset mode.\n   * @private\n   */\n  reset_() {\n    goog.asserts.assert(this.autoReset_, 'Should only be used for auto-reset!');\n    this.numAttempts_ = 1;\n    this.nextUnfuzzedDelay_ = this.baseDelay_;\n  }\n\n  /**\n   * This method is only public for testing. It allows us to intercept the\n   * time-delay call.\n   *\n   * @param {number} delayInMs\n   * @param {function()} callback\n   */\n  static defer(delayInMs, callback) {\n    const timer = new shaka.util.Timer(callback);\n    timer.tickAfter(delayInMs / 1000);\n  }\n};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.util.AbortableOperation');\n\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.PublicPromise');\n\n/**\n * A utility to wrap abortable operations.  Note that these are not cancelable.\n * Cancelation implies undoing what has been done so far, whereas aborting only\n * means that further work is stopped.\n *\n * @implements {shaka.extern.IAbortableOperation.<T>}\n * @template T\n * @export\n */\nshaka.util.AbortableOperation = class {\n  /**\n   * @param {!Promise.<T>} promise\n   *   A Promise which represents the underlying operation.  It is resolved when\n   *   the operation is complete, and rejected if the operation fails or is\n   *   aborted.  Aborted operations should be rejected with a shaka.util.Error\n   *   object using the error code OPERATION_ABORTED.\n   * @param {function():!Promise} onAbort\n   *   Will be called by this object to abort the underlying operation.\n   *   This is not cancelation, and will not necessarily result in any work\n   *   being undone.  abort() should return a Promise which is resolved when the\n   *   underlying operation has been aborted.  The returned Promise should never\n   *   be rejected.\n   */\n  constructor(promise, onAbort) {\n    /** @const {!Promise.<T>} */\n    this.promise = promise;\n\n    /** @private {function():!Promise} */\n    this.onAbort_ = onAbort;\n\n    /** @private {boolean} */\n    this.aborted_ = false;\n  }\n\n  /**\n   * @param {!shaka.util.Error} error\n   * @return {!shaka.util.AbortableOperation} An operation which has already\n   *   failed with the error given by the caller.\n   * @export\n   */\n  static failed(error) {\n    return new shaka.util.AbortableOperation(\n        Promise.reject(error),\n        () => Promise.resolve());\n  }\n\n  /**\n   * @return {!shaka.util.AbortableOperation} An operation which has already\n   *   failed with the error OPERATION_ABORTED.\n   * @export\n   */\n  static aborted() {\n    const p = Promise.reject(shaka.util.AbortableOperation.abortError());\n    // Silence uncaught rejection errors, which may otherwise occur any place\n    // we don't explicitly handle aborted operations.\n    p.catch(() => {});\n    return new shaka.util.AbortableOperation(p, () => Promise.resolve());\n  }\n\n  /** @return {!shaka.util.Error} */\n  static abortError() {\n    return new shaka.util.Error(\n        shaka.util.Error.Severity.CRITICAL,\n        shaka.util.Error.Category.PLAYER,\n        shaka.util.Error.Code.OPERATION_ABORTED);\n  }\n\n  /**\n   * @param {U} value\n   * @return {!shaka.util.AbortableOperation.<U>} An operation which has already\n   *   completed with the given value.\n   * @template U\n   * @export\n   */\n  static completed(value) {\n    return new shaka.util.AbortableOperation(\n        Promise.resolve(value),\n        () => Promise.resolve());\n  }\n\n  /**\n   * @param {!Promise.<U>} promise\n   * @return {!shaka.util.AbortableOperation.<U>} An operation which cannot be\n   *   aborted.  It will be completed when the given Promise is resolved, or\n   *   will be failed when the given Promise is rejected.\n   * @template U\n   * @export\n   */\n  static notAbortable(promise) {\n    return new shaka.util.AbortableOperation(\n        promise,\n        // abort() here will return a Promise which is resolved when the input\n        // promise either resolves or fails.\n        () => promise.catch(() => {}));\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  abort() {\n    this.aborted_ = true;\n    return this.onAbort_();\n  }\n\n  /**\n   * @param {!Array.<!shaka.util.AbortableOperation>} operations\n   * @return {!shaka.util.AbortableOperation} An operation which is resolved\n   *   when all operations are successful and fails when any operation fails.\n   *   For this operation, abort() aborts all given operations.\n   * @export\n   */\n  static all(operations) {\n    return new shaka.util.AbortableOperation(\n        Promise.all(operations.map((op) => op.promise)),\n        () => Promise.all(operations.map((op) => op.abort())));\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  finally(onFinal) {\n    this.promise.then((value) => onFinal(true), (e) => onFinal(false));\n    return this;\n  }\n\n  /**\n   * @param {(undefined|\n   *          function(T):U|\n   *          function(T):!Promise.<U>|\n   *          function(T):!shaka.util.AbortableOperation.<U>)} onSuccess\n   *   A callback to be invoked after this operation is complete, to chain to\n   *   another operation.  The callback can return a plain value, a Promise to\n   *   an asynchronous value, or another AbortableOperation.\n   * @param {function(*)=} onError\n   *   An optional callback to be invoked if this operation fails, to perform\n   *   some cleanup or error handling.  Analogous to the second parameter of\n   *   Promise.prototype.then.\n   * @return {!shaka.util.AbortableOperation.<U>} An operation which is resolved\n   *   when this operation and the operation started by the callback are both\n   *   complete.\n   * @template U\n   * @export\n   */\n  chain(onSuccess, onError) {\n    const newPromise = new shaka.util.PublicPromise();\n    const abortError = shaka.util.AbortableOperation.abortError();\n\n    // If called before \"this\" completes, just abort \"this\".\n    let abort = () => {\n      newPromise.reject(abortError);\n      return this.abort();\n    };\n\n    const makeCallback = (isSuccess) => {\n      return (value) => {\n        if (this.aborted_ && isSuccess) {\n          // If \"this\" is not abortable(), or if abort() is called after \"this\"\n          // is complete but before the next stage in the chain begins, we\n          // should stop right away.\n          newPromise.reject(abortError);\n          return;\n        }\n\n        const cb = isSuccess ? onSuccess : onError;\n        if (!cb) {\n          // No callback?  Pass it along.\n          const next = isSuccess ? newPromise.resolve : newPromise.reject;\n          next(value);\n          return;\n        }\n\n        // Call the callback, interpret the return value, set the Promise state,\n        // and get the next abort function.\n        abort = shaka.util.AbortableOperation.wrapChainCallback_(\n            cb, value, newPromise);\n      };\n    };\n    this.promise.then(makeCallback(true), makeCallback(false));\n\n    return new shaka.util.AbortableOperation(\n        newPromise,\n        // By creating a closure around abort(), we can update the value of\n        // abort() at various stages.\n        () => abort());\n  }\n\n  /**\n   * @param {(function(T):U|\n   *          function(T):!Promise.<U>|\n   *          function(T):!shaka.util.AbortableOperation.<U>|\n   *          function(*))} callback\n   *   A callback to be invoked with the given value.\n   * @param {T} value\n   * @param {!shaka.util.PublicPromise} newPromise The promise for the next\n   *   stage in the chain.\n   * @return {function():!Promise} The next abort() function for the chain.\n   * @private\n   * @template T, U\n   */\n  static wrapChainCallback_(callback, value, newPromise) {\n    try {\n      const ret = callback(value);\n\n      if (ret && ret.promise && ret.abort) {\n        // This is an abortable operation, with its own abort() method.\n        // After this point, abort() should abort the operation from the\n        // callback, and the new promise should be tied to the promise\n        // from the callback's operation.\n        newPromise.resolve(ret.promise);\n        // This used to say \"return ret.abort;\", but it caused subtle issues by\n        // unbinding part of the abort chain.  There is now a test to ensure\n        // that we don't call abort with the wrong \"this\".\n        return () => ret.abort();\n      } else {\n        // This is a Promise or a plain value, and this step cannot be aborted.\n        newPromise.resolve(ret);\n        // Abort is complete when the returned value/Promise is resolved or\n        // fails, but never fails itself nor returns a value.\n        return () => Promise.resolve(ret).then(() => {}, () => {});\n      }\n    } catch (exception) {\n      // The callback threw an exception or error.  Reject the new Promise and\n      // resolve any future abort call right away.\n      newPromise.reject(exception);\n      return () => Promise.resolve();\n    }\n  }\n};\n\n/**\n * @const {!Promise.<T>}\n * @exportInterface\n */\n// eslint-disable-next-line no-restricted-syntax\nshaka.util.AbortableOperation.prototype.promise;\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.util.FakeEvent');\n\n\n/**\n * @summary Create an Event work-alike object based on the provided dictionary.\n * The event should contain all of the same properties from the dict.\n *\n * @extends {Event}\n * @export\n */\nshaka.util.FakeEvent = class {\n  /**\n   * @param {string} type\n   * @param {Object=} dict\n   */\n  constructor(type, dict = {}) {\n    // Take properties from dict if present.\n    for (const key in dict) {\n      Object.defineProperty(this, key, {\n        value: dict[key],\n        writable: true,\n        enumerable: true,\n      });\n    }\n\n    // The properties below cannot be set by the dict.  They are all provided\n    // for compatibility with native events.\n\n    /** @const {boolean} */\n    this.bubbles = false;\n\n    /** @type {boolean} */\n    this.cancelable = false;\n\n    /** @type {boolean} */\n    this.defaultPrevented = false;\n\n    /**\n     * According to MDN, Chrome uses high-res timers instead of epoch time.\n     * Follow suit so that timeStamps on FakeEvents use the same base as\n     * on native Events.\n     * @const {number}\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/Event/timeStamp\n     */\n    this.timeStamp = window.performance && window.performance.now ?\n        window.performance.now() : Date.now();\n\n    /** @const {string} */\n    this.type = type;\n\n    /** @const {boolean} */\n    this.isTrusted = false;\n\n    /** @type {EventTarget} */\n    this.currentTarget = null;\n\n    /** @type {EventTarget} */\n    this.target = null;\n\n    /**\n     * Non-standard property read by FakeEventTarget to stop processing\n     * listeners.\n     * @type {boolean}\n     */\n    this.stopped = false;\n  }\n\n  /**\n   * Prevents the default action of the event.  Has no effect if the event isn't\n   * cancellable.\n   * @override\n   */\n  preventDefault() {\n    if (this.cancelable) {\n      this.defaultPrevented = true;\n    }\n  }\n\n  /**\n   * Stops processing event listeners for this event.  Provided for\n   * compatibility with native Events.\n   * @override\n   */\n  stopImmediatePropagation() {\n    this.stopped = true;\n  }\n\n  /**\n   * Does nothing, since FakeEvents do not bubble.  Provided for compatibility\n   * with native Events.\n   * @override\n   */\n  stopPropagation() {}\n};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.util.MultiMap');\n\n\n/**\n * @summary A simple multimap template.\n * @template T\n */\nshaka.util.MultiMap = class {\n  constructor() {\n    /** @private {!Object.<string, !Array.<T>>} */\n    this.map_ = {};\n  }\n\n\n  /**\n   * Add a key, value pair to the map.\n   * @param {string} key\n   * @param {T} value\n   */\n  push(key, value) {\n    if (this.map_.hasOwnProperty(key)) {\n      this.map_[key].push(value);\n    } else {\n      this.map_[key] = [value];\n    }\n  }\n\n\n  /**\n   * Get a list of values by key.\n   * @param {string} key\n   * @return {Array.<T>} or null if no such key exists.\n   */\n  get(key) {\n    const list = this.map_[key];\n    // slice() clones the list so that it and the map can each be modified\n    // without affecting the other.\n    return list ? list.slice() : null;\n  }\n\n\n  /**\n   * Get a list of all values.\n   * @return {!Array.<T>}\n   */\n  getAll() {\n    const list = [];\n    for (const key in this.map_) {\n      list.push(...this.map_[key]);\n    }\n    return list;\n  }\n\n\n  /**\n   * Remove a specific value, if it exists.\n   * @param {string} key\n   * @param {T} value\n   */\n  remove(key, value) {\n    if (!(key in this.map_)) {\n      return;\n    }\n    this.map_[key] = this.map_[key].filter((i) => i != value);\n  }\n\n\n  /**\n   * Clear all keys and values from the multimap.\n   */\n  clear() {\n    this.map_ = {};\n  }\n\n\n  /**\n   * @param {function(string, !Array.<T>)} callback\n   */\n  forEach(callback) {\n    for (const key in this.map_) {\n      callback(key, this.map_[key]);\n    }\n  }\n};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.util.FakeEventTarget');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.util.FakeEvent');\ngoog.require('shaka.util.MultiMap');\n\n\n/**\n * @summary A work-alike for EventTarget.  Only DOM elements may be true\n * EventTargets, but this can be used as a base class to provide event dispatch\n * to non-DOM classes.  Only FakeEvents should be dispatched.\n *\n * @implements {EventTarget}\n * @exportInterface\n */\nshaka.util.FakeEventTarget = class {\n  constructor() {\n    /**\n     * @private {!shaka.util.MultiMap.<shaka.util.FakeEventTarget.ListenerType>}\n     */\n    this.listeners_ = new shaka.util.MultiMap();\n\n    /**\n     * The target of all dispatched events.  Defaults to |this|.\n     * @type {EventTarget}\n     */\n    this.dispatchTarget = this;\n  }\n\n  /**\n   * Add an event listener to this object.\n   *\n   * @param {string} type The event type to listen for.\n   * @param {shaka.util.FakeEventTarget.ListenerType} listener The callback or\n   *   listener object to invoke.\n   * @param {(!AddEventListenerOptions|boolean)=} options Ignored.\n   * @override\n   * @exportInterface\n   */\n  addEventListener(type, listener, options) {\n    this.listeners_.push(type, listener);\n  }\n\n  /**\n   * Remove an event listener from this object.\n   *\n   * @param {string} type The event type for which you wish to remove a\n   *   listener.\n   * @param {shaka.util.FakeEventTarget.ListenerType} listener The callback or\n   *   listener object to remove.\n   * @param {(EventListenerOptions|boolean)=} options Ignored.\n   * @override\n   * @exportInterface\n   */\n  removeEventListener(type, listener, options) {\n    this.listeners_.remove(type, listener);\n  }\n\n  /**\n   * Dispatch an event from this object.\n   *\n   * @param {!Event} event The event to be dispatched from this object.\n   * @return {boolean} True if the default action was prevented.\n   * @override\n   * @exportInterface\n   */\n  dispatchEvent(event) {\n    // In many browsers, it is complex to overwrite properties of actual Events.\n    // Here we expect only to dispatch FakeEvents, which are simpler.\n    goog.asserts.assert(event instanceof shaka.util.FakeEvent,\n        'FakeEventTarget can only dispatch FakeEvents!');\n\n    const listeners = this.listeners_.get(event.type) || [];\n\n    // Execute this event on listeners until the event has been stopped or we\n    // run out of listeners.\n    for (const listener of listeners) {\n      // Do this every time, since events can be re-dispatched from handlers.\n      event.target = this.dispatchTarget;\n      event.currentTarget = this.dispatchTarget;\n\n      try {\n        // Check for the |handleEvent| member to test if this is a\n        // |EventListener| instance or a basic function.\n        if (listener.handleEvent) {\n          listener.handleEvent(event);\n        } else {\n          // eslint-disable-next-line no-restricted-syntax\n          listener.call(this, event);\n        }\n      } catch (exception) {\n        // Exceptions during event handlers should not affect the caller,\n        // but should appear on the console as uncaught, according to MDN:\n        // https://mzl.la/2JXgwRo\n        shaka.log.error('Uncaught exception in event handler', exception,\n            exception ? exception.message : null,\n            exception ? exception.stack : null);\n      }\n\n      if (event.stopped) {\n        break;\n      }\n    }\n\n    return event.defaultPrevented;\n  }\n};\n\n/**\n * These are the listener types defined in the closure extern for EventTarget.\n * @typedef {EventListener|function(!Event):*}\n * @exportInterface\n */\nshaka.util.FakeEventTarget.ListenerType;\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.util.ObjectUtils');\n\n\nshaka.util.ObjectUtils = class {\n  /**\n   * Performs a deep clone of the given simple object.  This does not copy\n   * prototypes, custom properties (e.g. read-only), or multiple references to\n   * the same object.  If the caller needs these fields, it will need to set\n   * them after this returns.\n   *\n   * @template T\n   * @param {T} arg\n   * @return {T}\n   */\n  static cloneObject(arg) {\n    const seenObjects = new Set();\n    // This recursively clones the value |val|, using the captured variable\n    // |seenObjects| to track the objects we have already cloned.\n    const clone = (val) => {\n      switch (typeof val) {\n        case 'undefined':\n        case 'boolean':\n        case 'number':\n        case 'string':\n        case 'symbol':\n        case 'function':\n          return val;\n        case 'object':\n        default: {\n          // typeof null === 'object'\n          if (!val) {\n            return val;\n          }\n\n          // This covers Uint8Array and friends, even without a TypedArray\n          // base-class constructor.\n          const isTypedArray =\n              val.buffer && val.buffer.constructor == ArrayBuffer;\n          if (isTypedArray) {\n            return val;\n          }\n\n          if (seenObjects.has(val)) {\n            return null;\n          }\n\n          const isArray = val.constructor == Array;\n          if (val.constructor != Object && !isArray) {\n            return null;\n          }\n\n          seenObjects.add(val);\n          const ret = isArray ? [] : {};\n          // Note |name| will equal a number for arrays.\n          for (const name in val) {\n            ret[name] = clone(val[name]);\n          }\n\n          // Length is a non-enumerable property, but we should copy it over in\n          // case it is not the default.\n          if (isArray) {\n            ret.length = val.length;\n          }\n          return ret;\n        }\n      }\n    };\n    return clone(arg);\n  }\n\n  /**\n   * Performs a shallow clone of the given simple object.  This does not copy\n   * prototypes or custom properties (e.g. read-only).\n   *\n   * @template T\n   * @param {T} original\n   * @return {T}\n   */\n  static shallowCloneObject(original) {\n    const clone = /** @type {?} */({});\n    for (const k in original) {\n      clone[k] = original[k];\n    }\n    return clone;\n  }\n};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.util.ArrayUtils');\n\n\n/**\n * @namespace shaka.util.ArrayUtils\n * @summary Array utility functions.\n */\n\n\nshaka.util.ArrayUtils = class {\n  /**\n   * Returns whether the two values contain the same value.  This correctly\n   * handles comparisons involving NaN.\n   * @param {T} a\n   * @param {T} b\n   * @return {boolean}\n   * @template T\n   */\n  static defaultEquals(a, b) {\n    // NaN !== NaN, so we need to special case it.\n    if (typeof a === 'number' &&\n        typeof b === 'number' && isNaN(a) && isNaN(b)) {\n      return true;\n    }\n    return a === b;\n  }\n\n\n  /**\n   * Remove given element from array (assumes no duplicates).\n   * @param {!Array.<T>} array\n   * @param {T} element\n   * @template T\n   */\n  static remove(array, element) {\n    const index = array.indexOf(element);\n    if (index > -1) {\n      array.splice(index, 1);\n    }\n  }\n\n\n  /**\n   * Count the number of items in the list that pass the check function.\n   * @param {!Array.<T>} array\n   * @param {function(T):boolean} check\n   * @return {number}\n   * @template T\n   */\n  static count(array, check) {\n    let count = 0;\n\n    for (const element of array) {\n      count += check(element) ? 1 : 0;\n    }\n\n    return count;\n  }\n\n\n  /**\n   * Determines if the given arrays contain equal elements in any order.\n   *\n   * @param {!Array.<T>} a\n   * @param {!Array.<T>} b\n   * @param {function(T, T):boolean=} compareFn\n   * @return {boolean}\n   * @template T\n   */\n  static hasSameElements(a, b, compareFn) {\n    if (!compareFn) {\n      compareFn = shaka.util.ArrayUtils.defaultEquals;\n    }\n    if (a.length != b.length) {\n      return false;\n    }\n\n    const copy = b.slice();\n    for (const item of a) {\n      const idx = copy.findIndex((other) => compareFn(item, other));\n      if (idx == -1) {\n        return false;\n      }\n      // Since order doesn't matter, just swap the last element with\n      // this one and then drop the last element.\n      copy[idx] = copy[copy.length - 1];\n      copy.pop();\n    }\n\n    return copy.length == 0;\n  }\n\n\n  /**\n   * Determines if the given arrays contain equal elements in the same order.\n   *\n   * @param {!Array.<T>} a\n   * @param {!Array.<T>} b\n   * @param {function(T, T):boolean=} compareFn\n   * @return {boolean}\n   * @template T\n   */\n  static equal(a, b, compareFn) {\n    if (!compareFn) {\n      compareFn = shaka.util.ArrayUtils.defaultEquals;\n    }\n    if (a.length != b.length) {\n      return false;\n    }\n\n    for (let i = 0; i < a.length; i++) {\n      if (!compareFn(a[i], b[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.util.OperationManager');\n\ngoog.require('shaka.util.ArrayUtils');\ngoog.require('shaka.util.IDestroyable');\n\n/**\n * A utility for cleaning up AbortableOperations, to help simplify common\n * patterns and reduce code duplication.\n *\n * @implements {shaka.util.IDestroyable}\n */\nshaka.util.OperationManager = class {\n  constructor() {\n    /** @private {!Array.<!shaka.extern.IAbortableOperation>} */\n    this.operations_ = [];\n  }\n\n  /**\n   * Manage an operation.  This means aborting it on destroy() and removing it\n   * from the management set when it complete.\n   *\n   * @param {!shaka.extern.IAbortableOperation} operation\n   */\n  manage(operation) {\n    this.operations_.push(operation.finally(() => {\n      shaka.util.ArrayUtils.remove(this.operations_, operation);\n    }));\n  }\n\n  /** @override */\n  destroy() {\n    const cleanup = [];\n    for (const op of this.operations_) {\n      // Catch and ignore any failures.  This silences error logs in the\n      // JavaScript console about uncaught Promise failures.\n      op.promise.catch(() => {});\n\n      // Now abort the operation.\n      cleanup.push(op.abort());\n    }\n\n    this.operations_ = [];\n    return Promise.all(cleanup);\n  }\n};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.net.NetworkingEngine');\ngoog.provide('shaka.net.NetworkingEngine.RequestType');\ngoog.provide('shaka.net.NetworkingEngine.PendingRequest');\n\ngoog.require('goog.Uri');\ngoog.require('goog.asserts');\ngoog.require('shaka.net.Backoff');\ngoog.require('shaka.util.AbortableOperation');\ngoog.require('shaka.util.BufferUtils');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.FakeEvent');\ngoog.require('shaka.util.FakeEventTarget');\ngoog.require('shaka.util.IDestroyable');\ngoog.require('shaka.util.ObjectUtils');\ngoog.require('shaka.util.OperationManager');\n\n\n/**\n * @event shaka.net.NetworkingEngine.RetryEvent\n * @description Fired when the networking engine receives a recoverable error\n *   and retries.\n * @property {string} type\n *   'retry'\n * @property {?shaka.util.Error} error\n *   The error that caused the retry. If it was a non-Shaka error, this is set\n *   to null.\n * @exportDoc\n */\n\n\n/**\n * NetworkingEngine wraps all networking operations.  This accepts plugins that\n * handle the actual request.  A plugin is registered using registerScheme.\n * Each scheme has at most one plugin to handle the request.\n *\n * @implements {shaka.util.IDestroyable}\n * @export\n */\nshaka.net.NetworkingEngine = class extends shaka.util.FakeEventTarget {\n  /**\n   * @param {function(number, number)=} onProgressUpdated Called when a progress\n   *   event is triggered. Passed the duration, in milliseconds, that the\n   *   request took, and the number of bytes transferred.\n   */\n  constructor(onProgressUpdated) {\n    super();\n\n    /** @private {boolean} */\n    this.destroyed_ = false;\n\n    /** @private {!shaka.util.OperationManager} */\n    this.operationManager_ = new shaka.util.OperationManager();\n\n    /** @private {!Set.<shaka.extern.RequestFilter>} */\n    this.requestFilters_ = new Set();\n\n    /** @private {!Set.<shaka.extern.ResponseFilter>} */\n    this.responseFilters_ = new Set();\n\n    /** @private {?function(number, number)} */\n    this.onProgressUpdated_ = onProgressUpdated || null;\n  }\n\n  /**\n   * Registers a scheme plugin.  This plugin will handle all requests with the\n   * given scheme.  If a plugin with the same scheme already exists, it is\n   * replaced, unless the existing plugin is of higher priority.\n   * If no priority is provided, this defaults to the highest priority of\n   * APPLICATION.\n   *\n   * @param {string} scheme\n   * @param {shaka.extern.SchemePlugin} plugin\n   * @param {number=} priority\n   * @export\n   */\n  static registerScheme(scheme, plugin, priority) {\n    goog.asserts.assert(\n        priority == undefined || priority > 0, 'explicit priority must be > 0');\n    priority =\n        priority || shaka.net.NetworkingEngine.PluginPriority.APPLICATION;\n    const existing = shaka.net.NetworkingEngine.schemes_[scheme];\n    if (!existing || priority >= existing.priority) {\n      shaka.net.NetworkingEngine.schemes_[scheme] = {\n        priority: priority,\n        plugin: plugin,\n      };\n    }\n  }\n\n  /**\n   * Removes a scheme plugin.\n   *\n   * @param {string} scheme\n   * @export\n   */\n  static unregisterScheme(scheme) {\n    delete shaka.net.NetworkingEngine.schemes_[scheme];\n  }\n\n  /**\n   * Registers a new request filter.  All filters are applied in the order they\n   * are registered.\n   *\n   * @param {shaka.extern.RequestFilter} filter\n   * @export\n   */\n  registerRequestFilter(filter) {\n    this.requestFilters_.add(filter);\n  }\n\n  /**\n   * Removes a request filter.\n   *\n   * @param {shaka.extern.RequestFilter} filter\n   * @export\n   */\n  unregisterRequestFilter(filter) {\n    this.requestFilters_.delete(filter);\n  }\n\n  /**\n   * Clears all request filters.\n   *\n   * @export\n   */\n  clearAllRequestFilters() {\n    this.requestFilters_.clear();\n  }\n\n  /**\n   * Registers a new response filter.  All filters are applied in the order they\n   * are registered.\n   *\n   * @param {shaka.extern.ResponseFilter} filter\n   * @export\n   */\n  registerResponseFilter(filter) {\n    this.responseFilters_.add(filter);\n  }\n\n  /**\n   * Removes a response filter.\n   *\n   * @param {shaka.extern.ResponseFilter} filter\n   * @export\n   */\n  unregisterResponseFilter(filter) {\n    this.responseFilters_.delete(filter);\n  }\n\n  /**\n   * Clears all response filters.\n   *\n   * @export\n   */\n  clearAllResponseFilters() {\n    this.responseFilters_.clear();\n  }\n\n  /**\n   * Gets a copy of the default retry parameters.\n   *\n   * @return {shaka.extern.RetryParameters}\n   *\n   * NOTE: The implementation moved to shaka.net.Backoff to avoid a circular\n   * dependency between the two classes.\n   *\n   * @export\n   */\n  static defaultRetryParameters() {\n    return shaka.net.Backoff.defaultRetryParameters();\n  }\n\n  /**\n   * Makes a simple network request for the given URIs.\n   *\n   * @param {!Array.<string>} uris\n   * @param {shaka.extern.RetryParameters} retryParams\n   * @return {shaka.extern.Request}\n   * @export\n   */\n  static makeRequest(uris, retryParams) {\n    return {\n      uris: uris,\n      method: 'GET',\n      body: null,\n      headers: {},\n      allowCrossSiteCredentials: false,\n      retryParameters: retryParams,\n      licenseRequestType: null,\n      sessionId: null,\n    };\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  destroy() {\n    this.destroyed_ = true;\n    this.requestFilters_.clear();\n    this.responseFilters_.clear();\n    return this.operationManager_.destroy();\n  }\n\n  /**\n   * Makes a network request and returns the resulting data.\n   *\n   * @param {shaka.net.NetworkingEngine.RequestType} type\n   * @param {shaka.extern.Request} request\n   * @return {!shaka.net.NetworkingEngine.PendingRequest}\n   * @export\n   */\n  request(type, request) {\n    const ObjectUtils = shaka.util.ObjectUtils;\n    const numBytesRemainingObj =\n        new shaka.net.NetworkingEngine.NumBytesRemainingClass();\n\n    // Reject all requests made after destroy is called.\n    if (this.destroyed_) {\n      const p = Promise.reject(new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.PLAYER,\n          shaka.util.Error.Code.OPERATION_ABORTED));\n      // Silence uncaught rejection errors, which may otherwise occur any place\n      // we don't explicitly handle aborted operations.\n      p.catch(() => {});\n      return new shaka.net.NetworkingEngine.PendingRequest(\n          p, () => Promise.resolve(), numBytesRemainingObj);\n    }\n\n    goog.asserts.assert(\n        request.uris && request.uris.length, 'Request without URIs!');\n\n    // If a request comes from outside the library, some parameters may be left\n    // undefined.  To make it easier for application developers, we will fill\n    // them in with defaults if necessary.\n    //\n    // We clone retryParameters and uris so that if a filter modifies the\n    // request, it doesn't contaminate future requests.\n    request.method = request.method || 'GET';\n    request.headers = request.headers || {};\n    request.retryParameters = request.retryParameters ?\n        ObjectUtils.cloneObject(request.retryParameters) :\n        shaka.net.NetworkingEngine.defaultRetryParameters();\n    request.uris = ObjectUtils.cloneObject(request.uris);\n\n    // Apply the registered filters to the request.\n    const requestFilterOperation = this.filterRequest_(type, request);\n    const requestOperation = requestFilterOperation.chain(\n        () => this.makeRequestWithRetry_(type, request, numBytesRemainingObj));\n    const responseFilterOperation = requestOperation.chain(\n        (responseAndGotProgress) =>\n          this.filterResponse_(type, responseAndGotProgress));\n\n    // Keep track of time spent in filters.\n    const requestFilterStartTime = Date.now();\n    let requestFilterMs = 0;\n    requestFilterOperation.promise.then(() => {\n      requestFilterMs = Date.now() - requestFilterStartTime;\n    }, () => {});  // Silence errors in this fork of the Promise chain.\n\n    let responseFilterStartTime = 0;\n    requestOperation.promise.then(() => {\n      responseFilterStartTime = Date.now();\n    }, () => {});  // Silence errors in this fork of the Promise chain.\n\n    const op = responseFilterOperation.chain((responseAndGotProgress) => {\n      const responseFilterMs = Date.now() - responseFilterStartTime;\n      const response = responseAndGotProgress.response;\n      response.timeMs += requestFilterMs;\n      response.timeMs += responseFilterMs;\n      if (!responseAndGotProgress.gotProgress &&\n          this.onProgressUpdated_ &&\n          !response.fromCache &&\n          type == shaka.net.NetworkingEngine.RequestType.SEGMENT) {\n        this.onProgressUpdated_(response.timeMs, response.data.byteLength);\n      }\n      return response;\n    }, (e) => {\n      // Any error thrown from elsewhere should be recategorized as CRITICAL\n      // here.  This is because by the time it gets here, we've exhausted\n      // retries.\n      if (e) {\n        goog.asserts.assert(e instanceof shaka.util.Error, 'Wrong error type');\n        e.severity = shaka.util.Error.Severity.CRITICAL;\n      }\n\n      throw e;\n    });\n\n    // Return the pending request, which carries the response operation, and the\n    // number of bytes remaining to be downloaded, updated by the progress\n    // events.  Add the operation to the manager for later cleanup.\n    const pendingRequest =\n        new shaka.net.NetworkingEngine.PendingRequest(\n            op.promise, () => op.abort(), numBytesRemainingObj);\n    this.operationManager_.manage(pendingRequest);\n    return pendingRequest;\n  }\n\n  /**\n   * @param {shaka.net.NetworkingEngine.RequestType} type\n   * @param {shaka.extern.Request} request\n   * @return {!shaka.util.AbortableOperation.<undefined>}\n   * @private\n   */\n  filterRequest_(type, request) {\n    let filterOperation = shaka.util.AbortableOperation.completed(undefined);\n\n    for (const requestFilter of this.requestFilters_) {\n      // Request filters are run sequentially.\n      filterOperation = filterOperation.chain(() => {\n        if (request.body) {\n          // TODO: For v4.0 we should remove this or change to always pass a\n          // Uint8Array.  To make it easier for apps to write filters, it may be\n          // better to always pass a Uint8Array so they know what they are\n          // getting; but we shouldn't use ArrayBuffer since that would require\n          // copying buffers if this is a partial view.\n          request.body = shaka.util.BufferUtils.toArrayBuffer(request.body);\n        }\n        return requestFilter(type, request);\n      });\n    }\n\n    // Catch any errors thrown by request filters, and substitute\n    // them with a Shaka-native error.\n    return filterOperation.chain(undefined, (e) => {\n      if (e instanceof shaka.util.Error &&\n          e.code == shaka.util.Error.Code.OPERATION_ABORTED) {\n        // Don't change anything if the operation was aborted.\n        throw e;\n      }\n\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.NETWORK,\n          shaka.util.Error.Code.REQUEST_FILTER_ERROR, e);\n    });\n  }\n\n  /**\n   * @param {shaka.net.NetworkingEngine.RequestType} type\n   * @param {shaka.extern.Request} request\n   * @param {shaka.net.NetworkingEngine.NumBytesRemainingClass}\n   *            numBytesRemainingObj\n   * @return {!shaka.extern.IAbortableOperation.<\n   *            shaka.net.NetworkingEngine.ResponseAndGotProgress>}\n   * @private\n   */\n  makeRequestWithRetry_(type, request, numBytesRemainingObj) {\n    const backoff = new shaka.net.Backoff(\n        request.retryParameters, /* autoReset= */ false);\n    const index = 0;\n    return this.send_(\n        type, request, backoff, index, /* lastError= */ null,\n        numBytesRemainingObj);\n  }\n\n  /**\n   * Sends the given request to the correct plugin and retry using Backoff.\n   *\n   * @param {shaka.net.NetworkingEngine.RequestType} type\n   * @param {shaka.extern.Request} request\n   * @param {!shaka.net.Backoff} backoff\n   * @param {number} index\n   * @param {?shaka.util.Error} lastError\n   * @param {shaka.net.NetworkingEngine.NumBytesRemainingClass}\n   *     numBytesRemainingObj\n   * @return {!shaka.extern.IAbortableOperation.<\n   *               shaka.net.NetworkingEngine.ResponseAndGotProgress>}\n   * @private\n   */\n  send_(type, request, backoff, index, lastError, numBytesRemainingObj) {\n    const uri = new goog.Uri(request.uris[index]);\n    let scheme = uri.getScheme();\n    // Whether it got a progress event.\n    let gotProgress = false;\n    if (!scheme) {\n      // If there is no scheme, infer one from the location.\n      scheme = shaka.net.NetworkingEngine.getLocationProtocol_();\n      goog.asserts.assert(\n          scheme[scheme.length - 1] == ':',\n          'location.protocol expected to end with a colon!');\n      // Drop the colon.\n      scheme = scheme.slice(0, -1);\n\n      // Override the original URI to make the scheme explicit.\n      uri.setScheme(scheme);\n      request.uris[index] = uri.toString();\n    }\n\n    // Schemes are meant to be case-insensitive.\n    // See https://github.com/google/shaka-player/issues/2173\n    // and https://tools.ietf.org/html/rfc3986#section-3.1\n    scheme = scheme.toLowerCase();\n\n    const object = shaka.net.NetworkingEngine.schemes_[scheme];\n    const plugin = object ? object.plugin : null;\n    if (!plugin) {\n      return shaka.util.AbortableOperation.failed(\n          new shaka.util.Error(\n              shaka.util.Error.Severity.CRITICAL,\n              shaka.util.Error.Category.NETWORK,\n              shaka.util.Error.Code.UNSUPPORTED_SCHEME,\n              uri));\n    }\n\n\n    // Every attempt must have an associated backoff.attempt() call so that the\n    // accounting is correct.\n    const backoffOperation =\n        shaka.util.AbortableOperation.notAbortable(backoff.attempt());\n\n    let startTimeMs;\n    const sendOperation = backoffOperation.chain(() => {\n      if (this.destroyed_) {\n        return shaka.util.AbortableOperation.aborted();\n      }\n\n      startTimeMs = Date.now();\n      const segment = shaka.net.NetworkingEngine.RequestType.SEGMENT;\n\n      return plugin(request.uris[index],\n          request,\n          type,\n          // The following function is passed to plugin.\n          (time, bytes, numBytesRemaining) => {\n            if (this.onProgressUpdated_ && type == segment) {\n              this.onProgressUpdated_(time, bytes);\n              gotProgress = true;\n              numBytesRemainingObj.setBytes(numBytesRemaining);\n            }\n          });\n    }).chain((response) => {\n      if (response.timeMs == undefined) {\n        response.timeMs = Date.now() - startTimeMs;\n      }\n      const responseAndGotProgress = {\n        response: response,\n        gotProgress: gotProgress,\n      };\n\n      return responseAndGotProgress;\n    }, (error) => {\n      if (this.destroyed_) {\n        return shaka.util.AbortableOperation.aborted();\n      }\n\n      if (error instanceof shaka.util.Error) {\n        if (error.code == shaka.util.Error.Code.OPERATION_ABORTED) {\n          // Don't change anything if the operation was aborted.\n          throw error;\n        } else if (error.code == shaka.util.Error.Code.ATTEMPTS_EXHAUSTED) {\n          goog.asserts.assert(lastError, 'Should have last error');\n          throw lastError;\n        }\n\n        if (error.severity == shaka.util.Error.Severity.RECOVERABLE) {\n          const event = new shaka.util.FakeEvent('retry', {'error': error});\n          this.dispatchEvent(event);\n\n          // Move to the next URI.\n          index = (index + 1) % request.uris.length;\n          return this.send_(\n              type, request, backoff, index, error, numBytesRemainingObj);\n        }\n      }\n\n      // The error was not recoverable, so do not try again.\n      throw error;\n    });\n\n    return sendOperation;\n  }\n\n  /**\n   * @param {shaka.net.NetworkingEngine.RequestType} type\n   * @param {shaka.net.NetworkingEngine.ResponseAndGotProgress}\n   *        responseAndGotProgress\n   * @return {!shaka.extern.IAbortableOperation.<\n   *               shaka.net.NetworkingEngine.ResponseAndGotProgress>}\n   * @private\n   */\n  filterResponse_(type, responseAndGotProgress) {\n    let filterOperation = shaka.util.AbortableOperation.completed(undefined);\n    for (const responseFilter of this.responseFilters_) {\n      // Response filters are run sequentially.\n      filterOperation = filterOperation.chain(() => {\n        const resp = responseAndGotProgress.response;\n        if (resp.data) {\n          // TODO: See TODO in filterRequest_.\n          resp.data = shaka.util.BufferUtils.toArrayBuffer(resp.data);\n        }\n        return responseFilter(type, resp);\n      });\n    }\n    // If successful, return the filtered response with whether it got\n    // progress.\n    return filterOperation.chain(() => {\n      return responseAndGotProgress;\n    }, (e) => {\n      // Catch any errors thrown by request filters, and substitute\n      // them with a Shaka-native error.\n\n      // The error is assumed to be critical if the original wasn't a Shaka\n      // error.\n      let severity = shaka.util.Error.Severity.CRITICAL;\n      if (e instanceof shaka.util.Error) {\n        if (e.code == shaka.util.Error.Code.OPERATION_ABORTED) {\n          // Don't change anything if the operation was aborted.\n          throw e;\n        }\n\n        severity = e.severity;\n      }\n\n      throw new shaka.util.Error(\n          severity,\n          shaka.util.Error.Category.NETWORK,\n          shaka.util.Error.Code.RESPONSE_FILTER_ERROR, e);\n    });\n  }\n\n  /**\n   * This is here only for testability.  We can't mock location in our tests on\n   * all browsers, so instead we mock this.\n   *\n   * @return {string} The value of location.protocol.\n   * @private\n   */\n  static getLocationProtocol_() {\n    return location.protocol;\n  }\n};\n\n/**\n * A wrapper class for the number of bytes remaining to be downloaded for the\n * request.\n * Instead of using PendingRequest directly, this class is needed to be sent to\n * plugin as a parameter, and a Promise is returned, before PendingRequest is\n * created.\n *\n * @export\n */\nshaka.net.NetworkingEngine.NumBytesRemainingClass = class {\n  /**\n   * Constructor\n   */\n  constructor() {\n    /** @private {number} */\n    this.bytesToLoad_ = 0;\n  }\n\n  /**\n   * @param {number} bytesToLoad\n   */\n  setBytes(bytesToLoad) {\n    this.bytesToLoad_ = bytesToLoad;\n  }\n\n  /**\n   * @return {number}\n   */\n  getBytes() {\n    return this.bytesToLoad_;\n  }\n};\n\n/**\n * A pending network request. This can track the current progress of the\n * download, and allows the request to be aborted if the network is slow.\n *\n * @implements {shaka.extern.IAbortableOperation.<shaka.extern.Response>}\n * @extends {shaka.util.AbortableOperation}\n * @export\n */\nshaka.net.NetworkingEngine.PendingRequest =\nclass extends shaka.util.AbortableOperation {\n  /**\n   * @param {!Promise} promise\n   *   A Promise which represents the underlying operation.  It is resolved\n   *   when the operation is complete, and rejected if the operation fails or\n   *   is aborted.  Aborted operations should be rejected with a\n   *   shaka.util.Error object using the error code OPERATION_ABORTED.\n   * @param {function():!Promise} onAbort\n   *   Will be called by this object to abort the underlying operation.  This\n   *   is not cancelation, and will not necessarily result in any work being\n   *   undone.  abort() should return a Promise which is resolved when the\n   *   underlying operation has been aborted.  The returned Promise should\n   *   never be rejected.\n   * @param {shaka.net.NetworkingEngine.NumBytesRemainingClass}\n   *   numBytesRemainingObj\n   */\n  constructor(promise, onAbort, numBytesRemainingObj) {\n    super(promise, onAbort);\n\n    /** @private {shaka.net.NetworkingEngine.NumBytesRemainingClass} */\n    this.bytesRemaining_ = numBytesRemainingObj;\n  }\n\n  /**\n   * @return {number}\n   */\n  getBytesRemaining() {\n    return this.bytesRemaining_.getBytes();\n  }\n};\n\n/**\n * Request types.  Allows a filter to decide which requests to read/alter.\n *\n * @enum {number}\n * @export\n */\nshaka.net.NetworkingEngine.RequestType = {\n  'MANIFEST': 0,\n  'SEGMENT': 1,\n  'LICENSE': 2,\n  'APP': 3,\n  'TIMING': 4,\n};\n\n\n/**\n * Priority level for network scheme plugins.\n * If multiple plugins are provided for the same scheme, only the\n * highest-priority one is used.\n *\n * @enum {number}\n * @export\n */\nshaka.net.NetworkingEngine.PluginPriority = {\n  'FALLBACK': 1,\n  'PREFERRED': 2,\n  'APPLICATION': 3,\n};\n\n\n/**\n * @typedef {{\n *   plugin: shaka.extern.SchemePlugin,\n *   priority: number\n * }}\n * @property {shaka.extern.SchemePlugin} plugin\n *   The associated plugin.\n * @property {number} priority\n *   The plugin's priority.\n */\nshaka.net.NetworkingEngine.SchemeObject;\n\n\n/**\n * Contains the scheme plugins.\n *\n * @private {!Object.<string, shaka.net.NetworkingEngine.SchemeObject>}\n */\nshaka.net.NetworkingEngine.schemes_ = {};\n\n/**\n * @typedef {{\n *   response: shaka.extern.Response,\n *   gotProgress: boolean\n * }}\n *\n * @description\n * Defines a response wrapper object, including the response object and whether\n * progress event is fired by the scheme plugin.\n *\n * @property {shaka.extern.Response} response\n * @property {boolean} gotProgress\n * @private\n */\nshaka.net.NetworkingEngine.ResponseAndGotProgress;\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.util.Destroyer');\n\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.PublicPromise');\n\n\n/**\n * @summary\n * A utility class to help work with |shaka.util.IDestroyable| objects.\n *\n * @final\n */\nshaka.util.Destroyer = class {\n  /**\n   * @param {function():!Promise} callback\n   *    A callback to destroy an object. This callback will only be called once\n   *    regardless of how many times |destroy| is called.\n   */\n  constructor(callback) {\n    /** @private {boolean} */\n    this.destroyed_ = false;\n\n    /** @private {!shaka.util.PublicPromise} */\n    this.waitOnDestroy_ = new shaka.util.PublicPromise();\n\n    /** @private {function():!Promise} */\n    this.onDestroy_ = callback;\n  }\n\n  /**\n   * Check if |destroy| has been called. This returning |true| does not mean\n   * that the promise returned by |destroy| has resolved yet.\n   *\n   * @return {boolean}\n   * @final\n   */\n  destroyed() {\n    return this.destroyed_;\n  }\n\n  /**\n   * Request that the destroy callback be called. Will return a promise that\n   * will resolve once the callback terminates. The promise will never be\n   * rejected.\n   *\n   * @return {!Promise}\n   * @final\n   */\n  destroy() {\n    if (this.destroyed_) {\n      return this.waitOnDestroy_;\n    }\n\n    // We have started destroying this object, so we should never get here\n    // again.\n    this.destroyed_ = true;\n\n    return this.onDestroy_().then(\n        () => { this.waitOnDestroy_.resolve(); },\n        () => { this.waitOnDestroy_.resolve(); });\n  }\n\n  /**\n   * Checks if the object is destroyed and throws an error if it is.\n   * @param {*=} error The inner error, if any.\n   */\n  ensureNotDestroyed(error) {\n    if (this.destroyed_) {\n      if (error instanceof shaka.util.Error &&\n          error.code == shaka.util.Error.Code.OBJECT_DESTROYED) {\n        throw error;\n      }\n      throw shaka.util.Destroyer.destroyedError(error);\n    }\n  }\n\n  /**\n   * @param {*=} error The inner error, if any.\n   * @return {!shaka.util.Error}\n   */\n  static destroyedError(error) {\n    return new shaka.util.Error(\n        shaka.util.Error.Severity.CRITICAL,\n        shaka.util.Error.Category.PLAYER,\n        shaka.util.Error.Code.OBJECT_DESTROYED,\n        error);\n  }\n};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.util.EventManager');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.util.IReleasable');\ngoog.require('shaka.util.MultiMap');\n\n\n/**\n * @summary\n * An EventManager maintains a collection of \"event\n * bindings\" between event targets and event listeners.\n *\n * @implements {shaka.util.IReleasable}\n * @export\n */\nshaka.util.EventManager = class {\n  constructor() {\n    /**\n     * Maps an event type to an array of event bindings.\n     * @private {shaka.util.MultiMap.<!shaka.util.EventManager.Binding_>}\n     */\n    this.bindingMap_ = new shaka.util.MultiMap();\n  }\n\n\n  /**\n   * Detaches all event listeners.\n   * @override\n   * @export\n   */\n  release() {\n    this.removeAll();\n    this.bindingMap_ = null;\n  }\n\n\n  /**\n   * Attaches an event listener to an event target.\n   * @param {EventTarget} target The event target.\n   * @param {string} type The event type.\n   * @param {shaka.util.EventManager.ListenerType} listener The event listener.\n   * @param {(boolean|!AddEventListenerOptions)=} options An object that\n   *    specifies characteristics about the event listener.\n   *    The passive option, if true, indicates that this function will never\n   *    call preventDefault(), which improves scrolling performance.\n   * @export\n   */\n  listen(target, type, listener, options) {\n    if (!this.bindingMap_) {\n      return;\n    }\n\n    const binding =\n        new shaka.util.EventManager.Binding_(target, type, listener, options);\n    this.bindingMap_.push(type, binding);\n  }\n\n\n  /**\n   * Attaches an event listener to an event target.  The listener will be\n   * removed when the first instance of the event is fired.\n   * @param {EventTarget} target The event target.\n   * @param {string} type The event type.\n   * @param {shaka.util.EventManager.ListenerType} listener The event listener.\n   * @param {(boolean|!AddEventListenerOptions)=} options An object that\n   *    specifies characteristics about the event listener.\n   *    The passive option, if true, indicates that this function will never\n   *    call preventDefault(), which improves scrolling performance.\n   * @export\n   */\n  listenOnce(target, type, listener, options) {\n    // Install a shim listener that will stop listening after the first event.\n    const shim = (event) => {\n      // Stop listening to this event.\n      this.unlisten(target, type, shim);\n      // Call the original listener.\n      listener(event);\n    };\n    this.listen(target, type, shim, options);\n  }\n\n\n  /**\n   * Detaches an event listener from an event target.\n   * @param {EventTarget} target The event target.\n   * @param {string} type The event type.\n   * @param {shaka.util.EventManager.ListenerType=} listener The event listener.\n   * @export\n   */\n  unlisten(target, type, listener) {\n    if (!this.bindingMap_) {\n      return;\n    }\n\n    const list = this.bindingMap_.get(type) || [];\n\n    for (const binding of list) {\n      if (binding.target == target) {\n        if (listener == binding.listener || !listener) {\n          binding.unlisten();\n          this.bindingMap_.remove(type, binding);\n        }\n      }\n    }\n  }\n\n\n  /**\n   * Detaches all event listeners from all targets.\n   * @export\n   */\n  removeAll() {\n    if (!this.bindingMap_) {\n      return;\n    }\n\n    const list = this.bindingMap_.getAll();\n\n    for (const binding of list) {\n      binding.unlisten();\n    }\n\n    this.bindingMap_.clear();\n  }\n};\n\n\n/**\n * @typedef {function(!Event)}\n * @export\n */\nshaka.util.EventManager.ListenerType;\n\n\n/**\n * Creates a new Binding_ and attaches the event listener to the event target.\n *\n * @private\n */\nshaka.util.EventManager.Binding_ = class {\n  /**\n   * @param {EventTarget} target The event target.\n   * @param {string} type The event type.\n   * @param {shaka.util.EventManager.ListenerType} listener The event listener.\n   * @param {(boolean|!AddEventListenerOptions)=} options An object that\n   *    specifies characteristics about the event listener.\n   *    The passive option, if true, indicates that this function will never\n   *    call preventDefault(), which improves scrolling performance.\n   */\n  constructor(target, type, listener, options) {\n    /** @type {EventTarget} */\n    this.target = target;\n\n    /** @type {string} */\n    this.type = type;\n\n    /** @type {?shaka.util.EventManager.ListenerType} */\n    this.listener = listener;\n\n    /** @type {(boolean|!AddEventListenerOptions)} */\n    this.options =\n        shaka.util.EventManager.Binding_.convertOptions_(target, options);\n\n    this.target.addEventListener(type, listener, this.options);\n  }\n\n\n  /**\n   * Detaches the event listener from the event target. This does nothing if\n   * the event listener is already detached.\n   */\n  unlisten() {\n    goog.asserts.assert(this.target, 'Missing target');\n    this.target.removeEventListener(this.type, this.listener, this.options);\n\n    this.target = null;\n    this.listener = null;\n    this.options = false;\n  }\n\n  /**\n   * Converts the provided options value into a value accepted by the browser.\n   * Some browsers (e.g. IE11 and Tizen) don't support passing options as an\n   * object.  So this detects this case and converts it.\n   *\n   * @param {EventTarget} target\n   * @param {(boolean|!AddEventListenerOptions)=} value\n   * @return {(boolean|!AddEventListenerOptions)}\n   * @private\n   */\n  static convertOptions_(target, value) {\n    if (value == undefined) {\n      return false;\n    } else if (typeof value == 'boolean') {\n      return value;\n    } else {\n      // Ignore the 'passive' option since it is just an optimization and\n      // doesn't affect behavior.  Assert there aren't any other settings to\n      // ensure we don't have different behavior on different browsers by\n      // ignoring an important option.\n      const ignored = new Set(['passive', 'capture']);\n      const keys = Object.keys(value).filter((k) => !ignored.has(k));\n      goog.asserts.assert(\n          keys.length == 0,\n          'Unsupported flag(s) to addEventListener: ' + keys.join(','));\n\n      const supports =\n          shaka.util.EventManager.Binding_.doesSupportObject_(target);\n      if (supports) {\n        return value;\n      } else {\n        return value['capture'] || false;\n      }\n    }\n  }\n\n  /**\n   * Checks whether the browser supports passing objects as the third argument\n   * to addEventListener.  This caches the result value in a static field to\n   * avoid a bunch of checks.\n   *\n   * @param {EventTarget} target\n   * @return {boolean}\n   * @private\n   */\n  static doesSupportObject_(target) {\n    // https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Safely_detecting_option_support\n    let supports = shaka.util.EventManager.Binding_.supportsObject_;\n    if (supports == undefined) {\n      supports = false;\n      try {\n        const options = {};\n        // This defines a getter that will set this variable if called.  So if\n        // the browser gets this property, it supports using an object.  If the\n        // browser doesn't get these fields, it won't support objects.\n        const prop = {\n          get: () => {\n            supports = true;\n            return false;\n          },\n        };\n        Object.defineProperty(options, 'passive', prop);\n        Object.defineProperty(options, 'capture', prop);\n\n        const call = () => {};\n        target.addEventListener('test', call, options);\n        target.removeEventListener('test', call, options);\n      } catch (e) {\n        supports = false;\n      }\n      shaka.util.EventManager.Binding_.supportsObject_ = supports;\n    }\n    return supports || false;  // \"false\" fallback needed for compiler.\n  }\n};\n\n/** @private {(boolean|undefined)} */\nshaka.util.EventManager.Binding_.supportsObject_ = undefined;\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.util.FairPlayUtils');\n\ngoog.require('goog.Uri');\ngoog.require('goog.asserts');\ngoog.require('shaka.util.BufferUtils');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.StringUtils');\n\n\n/**\n * @summary A set of FairPlay utility functions.\n * @export\n */\nshaka.util.FairPlayUtils = class {\n  /**\n   * Using the default method, extract a content ID from the init data.  This is\n   * based on the FairPlay example documentation.\n   *\n   * @param {!BufferSource} initData\n   * @return {string}\n   * @export\n   */\n  static defaultGetContentId(initData) {\n    const uriString = shaka.util.StringUtils.fromBytesAutoDetect(initData);\n\n    // The domain of that URI is the content ID according to Apple's FPS\n    // sample.\n    const uri = new goog.Uri(uriString);\n    return uri.getDomain();\n  }\n\n  /**\n   * Transforms the init data buffer using the given data.  The format is:\n   *\n   * <pre>\n   * [4 bytes] initDataSize\n   * [initDataSize bytes] initData\n   * [4 bytes] contentIdSize\n   * [contentIdSize bytes] contentId\n   * [4 bytes] certSize\n   * [certSize bytes] cert\n   * </pre>\n   *\n   * @param {!BufferSource} initData\n   * @param {!BufferSource|string} contentId\n   * @param {?BufferSource} cert  The server certificate; this will throw if not\n   *   provided.\n   * @return {!Uint8Array}\n   * @export\n   */\n  static initDataTransform(initData, contentId, cert) {\n    if (!cert || !cert.byteLength) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.DRM,\n          shaka.util.Error.Code.SERVER_CERTIFICATE_REQUIRED);\n    }\n\n    // From that, we build a new init data to use in the session.  This is\n    // composed of several parts.  First, the init data as a UTF-16 sdk:// URL.\n    // Second, a 4-byte LE length followed by the content ID in UTF-16-LE.\n    // Third, a 4-byte LE length followed by the certificate.\n    /** @type {BufferSource} */\n    let contentIdArray;\n    if (typeof contentId == 'string') {\n      contentIdArray =\n          shaka.util.StringUtils.toUTF16(contentId, /* littleEndian= */ true);\n    } else {\n      contentIdArray = contentId;\n    }\n\n    // The init data we get is a UTF-8 string; convert that to a UTF-16 string.\n    const sdkUri = shaka.util.StringUtils.fromBytesAutoDetect(initData);\n    const utf16 =\n        shaka.util.StringUtils.toUTF16(sdkUri, /* littleEndian= */ true);\n\n    const rebuiltInitData = new Uint8Array(\n        12 + utf16.byteLength + contentIdArray.byteLength + cert.byteLength);\n\n    let offset = 0;\n    /** @param {BufferSource} array */\n    const append = (array) => {\n      rebuiltInitData.set(shaka.util.BufferUtils.toUint8(array), offset);\n      offset += array.byteLength;\n    };\n    /** @param {BufferSource} array */\n    const appendWithLength = (array) => {\n      const view = shaka.util.BufferUtils.toDataView(rebuiltInitData);\n      const value = array.byteLength;\n      view.setUint32(offset, value, /* littleEndian= */ true);\n      offset += 4;\n      append(array);\n    };\n\n    appendWithLength(utf16);\n    appendWithLength(contentIdArray);\n    appendWithLength(cert);\n\n    goog.asserts.assert(\n        offset == rebuiltInitData.length, 'Inconsistent init data length');\n    return rebuiltInitData;\n  }\n};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.util.MapUtils');\n\n\n/**\n * @summary A set of map/object utility functions.\n */\nshaka.util.MapUtils = class {\n  /**\n   * @param {!Object.<KEY, VALUE>} object\n   * @return {!Map.<KEY, VALUE>}\n   * @template KEY,VALUE\n   */\n  static asMap(object) {\n    const map = new Map();\n    for (const key of Object.keys(object)) {\n      map.set(key, object[key]);\n    }\n\n    return map;\n  }\n\n\n  /**\n   * @param {!Map.<KEY, VALUE>} map\n   * @return {!Object.<KEY, VALUE>}\n   * @template KEY,VALUE\n   */\n  static asObject(map) {\n    const obj = {};\n    map.forEach((value, key) => {\n      obj[key] = value;\n    });\n\n    return obj;\n  }\n\n  /**\n   * NOTE: This only works for simple value types and\n   * will not be accurate if map values are objects!\n   *\n   * @param {Map.<KEY, VALUE>} map1\n   * @param {Map.<KEY, VALUE>} map2\n   * @return {boolean}\n   * @template KEY,VALUE\n   */\n  static hasSameElements(map1, map2) {\n    if (!map1 && !map2) {\n      return true;\n    } else if (map1 && !map2) {\n      return false;\n    } else if (map2 && !map1) {\n      return false;\n    }\n\n    if (map1.size != map2.size) {\n      return false;\n    }\n\n    for (const [key, val] of map1) {\n      if (!map2.has(key)) {\n        return false;\n      }\n\n      const val2 = map2.get(key);\n      if (val2 != val || (val2 == undefined)) {\n        return false;\n      }\n    }\n    return true;\n  }\n};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.util.MimeUtils');\n\n\n/**\n * @summary A set of utility functions for dealing with MIME types.\n */\nshaka.util.MimeUtils = class {\n  /**\n   * Takes a MIME type and optional codecs string and produces the full MIME\n   * type.\n   *\n   * @param {string} mimeType\n   * @param {string=} codecs\n   * @return {string}\n   */\n  static getFullType(mimeType, codecs) {\n    let fullMimeType = mimeType;\n    if (codecs) {\n      fullMimeType += '; codecs=\"' + codecs + '\"';\n    }\n    return fullMimeType;\n  }\n\n  /**\n   * Takes a Stream object and produces an extended MIME type with information\n   * beyond the container and codec type, when available.\n   *\n   * @param {shaka.extern.Stream} stream\n   * @return {string}\n   */\n  static getExtendedType(stream) {\n    const components = [stream.mimeType];\n\n    const extendedMimeParams = shaka.util.MimeUtils.EXTENDED_MIME_PARAMETERS_;\n    extendedMimeParams.forEach((mimeKey, streamKey) => {\n      const value = stream[streamKey];\n      if (value) {\n        components.push(mimeKey + '=\"' + value + '\"');\n      }\n    });\n\n    return components.join(';');\n  }\n\n  /**\n   * Split a list of codecs encoded in a string into a list of codecs.\n   * @param {string} codecs\n   * @return {!Array.<string>}\n   */\n  static splitCodecs(codecs) {\n    return codecs.split(',');\n  }\n\n  /**\n   * Get the base codec from a codec string.\n   *\n   * @param {string} codecString\n   * @return {string}\n   */\n  static getCodecBase(codecString) {\n    const parts = shaka.util.MimeUtils.getCodecParts_(codecString);\n    return parts[0];\n  }\n\n  /**\n   * Get the base and profile of a codec string. Where [0] will be the codec\n   * base and [1] will be the profile.\n   * @param {string} codecString\n   * @return {!Array.<string>}\n   * @private\n   */\n  static getCodecParts_(codecString) {\n    const parts = codecString.split('.');\n\n    const base = parts[0];\n\n    parts.pop();\n    const profile = parts.join('.');\n\n    // Make sure that we always return a \"base\" and \"profile\".\n    return [base, profile];\n  }\n};\n\n\n/**\n * A map from Stream object keys to MIME type parameters.  These should be\n * ignored by platforms that do not recognize them.\n *\n * This initial set of parameters are all recognized by Chromecast.\n *\n * @const {!Map.<string, string>}\n * @private\n */\nshaka.util.MimeUtils.EXTENDED_MIME_PARAMETERS_ = new Map()\n    .set('codecs', 'codecs')\n    .set('frameRate', 'framerate')  // Ours is camelCase, theirs is lowercase.\n    .set('bandwidth', 'bitrate')  // They are in the same units: bits/sec.\n    .set('width', 'width')\n    .set('height', 'height')\n    .set('channelsCount', 'channels');\n\n\n/**\n * A mimetype created for CEA closed captions.\n * @const {string}\n */\nshaka.util.MimeUtils.CLOSED_CAPTION_MIMETYPE = 'application/cea-608';\n\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.util.Platform');\n\ngoog.require('shaka.util.Timer');\n\n\n/**\n * A wrapper for platform-specific functions.\n *\n * @final\n */\nshaka.util.Platform = class {\n  /**\n   * Check if the current platform supports media source. We assume that if\n   * the current platform supports media source, then we can use media source\n   * as per its design.\n   *\n   * @return {boolean}\n   */\n  static supportsMediaSource() {\n    // Browsers that lack a media source implementation will have no reference\n    // to |window.MediaSource|. Platforms that we see having problematic media\n    // source implementations will have this reference removed via a polyfill.\n    if (!window.MediaSource) {\n      return false;\n    }\n\n    // Some very old MediaSource implementations didn't have isTypeSupported.\n    if (!MediaSource.isTypeSupported) {\n      return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Returns true if the media type is supported natively by the platform.\n   *\n   * @param {string} mimeType\n   * @return {boolean}\n   */\n  static supportsMediaType(mimeType) {\n    const video = shaka.util.Platform.anyMediaElement();\n    return video.canPlayType(mimeType) != '';\n  }\n\n  /**\n   * Check if the current platform is MS Edge.\n   *\n   * @return {boolean}\n   */\n  static isEdge() {\n    // Legacy Edge contains \"Edge/version\".\n    // Chromium-based Edge contains \"Edg/version\" (no \"e\").\n    if (navigator.userAgent.match(/Edge?\\//)) {\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Check if the current platform is Legacy Edge.\n   *\n   * @return {boolean}\n   */\n  static isLegacyEdge() {\n    // Legacy Edge contains \"Edge/version\".\n    // Chromium-based Edge contains \"Edg/version\" (no \"e\").\n    if (navigator.userAgent.match(/Edge\\//)) {\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Check if the current platform is MS IE.\n   *\n   * @return {boolean}\n   */\n  static isIE() {\n    return shaka.util.Platform.userAgentContains_('Trident/');\n  }\n\n  /**\n   * Check if the current platform is a Tizen TV.\n   *\n   * @return {boolean}\n   */\n  static isTizen() {\n    return shaka.util.Platform.userAgentContains_('Tizen');\n  }\n\n  /**\n   * Check if the current platform is a Tizen 4 TV.\n   *\n   * @return {boolean}\n   */\n  static isTizen4() {\n    return shaka.util.Platform.userAgentContains_('Tizen 4');\n  }\n\n  /**\n   * Check if the current platform is a Tizen 3 TV.\n   *\n   * @return {boolean}\n   */\n  static isTizen3() {\n    return shaka.util.Platform.userAgentContains_('Tizen 3');\n  }\n\n  /**\n   * Check if the current platform is a Tizen 2 TV.\n   *\n   * @return {boolean}\n   */\n  static isTizen2() {\n    return shaka.util.Platform.userAgentContains_('Tizen 2');\n  }\n\n  /**\n   * Check if the current platform is a WebOS.\n   *\n   * @return {boolean}\n   */\n  static isWebOS() {\n    return shaka.util.Platform.userAgentContains_('Web0S');\n  }\n\n  /**\n   * Check if the current platform is a Google Chromecast.\n   *\n   * @return {boolean}\n   */\n  static isChromecast() {\n    return shaka.util.Platform.userAgentContains_('CrKey');\n  }\n\n  /**\n   * Check if the current platform is Google Chrome.\n   *\n   * @return {boolean}\n   */\n  static isChrome() {\n    // The Edge user agent will also contain the \"Chrome\" keyword, so we need\n    // to make sure this is not Edge.\n    return shaka.util.Platform.userAgentContains_('Chrome') &&\n           !shaka.util.Platform.isEdge();\n  }\n\n\n  /**\n   * Check if the current platform is from Apple.\n   *\n   * Returns true on all iOS browsers and on desktop Safari.\n   *\n   * Returns false for non-Safari browsers on macOS, which are independent of\n   * Apple.\n   *\n   * @return {boolean}\n   */\n  static isApple() {\n    return !!navigator.vendor && navigator.vendor.includes('Apple')\n            && !shaka.util.Platform.isTizen();\n  }\n\n  /**\n   * Returns a major version number for Safari, or Safari-based iOS browsers.\n   *\n   * For example:\n   *   - Safari 13.0.4 on macOS returns 13.\n   *   - Safari on iOS 13.3.1 returns 13.\n   *   - Chrome on iOS 13.3.1 returns 13 (since this is based on Safari/WebKit).\n   *   - Chrome on macOS returns null (since this is independent of Apple).\n   *\n   * Returns null on Firefox on iOS, where this version information is not\n   * available.\n   *\n   * @return {?number} A major version number or null if not iOS.\n   */\n  static safariVersion() {\n    // All iOS browsers and desktop Safari will return true for isApple().\n    if (!shaka.util.Platform.isApple()) {\n      return null;\n    }\n\n    // This works for iOS Safari and desktop Safari, which contain something\n    // like \"Version/13.0\" indicating the major Safari or iOS version.\n    let match = navigator.userAgent.match(/Version\\/(\\d+)/);\n    if (match) {\n      return parseInt(match[1], /* base= */ 10);\n    }\n\n    // This works for all other browsers on iOS, which contain something like\n    // \"OS 13_3\" indicating the major & minor iOS version.\n    match = navigator.userAgent.match(/OS (\\d+)(?:_\\d+)?/);\n    if (match) {\n      return parseInt(match[1], /* base= */ 10);\n    }\n\n    return null;\n  }\n\n  /**\n   * Guesses if the platform is a mobile one (iOS or Android).\n   *\n   * @return {boolean}\n   */\n  static isMobile() {\n    if (/(?:iPhone|iPad|iPod|Android)/.test(navigator.userAgent)) {\n      // This is Android, iOS, or iPad < 13.\n      return true;\n    }\n\n    // Starting with iOS 13 on iPad, the user agent string no longer has the\n    // word \"iPad\" in it.  It looks very similar to desktop Safari.  This seems\n    // to be intentional on Apple's part.\n    // See: https://forums.developer.apple.com/thread/119186\n    //\n    // So if it's an Apple device with multi-touch support, assume it's a mobile\n    // device.  If some future iOS version starts masking their user agent on\n    // both iPhone & iPad, this clause should still work.  If a future\n    // multi-touch desktop Mac is released, this will need some adjustment.\n    //\n    // As of January 2020, this is mainly used to adjust the default UI config\n    // for mobile devices, so it's low risk if something changes to break this\n    // detection.\n    return shaka.util.Platform.isApple() && navigator.maxTouchPoints > 1;\n  }\n\n  /**\n   * Check if the user agent contains a key. This is the best way we know of\n   * right now to detect platforms. If there is a better way, please send a\n   * PR.\n   *\n   * @param {string} key\n   * @return {boolean}\n   * @private\n   */\n  static userAgentContains_(key) {\n    const userAgent = navigator.userAgent || '';\n    return userAgent.includes(key);\n  }\n\n  /**\n   * For canPlayType queries, we just need any instance.\n   *\n   * First, use a cached element from a previous query.\n   * Second, search the page for one.\n   * Third, create a temporary one.\n   *\n   * Cached elements expire in one second so that they can be GC'd or removed.\n   *\n   * @return {!HTMLMediaElement}\n   */\n  static anyMediaElement() {\n    const Platform = shaka.util.Platform;\n    if (Platform.cachedMediaElement_) {\n      return Platform.cachedMediaElement_;\n    }\n\n    if (!Platform.cacheExpirationTimer_) {\n      Platform.cacheExpirationTimer_ = new shaka.util.Timer(() => {\n        Platform.cachedMediaElement_ = null;\n      });\n    }\n\n    Platform.cachedMediaElement_ = /** @type {HTMLMediaElement} */(\n      document.getElementsByTagName('video')[0] ||\n      document.getElementsByTagName('audio')[0]);\n\n    if (!Platform.cachedMediaElement_) {\n      Platform.cachedMediaElement_ = /** @type {!HTMLMediaElement} */(\n        document.createElement('video'));\n    }\n\n    Platform.cacheExpirationTimer_.tickAfter(/* seconds= */ 1);\n    return Platform.cachedMediaElement_;\n  }\n};\n\n/** @private {shaka.util.Timer} */\nshaka.util.Platform.cacheExpirationTimer_ = null;\n\n/** @private {HTMLMediaElement} */\nshaka.util.Platform.cachedMediaElement_ = null;\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.media.DrmEngine');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.media.Transmuxer');\ngoog.require('shaka.net.NetworkingEngine');\ngoog.require('shaka.util.BufferUtils');\ngoog.require('shaka.util.Destroyer');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.EventManager');\ngoog.require('shaka.util.FairPlayUtils');\ngoog.require('shaka.util.FakeEvent');\ngoog.require('shaka.util.IDestroyable');\ngoog.require('shaka.util.Iterables');\ngoog.require('shaka.util.Lazy');\ngoog.require('shaka.util.ManifestParserUtils');\ngoog.require('shaka.util.MapUtils');\ngoog.require('shaka.util.MimeUtils');\ngoog.require('shaka.util.Platform');\ngoog.require('shaka.util.PublicPromise');\ngoog.require('shaka.util.StringUtils');\ngoog.require('shaka.util.Timer');\ngoog.require('shaka.util.Uint8ArrayUtils');\n\n\n/** @implements {shaka.util.IDestroyable} */\nshaka.media.DrmEngine = class {\n  /**\n   * @param {shaka.media.DrmEngine.PlayerInterface} playerInterface\n   * @param {number=} updateExpirationTime\n   */\n  constructor(playerInterface, updateExpirationTime = 1) {\n    /** @private {?shaka.media.DrmEngine.PlayerInterface} */\n    this.playerInterface_ = playerInterface;\n\n    /** @private {!Set.<string>} */\n    this.supportedTypes_ = new Set();\n\n    /** @private {MediaKeys} */\n    this.mediaKeys_ = null;\n\n    /** @private {HTMLMediaElement} */\n    this.video_ = null;\n\n    /** @private {boolean} */\n    this.initialized_ = false;\n\n    /** @private {number} */\n    this.licenseTimeSeconds_ = 0;\n\n    /** @private {?shaka.extern.DrmInfo} */\n    this.currentDrmInfo_ = null;\n\n    /** @private {shaka.util.EventManager} */\n    this.eventManager_ = new shaka.util.EventManager();\n\n    /**\n     * @private {!Map.<MediaKeySession,\n     *           shaka.media.DrmEngine.SessionMetaData>}\n     */\n    this.activeSessions_ = new Map();\n\n    /** @private {!Array.<string>} */\n    this.offlineSessionIds_ = [];\n\n    /** @private {!shaka.util.PublicPromise} */\n    this.allSessionsLoaded_ = new shaka.util.PublicPromise();\n\n    /** @private {?shaka.extern.DrmConfiguration} */\n    this.config_ = null;\n\n    /** @private {function(!shaka.util.Error)} */\n    this.onError_ = (err) => {\n      this.allSessionsLoaded_.reject(err);\n      playerInterface.onError(err);\n    };\n\n    /**\n     * The most recent key status information we have.\n     * We may not have announced this information to the outside world yet,\n     * which we delay to batch up changes and avoid spurious \"missing key\"\n     * errors.\n     * @private {!Map.<string, string>}\n     */\n    this.keyStatusByKeyId_ = new Map();\n\n    /**\n     * The key statuses most recently announced to other classes.\n     * We may have more up-to-date information being collected in\n     * this.keyStatusByKeyId_, which has not been batched up and released yet.\n     * @private {!Map.<string, string>}\n     */\n    this.announcedKeyStatusByKeyId_ = new Map();\n\n    /** @private {shaka.util.Timer} */\n    this.keyStatusTimer_ =\n        new shaka.util.Timer(() => this.processKeyStatusChanges_());\n\n    /** @private {boolean} */\n    this.usePersistentLicenses_ = false;\n\n    /** @private {!Array.<!MediaKeyMessageEvent>} */\n    this.mediaKeyMessageEvents_ = [];\n\n    /** @private {boolean} */\n    this.initialRequestsSent_ = false;\n\n    /** @private {?shaka.util.Timer} */\n    this.expirationTimer_ = new shaka.util.Timer(() => {\n      this.pollExpiration_();\n    }).tickEvery(/* seconds= */ updateExpirationTime);\n\n    // Add a catch to the Promise to avoid console logs about uncaught errors.\n    const noop = () => {};\n    this.allSessionsLoaded_.catch(noop);\n\n    /** @const {!shaka.util.Destroyer} */\n    this.destroyer_ = new shaka.util.Destroyer(() => this.destroyNow_());\n  }\n\n  /** @override */\n  destroy() {\n    return this.destroyer_.destroy();\n  }\n\n  /**\n   * Destroy this instance of DrmEngine. This assumes that all other checks\n   * about \"if it should\" have passed.\n   *\n   * @private\n   */\n  async destroyNow_() {\n    // |eventManager_| should only be |null| after we call |destroy|. Destroy it\n    // first so that we will stop responding to events.\n    this.eventManager_.release();\n    this.eventManager_ = null;\n\n    // Since we are destroying ourselves, we don't want to react to the \"all\n    // sessions loaded\" event.\n    this.allSessionsLoaded_.reject();\n\n    // Stop all timers. This will ensure that they do not start any new work\n    // while we are destroying ourselves.\n    this.expirationTimer_.stop();\n    this.expirationTimer_ = null;\n\n    this.keyStatusTimer_.stop();\n    this.keyStatusTimer_ = null;\n\n    // Close all open sessions.\n    await this.closeOpenSessions_();\n\n    // |video_| will be |null| if we never attached to a video element.\n    if (this.video_) {\n      goog.asserts.assert(!this.video_.src, 'video src must be removed first!');\n\n      try {\n        await this.video_.setMediaKeys(null);\n      } catch (error) {\n        // Ignore any failures while removing media keys from the video element.\n      }\n\n      this.video_ = null;\n    }\n\n    // Break references to everything else we hold internally.\n    this.currentDrmInfo_ = null;\n    this.supportedTypes_.clear();\n    this.mediaKeys_ = null;\n    this.offlineSessionIds_ = [];\n    this.config_ = null;\n    this.onError_ = () => {};\n    this.playerInterface_ = null;\n  }\n\n  /**\n   * Called by the Player to provide an updated configuration any time it\n   * changes.\n   * Must be called at least once before init().\n   *\n   * @param {shaka.extern.DrmConfiguration} config\n   */\n  configure(config) {\n    this.config_ = config;\n  }\n\n  /**\n   * Initialize the drm engine for storing and deleting stored content.\n   *\n   * @param {!Array.<shaka.extern.Variant>} variants\n   *    The variants that are going to be stored.\n   * @param {boolean} usePersistentLicenses\n   *    Whether or not persistent licenses should be requested and stored for\n   *    |manifest|.\n   * @return {!Promise}\n   */\n  initForStorage(variants, usePersistentLicenses) {\n    // There are two cases for this call:\n    //  1. We are about to store a manifest - in that case, there are no offline\n    //     sessions and therefore no offline session ids.\n    //  2. We are about to remove the offline sessions for this manifest - in\n    //     that case, we don't need to know about them right now either as\n    //     we will be told which ones to remove later.\n    this.offlineSessionIds_ = [];\n\n    // What we really need to know is whether or not they are expecting to use\n    // persistent licenses.\n    this.usePersistentLicenses_ = usePersistentLicenses;\n\n    return this.init_(variants);\n  }\n\n  /**\n   * Initialize the drm engine for playback operations.\n   *\n   * @param {!Array.<shaka.extern.Variant>} variants\n   *    The variants that we want to support playing.\n   * @param {!Array.<string>} offlineSessionIds\n   * @return {!Promise}\n   */\n  initForPlayback(variants, offlineSessionIds) {\n    this.offlineSessionIds_ = offlineSessionIds;\n    this.usePersistentLicenses_ = offlineSessionIds.length > 0;\n\n    return this.init_(variants);\n  }\n\n  /**\n   * Initializes the drm engine for removing persistent sessions.  Only the\n   * removeSession(s) methods will work correctly, creating new sessions may not\n   * work as desired.\n   *\n   * @param {string} keySystem\n   * @param {string} licenseServerUri\n   * @param {Uint8Array} serverCertificate\n   * @param {!Array.<MediaKeySystemMediaCapability>} audioCapabilities\n   * @param {!Array.<MediaKeySystemMediaCapability>} videoCapabilities\n   * @return {!Promise}\n   */\n  initForRemoval(keySystem, licenseServerUri, serverCertificate,\n      audioCapabilities, videoCapabilities) {\n    /** @type {!Map.<string, MediaKeySystemConfiguration>} */\n    const configsByKeySystem = new Map();\n\n    /** @type {MediaKeySystemConfiguration} */\n    const config = {\n      audioCapabilities: audioCapabilities,\n      videoCapabilities: videoCapabilities,\n      distinctiveIdentifier: 'optional',\n      persistentState: 'required',\n      sessionTypes: ['persistent-license'],\n      label: keySystem,  // Tracked by us, ignored by EME.\n    };\n\n    // TODO: refactor, don't stick drmInfos onto MediaKeySystemConfiguration\n    config['drmInfos'] = [{  // Non-standard attribute, ignored by EME.\n      keySystem: keySystem,\n      licenseServerUri: licenseServerUri,\n      distinctiveIdentifierRequired: false,\n      persistentStateRequired: true,\n      audioRobustness: '',  // Not required by queryMediaKeys_\n      videoRobustness: '',  // Same\n      serverCertificate: serverCertificate,\n      initData: null,\n      keyIds: null,\n    }];\n\n    configsByKeySystem.set(keySystem, config);\n    return this.queryMediaKeys_(configsByKeySystem);\n  }\n\n  /**\n   * Negotiate for a key system and set up MediaKeys.\n   * This will assume that both |usePersistentLicences_| and\n   * |offlineSessionIds_| have been properly set.\n   *\n   * @param {!Array.<shaka.extern.Variant>} variants\n   *    The variants that we expect to operate with during the drm engine's\n   *    lifespan of the drm engine.\n   * @return {!Promise} Resolved if/when a key system has been chosen.\n   * @private\n   */\n  init_(variants) {\n    goog.asserts.assert(this.config_,\n        'DrmEngine configure() must be called before init()!');\n\n    // ClearKey config overrides the manifest DrmInfo if present. The variants\n    // are modified so that filtering in Player still works.\n    // This comes before hadDrmInfo because it influences the value of that.\n    /** @type {?shaka.extern.DrmInfo} */\n    const clearKeyDrmInfo = this.configureClearKey_();\n    if (clearKeyDrmInfo) {\n      for (const variant of variants) {\n        if (variant.video) {\n          variant.video.drmInfos = [clearKeyDrmInfo];\n        }\n        if (variant.audio) {\n          variant.audio.drmInfos = [clearKeyDrmInfo];\n        }\n      }\n    }\n\n    const hadDrmInfo = variants.some((variant) => {\n      if (variant.video && variant.video.drmInfos.length) {\n        return true;\n      }\n      if (variant.audio && variant.audio.drmInfos.length) {\n        return true;\n      }\n      return false;\n    });\n\n    // When preparing to play live streams, it is possible that we won't know\n    // about some upcoming encrypted content. If we initialize the drm engine\n    // with no key systems, we won't be able to play when the encrypted content\n    // comes.\n    //\n    // To avoid this, we will set the drm engine up to work with as many key\n    // systems as possible so that we will be ready.\n    if (!hadDrmInfo) {\n      const servers = shaka.util.MapUtils.asMap(this.config_.servers);\n      shaka.media.DrmEngine.replaceDrmInfo_(variants, servers);\n    }\n\n    // Make sure all the drm infos are valid and filled in correctly.\n    for (const variant of variants) {\n      const videoDrmInfos = variant.video ? variant.video.drmInfos : [];\n      const audioDrmInfos = variant.audio ? variant.audio.drmInfos : [];\n      const drmInfos = videoDrmInfos.concat(audioDrmInfos);\n      for (const info of drmInfos) {\n        shaka.media.DrmEngine.fillInDrmInfoDefaults_(\n            info,\n            shaka.util.MapUtils.asMap(this.config_.servers),\n            shaka.util.MapUtils.asMap(this.config_.advanced || {}));\n      }\n    }\n\n    /** @type {!Map.<string, MediaKeySystemConfiguration>} */\n    const configsByKeySystem =\n        this.prepareMediaKeyConfigsForVariants_(variants);\n\n    // TODO(vaage): Find an explanation for the difference between this\n    //  \"unencrypted\" form and the \"no drm info unencrypted form\" and express\n    //  that difference here.\n    if (!configsByKeySystem.size) {\n      // Unencrypted.\n      this.initialized_ = true;\n      return Promise.resolve();\n    }\n\n    const p = this.queryMediaKeys_(configsByKeySystem);\n\n    // TODO(vaage): Look into the assertion below. If we do not have any drm\n    // info, we create drm info so that content can play if it has drm info\n    // later.\n    // However it is okay if we fail to initialize? If we fail to initialize,\n    // it means we won't be able to play the later-encrypted content, which is\n    // not okay.\n\n    // If the content did not originally have any drm info, then it doesn't\n    // matter if we fail to initialize the drm engine, because we won't need it\n    // anyway.\n    return hadDrmInfo ? p : p.catch(() => {});\n  }\n\n  /**\n   * Attach MediaKeys to the video element and start processing events.\n   * @param {HTMLMediaElement} video\n   * @return {!Promise}\n   */\n  async attach(video) {\n    if (!this.mediaKeys_) {\n      // Unencrypted, or so we think.  We listen for encrypted events in order\n      // to warn when the stream is encrypted, even though the manifest does\n      // not know it.\n      // Don't complain about this twice, so just listenOnce().\n      // FIXME: This is ineffective when a prefixed event is translated by our\n      // polyfills, since those events are only caught and translated by a\n      // MediaKeys instance.  With clear content and no polyfilled MediaKeys\n      // instance attached, you'll never see the 'encrypted' event on those\n      // platforms (IE 11 & Safari).\n      this.eventManager_.listenOnce(video, 'encrypted', (event) => {\n        this.onError_(new shaka.util.Error(\n            shaka.util.Error.Severity.CRITICAL,\n            shaka.util.Error.Category.DRM,\n            shaka.util.Error.Code.ENCRYPTED_CONTENT_WITHOUT_DRM_INFO));\n      });\n      return;\n    }\n\n    this.video_ = video;\n\n    this.eventManager_.listenOnce(this.video_, 'play', () => this.onPlay_());\n    if ('webkitCurrentPlaybackTargetIsWireless' in this.video_) {\n      this.eventManager_.listen(this.video_,\n          'webkitcurrentplaybacktargetiswirelesschanged',\n          () => this.closeOpenSessions_());\n    }\n\n    let setMediaKeys = this.video_.setMediaKeys(this.mediaKeys_);\n    setMediaKeys = setMediaKeys.catch((exception) => {\n      goog.asserts.assert(exception instanceof Error, 'Wrong error type!');\n      return Promise.reject(new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.DRM,\n          shaka.util.Error.Code.FAILED_TO_ATTACH_TO_VIDEO,\n          exception.message));\n    });\n\n    await setMediaKeys;\n    this.destroyer_.ensureNotDestroyed();\n\n    this.createOrLoad();\n    if (!this.currentDrmInfo_.initData.length &&\n        !this.offlineSessionIds_.length) {\n      // Explicit init data for any one stream or an offline session is\n      // sufficient to suppress 'encrypted' events for all streams.\n      const cb = (e) => this.newInitData(\n          e.initDataType, shaka.util.BufferUtils.toUint8(e.initData));\n      this.eventManager_.listen(this.video_, 'encrypted', cb);\n    }\n  }\n\n  /**\n   * Sets the server certificate based on the current DrmInfo.\n   *\n   * @return {!Promise}\n   */\n  async setServerCertificate() {\n    goog.asserts.assert(this.initialized_,\n        'Must call init() before setServerCertificate');\n\n    if (this.mediaKeys_ &&\n        this.currentDrmInfo_ &&\n        this.currentDrmInfo_.serverCertificate &&\n        this.currentDrmInfo_.serverCertificate.length) {\n      try {\n        const supported = await this.mediaKeys_.setServerCertificate(\n            this.currentDrmInfo_.serverCertificate);\n        if (!supported) {\n          shaka.log.warning('Server certificates are not supported by the ' +\n                            'key system.  The server certificate has been ' +\n                            'ignored.');\n        }\n      } catch (exception) {\n        throw new shaka.util.Error(\n            shaka.util.Error.Severity.CRITICAL,\n            shaka.util.Error.Category.DRM,\n            shaka.util.Error.Code.INVALID_SERVER_CERTIFICATE,\n            exception.message);\n      }\n    }\n  }\n\n  /**\n   * Remove an offline session and delete it's data. This can only be called\n   * after a successful call to |init|. This will wait until the\n   * 'license-release' message is handled. The returned Promise will be rejected\n   * if there is an error releasing the license.\n   *\n   * @param {string} sessionId\n   * @return {!Promise}\n   */\n  async removeSession(sessionId) {\n    goog.asserts.assert(this.mediaKeys_,\n        'Must call init() before removeSession');\n\n    const session = await this.loadOfflineSession_(sessionId);\n\n    // This will be null on error, such as session not found.\n    if (!session) {\n      shaka.log.v2('Ignoring attempt to remove missing session', sessionId);\n      return;\n    }\n\n    // TODO: Consider adding a timeout to get the 'message' event.\n    // Note that the 'message' event will get raised after the remove()\n    // promise resolves.\n    const tasks = [];\n\n    const found = this.activeSessions_.get(session);\n    if (found) {\n      // This will force us to wait until the 'license-release' message has been\n      // handled.\n      found.updatePromise = new shaka.util.PublicPromise();\n      tasks.push(found.updatePromise);\n    }\n\n    shaka.log.v2('Attempting to remove session', sessionId);\n    tasks.push(session.remove());\n\n    await Promise.all(tasks);\n  }\n\n  /**\n   * Creates the sessions for the init data and waits for them to become ready.\n   *\n   * @return {!Promise}\n   */\n  createOrLoad() {\n    // Create temp sessions.\n    const initDatas =\n        (this.currentDrmInfo_ ? this.currentDrmInfo_.initData : []) || [];\n    for (const initDataOverride of initDatas) {\n      this.newInitData(\n          initDataOverride.initDataType, initDataOverride.initData);\n    }\n\n    // Load each session.\n    for (const sessionId of this.offlineSessionIds_) {\n      this.loadOfflineSession_(sessionId);\n    }\n\n    // If we have no sessions, we need to resolve the promise right now or else\n    // it will never get resolved.\n    if (!initDatas.length && !this.offlineSessionIds_.length) {\n      this.allSessionsLoaded_.resolve();\n    }\n\n    return this.allSessionsLoaded_;\n  }\n\n  /**\n   * Called when new initialization data is encountered.  If this data hasn't\n   * been seen yet, this will create a new session for it.\n   *\n   * @param {string} initDataType\n   * @param {!Uint8Array} initData\n   */\n  newInitData(initDataType, initData) {\n    // Suppress duplicate init data.\n    // Note that some init data are extremely large and can't portably be used\n    // as keys in a dictionary.\n\n    const metadatas = this.activeSessions_.values();\n    for (const metadata of metadatas) {\n      // Tizen 2015 and 2016 models will send multiple webkitneedkey events\n      // with the same init data. If the duplicates are supressed, playback\n      // will stall without errors.\n      if (shaka.util.BufferUtils.equal(initData, metadata.initData) &&\n          !shaka.util.Platform.isTizen2()) {\n        shaka.log.debug('Ignoring duplicate init data.');\n        return;\n      }\n    }\n\n    this.createTemporarySession_(initDataType, initData);\n  }\n\n  /** @return {boolean} */\n  initialized() {\n    return this.initialized_;\n  }\n\n  /**\n   * @param {?shaka.extern.DrmInfo} drmInfo\n   * @return {string} */\n  static keySystem(drmInfo) {\n    return drmInfo ? drmInfo.keySystem : '';\n  }\n\n  /**\n   * Check if DrmEngine (as initialized) will likely be able to support the\n   * given content type.\n   *\n   * @param {string} contentType\n   * @return {boolean}\n   */\n  willSupport(contentType) {\n    // Edge 14 does not report correct capabilities.  It will only report the\n    // first MIME type even if the others are supported.  To work around this,\n    // we say that Edge supports everything.\n    //\n    // See https://github.com/google/shaka-player/issues/1495 for details.\n    if (shaka.util.Platform.isLegacyEdge()) {\n      return true;\n    }\n\n    contentType = contentType.toLowerCase();\n\n    if (shaka.util.Platform.isTizen() &&\n        contentType.includes('codecs=\"ac-3\"')) {\n      // Some Tizen devices seem to misreport AC-3 support.  This works around\n      // the issue, by falling back to EC-3, which seems to be supported on the\n      // same devices and be correctly reported in all cases we have observed.\n      // See https://github.com/google/shaka-player/issues/2989 for details.\n      const fallback = contentType.replace('ac-3', 'ec-3');\n      return this.supportedTypes_.has(contentType) ||\n             this.supportedTypes_.has(fallback);\n    }\n\n    return this.supportedTypes_.has(contentType);\n  }\n\n  /**\n   * Returns the ID of the sessions currently active.\n   *\n   * @return {!Array.<string>}\n   */\n  getSessionIds() {\n    const sessions = this.activeSessions_.keys();\n    const ids = shaka.util.Iterables.map(sessions, (s) => s.sessionId);\n\n    // TODO: Make |getSessionIds| return |Iterable| instead of |Array|.\n    return Array.from(ids);\n  }\n\n  /**\n   * Returns the next expiration time, or Infinity.\n   * @return {number}\n   */\n  getExpiration() {\n    // This will equal Infinity if there are no entries.\n    let min = Infinity;\n\n    const sessions = this.activeSessions_.keys();\n    for (const session of sessions) {\n      if (!isNaN(session.expiration)) {\n        min = Math.min(min, session.expiration);\n      }\n    }\n\n    return min;\n  }\n\n  /**\n   * Returns the time spent on license requests during this session, or NaN.\n   *\n   * @return {number}\n   */\n  getLicenseTime() {\n    if (this.licenseTimeSeconds_) {\n      return this.licenseTimeSeconds_;\n    }\n    return NaN;\n  }\n\n  /**\n   * Returns the DrmInfo that was used to initialize the current key system.\n   *\n   * @return {?shaka.extern.DrmInfo}\n   */\n  getDrmInfo() {\n    return this.currentDrmInfo_;\n  }\n\n  /**\n   * Returns the current key statuses.\n   *\n   * @return {!Object.<string, string>}\n   */\n  getKeyStatuses() {\n    return shaka.util.MapUtils.asObject(this.announcedKeyStatusByKeyId_);\n  }\n\n  /**\n   * @param {!Array.<shaka.extern.Variant>} variants\n   * @see https://bit.ly/EmeConfig for MediaKeySystemConfiguration spec\n   * @return {!Map.<string, MediaKeySystemConfiguration>}\n   * @private\n   */\n  prepareMediaKeyConfigsForVariants_(variants) {\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n\n    // Get all the drm info so that we can avoid using nested loops when we just\n    // need the drm info.\n    const allDrmInfo = new Set();\n    for (const variant of variants) {\n      const videoDrmInfos = variant.video ? variant.video.drmInfos : [];\n      const audioDrmInfos = variant.audio ? variant.audio.drmInfos : [];\n      const drmInfos = videoDrmInfos.concat(audioDrmInfos);\n      for (const info of drmInfos) {\n        allDrmInfo.add(info);\n      }\n    }\n\n    // Make sure all the drm infos are valid and filled in correctly.\n    for (const info of allDrmInfo) {\n      shaka.media.DrmEngine.fillInDrmInfoDefaults_(\n          info,\n          shaka.util.MapUtils.asMap(this.config_.servers),\n          shaka.util.MapUtils.asMap(this.config_.advanced || {}));\n    }\n\n    const persistentState =\n        this.usePersistentLicenses_ ? 'required' : 'optional';\n    const sessionTypes =\n        this.usePersistentLicenses_ ? ['persistent-license'] : ['temporary'];\n\n    const configs = new Map();\n\n    // Create a config entry for each key system.\n    for (const info of allDrmInfo) {\n      const config = {\n        // Ignore initDataTypes.\n        audioCapabilities: [],\n        videoCapabilities: [],\n        distinctiveIdentifier: 'optional',\n        persistentState: persistentState,\n        sessionTypes: sessionTypes,\n        label: info.keySystem,  // Tracked by us, ignored by EME.\n      };\n      // TODO: refactor, don't stick drmInfos onto MediaKeySystemConfiguration\n      config['drmInfos'] = [];  // Non-standard attribute, ignored by EME.\n\n      // Multiple calls to |set| will still respect the insertion order of the\n      // first call to |set| for a given key.\n      configs.set(info.keySystem, config);\n    }\n\n    // Connect each key system with each stream using it.\n    for (const variant of variants) {\n      /** @type {?shaka.extern.Stream} */\n      const audio = variant.audio;\n      /** @type {?shaka.extern.Stream} */\n      const video = variant.video;\n\n      // Add the last bit of information to each config;\n      for (const stream of [audio, video]) {\n        if (!stream) {\n          continue;\n        }\n\n        const mimeType = shaka.media.DrmEngine.computeMimeType_(stream);\n        let fallbackMimeType = null;\n\n        if (stream.codecs.toLowerCase() == 'ac-3' &&\n            shaka.util.Platform.isTizen()) {\n          // Some Tizen devices seem to misreport AC-3 support, but correctly\n          // report EC-3 support.  So query EC-3 as a fallback for AC-3.\n          // See https://github.com/google/shaka-player/issues/2989 for details.\n          fallbackMimeType = shaka.media.DrmEngine.computeMimeType_(stream,\n              'ec-3');\n        }\n\n        for (const info of stream.drmInfos) {\n          const config = configs.get(info.keySystem);\n          goog.asserts.assert(\n              config,\n              'Any missing configs should have be filled in before.');\n\n          // TODO: refactor, don't stick drmInfos onto\n          // MediaKeySystemConfiguration\n          config['drmInfos'].push(info);\n\n          if (info.distinctiveIdentifierRequired) {\n            config.distinctiveIdentifier = 'required';\n          }\n          if (info.persistentStateRequired) {\n            config.persistentState = 'required';\n          }\n\n          const robustness = (stream.type == ContentType.AUDIO) ?\n              info.audioRobustness : info.videoRobustness;\n\n          /** @type {MediaKeySystemMediaCapability} */\n          const capability = {\n            robustness: robustness || '',\n            contentType: mimeType,\n          };\n\n          if (stream.type == ContentType.AUDIO) {\n            config.audioCapabilities.push(capability);\n          } else {\n            config.videoCapabilities.push(capability);\n          }\n\n          // This is how we work around some misbehaving platforms by adding\n          // synthetic capability records using a fallback MIME type.\n          if (fallbackMimeType) {\n            /** @type {MediaKeySystemMediaCapability} */\n            const fallbackCapability = {\n              robustness: robustness || '',\n              contentType: fallbackMimeType,\n            };\n\n            if (stream.type == ContentType.AUDIO) {\n              config.audioCapabilities.push(fallbackCapability);\n            } else {\n              config.videoCapabilities.push(fallbackCapability);\n            }\n          }\n        } // for (const info of stream.drmInfos)\n      } // for (const stream of [audio, video])\n    }  // for (const variant of variants)\n\n    return configs;\n  }\n\n  /**\n   * @param {shaka.extern.Stream} stream\n   * @param {string=} codecOverride\n   * @return {string}\n   * @private\n   */\n  static computeMimeType_(stream, codecOverride) {\n    const realMimeType = shaka.util.MimeUtils.getFullType(stream.mimeType,\n        codecOverride || stream.codecs);\n    if (shaka.media.Transmuxer.isSupported(realMimeType)) {\n      // This will be handled by the Transmuxer, so use the MIME type that the\n      // Transmuxer will produce.\n      return shaka.media.Transmuxer.convertTsCodecs(stream.type, realMimeType);\n    }\n    return realMimeType;\n  }\n\n  /**\n   * @param {!Map.<string, MediaKeySystemConfiguration>} configsByKeySystem\n   *   A dictionary of configs, indexed by key system, with an iteration order\n   *   (insertion order) that reflects the preference for the application.\n   * @return {!Promise} Resolved if/when a key system has been chosen.\n   * @private\n   */\n  async queryMediaKeys_(configsByKeySystem) {\n    if (configsByKeySystem.size == 1 && configsByKeySystem.has('')) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.DRM,\n          shaka.util.Error.Code.NO_RECOGNIZED_KEY_SYSTEMS);\n    }\n\n    // If there are no tracks of a type, these should be not present.\n    // Otherwise the query will fail.\n    for (const config of configsByKeySystem.values()) {\n      if (config.audioCapabilities.length == 0) {\n        delete config.audioCapabilities;\n      }\n      if (config.videoCapabilities.length == 0) {\n        delete config.videoCapabilities;\n      }\n    }\n\n    let mediaKeySystemAccess;\n\n    // Try key systems with configured license servers first.  We only have to\n    // try key systems without configured license servers for diagnostic\n    // reasons, so that we can differentiate between \"none of these key systems\n    // are available\" and \"some are available, but you did not configure them\n    // properly.\"  The former takes precedence.\n    for (const shouldHaveLicenseServer of [true, false]) {\n      for (const keySystem of configsByKeySystem.keys()) {\n        const config = configsByKeySystem.get(keySystem);\n        // TODO: refactor, don't stick drmInfos onto MediaKeySystemConfiguration\n        const hasLicenseServer = config['drmInfos'].some((info) => {\n          return !!info.licenseServerUri;\n        });\n        if (hasLicenseServer != shouldHaveLicenseServer) {\n          continue;\n        }\n\n        try {\n          mediaKeySystemAccess =  // eslint-disable-next-line no-await-in-loop\n              await navigator.requestMediaKeySystemAccess(keySystem, [config]);\n          break;\n        } catch (error) {} // Suppress errors.\n        this.destroyer_.ensureNotDestroyed();\n      }\n      if (mediaKeySystemAccess) {\n        break;\n      }\n    }\n\n    if (!mediaKeySystemAccess) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.DRM,\n          shaka.util.Error.Code.REQUESTED_KEY_SYSTEM_CONFIG_UNAVAILABLE);\n    }\n    this.destroyer_.ensureNotDestroyed();\n\n    try {\n      // Get the set of supported content types from the audio and video\n      // capabilities. Avoid duplicates so that it is easier to read what is\n      // supported.\n      this.supportedTypes_.clear();\n\n      // Store the capabilities of the key system.\n      const realConfig = mediaKeySystemAccess.getConfiguration();\n      const audioCaps = realConfig.audioCapabilities || [];\n      const videoCaps = realConfig.videoCapabilities || [];\n\n      for (const cap of audioCaps) {\n        this.supportedTypes_.add(cap.contentType.toLowerCase());\n      }\n\n      for (const cap of videoCaps) {\n        this.supportedTypes_.add(cap.contentType.toLowerCase());\n      }\n\n      goog.asserts.assert(this.supportedTypes_.size,\n          'We should get at least one supported MIME type');\n\n      this.currentDrmInfo_ = shaka.media.DrmEngine.createDrmInfoFor_(\n          mediaKeySystemAccess.keySystem,\n          configsByKeySystem.get(mediaKeySystemAccess.keySystem));\n\n      if (!this.currentDrmInfo_.licenseServerUri) {\n        throw new shaka.util.Error(\n            shaka.util.Error.Severity.CRITICAL,\n            shaka.util.Error.Category.DRM,\n            shaka.util.Error.Code.NO_LICENSE_SERVER_GIVEN,\n            this.currentDrmInfo_.keySystem);\n      }\n\n      const mediaKeys = await mediaKeySystemAccess.createMediaKeys();\n      this.destroyer_.ensureNotDestroyed();\n      shaka.log.info('Created MediaKeys object for key system',\n          this.currentDrmInfo_.keySystem);\n\n      this.mediaKeys_ = mediaKeys;\n      this.initialized_ = true;\n\n      await this.setServerCertificate();\n      this.destroyer_.ensureNotDestroyed();\n    } catch (exception) {\n      this.destroyer_.ensureNotDestroyed(exception);\n\n      // Don't rewrap a shaka.util.Error from earlier in the chain:\n      this.currentDrmInfo_ = null;\n      this.supportedTypes_.clear();\n      if (exception instanceof shaka.util.Error) {\n        throw exception;\n      }\n\n      // We failed to create MediaKeys.  This generally shouldn't happen.\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.DRM,\n          shaka.util.Error.Code.FAILED_TO_CREATE_CDM,\n          exception.message);\n    }\n  }\n\n  /**\n   * Create a DrmInfo using configured clear keys.\n   * The server URI will be a data URI which decodes to a clearkey license.\n   * @return {?shaka.extern.DrmInfo} or null if clear keys are not configured.\n   * @private\n   * @see https://bit.ly/2K8gOnv for the spec on the clearkey license format.\n   */\n  configureClearKey_() {\n    const clearKeys = shaka.util.MapUtils.asMap(this.config_.clearKeys);\n    if (clearKeys.size == 0) {\n      return null;\n    }\n\n    const StringUtils = shaka.util.StringUtils;\n    const Uint8ArrayUtils = shaka.util.Uint8ArrayUtils;\n    const keys = [];\n    const keyIds = [];\n\n    clearKeys.forEach((keyHex, keyIdHex) => {\n      const keyId = Uint8ArrayUtils.fromHex(keyIdHex);\n      const key = Uint8ArrayUtils.fromHex(keyHex);\n      const keyObj = {\n        kty: 'oct',\n        kid: Uint8ArrayUtils.toBase64(keyId, false),\n        k: Uint8ArrayUtils.toBase64(key, false),\n      };\n\n      keys.push(keyObj);\n      keyIds.push(keyObj.kid);\n    });\n\n    const jwkSet = {keys: keys};\n    const license = JSON.stringify(jwkSet);\n\n    // Use the keyids init data since is suggested by EME.\n    // Suggestion: https://bit.ly/2JYcNTu\n    // Format: https://www.w3.org/TR/eme-initdata-keyids/\n    const initDataStr = JSON.stringify({'kids': keyIds});\n    const initData =\n        shaka.util.BufferUtils.toUint8(StringUtils.toUTF8(initDataStr));\n    const initDatas = [{initData: initData, initDataType: 'keyids'}];\n\n    return {\n      keySystem: 'org.w3.clearkey',\n      licenseServerUri: 'data:application/json;base64,' + window.btoa(license),\n      distinctiveIdentifierRequired: false,\n      persistentStateRequired: false,\n      audioRobustness: '',\n      videoRobustness: '',\n      serverCertificate: null,\n      initData: initDatas,\n      keyIds: new Set(keyIds),\n    };\n  }\n\n  /**\n   * @param {string} sessionId\n   * @return {!Promise.<MediaKeySession>}\n   * @private\n   */\n  async loadOfflineSession_(sessionId) {\n    let session;\n    try {\n      shaka.log.v1('Attempting to load an offline session', sessionId);\n      session = this.mediaKeys_.createSession('persistent-license');\n    } catch (exception) {\n      const error = new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.DRM,\n          shaka.util.Error.Code.FAILED_TO_CREATE_SESSION,\n          exception.message);\n      this.onError_(error);\n      return Promise.reject(error);\n    }\n\n    this.eventManager_.listen(session, 'message',\n        /** @type {shaka.util.EventManager.ListenerType} */(\n          (event) => this.onSessionMessage_(event)));\n    this.eventManager_.listen(session, 'keystatuseschange',\n        (event) => this.onKeyStatusesChange_(event));\n\n    const metadata = {\n      initData: null,\n      loaded: false,\n      oldExpiration: Infinity,\n      updatePromise: null,\n    };\n    this.activeSessions_.set(session, metadata);\n\n    try {\n      const present = await session.load(sessionId);\n      this.destroyer_.ensureNotDestroyed();\n      shaka.log.v2('Loaded offline session', sessionId, present);\n\n      if (!present) {\n        this.activeSessions_.delete(session);\n\n        this.onError_(new shaka.util.Error(\n            shaka.util.Error.Severity.CRITICAL,\n            shaka.util.Error.Category.DRM,\n            shaka.util.Error.Code.OFFLINE_SESSION_REMOVED));\n        return Promise.resolve();\n      }\n\n      // TODO: We should get a key status change event.  Remove once Chrome CDM\n      // is fixed.\n      metadata.loaded = true;\n      if (this.areAllSessionsLoaded_()) {\n        this.allSessionsLoaded_.resolve();\n      }\n\n      return session;\n    } catch (error) {\n      this.destroyer_.ensureNotDestroyed(error);\n\n      this.activeSessions_.delete(session);\n\n      this.onError_(new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.DRM,\n          shaka.util.Error.Code.FAILED_TO_CREATE_SESSION,\n          error.message));\n    }\n    return Promise.resolve();\n  }\n\n  /**\n   * @param {string} initDataType\n   * @param {!Uint8Array} initData\n   * @private\n   */\n  createTemporarySession_(initDataType, initData) {\n    let session;\n    try {\n      if (this.usePersistentLicenses_) {\n        shaka.log.v1('Creating new persistent session');\n        session = this.mediaKeys_.createSession('persistent-license');\n      } else {\n        shaka.log.v1('Creating new temporary session');\n        session = this.mediaKeys_.createSession();\n      }\n    } catch (exception) {\n      this.onError_(new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.DRM,\n          shaka.util.Error.Code.FAILED_TO_CREATE_SESSION,\n          exception.message));\n      return;\n    }\n\n    this.eventManager_.listen(session, 'message',\n    /** @type {shaka.util.EventManager.ListenerType} */(\n          (event) => this.onSessionMessage_(event)));\n    this.eventManager_.listen(session, 'keystatuseschange',\n        (event) => this.onKeyStatusesChange_(event));\n\n    const metadata = {\n      initData: initData,\n      loaded: false,\n      oldExpiration: Infinity,\n      updatePromise: null,\n    };\n    this.activeSessions_.set(session, metadata);\n\n    try {\n      initData = this.config_.initDataTransform(\n          initData, initDataType, this.currentDrmInfo_);\n    } catch (error) {\n      let shakaError = error;\n      if (!(error instanceof shaka.util.Error)) {\n        shakaError = new shaka.util.Error(\n            shaka.util.Error.Severity.CRITICAL,\n            shaka.util.Error.Category.DRM,\n            shaka.util.Error.Code.INIT_DATA_TRANSFORM_ERROR,\n            error);\n      }\n      this.onError_(shakaError);\n      return;\n    }\n\n    if (this.config_.logLicenseExchange) {\n      const str = shaka.util.Uint8ArrayUtils.toBase64(initData);\n      shaka.log.info('EME init data: type=', initDataType, 'data=', str);\n    }\n\n    session.generateRequest(initDataType, initData).catch((error) => {\n      if (this.destroyer_.destroyed()) {\n        return;\n      }\n      goog.asserts.assert(error instanceof Error, 'Wrong error type!');\n\n      this.activeSessions_.delete(session);\n\n      // This may be supplied by some polyfills.\n      /** @type {MediaKeyError} */\n      const errorCode = error['errorCode'];\n\n      let extended;\n      if (errorCode && errorCode.systemCode) {\n        extended = errorCode.systemCode;\n        if (extended < 0) {\n          extended += Math.pow(2, 32);\n        }\n        extended = '0x' + extended.toString(16);\n      }\n\n      this.onError_(new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.DRM,\n          shaka.util.Error.Code.FAILED_TO_GENERATE_LICENSE_REQUEST,\n          error.message, error, extended));\n    });\n  }\n\n  /**\n   * @param {!Uint8Array} initData\n   * @param {string} initDataType\n   * @param {?shaka.extern.DrmInfo} drmInfo\n   * @return {!Uint8Array}\n   */\n  static defaultInitDataTransform(initData, initDataType, drmInfo) {\n    if (initDataType == 'skd') {\n      const cert = drmInfo.serverCertificate;\n      const contentId =\n          shaka.util.FairPlayUtils.defaultGetContentId(initData);\n      initData = shaka.util.FairPlayUtils.initDataTransform(\n          initData, contentId, cert);\n    }\n    return initData;\n  }\n\n  /**\n   * @param {!MediaKeyMessageEvent} event\n   * @private\n   */\n  onSessionMessage_(event) {\n    if (this.delayLicenseRequest_()) {\n      this.mediaKeyMessageEvents_.push(event);\n    } else {\n      this.sendLicenseRequest_(event);\n    }\n  }\n\n  /**\n   * @return {boolean}\n   * @private\n   */\n  delayLicenseRequest_() {\n    if (!this.video_) {\n      // If there's no video, don't delay the license request; i.e., in the case\n      // of offline storage.\n      return false;\n    }\n    return (this.config_.delayLicenseRequestUntilPlayed &&\n            this.video_.paused && !this.initialRequestsSent_);\n  }\n\n  /**\n   * Sends a license request.\n   * @param {!MediaKeyMessageEvent} event\n   * @private\n   */\n  async sendLicenseRequest_(event) {\n    /** @type {!MediaKeySession} */\n    const session = event.target;\n    shaka.log.v1(\n        'Sending license request for session', session.sessionId, 'of type',\n        event.messageType);\n    if (this.config_.logLicenseExchange) {\n      const str = shaka.util.Uint8ArrayUtils.toBase64(event.message);\n      shaka.log.info('EME license request', str);\n    }\n\n    const metadata = this.activeSessions_.get(session);\n\n    let url = this.currentDrmInfo_.licenseServerUri;\n    const advancedConfig =\n        this.config_.advanced[this.currentDrmInfo_.keySystem];\n    if (event.messageType == 'individualization-request' && advancedConfig &&\n        advancedConfig.individualizationServer) {\n      url = advancedConfig.individualizationServer;\n    }\n\n    const requestType = shaka.net.NetworkingEngine.RequestType.LICENSE;\n    const request = shaka.net.NetworkingEngine.makeRequest(\n        [url], this.config_.retryParameters);\n    request.body = event.message;\n    request.method = 'POST';\n    request.licenseRequestType = event.messageType;\n    request.sessionId = session.sessionId;\n    // NOTE: allowCrossSiteCredentials can be set in a request filter.\n\n    if (this.currentDrmInfo_.keySystem == 'com.microsoft.playready' ||\n        this.currentDrmInfo_.keySystem == 'com.chromecast.playready') {\n      this.unpackPlayReadyRequest_(request);\n    }\n\n    const startTimeRequest = Date.now();\n\n    let response;\n    try {\n      const req = this.playerInterface_.netEngine.request(requestType, request);\n      response = await req.promise;\n    } catch (error) {\n      // Request failed!\n      goog.asserts.assert(error instanceof shaka.util.Error,\n          'Wrong NetworkingEngine error type!');\n      const shakaErr = new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.DRM,\n          shaka.util.Error.Code.LICENSE_REQUEST_FAILED,\n          error);\n      this.onError_(shakaErr);\n      if (metadata && metadata.updatePromise) {\n        metadata.updatePromise.reject(shakaErr);\n      }\n      return;\n    }\n    if (this.destroyer_.destroyed()) {\n      return;\n    }\n\n    this.licenseTimeSeconds_ += (Date.now() - startTimeRequest) / 1000;\n\n    if (this.config_.logLicenseExchange) {\n      const str = shaka.util.Uint8ArrayUtils.toBase64(response.data);\n      shaka.log.info('EME license response', str);\n    }\n\n    // Request succeeded, now pass the response to the CDM.\n    try {\n      shaka.log.v1('Updating session', session.sessionId);\n      await session.update(response.data);\n    } catch (error) {\n      // Session update failed!\n      const shakaErr = new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.DRM,\n          shaka.util.Error.Code.LICENSE_RESPONSE_REJECTED,\n          error.message);\n      this.onError_(shakaErr);\n      if (metadata && metadata.updatePromise) {\n        metadata.updatePromise.reject(shakaErr);\n      }\n      return;\n    }\n\n    const updateEvent = new shaka.util.FakeEvent('drmsessionupdate');\n    this.playerInterface_.onEvent(updateEvent);\n\n    if (metadata) {\n      if (metadata.updatePromise) {\n        metadata.updatePromise.resolve();\n      }\n      // In case there are no key statuses, consider this session loaded\n      // after a reasonable timeout.  It should definitely not take 5\n      // seconds to process a license.\n      const timer = new shaka.util.Timer(() => {\n        metadata.loaded = true;\n        if (this.areAllSessionsLoaded_()) {\n          this.allSessionsLoaded_.resolve();\n        }\n      });\n\n      timer.tickAfter(\n          /* seconds= */ shaka.media.DrmEngine.SESSION_LOAD_TIMEOUT_);\n    }\n  }\n\n  /**\n   * Unpacks PlayReady license requests.  Modifies the request object.\n   * @param {shaka.extern.Request} request\n   * @private\n   */\n  unpackPlayReadyRequest_(request) {\n    // On IE and Edge, the raw license message is UTF-16-encoded XML.  We need\n    // to unpack the Challenge element (base64-encoded string containing the\n    // actual license request) and any HttpHeader elements (sent as request\n    // headers).\n\n    // Example XML:\n\n    // <PlayReadyKeyMessage type=\"LicenseAcquisition\">\n    //   <LicenseAcquisition Version=\"1\">\n    //     <Challenge encoding=\"base64encoded\">{Base64Data}</Challenge>\n    //     <HttpHeaders>\n    //       <HttpHeader>\n    //         <name>Content-Type</name>\n    //         <value>text/xml; charset=utf-8</value>\n    //       </HttpHeader>\n    //       <HttpHeader>\n    //         <name>SOAPAction</name>\n    //         <value>http://schemas.microsoft.com/DRM/etc/etc</value>\n    //       </HttpHeader>\n    //     </HttpHeaders>\n    //   </LicenseAcquisition>\n    // </PlayReadyKeyMessage>\n\n    const xml = shaka.util.StringUtils.fromUTF16(\n        request.body, /* littleEndian= */ true, /* noThrow= */ true);\n    if (!xml.includes('PlayReadyKeyMessage')) {\n      // This does not appear to be a wrapped message as on IE and Edge.  Some\n      // clients do not need this unwrapping, so we will assume this is one of\n      // them.  Note that \"xml\" at this point probably looks like random\n      // garbage, since we interpreted UTF-8 as UTF-16.\n      shaka.log.debug('PlayReady request is already unwrapped.');\n      request.headers['Content-Type'] = 'text/xml; charset=utf-8';\n      return;\n    }\n    shaka.log.debug('Unwrapping PlayReady request.');\n    const dom = new DOMParser().parseFromString(xml, 'application/xml');\n\n    // Set request headers.\n    const headers = dom.getElementsByTagName('HttpHeader');\n    for (const header of headers) {\n      const name = header.getElementsByTagName('name')[0];\n      const value = header.getElementsByTagName('value')[0];\n      goog.asserts.assert(name && value, 'Malformed PlayReady headers!');\n      request.headers[name.textContent] = value.textContent;\n    }\n\n    // Unpack the base64-encoded challenge.\n    const challenge = dom.getElementsByTagName('Challenge')[0];\n    goog.asserts.assert(challenge, 'Malformed PlayReady challenge!');\n    goog.asserts.assert(challenge.getAttribute('encoding') == 'base64encoded',\n        'Unexpected PlayReady challenge encoding!');\n    request.body = shaka.util.Uint8ArrayUtils.fromBase64(challenge.textContent);\n  }\n\n  /**\n   * @param {!Event} event\n   * @private\n   * @suppress {invalidCasts} to swap keyId and status\n   */\n  onKeyStatusesChange_(event) {\n    const session = /** @type {!MediaKeySession} */(event.target);\n    shaka.log.v2('Key status changed for session', session.sessionId);\n\n    const found = this.activeSessions_.get(session);\n    const keyStatusMap = session.keyStatuses;\n    let hasExpiredKeys = false;\n\n    keyStatusMap.forEach((status, keyId) => {\n      // The spec has changed a few times on the exact order of arguments here.\n      // As of 2016-06-30, Edge has the order reversed compared to the current\n      // EME spec.  Given the back and forth in the spec, it may not be the only\n      // one.  Try to detect this and compensate:\n      if (typeof keyId == 'string') {\n        const tmp = keyId;\n        keyId = /** @type {!ArrayBuffer} */(status);\n        status = /** @type {string} */(tmp);\n      }\n\n      // Microsoft's implementation in Edge seems to present key IDs as\n      // little-endian UUIDs, rather than big-endian or just plain array of\n      // bytes.\n      // standard: 6e 5a 1d 26 - 27 57 - 47 d7 - 80 46 ea a5 d1 d3 4b 5a\n      // on Edge:  26 1d 5a 6e - 57 27 - d7 47 - 80 46 ea a5 d1 d3 4b 5a\n      // Bug filed: https://bit.ly/2thuzXu\n\n      // NOTE that we skip this if byteLength != 16.  This is used for the IE11\n      // and Edge 12 EME polyfill, which uses single-byte dummy key IDs.\n      // However, unlike Edge and Chromecast, Tizen doesn't have this problem.\n      if (this.currentDrmInfo_.keySystem == 'com.microsoft.playready' &&\n          keyId.byteLength == 16 &&\n          (shaka.util.Platform.isIE() || shaka.util.Platform.isEdge())) {\n        // Read out some fields in little-endian:\n        const dataView = shaka.util.BufferUtils.toDataView(keyId);\n        const part0 = dataView.getUint32(0, /* LE= */ true);\n        const part1 = dataView.getUint16(4, /* LE= */ true);\n        const part2 = dataView.getUint16(6, /* LE= */ true);\n        // Write it back in big-endian:\n        dataView.setUint32(0, part0, /* BE= */ false);\n        dataView.setUint16(4, part1, /* BE= */ false);\n        dataView.setUint16(6, part2, /* BE= */ false);\n      }\n\n      // Microsoft's implementation in IE11 seems to never set key status to\n      // 'usable'.  It is stuck forever at 'status-pending'.  In spite of this,\n      // the keys do seem to be usable and content plays correctly.\n      // Bug filed: https://bit.ly/2tpIU3n\n      // Microsoft has fixed the issue on Edge, but it remains in IE.\n      if (this.currentDrmInfo_.keySystem == 'com.microsoft.playready' &&\n          status == 'status-pending') {\n        status = 'usable';\n      }\n\n      if (status != 'status-pending') {\n        found.loaded = true;\n      }\n\n      if (!found) {\n        // We can get a key status changed for a closed session after it has\n        // been removed from |activeSessions_|.  If it is closed, none of its\n        // keys should be usable.\n        goog.asserts.assert(\n            status != 'usable', 'Usable keys found in closed session');\n      }\n\n      if (status == 'expired') {\n        hasExpiredKeys = true;\n      }\n\n      const keyIdHex = shaka.util.Uint8ArrayUtils.toHex(keyId);\n\n      this.keyStatusByKeyId_.set(keyIdHex, status);\n    });\n\n    // If the session has expired, close it.\n    // Some CDMs do not have sub-second time resolution, so the key status may\n    // fire with hundreds of milliseconds left until the stated expiration time.\n    const msUntilExpiration = session.expiration - Date.now();\n    if (msUntilExpiration < 0 || (hasExpiredKeys && msUntilExpiration < 1000)) {\n      // If this is part of a remove(), we don't want to close the session until\n      // the update is complete.  Otherwise, we will orphan the session.\n      if (found && !found.updatePromise) {\n        shaka.log.debug('Session has expired', session.sessionId);\n        this.activeSessions_.delete(session);\n        session.close().catch(() => {});  // Silence uncaught rejection errors\n      }\n    }\n\n    if (!this.areAllSessionsLoaded_()) {\n      // Don't announce key statuses or resolve the \"all loaded\" promise until\n      // everything is loaded.\n      return;\n    }\n\n    this.allSessionsLoaded_.resolve();\n\n    // Batch up key status changes before checking them or notifying Player.\n    // This handles cases where the statuses of multiple sessions are set\n    // simultaneously by the browser before dispatching key status changes for\n    // each of them.  By batching these up, we only send one status change event\n    // and at most one EXPIRED error on expiration.\n    this.keyStatusTimer_.tickAfter(\n        /* seconds= */ shaka.media.DrmEngine.KEY_STATUS_BATCH_TIME);\n  }\n\n  /** @private */\n  processKeyStatusChanges_() {\n    const privateMap = this.keyStatusByKeyId_;\n    const publicMap = this.announcedKeyStatusByKeyId_;\n\n    // Copy the latest key statuses into the publicly-accessible map.\n    publicMap.clear();\n    privateMap.forEach((status, keyId) => publicMap.set(keyId, status));\n\n    // If all keys are expired, fire an error. |every| is always true for an\n    // empty array but we shouldn't fire an error for a lack of key status info.\n    const statuses = Array.from(publicMap.values());\n    const allExpired = statuses.length &&\n                       statuses.every((status) => status == 'expired');\n\n    if (allExpired) {\n      this.onError_(new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.DRM,\n          shaka.util.Error.Code.EXPIRED));\n    }\n\n    this.playerInterface_.onKeyStatus(shaka.util.MapUtils.asObject(publicMap));\n  }\n\n  /**\n   * Returns true if the browser has recent EME APIs.\n   *\n   * @return {boolean}\n   */\n  static isBrowserSupported() {\n    const basic =\n        !!window.MediaKeys &&\n        !!window.navigator &&\n        !!window.navigator.requestMediaKeySystemAccess &&\n        !!window.MediaKeySystemAccess &&\n        // eslint-disable-next-line no-restricted-syntax\n        !!window.MediaKeySystemAccess.prototype.getConfiguration;\n\n    return basic;\n  }\n\n  /**\n   * Returns a Promise to a map of EME support for well-known key systems.\n   *\n   * @return {!Promise.<!Object.<string, ?shaka.extern.DrmSupportType>>}\n   */\n  static async probeSupport() {\n    goog.asserts.assert(shaka.media.DrmEngine.isBrowserSupported(),\n        'Must have basic EME support');\n\n    const testKeySystems = [\n      'org.w3.clearkey',\n      'com.widevine.alpha',\n      'com.microsoft.playready',\n      'com.apple.fps.3_0',\n      'com.apple.fps.2_0',\n      'com.apple.fps.1_0',\n      'com.apple.fps',\n      'com.adobe.primetime',\n    ];\n\n    const basicVideoCapabilities = [\n      {contentType: 'video/mp4; codecs=\"avc1.42E01E\"'},\n      {contentType: 'video/webm; codecs=\"vp8\"'},\n    ];\n\n    const basicConfig = {\n      videoCapabilities: basicVideoCapabilities,\n    };\n    const offlineConfig = {\n      videoCapabilities: basicVideoCapabilities,\n      persistentState: 'required',\n      sessionTypes: ['persistent-license'],\n    };\n\n    // Try the offline config first, then fall back to the basic config.\n    const configs = [offlineConfig, basicConfig];\n\n    /** @type {!Map.<string, ?shaka.extern.DrmSupportType>} */\n    const support = new Map();\n\n    const testSystem = async (keySystem) => {\n      try {\n        const access = await navigator.requestMediaKeySystemAccess(\n            keySystem, configs);\n\n        // Edge doesn't return supported session types, but current versions\n        // do not support persistent-license.  If sessionTypes is missing,\n        // assume no support for persistent-license.\n        // TODO: Polyfill Edge to return known supported session types.\n        // Edge bug: https://bit.ly/2IeKzho\n        const sessionTypes = access.getConfiguration().sessionTypes;\n        let persistentState = sessionTypes ?\n            sessionTypes.includes('persistent-license') : false;\n\n        // Tizen 3.0 doesn't support persistent licenses, but reports that it\n        // does.  It doesn't fail until you call update() with a license\n        // response, which is way too late.\n        // This is a work-around for #894.\n        if (shaka.util.Platform.isTizen3()) {\n          persistentState = false;\n        }\n\n        support.set(keySystem, {persistentState: persistentState});\n        await access.createMediaKeys();\n      } catch (e) {\n        // Either the request failed or createMediaKeys failed.\n        // Either way, write null to the support object.\n        support.set(keySystem, null);\n      }\n    };\n\n    // Test each key system.\n    const tests = testKeySystems.map((keySystem) => testSystem(keySystem));\n    await Promise.all(tests);\n    return shaka.util.MapUtils.asObject(support);\n  }\n\n  /** @private */\n  onPlay_() {\n    for (const event of this.mediaKeyMessageEvents_) {\n      this.sendLicenseRequest_(event);\n    }\n\n    this.initialRequestsSent_ = true;\n    this.mediaKeyMessageEvents_ = [];\n  }\n\n  /**\n   * Close a drm session while accounting for a bug in Chrome. Sometimes the\n   * Promise returned by close() never resolves.\n   *\n   * See issue #2741 and http://crbug.com/1108158.\n   * @param {!MediaKeySession} session\n   * @return {!Promise}\n   * @private\n   */\n  async closeSession_(session) {\n    const DrmEngine = shaka.media.DrmEngine;\n\n    const timeout = new Promise((resolve, reject) => {\n      const timer = new shaka.util.Timer(reject);\n      timer.tickAfter(DrmEngine.CLOSE_TIMEOUT_);\n    });\n\n    try {\n      await Promise.race([\n        Promise.all([session.close(), session.closed]),\n        timeout,\n      ]);\n    } catch (e) {\n      shaka.log.warning('Timeout waiting for session close');\n    }\n  }\n\n  /** @private */\n  async closeOpenSessions_() {\n    // Close all open sessions.\n    const openSessions = Array.from(this.activeSessions_.keys());\n    this.activeSessions_.clear();\n\n    // Close all sessions before we remove media keys from the video element.\n    await Promise.all(openSessions.map(async (session) => {\n      shaka.log.v1('Closing session', session.sessionId);\n\n      try {\n        await this.closeSession_(session);\n      } catch (error) {\n        // Ignore errors when closing the sessions. Closing a session that\n        // generated no key requests will throw an error.\n      }\n    }));\n  }\n\n  /**\n   * Check if a variant is likely to be supported by DrmEngine. This will err on\n   * the side of being too accepting and may not reject a variant that it will\n   * later fail to play.\n   *\n   * @param {!shaka.extern.Variant} variant\n   * @return {boolean}\n   */\n  supportsVariant(variant) {\n    /** @type {?shaka.extern.Stream} */\n    const audio = variant.audio;\n    /** @type {?shaka.extern.Stream} */\n    const video = variant.video;\n\n    if (audio && audio.encrypted) {\n      const audioContentType = shaka.media.DrmEngine.computeMimeType_(audio);\n      if (!this.willSupport(audioContentType)) {\n        return false;\n      }\n    }\n\n    if (video && video.encrypted) {\n      const videoContentType = shaka.media.DrmEngine.computeMimeType_(video);\n      if (!this.willSupport(videoContentType)) {\n        return false;\n      }\n    }\n\n    const keySystem = shaka.media.DrmEngine.keySystem(this.currentDrmInfo_);\n\n    const videoDrmInfos = video ? video.drmInfos : [];\n    const audioDrmInfos = audio ? audio.drmInfos : [];\n    const drmInfos = videoDrmInfos.concat(audioDrmInfos);\n\n    return drmInfos.length == 0 ||\n        drmInfos.some((drmInfo) => drmInfo.keySystem == keySystem);\n  }\n\n  /**\n   * Checks if two DrmInfos can be decrypted using the same key system.\n   * Clear content is considered compatible with every key system.\n   *\n   * @param {!Array.<!shaka.extern.DrmInfo>} drms1\n   * @param {!Array.<!shaka.extern.DrmInfo>} drms2\n   * @return {boolean}\n   */\n  static areDrmCompatible(drms1, drms2) {\n    if (!drms1.length || !drms2.length) {\n      return true;\n    }\n\n    return shaka.media.DrmEngine.getCommonDrmInfos(\n        drms1, drms2).length > 0;\n  }\n\n  /**\n   * Returns an array of drm infos that are present in both input arrays.\n   * If one of the arrays is empty, returns the other one since clear\n   * content is considered compatible with every drm info.\n   *\n   * @param {!Array.<!shaka.extern.DrmInfo>} drms1\n   * @param {!Array.<!shaka.extern.DrmInfo>} drms2\n   * @return {!Array.<!shaka.extern.DrmInfo>}\n   */\n  static getCommonDrmInfos(drms1, drms2) {\n    if (!drms1.length) {\n      return drms2;\n    }\n    if (!drms2.length) {\n      return drms1;\n    }\n\n    const commonDrms = [];\n\n    for (const drm1 of drms1) {\n      for (const drm2 of drms2) {\n        // This method is only called to compare drmInfos of a video and an\n        // audio adaptations, so we shouldn't have to worry about checking\n        // robustness.\n        if (drm1.keySystem == drm2.keySystem) {\n          let initData = [];\n          initData = initData.concat(drm1.initData || []);\n          initData = initData.concat(drm2.initData || []);\n          const keyIds = drm1.keyIds && drm2.keyIds ?\n              new Set([...drm1.keyIds, ...drm2.keyIds]) :\n              drm1.keyIds || drm2.keyIds;\n          const mergedDrm = {\n            keySystem: drm1.keySystem,\n            licenseServerUri: drm1.licenseServerUri || drm2.licenseServerUri,\n            distinctiveIdentifierRequired: drm1.distinctiveIdentifierRequired ||\n                drm2.distinctiveIdentifierRequired,\n            persistentStateRequired: drm1.persistentStateRequired ||\n                drm2.persistentStateRequired,\n            videoRobustness: drm1.videoRobustness || drm2.videoRobustness,\n            audioRobustness: drm1.audioRobustness || drm2.audioRobustness,\n            serverCertificate: drm1.serverCertificate || drm2.serverCertificate,\n            initData,\n            keyIds,\n          };\n          commonDrms.push(mergedDrm);\n          break;\n        }\n      }\n    }\n\n    return commonDrms;\n  }\n\n  /**\n   * Called in an interval timer to poll the expiration times of the sessions.\n   * We don't get an event from EME when the expiration updates, so we poll it\n   * so we can fire an event when it happens.\n   * @private\n   */\n  pollExpiration_() {\n    this.activeSessions_.forEach((metadata, session) => {\n      const oldTime = metadata.oldExpiration;\n      let newTime = session.expiration;\n      if (isNaN(newTime)) {\n        newTime = Infinity;\n      }\n\n      if (newTime != oldTime) {\n        this.playerInterface_.onExpirationUpdated(session.sessionId, newTime);\n        metadata.oldExpiration = newTime;\n      }\n    });\n  }\n\n  /**\n   * @return {boolean}\n   * @private\n   */\n  areAllSessionsLoaded_() {\n    const metadatas = this.activeSessions_.values();\n    return shaka.util.Iterables.every(metadatas, (data) => data.loaded);\n  }\n\n  /**\n   * Replace the drm info used in each variant in |variants| to reflect each\n   * key service in |keySystems|.\n   *\n   * @param {!Array.<shaka.extern.Variant>} variants\n   * @param {!Map.<string, string>} keySystems\n   * @private\n   */\n  static replaceDrmInfo_(variants, keySystems) {\n    const drmInfos = [];\n\n    keySystems.forEach((uri, keySystem) => {\n      drmInfos.push({\n        keySystem: keySystem,\n        licenseServerUri: uri,\n        distinctiveIdentifierRequired: false,\n        persistentStateRequired: false,\n        audioRobustness: '',\n        videoRobustness: '',\n        serverCertificate: null,\n        initData: [],\n        keyIds: new Set(),\n      });\n    });\n\n    for (const variant of variants) {\n      if (variant.video) {\n        variant.video.drmInfos = drmInfos;\n      }\n      if (variant.audio) {\n        variant.audio.drmInfos = drmInfos;\n      }\n    }\n  }\n\n  /**\n   * Creates a DrmInfo object describing the settings used to initialize the\n   * engine.\n   *\n   * @param {string} keySystem\n   * @param {MediaKeySystemConfiguration} config\n   * @return {shaka.extern.DrmInfo}\n   *\n   * @private\n   */\n  static createDrmInfoFor_(keySystem, config) {\n    /** @type {!Array.<string>} */\n    const licenseServers = [];\n\n    /** @type {!Array.<!Uint8Array>} */\n    const serverCerts = [];\n\n    /** @type {!Array.<!shaka.extern.InitDataOverride>} */\n    const initDatas = [];\n\n    /** @type {!Set.<string>} */\n    const keyIds = new Set();\n\n    // TODO: refactor, don't stick drmInfos onto MediaKeySystemConfiguration\n    shaka.media.DrmEngine.processDrmInfos_(\n        config['drmInfos'], licenseServers, serverCerts, initDatas, keyIds);\n\n    if (serverCerts.length > 1) {\n      shaka.log.warning('Multiple unique server certificates found! ' +\n                        'Only the first will be used.');\n    }\n\n    if (licenseServers.length > 1) {\n      shaka.log.warning('Multiple unique license server URIs found! ' +\n                        'Only the first will be used.');\n    }\n\n    // TODO: This only works when all DrmInfo have the same robustness.\n    const audioRobustness =\n        config.audioCapabilities ? config.audioCapabilities[0].robustness : '';\n    const videoRobustness =\n        config.videoCapabilities ? config.videoCapabilities[0].robustness : '';\n\n    const distinctiveIdentifier = config.distinctiveIdentifier;\n    return {\n      keySystem,\n      licenseServerUri: licenseServers[0],\n      distinctiveIdentifierRequired: (distinctiveIdentifier == 'required'),\n      persistentStateRequired: (config.persistentState == 'required'),\n      audioRobustness: audioRobustness || '',\n      videoRobustness: videoRobustness || '',\n      serverCertificate: serverCerts[0],\n      initData: initDatas,\n      keyIds,\n    };\n  }\n\n  /**\n   * Extract license server, server cert, and init data from |drmInfos|, taking\n   * care to eliminate duplicates.\n   *\n   * @param {!Array.<shaka.extern.DrmInfo>} drmInfos\n   * @param {!Array.<string>} licenseServers\n   * @param {!Array.<!Uint8Array>} serverCerts\n   * @param {!Array.<!shaka.extern.InitDataOverride>} initDatas\n   * @param {!Set.<string>} keyIds\n   * @private\n   */\n  static processDrmInfos_(\n      drmInfos, licenseServers, serverCerts, initDatas, keyIds) {\n    /** @type {function(shaka.extern.InitDataOverride,\n     *                  shaka.extern.InitDataOverride):boolean} */\n    const initDataOverrideEqual = (a, b) => {\n      if (a.keyId && a.keyId == b.keyId) {\n        // Two initDatas with the same keyId are considered to be the same,\n        // unless that \"same keyId\" is null.\n        return true;\n      }\n      return a.initDataType == b.initDataType &&\n         shaka.util.BufferUtils.equal(a.initData, b.initData);\n    };\n\n    for (const drmInfo of drmInfos) {\n      // Build an array of unique license servers.\n      if (!licenseServers.includes(drmInfo.licenseServerUri)) {\n        licenseServers.push(drmInfo.licenseServerUri);\n      }\n\n      // Build an array of unique server certs.\n      if (drmInfo.serverCertificate) {\n        const found = serverCerts.some(\n            (cert) => shaka.util.BufferUtils.equal(\n                cert, drmInfo.serverCertificate));\n        if (!found) {\n          serverCerts.push(drmInfo.serverCertificate);\n        }\n      }\n\n      // Build an array of unique init datas.\n      if (drmInfo.initData) {\n        for (const initDataOverride of drmInfo.initData) {\n          const found = initDatas.some(\n              (initData) =>\n                initDataOverrideEqual(initData, initDataOverride));\n          if (!found) {\n            initDatas.push(initDataOverride);\n          }\n        }\n      }\n\n      if (drmInfo.keyIds) {\n        for (const keyId of drmInfo.keyIds) {\n          keyIds.add(keyId);\n        }\n      }\n    }\n  }\n\n  /**\n   * Use |servers| and |advancedConfigs| to fill in missing values in drmInfo\n   * that the parser left blank. Before working with any drmInfo, it should be\n   * passed through here as it is uncommon for drmInfo to be complete when\n   * fetched from a manifest because most manifest formats do not have the\n   * required information.\n   *\n   * @param {shaka.extern.DrmInfo} drmInfo\n   * @param {!Map.<string, string>} servers\n   * @param {!Map.<string, shaka.extern.AdvancedDrmConfiguration>}\n   *   advancedConfigs\n   * @private\n   */\n  static fillInDrmInfoDefaults_(drmInfo, servers, advancedConfigs) {\n    if (!drmInfo.keySystem) {\n      // This is a placeholder from the manifest parser for an unrecognized key\n      // system.  Skip this entry, to avoid logging nonsensical errors.\n      return;\n    }\n\n    // The order of preference for drmInfo:\n    // 1. Clear Key config, used for debugging, should override everything else.\n    //    (The application can still specify a clearkey license server.)\n    // 2. Application-configured servers, if any are present, should override\n    //    anything from the manifest.  Nuance: if key system A is in the\n    //    manifest and key system B is in the player config, only B will be\n    //    used, not A.\n    // 3. Manifest-provided license servers are only used if nothing else is\n    //    specified.\n    // This is important because it allows the application a clear way to\n    // indicate which DRM systems should be used on platforms with multiple DRM\n    // systems.\n    // The only way to get license servers from the manifest is not to specify\n    // any in your player config.\n\n    if (drmInfo.keySystem == 'org.w3.clearkey' && drmInfo.licenseServerUri) {\n      // Preference 1: Clear Key with pre-configured keys will have a data URI\n      // assigned as its license server.  Don't change anything.\n      return;\n    } else if (servers.size) {\n      // Preference 2: If anything is configured at the application level,\n      // override whatever was in the manifest.\n      const server = servers.get(drmInfo.keySystem) || '';\n      drmInfo.licenseServerUri = server;\n    } else {\n      // Preference 3: Keep whatever we had in drmInfo.licenseServerUri, which\n      // comes from the manifest.\n    }\n\n    if (!drmInfo.keyIds) {\n      drmInfo.keyIds = new Set();\n    }\n\n    const advancedConfig = advancedConfigs.get(drmInfo.keySystem);\n    if (advancedConfig) {\n      if (!drmInfo.distinctiveIdentifierRequired) {\n        drmInfo.distinctiveIdentifierRequired =\n            advancedConfig.distinctiveIdentifierRequired;\n      }\n\n      if (!drmInfo.persistentStateRequired) {\n        drmInfo.persistentStateRequired =\n            advancedConfig.persistentStateRequired;\n      }\n\n      if (!drmInfo.videoRobustness) {\n        drmInfo.videoRobustness = advancedConfig.videoRobustness;\n      }\n\n      if (!drmInfo.audioRobustness) {\n        drmInfo.audioRobustness = advancedConfig.audioRobustness;\n      }\n\n      if (!drmInfo.serverCertificate) {\n        drmInfo.serverCertificate = advancedConfig.serverCertificate;\n      }\n    }\n\n    // Chromecast has a variant of PlayReady that uses a different key\n    // system ID.  Since manifest parsers convert the standard PlayReady\n    // UUID to the standard PlayReady key system ID, here we will switch\n    // to the Chromecast version if we are running on that platform.\n    // Note that this must come after fillInDrmInfoDefaults_, since the\n    // player config uses the standard PlayReady ID for license server\n    // configuration.\n    if (window.cast && window.cast.__platform__) {\n      if (drmInfo.keySystem == 'com.microsoft.playready') {\n        drmInfo.keySystem = 'com.chromecast.playready';\n      }\n    }\n  }\n};\n\n\n/**\n * @typedef {{\n *   loaded: boolean,\n *   initData: Uint8Array,\n *   oldExpiration: number,\n *   updatePromise: shaka.util.PublicPromise\n * }}\n *\n * @description A record to track sessions and suppress duplicate init data.\n * @property {boolean} loaded\n *   True once the key status has been updated (to a non-pending state).  This\n *   does not mean the session is 'usable'.\n * @property {Uint8Array} initData\n *   The init data used to create the session.\n * @property {!MediaKeySession} session\n *   The session object.\n * @property {number} oldExpiration\n *   The expiration of the session on the last check.  This is used to fire\n *   an event when it changes.\n * @property {shaka.util.PublicPromise} updatePromise\n *   An optional Promise that will be resolved/rejected on the next update()\n *   call.  This is used to track the 'license-release' message when calling\n *   remove().\n */\nshaka.media.DrmEngine.SessionMetaData;\n\n\n/**\n * @typedef {{\n *   netEngine: !shaka.net.NetworkingEngine,\n *   onError: function(!shaka.util.Error),\n *   onKeyStatus: function(!Object.<string,string>),\n *   onExpirationUpdated: function(string,number),\n *   onEvent: function(!Event)\n * }}\n *\n * @property {shaka.net.NetworkingEngine} netEngine\n *   The NetworkingEngine instance to use.  The caller retains ownership.\n * @property {function(!shaka.util.Error)} onError\n *   Called when an error occurs.  If the error is recoverable (see\n *   {@link shaka.util.Error}) then the caller may invoke either\n *   StreamingEngine.switch*() or StreamingEngine.seeked() to attempt recovery.\n * @property {function(!Object.<string,string>)} onKeyStatus\n *   Called when key status changes.  The argument is a map of hex key IDs to\n *   statuses.\n * @property {function(string,number)} onExpirationUpdated\n *   Called when the session expiration value changes.\n * @property {function(!Event)} onEvent\n *   Called when an event occurs that should be sent to the app.\n */\nshaka.media.DrmEngine.PlayerInterface;\n\n/**\n * The amount of time, in seconds, we wait to consider a session closed.\n * This allows us to work around Chrome bug https://crbug.com/1108158.\n * @private {number}\n */\nshaka.media.DrmEngine.CLOSE_TIMEOUT_ = 1;\n\n\n/**\n * The amount of time, in seconds, we wait to consider session loaded even if no\n * key status information is available.  This allows us to support browsers/CDMs\n * without key statuses.\n * @private {number}\n */\nshaka.media.DrmEngine.SESSION_LOAD_TIMEOUT_ = 5;\n\n\n/**\n * The amount of time, in seconds, we wait to batch up rapid key status changes.\n * This allows us to avoid multiple expiration events in most cases.\n * @type {number}\n */\nshaka.media.DrmEngine.KEY_STATUS_BATCH_TIME = 0.5;\n\n\n/**\n * Contains the suggested \"default\" key ID used by EME polyfills that do not\n * have a per-key key status. See w3c/encrypted-media#32.\n * @type {!shaka.util.Lazy.<!ArrayBuffer>}\n */\nshaka.media.DrmEngine.DUMMY_KEY_ID = new shaka.util.Lazy(\n    () => shaka.util.BufferUtils.toArrayBuffer(new Uint8Array([0])));\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.media.IClosedCaptionParser');\ngoog.provide('shaka.media.MuxJSClosedCaptionParser');\ngoog.provide('shaka.media.NoopCaptionParser');\n\ngoog.require('shaka.util.BufferUtils');\n\n\n/**\n * The IClosedCaptionParser defines the interface to provide all operations for\n * parsing the closed captions embedded in Dash videos streams.\n * @interface\n */\nshaka.media.IClosedCaptionParser = class {\n  /**\n   * Initialize the caption parser. This should be called only once.\n   * @param {BufferSource} data\n   */\n  init(data) {}\n\n  /**\n   * Parses embedded CEA closed captions and interacts with the underlying\n   * CaptionStream, and calls the callback function when there are closed\n   * captions.\n   *\n   * @param {BufferSource} data\n   * @param {function(Array.<muxjs.mp4.ClosedCaption>)} onCaptions\n   *         A callback function to handle the closed captions from parsed data.\n   */\n  parseFrom(data, onCaptions) {}\n\n  /**\n   * Resets the CaptionStream.\n   */\n  reset() {}\n};\n\n\n/**\n * Closed Caption Parser provides all operations for parsing the closed captions\n * embedded in Dash videos streams.\n *\n * @implements {shaka.media.IClosedCaptionParser}\n * @final\n */\nshaka.media.MuxJSClosedCaptionParser = class {\n  constructor() {\n    /** @private {muxjs.mp4.CaptionParser} */\n    this.muxCaptionParser_ = new muxjs.mp4.CaptionParser();\n\n    /** @private {!Array.<number>} */\n    this.videoTrackIds_ = [];\n\n    /**\n     * Timescales from the init segments, used for mux.js CaptionParser.\n     * @private {!Object.<number, number>}\n     */\n    this.timescales_ = {};\n  }\n\n  /**\n   * @override\n   */\n  init(data) {\n    const probe = muxjs.mp4.probe;\n    // Caption parser for Dash\n    const initBytes = shaka.util.BufferUtils.toUint8(data);\n    this.videoTrackIds_ = probe.videoTrackIds(initBytes);\n    this.timescales_ = probe.timescale(initBytes);\n    this.muxCaptionParser_.init();\n  }\n\n  /**\n   * @override\n   */\n  parseFrom(data, onCaptions) {\n    const segmentBytes = shaka.util.BufferUtils.toUint8(data);\n    const dashParsed = this.muxCaptionParser_.parse(\n        segmentBytes, this.videoTrackIds_, this.timescales_);\n    if (dashParsed && dashParsed.captions) {\n      onCaptions(dashParsed.captions);\n    }\n    // ParsedCaptions is used by mux.js to store the captions parsed so far.\n    // It should be reset every time some data is parsed, so as to store new\n    // data.\n    this.muxCaptionParser_.clearParsedCaptions();\n  }\n\n  /**\n   * @override\n   */\n  reset() {\n    this.muxCaptionParser_.resetCaptionStream();\n  }\n\n  /**\n   * Check if the MuxJS closed caption parser is supported on this platform.\n   *\n   * @return {boolean}\n   */\n  static isSupported() {\n    return !!window.muxjs;\n  }\n};\n\n/**\n * Noop Caption Parser creates an empty caption parser object when mux.js is not\n * available.\n *\n * @implements {shaka.media.IClosedCaptionParser}\n * @final\n */\nshaka.media.NoopCaptionParser = class {\n  /**\n   * @override\n   */\n  init(data) {}\n\n  /**\n   * @override\n   */\n  parseFrom(data, onCaptions) {}\n\n  /**\n   * @override\n   */\n  reset() {}\n};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.media.TimeRangesUtils');\n\ngoog.require('shaka.util.Iterables');\ngoog.require('shaka.util.Platform');\n\n\n/**\n * @summary A set of utility functions for dealing with TimeRanges objects.\n */\nshaka.media.TimeRangesUtils = class {\n  /**\n   * Gets the first timestamp in the buffer.\n   *\n   * @param {TimeRanges} b\n   * @return {?number} The first buffered timestamp, in seconds, if |buffered|\n   *   is non-empty; otherwise, return null.\n   */\n  static bufferStart(b) {\n    if (!b) {\n      return null;\n    }\n    // Workaround Safari bug: https://bit.ly/2trx6O8\n    if (b.length == 1 && b.end(0) - b.start(0) < 1e-6) {\n      return null;\n    }\n    // Workaround Edge bug: https://bit.ly/2JYLPeB\n    if (b.length == 1 && b.start(0) < 0) {\n      return 0;\n    }\n    return b.length ? b.start(0) : null;\n  }\n\n\n  /**\n   * Gets the last timestamp in the buffer.\n   *\n   * @param {TimeRanges} b\n   * @return {?number} The last buffered timestamp, in seconds, if |buffered|\n   *   is non-empty; otherwise, return null.\n   */\n  static bufferEnd(b) {\n    if (!b) {\n      return null;\n    }\n    // Workaround Safari bug: https://bit.ly/2trx6O8\n    if (b.length == 1 && b.end(0) - b.start(0) < 1e-6) {\n      return null;\n    }\n    return b.length ? b.end(b.length - 1) : null;\n  }\n\n\n  /**\n   * Determines if the given time is inside a buffered range.  This includes\n   * gaps, meaning that if the playhead is in a gap, it is considered buffered.\n   * If there is a small gap between the playhead and buffer start, consider it\n   * as buffered.\n   *\n   * @param {TimeRanges} b\n   * @param {number} time Playhead time\n   * @param {number=} smallGapLimit Set in configuration\n   * @return {boolean}\n   */\n  static isBuffered(b, time, smallGapLimit = 0) {\n    if (!b || !b.length) {\n      return false;\n    }\n    // Workaround Safari bug: https://bit.ly/2trx6O8\n    if (b.length == 1 && b.end(0) - b.start(0) < 1e-6) {\n      return false;\n    }\n\n    if (time > b.end(b.length - 1)) {\n      return false;\n    }\n    // Push the time forward by the gap limit so that it is more likely to be in\n    // the range.\n    return (time + smallGapLimit >= b.start(0));\n  }\n\n\n  /**\n   * Computes how far ahead of the given timestamp is buffered.  To provide\n   * smooth playback while jumping gaps, we don't include the gaps when\n   * calculating this.\n   * This only includes the amount of content that is buffered.\n   *\n   * @param {TimeRanges} b\n   * @param {number} time\n   * @return {number} The number of seconds buffered, in seconds, ahead of the\n   *   given time.\n   */\n  static bufferedAheadOf(b, time) {\n    if (!b || !b.length) {\n      return 0;\n    }\n    // Workaround Safari bug: https://bit.ly/2trx6O8\n    if (b.length == 1 && b.end(0) - b.start(0) < 1e-6) {\n      return 0;\n    }\n\n    // NOTE: On IE11, buffered ranges may show appended data before the\n    // associated append operation is complete.\n\n    // We calculate the buffered amount by ONLY accounting for the content\n    // buffered (i.e. we ignore the times of the gaps).  We also buffer through\n    // all gaps.\n    // Therefore, we start at the end and add up all buffers until |time|.\n    let result = 0;\n    for (const {start, end} of shaka.media.TimeRangesUtils.getBufferedInfo(b)) {\n      if (end > time) {\n        result += end - Math.max(start, time);\n      }\n    }\n\n    return result;\n  }\n\n\n  /**\n   * Determines if the given time is inside a gap between buffered ranges.  If\n   * it is, this returns the index of the buffer that is *ahead* of the gap.\n   *\n   * @param {TimeRanges} b\n   * @param {number} time\n   * @return {?number} The index of the buffer after the gap, or null if not in\n   *   a gap.\n   */\n  static getGapIndex(b, time) {\n    const Platform = shaka.util.Platform;\n    const TimeRangesUtils = shaka.media.TimeRangesUtils;\n\n    if (!b || !b.length) {\n      return null;\n    }\n    // Workaround Safari bug: https://bit.ly/2trx6O8\n    if (b.length == 1 && b.end(0) - b.start(0) < 1e-6) {\n      return null;\n    }\n\n    // Some browsers will stop earlier than others before a gap (e.g. IE/Edge\n    // stops 0.5 seconds before a gap). So for some browsers we need to use a\n    // larger threshold. See: https://bit.ly/2K5xmJO\n    const useLargeThreshold = Platform.isLegacyEdge() ||\n                              Platform.isIE() ||\n                              Platform.isTizen() ||\n                              Platform.isChromecast();\n\n    const threshold = useLargeThreshold ? 0.5 : 0.1;\n\n    const idx = TimeRangesUtils.getBufferedInfo(b).findIndex((item, i, arr) => {\n      return item.start > time &&\n          (i == 0 || arr[i - 1].end - time <= threshold);\n    });\n    return idx >= 0 ? idx : null;\n  }\n\n\n  /**\n   * @param {TimeRanges} b\n   * @return {!Array.<shaka.extern.BufferedRange>}\n   */\n  static getBufferedInfo(b) {\n    if (!b) {\n      return [];\n    }\n    const ret = [];\n    for (const i of shaka.util.Iterables.range(b.length)) {\n      ret.push({start: b.start(i), end: b.end(i)});\n    }\n    return ret;\n  }\n};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.text.Cue');\ngoog.provide('shaka.text.CueRegion');\n\ngoog.require('shaka.util.ArrayUtils');\n\n\n/**\n * @implements {shaka.extern.Cue}\n * @export\n */\nshaka.text.Cue = class {\n  /**\n   * @param {number} startTime\n   * @param {number} endTime\n   * @param {string} payload\n   */\n  constructor(startTime, endTime, payload) {\n    const Cue = shaka.text.Cue;\n\n    /**\n     * @override\n     * @exportInterface\n     */\n    this.startTime = startTime;\n\n    /**\n     * @override\n     * @exportInterface\n     */\n    this.direction = Cue.direction.HORIZONTAL_LEFT_TO_RIGHT;\n\n    /**\n     * @override\n     * @exportInterface\n     */\n    this.endTime = endTime;\n\n    /**\n     * @override\n     * @exportInterface\n     */\n    this.payload = payload;\n\n    /**\n     * @override\n     * @exportInterface\n     */\n    this.region = new shaka.text.CueRegion();\n\n    /**\n     * @override\n     * @exportInterface\n     */\n    this.position = null;\n\n    /**\n     * @override\n     * @exportInterface\n     */\n    this.positionAlign = Cue.positionAlign.AUTO;\n\n    /**\n     * @override\n     * @exportInterface\n     */\n    this.size = 0;\n\n    /**\n     * @override\n     * @exportInterface\n     */\n    this.textAlign = Cue.textAlign.CENTER;\n\n    /**\n     * @override\n     * @exportInterface\n     */\n    this.writingMode = Cue.writingMode.HORIZONTAL_TOP_TO_BOTTOM;\n\n    /**\n     * @override\n     * @exportInterface\n     */\n    this.lineInterpretation = Cue.lineInterpretation.LINE_NUMBER;\n\n    /**\n     * @override\n     * @exportInterface\n     */\n    this.line = null;\n\n    /**\n     * @override\n     * @exportInterface\n     */\n    this.lineHeight = '';\n\n    /**\n     * Line Alignment is set to start by default.\n     * @override\n     * @exportInterface\n     */\n    this.lineAlign = Cue.lineAlign.START;\n\n    /**\n     * Set the captions at the bottom of the text container by default.\n     * @override\n     * @exportInterface\n     */\n    this.displayAlign = Cue.displayAlign.AFTER;\n\n    /**\n     * @override\n     * @exportInterface\n     */\n    this.color = '';\n\n    /**\n     * @override\n     * @exportInterface\n     */\n    this.backgroundColor = '';\n\n    /**\n     * @override\n     * @exportInterface\n     */\n    this.backgroundImage = '';\n\n    /**\n     * @override\n     * @exportInterface\n     */\n    this.border = '';\n\n    /**\n     * @override\n     * @exportInterface\n     */\n    this.fontSize = '';\n\n    /**\n     * @override\n     * @exportInterface\n     */\n    this.fontWeight = Cue.fontWeight.NORMAL;\n\n    /**\n     * @override\n     * @exportInterface\n     */\n    this.fontStyle = Cue.fontStyle.NORMAL;\n\n    /**\n     * @override\n     * @exportInterface\n     */\n    this.fontFamily = '';\n\n    /**\n     * @override\n     * @exportInterface\n     */\n    this.letterSpacing = '';\n\n    /**\n     * @override\n     * @exportInterface\n     */\n    this.linePadding = '';\n\n    /**\n     * @override\n     * @exportInterface\n     */\n    this.opacity = 1;\n\n    /**\n     * @override\n     * @exportInterface\n     */\n    this.textDecoration = [];\n\n    /**\n     * @override\n     * @exportInterface\n     */\n    this.wrapLine = true;\n\n    /**\n     * @override\n     * @exportInterface\n     */\n    this.id = '';\n\n    /**\n     * @override\n     * @exportInterface\n     */\n    this.nestedCues = [];\n\n    /**\n     * @override\n     * @exportInterface\n     */\n    this.spacer = false;\n\n    /**\n     * @override\n     * @exportInterface\n     */\n    this.cellResolution = {\n      columns: 32,\n      rows: 15,\n    };\n  }\n\n  /**\n   * Create a copy of the cue with the same properties.\n   * @return {!shaka.text.Cue}\n   * @suppress {checkTypes} since we must use [] and \"in\" with a struct type.\n   */\n  clone() {\n    const clone = new shaka.text.Cue(0, 0, '');\n\n    for (const k in this) {\n      clone[k] = this[k];\n\n      // Make copies of array fields, but only one level deep.  That way, if we\n      // change, for instance, textDecoration on the clone, we don't affect the\n      // original.\n      if (clone[k] && clone[k].constructor == Array) {\n        clone[k] = /** @type {!Array} */(clone[k]).slice();\n      }\n    }\n\n    return clone;\n  }\n\n  /**\n   * Check if two Cues have all the same values in all properties.\n   * @param {!shaka.text.Cue} cue1\n   * @param {!shaka.text.Cue} cue2\n   * @return {boolean}\n   * @suppress {checkTypes} since we must use [] and \"in\" with a struct type.\n   */\n  static equal(cue1, cue2) {\n    // Compare the start time, end time and payload of the cues first for\n    // performance optimization.  We can avoid the more expensive recursive\n    // checks if the top-level properties don't match.\n    // See: https://github.com/google/shaka-player/issues/3018\n    if (cue1.startTime != cue2.startTime || cue1.endTime != cue2.endTime ||\n      cue1.payload != cue2.payload) {\n      return false;\n    }\n    for (const k in cue1) {\n      if (k == 'startTime' || k == 'endTime' || k == 'payload') {\n        // Already compared.\n      } else if (k == 'nestedCues') {\n        // This uses shaka.text.Cue.equal rather than just this.equal, since\n        // otherwise recursing here will unbox the method and cause \"this\" to be\n        // undefined in deeper recursion.\n        if (!shaka.util.ArrayUtils.equal(\n            cue1.nestedCues, cue2.nestedCues, shaka.text.Cue.equal)) {\n          return false;\n        }\n      } else if (k == 'region' || k == 'cellResolution') {\n        for (const k2 in cue1[k]) {\n          if (cue1[k][k2] != cue2[k][k2]) {\n            return false;\n          }\n        }\n      } else if (Array.isArray(cue1[k])) {\n        if (!shaka.util.ArrayUtils.equal(cue1[k], cue2[k])) {\n          return false;\n        }\n      } else {\n        if (cue1[k] != cue2[k]) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  }\n};\n\n\n/**\n * @enum {string}\n * @export\n */\nshaka.text.Cue.positionAlign = {\n  'LEFT': 'line-left',\n  'RIGHT': 'line-right',\n  'CENTER': 'center',\n  'AUTO': 'auto',\n};\n\n\n/**\n * @enum {string}\n * @export\n */\nshaka.text.Cue.textAlign = {\n  'LEFT': 'left',\n  'RIGHT': 'right',\n  'CENTER': 'center',\n  'START': 'start',\n  'END': 'end',\n};\n\n\n/**\n * Vertical alignments of the cues within their extents.\n * 'BEFORE' means displaying at the top of the captions container box, 'CENTER'\n *  means in the middle, 'BOTTOM' means at the bottom.\n * @enum {string}\n * @export\n */\nshaka.text.Cue.displayAlign = {\n  'BEFORE': 'before',\n  'CENTER': 'center',\n  'AFTER': 'after',\n};\n\n\n/**\n * @enum {string}\n * @export\n */\nshaka.text.Cue.direction = {\n  'HORIZONTAL_LEFT_TO_RIGHT': 'ltr',\n  'HORIZONTAL_RIGHT_TO_LEFT': 'rtl',\n};\n\n\n/**\n * @enum {string}\n * @export\n */\nshaka.text.Cue.writingMode = {\n  'HORIZONTAL_TOP_TO_BOTTOM': 'horizontal-tb',\n  'VERTICAL_LEFT_TO_RIGHT': 'vertical-lr',\n  'VERTICAL_RIGHT_TO_LEFT': 'vertical-rl',\n};\n\n\n/**\n * @enum {number}\n * @export\n */\nshaka.text.Cue.lineInterpretation = {\n  'LINE_NUMBER': 0,\n  'PERCENTAGE': 1,\n};\n\n\n/**\n * @enum {string}\n * @export\n */\nshaka.text.Cue.lineAlign = {\n  'CENTER': 'center',\n  'START': 'start',\n  'END': 'end',\n};\n\n\n/**\n * In CSS font weight can be a number, where 400 is normal and 700 is bold.\n * Use these values for the enum for consistency.\n * @enum {number}\n * @export\n */\nshaka.text.Cue.fontWeight = {\n  'NORMAL': 400,\n  'BOLD': 700,\n};\n\n\n/**\n * @enum {string}\n * @export\n */\nshaka.text.Cue.fontStyle = {\n  'NORMAL': 'normal',\n  'ITALIC': 'italic',\n  'OBLIQUE': 'oblique',\n};\n\n\n/**\n * @enum {string}\n * @export\n */\nshaka.text.Cue.textDecoration = {\n  'UNDERLINE': 'underline',\n  'LINE_THROUGH': 'lineThrough',\n  'OVERLINE': 'overline',\n};\n\n\n/**\n * @implements {shaka.extern.CueRegion}\n * @struct\n * @export\n */\nshaka.text.CueRegion = class {\n  constructor() {\n    const CueRegion = shaka.text.CueRegion;\n\n    /**\n     * @override\n     * @exportInterface\n     */\n    this.id = '';\n\n    /**\n     * @override\n     * @exportInterface\n     */\n    this.viewportAnchorX = 0;\n\n    /**\n     * @override\n     * @exportInterface\n     */\n    this.viewportAnchorY = 0;\n\n    /**\n     * @override\n     * @exportInterface\n     */\n    this.regionAnchorX = 0;\n\n    /**\n     * @override\n     * @exportInterface\n     */\n    this.regionAnchorY = 0;\n\n    /**\n     * @override\n     * @exportInterface\n     */\n    this.width = 100;\n\n    /**\n     * @override\n     * @exportInterface\n     */\n    this.height = 100;\n\n    /**\n     * @override\n     * @exportInterface\n     */\n    this.heightUnits = CueRegion.units.PERCENTAGE;\n\n    /**\n     * @override\n     * @exportInterface\n     */\n    this.widthUnits = CueRegion.units.PERCENTAGE;\n\n    /**\n     * @override\n     * @exportInterface\n     */\n    this.viewportAnchorUnits = CueRegion.units.PERCENTAGE;\n\n    /**\n     * @override\n     * @exportInterface\n     */\n    this.scroll = CueRegion.scrollMode.NONE;\n  }\n};\n\n\n/**\n * @enum {number}\n * @export\n */\nshaka.text.CueRegion.units = {\n  'PX': 0,\n  'PERCENTAGE': 1,\n  'LINES': 2,\n};\n\n\n/**\n * @enum {string}\n * @export\n */\nshaka.text.CueRegion.scrollMode = {\n  'NONE': '',\n  'UP': 'up',\n};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.text.TextEngine');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.text.Cue');\ngoog.require('shaka.util.BufferUtils');\ngoog.require('shaka.util.Functional');\ngoog.require('shaka.util.IDestroyable');\ngoog.require('shaka.util.MimeUtils');\n\n\n// TODO: revisit this when Closure Compiler supports partially-exported classes.\n/**\n * @summary Manages text parsers and cues.\n * @implements {shaka.util.IDestroyable}\n * @export\n */\nshaka.text.TextEngine = class {\n  /** @param {shaka.extern.TextDisplayer} displayer */\n  constructor(displayer) {\n    /** @private {shaka.extern.TextParser} */\n    this.parser_ = null;\n\n    /** @private {shaka.extern.TextDisplayer} */\n    this.displayer_ = displayer;\n\n    /** @private {number} */\n    this.timestampOffset_ = 0;\n\n    /** @private {number} */\n    this.appendWindowStart_ = 0;\n\n    /** @private {number} */\n    this.appendWindowEnd_ = Infinity;\n\n    /** @private {?number} */\n    this.bufferStart_ = null;\n\n    /** @private {?number} */\n    this.bufferEnd_ = null;\n\n    /** @private {string} */\n    this.selectedClosedCaptionId_ = '';\n\n    /**\n     * The closed captions map stores the CEA closed captions by closed captions\n     * id and start and end time.\n     * It's used as the buffer of closed caption text streams, to show captions\n     * when we start displaying captions or switch caption tracks, we need to be\n     * able to get the cues for the other language and display them without\n     * re-fetching the video segments they were embedded in.\n     * Structure of closed caption map:\n     * closed caption id -> {start and end time -> cues}\n     * @private {!Map.<string, !Map.<string, !Array.<shaka.text.Cue>>>} */\n    this.closedCaptionsMap_ = new Map();\n  }\n\n  /**\n   * @param {string} mimeType\n   * @param {!shaka.extern.TextParserPlugin} plugin\n   * @export\n   */\n  static registerParser(mimeType, plugin) {\n    shaka.text.TextEngine.parserMap_[mimeType] = plugin;\n  }\n\n  /**\n   * @param {string} mimeType\n   * @export\n   */\n  static unregisterParser(mimeType) {\n    delete shaka.text.TextEngine.parserMap_[mimeType];\n  }\n\n  /**\n   * @param {string} mimeType\n   * @return {boolean}\n   */\n  static isTypeSupported(mimeType) {\n    if (shaka.text.TextEngine.parserMap_[mimeType]) {\n      // An actual parser is available.\n      return true;\n    }\n    if (window.muxjs &&\n        mimeType == shaka.util.MimeUtils.CLOSED_CAPTION_MIMETYPE) {\n      // Will be handled by mux.js.\n      return true;\n    }\n    return false;\n  }\n\n  // TODO: revisit this when the compiler supports partially-exported classes.\n  /**\n   * @override\n   * @export\n   */\n  destroy() {\n    this.parser_ = null;\n    this.displayer_ = null;\n    this.closedCaptionsMap_.clear();\n\n    return Promise.resolve();\n  }\n\n  /**\n   * @param {!shaka.extern.TextDisplayer} displayer\n   */\n  setDisplayer(displayer) {\n    this.displayer_ = displayer;\n  }\n\n  /**\n   * Initialize the parser.  This can be called multiple times, but must be\n   * called at least once before appendBuffer.\n   *\n   * @param {string} mimeType\n   */\n  initParser(mimeType) {\n    // No parser for CEA, which is extracted from video and side-loaded\n    // into TextEngine and TextDisplayer.\n    if (mimeType == shaka.util.MimeUtils.CLOSED_CAPTION_MIMETYPE) {\n      return;\n    }\n\n    const factory = shaka.text.TextEngine.parserMap_[mimeType];\n    goog.asserts.assert(\n        factory, 'Text type negotiation should have happened already');\n    this.parser_ = shaka.util.Functional.callFactory(factory);\n  }\n\n  /**\n   * @param {BufferSource} buffer\n   * @param {?number} startTime relative to the start of the presentation\n   * @param {?number} endTime relative to the start of the presentation\n   * @return {!Promise}\n   */\n  async appendBuffer(buffer, startTime, endTime) {\n    goog.asserts.assert(\n        this.parser_, 'The parser should already be initialized');\n\n    // Start the operation asynchronously to avoid blocking the caller.\n    await Promise.resolve();\n\n    // Check that TextEngine hasn't been destroyed.\n    if (!this.parser_ || !this.displayer_) {\n      return;\n    }\n\n    if (startTime == null || endTime == null) {\n      this.parser_.parseInit(shaka.util.BufferUtils.toUint8(buffer));\n      return;\n    }\n\n    /** @type {shaka.extern.TextParser.TimeContext} **/\n    const time = {\n      periodStart: this.timestampOffset_,\n      segmentStart: startTime,\n      segmentEnd: endTime,\n    };\n\n    // Parse the buffer and add the new cues.\n    const allCues = this.parser_.parseMedia(\n        shaka.util.BufferUtils.toUint8(buffer), time);\n    const cuesToAppend = allCues.filter((cue) => {\n      return cue.startTime >= this.appendWindowStart_ &&\n          cue.startTime < this.appendWindowEnd_;\n    });\n\n    this.displayer_.append(cuesToAppend);\n\n    // NOTE: We update the buffered range from the start and end times\n    // passed down from the segment reference, not with the start and end\n    // times of the parsed cues.  This is important because some segments\n    // may contain no cues, but we must still consider those ranges\n    // buffered.\n    if (this.bufferStart_ == null) {\n      this.bufferStart_ = Math.max(startTime, this.appendWindowStart_);\n    } else {\n      // We already had something in buffer, and we assume we are extending\n      // the range from the end.\n      goog.asserts.assert(\n          this.bufferEnd_ != null,\n          'There should already be a buffered range end.');\n      goog.asserts.assert(\n          (startTime - this.bufferEnd_) <= 1,\n          'There should not be a gap in text references >1s');\n    }\n    this.bufferEnd_ = Math.min(endTime, this.appendWindowEnd_);\n  }\n\n  /**\n   * @param {number} startTime relative to the start of the presentation\n   * @param {number} endTime relative to the start of the presentation\n   * @return {!Promise}\n   */\n  async remove(startTime, endTime) {\n    // Start the operation asynchronously to avoid blocking the caller.\n    await Promise.resolve();\n\n    if (this.displayer_ && this.displayer_.remove(startTime, endTime)) {\n      if (this.bufferStart_ == null) {\n        goog.asserts.assert(\n            this.bufferEnd_ == null, 'end must be null if startTime is null');\n      } else {\n        goog.asserts.assert(\n            this.bufferEnd_ != null,\n            'end must be non-null if startTime is non-null');\n\n        // Update buffered range.\n        if (endTime <= this.bufferStart_ || startTime >= this.bufferEnd_) {\n          // No intersection.  Nothing was removed.\n        } else if (startTime <= this.bufferStart_ &&\n                   endTime >= this.bufferEnd_) {\n          // We wiped out everything.\n          this.bufferStart_ = this.bufferEnd_ = null;\n        } else if (startTime <= this.bufferStart_ &&\n                   endTime < this.bufferEnd_) {\n          // We removed from the beginning of the range.\n          this.bufferStart_ = endTime;\n        } else if (startTime > this.bufferStart_ &&\n                   endTime >= this.bufferEnd_) {\n          // We removed from the end of the range.\n          this.bufferEnd_ = startTime;\n        } else {\n          // We removed from the middle?  StreamingEngine isn't supposed to.\n          goog.asserts.assert(\n              false, 'removal from the middle is not supported by TextEngine');\n        }\n      }\n    }\n  }\n\n  /** @param {number} timestampOffset */\n  setTimestampOffset(timestampOffset) {\n    this.timestampOffset_ = timestampOffset;\n  }\n\n  /**\n   * @param {number} appendWindowStart\n   * @param {number} appendWindowEnd\n   */\n  setAppendWindow(appendWindowStart, appendWindowEnd) {\n    this.appendWindowStart_ = appendWindowStart;\n    this.appendWindowEnd_ = appendWindowEnd;\n  }\n\n  /**\n   * @return {?number} Time in seconds of the beginning of the buffered range,\n   *   or null if nothing is buffered.\n   */\n  bufferStart() {\n    return this.bufferStart_;\n  }\n\n  /**\n   * @return {?number} Time in seconds of the end of the buffered range,\n   *   or null if nothing is buffered.\n   */\n  bufferEnd() {\n    return this.bufferEnd_;\n  }\n\n  /**\n   * @param {number} t A timestamp\n   * @return {boolean}\n   */\n  isBuffered(t) {\n    if (this.bufferStart_ == null || this.bufferEnd_ == null) {\n      return false;\n    }\n    return t >= this.bufferStart_ && t < this.bufferEnd_;\n  }\n\n  /**\n   * @param {number} t A timestamp\n   * @return {number} Number of seconds ahead of 't' we have buffered\n   */\n  bufferedAheadOf(t) {\n    if (this.bufferEnd_ == null || this.bufferEnd_ < t) {\n      return 0;\n    }\n\n    goog.asserts.assert(\n        this.bufferStart_ != null,\n        'start should not be null if end is not null');\n\n    return this.bufferEnd_ - Math.max(t, this.bufferStart_);\n  }\n\n  /**\n   * Set the selected closed captions id.\n   * Append the cues stored in the closed captions map until buffer end time.\n   * This is to fill the gap between buffered and unbuffered captions, and to\n   * avoid duplicates that would be caused by any future video segments parsed\n   * for captions.\n   *\n   * @param {string} id\n   * @param {number} bufferEndTime Load any stored cues up to this time.\n   */\n  setSelectedClosedCaptionId(id, bufferEndTime) {\n    this.selectedClosedCaptionId_ = id;\n\n    const captionsMap = this.closedCaptionsMap_.get(id);\n    if (captionsMap) {\n      for (const startAndEndTime of captionsMap.keys()) {\n        /** @type {Array.<!shaka.text.Cue>} */\n        const cues = captionsMap.get(startAndEndTime)\n            .filter((c) => c.endTime <= bufferEndTime);\n        if (cues) {\n          this.displayer_.append(cues);\n        }\n      }\n    }\n  }\n\n  /**\n   * Store the closed captions in the text engine, and append the cues to the\n   * text displayer.  This is a side-channel used for embedded text only.\n   *\n   * @param {!Array.<muxjs.mp4.ClosedCaption>} closedCaptions\n   * @param {?number} startTime relative to the start of the presentation\n   * @param {?number} endTime relative to the start of the presentation\n   * @param {number} videoTimestampOffset the timestamp offset of the video\n   *   stream in which these captions were embedded\n   */\n  storeAndAppendClosedCaptions(\n      closedCaptions, startTime, endTime, videoTimestampOffset) {\n    const startAndEndTime = startTime + ' ' + endTime;\n    /** @type {!Map.<string, !Map.<string, !Array.<!shaka.text.Cue>>>} */\n    const captionsMap = new Map();\n\n    for (const caption of closedCaptions) {\n      const id = caption.stream;\n      if (!captionsMap.has(id)) {\n        captionsMap.set(id, new Map());\n      }\n      if (!captionsMap.get(id).has(startAndEndTime)) {\n        captionsMap.get(id).set(startAndEndTime, []);\n      }\n\n      // Adjust CEA captions with respect to the timestamp offset of the video\n      // stream in which they were embedded.\n      caption.startTime += videoTimestampOffset;\n      caption.endTime += videoTimestampOffset;\n\n      const keepThisCue =\n          caption.startTime >= this.appendWindowStart_ &&\n          caption.startTime < this.appendWindowEnd_;\n      if (!keepThisCue) {\n        continue;\n      }\n      /** @type {!shaka.text.Cue} */\n      const cue = new shaka.text.Cue(\n          caption.startTime, caption.endTime, caption.text);\n      captionsMap.get(id).get(startAndEndTime).push(cue);\n      if (id == this.selectedClosedCaptionId_) {\n        this.displayer_.append([cue]);\n      }\n    }\n\n    for (const id of captionsMap.keys()) {\n      if (!this.closedCaptionsMap_.has(id)) {\n        this.closedCaptionsMap_.set(id, new Map());\n      }\n      for (const startAndEndTime of captionsMap.get(id).keys()) {\n        const cues = captionsMap.get(id).get(startAndEndTime);\n        this.closedCaptionsMap_.get(id).set(startAndEndTime, cues);\n      }\n    }\n\n    if (this.bufferStart_ == null) {\n      this.bufferStart_ = Math.max(startTime, this.appendWindowStart_);\n    } else {\n      this.bufferStart_ = Math.min(\n          this.bufferStart_, Math.max(startTime, this.appendWindowStart_));\n    }\n\n    this.bufferEnd_ = Math.max(\n        this.bufferEnd_, Math.min(endTime, this.appendWindowEnd_));\n  }\n\n  /**\n   * Get the number of closed caption channels.\n   *\n   * This function is for TESTING ONLY. DO NOT USE in the library.\n   *\n   * @return {number}\n   */\n  getNumberOfClosedCaptionChannels() {\n    return this.closedCaptionsMap_.size;\n  }\n\n  /**\n   * Get the number of closed caption cues for a given channel. If there is\n   * no channel for the given channel id, this will return 0.\n   *\n   * This function is for TESTING ONLY. DO NOT USE in the library.\n   *\n   * @param {string} channelId\n   * @return {number}\n   */\n  getNumberOfClosedCaptionsInChannel(channelId) {\n    const channel = this.closedCaptionsMap_.get(channelId);\n    return channel ? channel.size : 0;\n  }\n};\n\n/** @private {!Object.<string, !shaka.extern.TextParserPlugin>} */\nshaka.text.TextEngine.parserMap_ = {};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.media.MediaSourceEngine');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.media.IClosedCaptionParser');\ngoog.require('shaka.media.TimeRangesUtils');\ngoog.require('shaka.media.Transmuxer');\ngoog.require('shaka.text.TextEngine');\ngoog.require('shaka.util.Destroyer');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.EventManager');\ngoog.require('shaka.util.Functional');\ngoog.require('shaka.util.IDestroyable');\ngoog.require('shaka.util.ManifestParserUtils');\ngoog.require('shaka.util.MimeUtils');\ngoog.require('shaka.util.Platform');\ngoog.require('shaka.util.PublicPromise');\n\n\n/**\n * @summary\n * MediaSourceEngine wraps all operations on MediaSource and SourceBuffers.\n * All asynchronous operations return a Promise, and all operations are\n * internally synchronized and serialized as needed.  Operations that can\n * be done in parallel will be done in parallel.\n *\n * @implements {shaka.util.IDestroyable}\n */\nshaka.media.MediaSourceEngine = class {\n  /**\n   * @param {HTMLMediaElement} video The video element, whose source is tied to\n   *   MediaSource during the lifetime of the MediaSourceEngine.\n   * @param {!shaka.media.IClosedCaptionParser} closedCaptionParser\n   *    The closed caption parser that should be used to parser closed captions\n   *    from the video stream. MediaSourceEngine takes ownership of the parser.\n   *    When MediaSourceEngine is destroyed, it will destroy the parser.\n   * @param {!shaka.extern.TextDisplayer} textDisplayer\n   *    The text displayer that will be used with the text engine.\n   *    MediaSourceEngine takes ownership of the displayer. When\n   *    MediaSourceEngine is destroyed, it will destroy the displayer.\n   * @param {!function(!Array.<shaka.extern.ID3Metadata>, number, ?number)=}\n   *    onMetadata\n   */\n  constructor(video, closedCaptionParser, textDisplayer,\n      onMetadata) {\n    /** @private {HTMLMediaElement} */\n    this.video_ = video;\n\n    /** @private {shaka.extern.TextDisplayer} */\n    this.textDisplayer_ = textDisplayer;\n\n    /** @private {!Object.<shaka.util.ManifestParserUtils.ContentType,\n                           SourceBuffer>} */\n    this.sourceBuffers_ = {};\n\n    /** @private {shaka.text.TextEngine} */\n    this.textEngine_ = null;\n\n    const onMetadataNoOp = (metadata, timestampOffset, segmentEnd) => {};\n\n    /** @private {!function(!Array.<shaka.extern.ID3Metadata>,\n                    number, ?number)} */\n    this.onMetadata_ = onMetadata || onMetadataNoOp;\n\n    /**\n     * @private {!Object.<string,\n     *                    !Array.<shaka.media.MediaSourceEngine.Operation>>}\n     */\n    this.queues_ = {};\n\n    /** @private {shaka.util.EventManager} */\n    this.eventManager_ = new shaka.util.EventManager();\n\n    /** @private {!Object.<string, !shaka.media.Transmuxer>} */\n    this.transmuxers_ = {};\n\n    /** @private {shaka.media.IClosedCaptionParser} */\n    this.captionParser_ = closedCaptionParser;\n\n    /** @private {!shaka.util.PublicPromise} */\n    this.mediaSourceOpen_ = new shaka.util.PublicPromise();\n\n    /** @private {MediaSource} */\n    this.mediaSource_ = this.createMediaSource(this.mediaSourceOpen_);\n\n    /** @type {!shaka.util.Destroyer} */\n    this.destroyer_ = new shaka.util.Destroyer(() => this.doDestroy_());\n\n    /** @private {string} */\n    this.url_ = '';\n  }\n\n  /**\n   * Create a MediaSource object, attach it to the video element, and return it.\n   * Resolves the given promise when the MediaSource is ready.\n   *\n   * Replaced by unit tests.\n   *\n   * @param {!shaka.util.PublicPromise} p\n   * @return {!MediaSource}\n   */\n  createMediaSource(p) {\n    const mediaSource = new MediaSource();\n\n    // Set up MediaSource on the video element.\n    this.eventManager_.listenOnce(\n        mediaSource, 'sourceopen', () => this.onSourceOpen_(p));\n\n    // Store the object URL for releasing it later.\n    this.url_ = shaka.media.MediaSourceEngine.createObjectURL(mediaSource);\n\n    this.video_.src = this.url_;\n\n    return mediaSource;\n  }\n\n  /**\n   * @param {!shaka.util.PublicPromise} p\n   * @private\n   */\n  onSourceOpen_(p) {\n    // Release the object URL that was previously created, to prevent memory\n    // leak.\n    // createObjectURL creates a strong reference to the MediaSource object\n    // inside the browser.  Setting the src of the video then creates another\n    // reference within the video element.  revokeObjectURL will remove the\n    // strong reference to the MediaSource object, and allow it to be\n    // garbage-collected later.\n    URL.revokeObjectURL(this.url_);\n    p.resolve();\n  }\n\n  /**\n   * Checks if a certain type is supported.\n   *\n   * @param {shaka.extern.Stream} stream\n   * @return {boolean}\n   */\n  static isStreamSupported(stream) {\n    const fullMimeType = shaka.util.MimeUtils.getFullType(\n        stream.mimeType, stream.codecs);\n    const extendedMimeType = shaka.util.MimeUtils.getExtendedType(stream);\n    return shaka.text.TextEngine.isTypeSupported(fullMimeType) ||\n        MediaSource.isTypeSupported(extendedMimeType) ||\n        shaka.media.Transmuxer.isSupported(fullMimeType, stream.type);\n  }\n\n  /**\n   * Returns a map of MediaSource support for well-known types.\n   *\n   * @return {!Object.<string, boolean>}\n   */\n  static probeSupport() {\n    const testMimeTypes = [\n      // MP4 types\n      'video/mp4; codecs=\"avc1.42E01E\"',\n      'video/mp4; codecs=\"avc3.42E01E\"',\n      'video/mp4; codecs=\"hev1.1.6.L93.90\"',\n      'video/mp4; codecs=\"hvc1.1.6.L93.90\"',\n      'video/mp4; codecs=\"hev1.2.4.L153.B0\"; eotf=\"smpte2084\"',  // HDR HEVC\n      'video/mp4; codecs=\"hvc1.2.4.L153.B0\"; eotf=\"smpte2084\"',  // HDR HEVC\n      'video/mp4; codecs=\"vp9\"',\n      'video/mp4; codecs=\"vp09.00.10.08\"',\n      'video/mp4; codecs=\"av01.0.01M.08\"',\n      'audio/mp4; codecs=\"mp4a.40.2\"',\n      'audio/mp4; codecs=\"ac-3\"',\n      'audio/mp4; codecs=\"ec-3\"',\n      'audio/mp4; codecs=\"opus\"',\n      'audio/mp4; codecs=\"flac\"',\n      // WebM types\n      'video/webm; codecs=\"vp8\"',\n      'video/webm; codecs=\"vp9\"',\n      'video/webm; codecs=\"vp09.00.10.08\"',\n      'audio/webm; codecs=\"vorbis\"',\n      'audio/webm; codecs=\"opus\"',\n      // MPEG2 TS types (video/ is also used for audio: https://bit.ly/TsMse)\n      'video/mp2t; codecs=\"avc1.42E01E\"',\n      'video/mp2t; codecs=\"avc3.42E01E\"',\n      'video/mp2t; codecs=\"hvc1.1.6.L93.90\"',\n      'video/mp2t; codecs=\"mp4a.40.2\"',\n      'video/mp2t; codecs=\"ac-3\"',\n      'video/mp2t; codecs=\"ec-3\"',\n      // WebVTT types\n      'text/vtt',\n      'application/mp4; codecs=\"wvtt\"',\n      // TTML types\n      'application/ttml+xml',\n      'application/mp4; codecs=\"stpp\"',\n    ];\n\n    const support = {};\n    for (const type of testMimeTypes) {\n      if (shaka.util.Platform.supportsMediaSource()) {\n        // Our TextEngine is only effective for MSE platforms at the moment.\n        if (shaka.text.TextEngine.isTypeSupported(type)) {\n          support[type] = true;\n        } else {\n          support[type] = MediaSource.isTypeSupported(type) ||\n                          shaka.media.Transmuxer.isSupported(type);\n        }\n      } else {\n        support[type] = shaka.util.Platform.supportsMediaType(type);\n      }\n\n      const basicType = type.split(';')[0];\n      support[basicType] = support[basicType] || support[type];\n    }\n\n    return support;\n  }\n\n  /** @override */\n  destroy() {\n    return this.destroyer_.destroy();\n  }\n\n  /** @private */\n  async doDestroy_() {\n    const Functional = shaka.util.Functional;\n\n    const cleanup = [];\n\n    for (const contentType in this.queues_) {\n      // Make a local copy of the queue and the first item.\n      const q = this.queues_[contentType];\n      const inProgress = q[0];\n\n      // Drop everything else out of the original queue.\n      this.queues_[contentType] = q.slice(0, 1);\n\n      // We will wait for this item to complete/fail.\n      if (inProgress) {\n        cleanup.push(inProgress.p.catch(Functional.noop));\n      }\n\n      // The rest will be rejected silently if possible.\n      for (const item of q.slice(1)) {\n        item.p.reject(shaka.util.Destroyer.destroyedError());\n      }\n    }\n\n    if (this.textEngine_) {\n      cleanup.push(this.textEngine_.destroy());\n    }\n    if (this.textDisplayer_) {\n      cleanup.push(this.textDisplayer_.destroy());\n    }\n\n    for (const contentType in this.transmuxers_) {\n      cleanup.push(this.transmuxers_[contentType].destroy());\n    }\n\n\n    await Promise.all(cleanup);\n    if (this.eventManager_) {\n      this.eventManager_.release();\n      this.eventManager_ = null;\n    }\n\n    if (this.video_) {\n      // \"unload\" the video element.\n      this.video_.removeAttribute('src');\n      this.video_.load();\n      this.video_ = null;\n    }\n\n    this.mediaSource_ = null;\n    this.textEngine_ = null;\n    this.textDisplayer_ = null;\n    this.sourceBuffers_ = {};\n    this.transmuxers_ = {};\n    this.captionParser_ = null;\n    if (goog.DEBUG) {\n      for (const contentType in this.queues_) {\n        goog.asserts.assert(\n            this.queues_[contentType].length == 0,\n            contentType + ' queue should be empty after destroy!');\n      }\n    }\n    this.queues_ = {};\n  }\n\n  /**\n   * @return {!Promise} Resolved when MediaSource is open and attached to the\n   *   media element.  This process is actually initiated by the constructor.\n   */\n  open() {\n    return this.mediaSourceOpen_;\n  }\n\n  /**\n   * Initialize MediaSourceEngine.\n   *\n   * Note that it is not valid to call this multiple times, except to add or\n   * reinitialize text streams.\n   *\n   * @param {!Map.<shaka.util.ManifestParserUtils.ContentType,\n   *               shaka.extern.Stream>} streamsByType\n   *   A map of content types to streams.  All streams must be supported\n   *   according to MediaSourceEngine.isStreamSupported.\n   * @param {boolean} forceTransmuxTS\n   *   If true, this will transmux TS content even if it is natively supported.\n   *\n   * @return {!Promise}\n   */\n  async init(streamsByType, forceTransmuxTS) {\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n\n    await this.mediaSourceOpen_;\n\n    for (const contentType of streamsByType.keys()) {\n      const stream = streamsByType.get(contentType);\n      goog.asserts.assert(\n          shaka.media.MediaSourceEngine.isStreamSupported(stream),\n          'Type negotiation should happen before MediaSourceEngine.init!');\n\n      let mimeType = shaka.util.MimeUtils.getFullType(\n          stream.mimeType, stream.codecs);\n      if (contentType == ContentType.TEXT) {\n        this.reinitText(mimeType);\n      } else {\n        if ((forceTransmuxTS || !MediaSource.isTypeSupported(mimeType)) &&\n            shaka.media.Transmuxer.isSupported(mimeType, contentType)) {\n          this.transmuxers_[contentType] = new shaka.media.Transmuxer();\n          mimeType =\n              shaka.media.Transmuxer.convertTsCodecs(contentType, mimeType);\n        }\n        const sourceBuffer = this.mediaSource_.addSourceBuffer(mimeType);\n        this.eventManager_.listen(\n            sourceBuffer, 'error',\n            () => this.onError_(contentType));\n        this.eventManager_.listen(\n            sourceBuffer, 'updateend',\n            () => this.onUpdateEnd_(contentType));\n        this.sourceBuffers_[contentType] = sourceBuffer;\n        this.queues_[contentType] = [];\n      }\n    }\n  }\n\n  /**\n   * Reinitialize the TextEngine for a new text type.\n   * @param {string} mimeType\n   */\n  reinitText(mimeType) {\n    if (!this.textEngine_) {\n      this.textEngine_ = new shaka.text.TextEngine(this.textDisplayer_);\n    }\n    this.textEngine_.initParser(mimeType);\n  }\n\n  /**\n   * @return {boolean} True if the MediaSource is in an \"ended\" state, or if the\n   *   object has been destroyed.\n   */\n  ended() {\n    return this.mediaSource_ ? this.mediaSource_.readyState == 'ended' : true;\n  }\n\n  /**\n   * Gets the first timestamp in buffer for the given content type.\n   *\n   * @param {shaka.util.ManifestParserUtils.ContentType} contentType\n   * @return {?number} The timestamp in seconds, or null if nothing is buffered.\n   */\n  bufferStart(contentType) {\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n    if (contentType == ContentType.TEXT) {\n      return this.textEngine_.bufferStart();\n    }\n    return shaka.media.TimeRangesUtils.bufferStart(\n        this.getBuffered_(contentType));\n  }\n\n  /**\n   * Gets the last timestamp in buffer for the given content type.\n   *\n   * @param {shaka.util.ManifestParserUtils.ContentType} contentType\n   * @return {?number} The timestamp in seconds, or null if nothing is buffered.\n   */\n  bufferEnd(contentType) {\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n    if (contentType == ContentType.TEXT) {\n      return this.textEngine_.bufferEnd();\n    }\n    return shaka.media.TimeRangesUtils.bufferEnd(\n        this.getBuffered_(contentType));\n  }\n\n  /**\n   * Determines if the given time is inside the buffered range of the given\n   * content type.\n   *\n   * @param {shaka.util.ManifestParserUtils.ContentType} contentType\n   * @param {number} time Playhead time\n   * @param {number=} smallGapLimit\n   * @return {boolean}\n   */\n  isBuffered(contentType, time, smallGapLimit) {\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n    if (contentType == ContentType.TEXT) {\n      return this.textEngine_.isBuffered(time);\n    } else {\n      const buffered = this.getBuffered_(contentType);\n      return shaka.media.TimeRangesUtils.isBuffered(\n          buffered, time, smallGapLimit);\n    }\n  }\n\n  /**\n   * Computes how far ahead of the given timestamp is buffered for the given\n   * content type.\n   *\n   * @param {shaka.util.ManifestParserUtils.ContentType} contentType\n   * @param {number} time\n   * @return {number} The amount of time buffered ahead in seconds.\n   */\n  bufferedAheadOf(contentType, time) {\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n    if (contentType == ContentType.TEXT) {\n      return this.textEngine_.bufferedAheadOf(time);\n    } else {\n      const buffered = this.getBuffered_(contentType);\n      return shaka.media.TimeRangesUtils.bufferedAheadOf(buffered, time);\n    }\n  }\n\n  /**\n   * Returns info about what is currently buffered.\n   * @return {shaka.extern.BufferedInfo}\n   */\n  getBufferedInfo() {\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n    const TimeRangeUtils = shaka.media.TimeRangesUtils;\n\n    const info = {\n      total: TimeRangeUtils.getBufferedInfo(this.video_.buffered),\n      audio: TimeRangeUtils.getBufferedInfo(\n          this.getBuffered_(ContentType.AUDIO)),\n      video: TimeRangeUtils.getBufferedInfo(\n          this.getBuffered_(ContentType.VIDEO)),\n      text: [],\n    };\n\n    if (this.textEngine_) {\n      const start = this.textEngine_.bufferStart();\n      const end = this.textEngine_.bufferEnd();\n\n      if (start != null && end != null) {\n        info.text.push({start: start, end: end});\n      }\n    }\n    return info;\n  }\n\n  /**\n   * @param {shaka.util.ManifestParserUtils.ContentType} contentType\n   * @return {TimeRanges} The buffered ranges for the given content type, or\n   *   null if the buffered ranges could not be obtained.\n   * @private\n   */\n  getBuffered_(contentType) {\n    try {\n      return this.sourceBuffers_[contentType].buffered;\n    } catch (exception) {\n      if (contentType in this.sourceBuffers_) {\n        // Note: previous MediaSource errors may cause access to |buffered| to\n        // throw.\n        shaka.log.error('failed to get buffered range for ' + contentType,\n            exception);\n      }\n      return null;\n    }\n  }\n\n  /**\n   * Enqueue an operation to append data to the SourceBuffer.\n   * Start and end times are needed for TextEngine, but not for MediaSource.\n   * Start and end times may be null for initialization segments; if present\n   * they are relative to the presentation timeline.\n   *\n   * @param {shaka.util.ManifestParserUtils.ContentType} contentType\n   * @param {BufferSource} data\n   * @param {?number} startTime relative to the start of the presentation\n   * @param {?number} endTime relative to the start of the presentation\n   * @param {?boolean} hasClosedCaptions True if the buffer contains CEA closed\n   * captions\n   * @return {!Promise}\n   */\n  async appendBuffer(contentType, data, startTime, endTime, hasClosedCaptions) {\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n\n    if (contentType == ContentType.TEXT) {\n      await this.textEngine_.appendBuffer(data, startTime, endTime);\n    } else if (this.transmuxers_[contentType]) {\n      const transmuxedData =\n          await this.transmuxers_[contentType].transmux(data);\n      // For HLS CEA-608/708 CLOSED-CAPTIONS, text data is embedded in\n      // the video stream, so textEngine may not have been initialized.\n      if (!this.textEngine_) {\n        this.reinitText('text/vtt');\n      }\n\n      if (transmuxedData.metadata) {\n        const timestampOffset =\n            this.sourceBuffers_[contentType].timestampOffset;\n        this.onMetadata_(transmuxedData.metadata, timestampOffset, endTime);\n      }\n      // This doesn't work for native TS support (ex. Edge/Chromecast),\n      // since no transmuxing is needed for native TS.\n      if (transmuxedData.captions && transmuxedData.captions.length) {\n        const videoOffset =\n        this.sourceBuffers_[ContentType.VIDEO].timestampOffset;\n        this.textEngine_.storeAndAppendClosedCaptions(\n            transmuxedData.captions, startTime, endTime, videoOffset);\n      }\n      await this.enqueueOperation_(\n          contentType, () => this.append_(contentType, transmuxedData.data));\n    } else if (hasClosedCaptions && window.muxjs) {\n      if (!this.textEngine_) {\n        this.reinitText('text/vtt');\n      }\n      // If it is the init segment for closed captions, initialize the closed\n      // caption parser.\n      if (startTime == null && endTime == null) {\n        this.captionParser_.init(data);\n      } else {\n        this.captionParser_.parseFrom(data, (captions) => {\n          if (captions.length) {\n            const videoOffset =\n            this.sourceBuffers_[ContentType.VIDEO].timestampOffset;\n            this.textEngine_.storeAndAppendClosedCaptions(\n                captions, startTime, endTime, videoOffset);\n          }\n        });\n      }\n      await this.enqueueOperation_(\n          contentType,\n          () => this.append_(contentType, data));\n    } else {\n      await this.enqueueOperation_(\n          contentType,\n          () => this.append_(contentType, data));\n    }\n  }\n\n  /**\n   * Set the selected closed captions Id and language.\n   *\n   * @param {string} id\n   */\n  setSelectedClosedCaptionId(id) {\n    const VIDEO = shaka.util.ManifestParserUtils.ContentType.VIDEO;\n    const videoBufferEndTime = this.bufferEnd(VIDEO) || 0;\n    this.textEngine_.setSelectedClosedCaptionId(id, videoBufferEndTime);\n  }\n\n  /**\n   * Enqueue an operation to remove data from the SourceBuffer.\n   *\n   * @param {shaka.util.ManifestParserUtils.ContentType} contentType\n   * @param {number} startTime relative to the start of the presentation\n   * @param {number} endTime relative to the start of the presentation\n   * @return {!Promise}\n   */\n  async remove(contentType, startTime, endTime) {\n    // On IE11, this operation would be permitted, but would have no effect!\n    // See https://github.com/google/shaka-player/issues/251\n    goog.asserts.assert(endTime < Number.MAX_VALUE,\n        'remove() with MAX_VALUE or Infinity is not IE-compatible!');\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n    if (contentType == ContentType.TEXT) {\n      await this.textEngine_.remove(startTime, endTime);\n    } else {\n      await this.enqueueOperation_(\n          contentType,\n          () => this.remove_(contentType, startTime, endTime));\n    }\n  }\n\n  /**\n   * Enqueue an operation to clear the SourceBuffer.\n   *\n   * @param {shaka.util.ManifestParserUtils.ContentType} contentType\n   * @return {!Promise}\n   */\n  async clear(contentType) {\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n    if (contentType == ContentType.TEXT) {\n      if (!this.textEngine_) {\n        return;\n      }\n      await this.textEngine_.remove(0, Infinity);\n    } else {\n      // Note that not all platforms allow clearing to Infinity.\n      await this.enqueueOperation_(\n          contentType,\n          () => this.remove_(contentType, 0, this.mediaSource_.duration));\n    }\n  }\n\n  /**\n   * Fully reset the state of the caption parser owned by MediaSourceEngine.\n   */\n  resetCaptionParser() {\n    this.captionParser_.reset();\n  }\n\n  /**\n   * Enqueue an operation to flush the SourceBuffer.\n   * This is a workaround for what we believe is a Chromecast bug.\n   *\n   * @param {shaka.util.ManifestParserUtils.ContentType} contentType\n   * @return {!Promise}\n   */\n  async flush(contentType) {\n    // Flush the pipeline.  Necessary on Chromecast, even though we have removed\n    // everything.\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n    if (contentType == ContentType.TEXT) {\n      // Nothing to flush for text.\n      return;\n    }\n    await this.enqueueOperation_(\n        contentType,\n        () => this.flush_(contentType));\n  }\n\n  /**\n   * Sets the timestamp offset and append window end for the given content type.\n   *\n   * @param {shaka.util.ManifestParserUtils.ContentType} contentType\n   * @param {number} timestampOffset The timestamp offset.  Segments which start\n   *   at time t will be inserted at time t + timestampOffset instead.  This\n   *   value does not affect segments which have already been inserted.\n   * @param {number} appendWindowStart The timestamp to set the append window\n   *   start to.  For future appends, frames/samples with timestamps less than\n   *   this value will be dropped.\n   * @param {number} appendWindowEnd The timestamp to set the append window end\n   *   to.  For future appends, frames/samples with timestamps greater than this\n   *   value will be dropped.\n   * @return {!Promise}\n   */\n  async setStreamProperties(\n      contentType, timestampOffset, appendWindowStart, appendWindowEnd) {\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n    if (contentType == ContentType.TEXT) {\n      this.textEngine_.setTimestampOffset(timestampOffset);\n      this.textEngine_.setAppendWindow(appendWindowStart, appendWindowEnd);\n      return;\n    }\n\n    await Promise.all([\n      // Queue an abort() to help MSE splice together overlapping segments.\n      // We set appendWindowEnd when we change periods in DASH content, and the\n      // period transition may result in overlap.\n      //\n      // An abort() also helps with MPEG2-TS.  When we append a TS segment, we\n      // always enter a PARSING_MEDIA_SEGMENT state and we can't change the\n      // timestamp offset.  By calling abort(), we reset the state so we can\n      // set it.\n      this.enqueueOperation_(\n          contentType,\n          () => this.abort_(contentType)),\n      this.enqueueOperation_(\n          contentType,\n          () => this.setTimestampOffset_(contentType, timestampOffset)),\n      this.enqueueOperation_(\n          contentType,\n          () => this.setAppendWindow_(\n              contentType, appendWindowStart, appendWindowEnd)),\n    ]);\n  }\n\n  /**\n   * @param {string=} reason Valid reasons are 'network' and 'decode'.\n   * @return {!Promise}\n   * @see http://w3c.github.io/media-source/#idl-def-EndOfStreamError\n   */\n  async endOfStream(reason) {\n    await this.enqueueBlockingOperation_(() => {\n      // If endOfStream() has already been called on the media source,\n      // don't call it again.\n      if (this.ended()) {\n        return;\n      }\n      // Tizen and IE11 won't let us pass undefined, but it will let us omit the\n      // argument.\n      if (reason) {\n        this.mediaSource_.endOfStream(reason);\n      } else {\n        this.mediaSource_.endOfStream();\n      }\n    });\n  }\n\n  /**\n   * We only support increasing duration at this time.  Decreasing duration\n   * causes the MSE removal algorithm to run, which results in an 'updateend'\n   * event.  Supporting this scenario would be complicated, and is not currently\n   * needed.\n   *\n   * @param {number} duration\n   * @return {!Promise}\n   */\n  async setDuration(duration) {\n    goog.asserts.assert(\n        isNaN(this.mediaSource_.duration) ||\n            this.mediaSource_.duration <= duration,\n        'duration cannot decrease: ' + this.mediaSource_.duration + ' -> ' +\n            duration);\n    await this.enqueueBlockingOperation_(() => {\n      this.mediaSource_.duration = duration;\n    });\n  }\n\n  /**\n   * Get the current MediaSource duration.\n   *\n   * @return {number}\n   */\n  getDuration() {\n    return this.mediaSource_.duration;\n  }\n\n  /**\n   * Append data to the SourceBuffer.\n   * @param {shaka.util.ManifestParserUtils.ContentType} contentType\n   * @param {BufferSource} data\n   * @private\n   */\n  append_(contentType, data) {\n    // This will trigger an 'updateend' event.\n    this.sourceBuffers_[contentType].appendBuffer(data);\n  }\n\n  /**\n   * Remove data from the SourceBuffer.\n   * @param {shaka.util.ManifestParserUtils.ContentType} contentType\n   * @param {number} startTime relative to the start of the presentation\n   * @param {number} endTime relative to the start of the presentation\n   * @private\n   */\n  remove_(contentType, startTime, endTime) {\n    if (endTime <= startTime) {\n      // Ignore removal of inverted or empty ranges.\n      // Fake 'updateend' event to resolve the operation.\n      this.onUpdateEnd_(contentType);\n      return;\n    }\n\n    // This will trigger an 'updateend' event.\n    this.sourceBuffers_[contentType].remove(startTime, endTime);\n  }\n\n  /**\n   * Call abort() on the SourceBuffer.\n   * This resets MSE's last_decode_timestamp on all track buffers, which should\n   * trigger the splicing logic for overlapping segments.\n   * @param {shaka.util.ManifestParserUtils.ContentType} contentType\n   * @private\n   */\n  abort_(contentType) {\n    // Save the append window, which is reset on abort().\n    const appendWindowStart =\n        this.sourceBuffers_[contentType].appendWindowStart;\n    const appendWindowEnd = this.sourceBuffers_[contentType].appendWindowEnd;\n\n    // This will not trigger an 'updateend' event, since nothing is happening.\n    // This is only to reset MSE internals, not to abort an actual operation.\n    this.sourceBuffers_[contentType].abort();\n\n    // Restore the append window.\n    this.sourceBuffers_[contentType].appendWindowStart = appendWindowStart;\n    this.sourceBuffers_[contentType].appendWindowEnd = appendWindowEnd;\n\n    // Fake an 'updateend' event to resolve the operation.\n    this.onUpdateEnd_(contentType);\n  }\n\n  /**\n   * Nudge the playhead to force the media pipeline to be flushed.\n   * This seems to be necessary on Chromecast to get new content to replace old\n   * content.\n   * @param {shaka.util.ManifestParserUtils.ContentType} contentType\n   * @private\n   */\n  flush_(contentType) {\n    // Never use flush_ if there's data.  It causes a hiccup in playback.\n    goog.asserts.assert(\n        this.video_.buffered.length == 0, 'MediaSourceEngine.flush_ should ' +\n        'only be used after clearing all data!');\n\n    // Seeking forces the pipeline to be flushed.\n    this.video_.currentTime -= 0.001;\n\n    // Fake an 'updateend' event to resolve the operation.\n    this.onUpdateEnd_(contentType);\n  }\n\n  /**\n   * Set the SourceBuffer's timestamp offset.\n   * @param {shaka.util.ManifestParserUtils.ContentType} contentType\n   * @param {number} timestampOffset\n   * @private\n   */\n  setTimestampOffset_(contentType, timestampOffset) {\n    // Work around for https://github.com/google/shaka-player/issues/1281:\n    // TODO(https://bit.ly/2ttKiBU): follow up when this is fixed in Edge\n    if (timestampOffset < 0) {\n      // Try to prevent rounding errors in Edge from removing the first\n      // keyframe.\n      timestampOffset += 0.001;\n    }\n\n    this.sourceBuffers_[contentType].timestampOffset = timestampOffset;\n\n    // Fake an 'updateend' event to resolve the operation.\n    this.onUpdateEnd_(contentType);\n  }\n\n  /**\n   * Set the SourceBuffer's append window end.\n   * @param {shaka.util.ManifestParserUtils.ContentType} contentType\n   * @param {number} appendWindowStart\n   * @param {number} appendWindowEnd\n   * @private\n   */\n  setAppendWindow_(contentType, appendWindowStart, appendWindowEnd) {\n    // You can't set start > end, so first set start to 0, then set the new\n    // end, then set the new start.  That way, there are no intermediate\n    // states which are invalid.\n    this.sourceBuffers_[contentType].appendWindowStart = 0;\n    this.sourceBuffers_[contentType].appendWindowEnd = appendWindowEnd;\n    this.sourceBuffers_[contentType].appendWindowStart = appendWindowStart;\n\n    // Fake an 'updateend' event to resolve the operation.\n    this.onUpdateEnd_(contentType);\n  }\n\n  /**\n   * @param {shaka.util.ManifestParserUtils.ContentType} contentType\n   * @private\n   */\n  onError_(contentType) {\n    const operation = this.queues_[contentType][0];\n    goog.asserts.assert(operation, 'Spurious error event!');\n    goog.asserts.assert(!this.sourceBuffers_[contentType].updating,\n        'SourceBuffer should not be updating on error!');\n    const code = this.video_.error ? this.video_.error.code : 0;\n    operation.p.reject(new shaka.util.Error(\n        shaka.util.Error.Severity.CRITICAL,\n        shaka.util.Error.Category.MEDIA,\n        shaka.util.Error.Code.MEDIA_SOURCE_OPERATION_FAILED,\n        code));\n    // Do not pop from queue.  An 'updateend' event will fire next, and to\n    // avoid synchronizing these two event handlers, we will allow that one to\n    // pop from the queue as normal.  Note that because the operation has\n    // already been rejected, the call to resolve() in the 'updateend' handler\n    // will have no effect.\n  }\n\n  /**\n   * @param {shaka.util.ManifestParserUtils.ContentType} contentType\n   * @private\n   */\n  onUpdateEnd_(contentType) {\n    const operation = this.queues_[contentType][0];\n    goog.asserts.assert(operation, 'Spurious updateend event!');\n    if (!operation) {\n      return;\n    }\n    goog.asserts.assert(!this.sourceBuffers_[contentType].updating,\n        'SourceBuffer should not be updating on updateend!');\n    operation.p.resolve();\n    this.popFromQueue_(contentType);\n  }\n\n  /**\n   * Enqueue an operation and start it if appropriate.\n   *\n   * @param {shaka.util.ManifestParserUtils.ContentType} contentType\n   * @param {function()} start\n   * @return {!Promise}\n   * @private\n   */\n  enqueueOperation_(contentType, start) {\n    this.destroyer_.ensureNotDestroyed();\n\n    const operation = {\n      start: start,\n      p: new shaka.util.PublicPromise(),\n    };\n    this.queues_[contentType].push(operation);\n\n    if (this.queues_[contentType].length == 1) {\n      this.startOperation_(contentType);\n    }\n    return operation.p;\n  }\n\n  /**\n   * Enqueue an operation which must block all other operations on all\n   * SourceBuffers.\n   *\n   * @param {function()} run\n   * @return {!Promise}\n   * @private\n   */\n  async enqueueBlockingOperation_(run) {\n    this.destroyer_.ensureNotDestroyed();\n\n    /** @type {!Array.<!shaka.util.PublicPromise>} */\n    const allWaiters = [];\n\n    // Enqueue a 'wait' operation onto each queue.\n    // This operation signals its readiness when it starts.\n    // When all wait operations are ready, the real operation takes place.\n    for (const contentType in this.sourceBuffers_) {\n      const ready = new shaka.util.PublicPromise();\n      const operation = {\n        start: () => ready.resolve(),\n        p: ready,\n      };\n\n      this.queues_[contentType].push(operation);\n      allWaiters.push(ready);\n\n      if (this.queues_[contentType].length == 1) {\n        operation.start();\n      }\n    }\n\n    // Return a Promise to the real operation, which waits to begin until\n    // there are no other in-progress operations on any SourceBuffers.\n    try {\n      await Promise.all(allWaiters);\n    } catch (error) {\n      // One of the waiters failed, which means we've been destroyed.\n      goog.asserts.assert(\n          this.destroyer_.destroyed(), 'Should be destroyed by now');\n      // We haven't popped from the queue.  Canceled waiters have been removed\n      // by destroy.  What's left now should just be resolved waiters.  In\n      // uncompiled mode, we will maintain good hygiene and make sure the\n      // assert at the end of destroy passes.  In compiled mode, the queues\n      // are wiped in destroy.\n      if (goog.DEBUG) {\n        for (const contentType in this.sourceBuffers_) {\n          if (this.queues_[contentType].length) {\n            goog.asserts.assert(\n                this.queues_[contentType].length == 1,\n                'Should be at most one item in queue!');\n            goog.asserts.assert(\n                allWaiters.includes(this.queues_[contentType][0].p),\n                'The item in queue should be one of our waiters!');\n            this.queues_[contentType].shift();\n          }\n        }\n      }\n      throw error;\n    }\n\n    if (goog.DEBUG) {\n      // If we did it correctly, nothing is updating.\n      for (const contentType in this.sourceBuffers_) {\n        goog.asserts.assert(\n            this.sourceBuffers_[contentType].updating == false,\n            'SourceBuffers should not be updating after a blocking op!');\n      }\n    }\n\n    // Run the real operation, which is synchronous.\n    try {\n      run();\n    } catch (exception) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.MEDIA,\n          shaka.util.Error.Code.MEDIA_SOURCE_OPERATION_THREW,\n          exception);\n    } finally {\n      // Unblock the queues.\n      for (const contentType in this.sourceBuffers_) {\n        this.popFromQueue_(contentType);\n      }\n    }\n  }\n\n  /**\n   * Pop from the front of the queue and start a new operation.\n   * @param {shaka.util.ManifestParserUtils.ContentType} contentType\n   * @private\n   */\n  popFromQueue_(contentType) {\n    // Remove the in-progress operation, which is now complete.\n    this.queues_[contentType].shift();\n    this.startOperation_(contentType);\n  }\n\n  /**\n   * Starts the next operation in the queue.\n   * @param {shaka.util.ManifestParserUtils.ContentType} contentType\n   * @private\n   */\n  startOperation_(contentType) {\n    // Retrieve the next operation, if any, from the queue and start it.\n    const next = this.queues_[contentType][0];\n    if (next) {\n      try {\n        next.start();\n      } catch (exception) {\n        if (exception.name == 'QuotaExceededError') {\n          next.p.reject(new shaka.util.Error(\n              shaka.util.Error.Severity.CRITICAL,\n              shaka.util.Error.Category.MEDIA,\n              shaka.util.Error.Code.QUOTA_EXCEEDED_ERROR,\n              contentType));\n        } else {\n          next.p.reject(new shaka.util.Error(\n              shaka.util.Error.Severity.CRITICAL,\n              shaka.util.Error.Category.MEDIA,\n              shaka.util.Error.Code.MEDIA_SOURCE_OPERATION_THREW,\n              exception));\n        }\n        this.popFromQueue_(contentType);\n      }\n    }\n  }\n\n  /**\n   * @return {!shaka.extern.TextDisplayer}\n   */\n  getTextDisplayer() {\n    goog.asserts.assert(\n        this.textDisplayer_,\n        'TextDisplayer should only be null when this is destroyed');\n\n    return this.textDisplayer_;\n  }\n\n  /**\n   * @param {!shaka.extern.TextDisplayer} textDisplayer\n   */\n  setTextDisplayer(textDisplayer) {\n    const oldTextDisplayer = this.textDisplayer_;\n    this.textDisplayer_ = textDisplayer;\n    if (oldTextDisplayer) {\n      textDisplayer.setTextVisibility(oldTextDisplayer.isTextVisible());\n      oldTextDisplayer.destroy();\n    }\n    if (this.textEngine_) {\n      this.textEngine_.setDisplayer(textDisplayer);\n    }\n  }\n};\n\n\n/**\n * Internal reference to window.URL.createObjectURL function to avoid\n * compatibility issues with other libraries and frameworks such as React\n * Native. For use in unit tests only, not meant for external use.\n *\n * @type {function(?):string}\n */\nshaka.media.MediaSourceEngine.createObjectURL = window.URL.createObjectURL;\n\n\n/**\n * @typedef {{\n *   start: function(),\n *   p: !shaka.util.PublicPromise\n * }}\n *\n * @summary An operation in queue.\n * @property {function()} start\n *   The function which starts the operation.\n * @property {!shaka.util.PublicPromise} p\n *   The PublicPromise which is associated with this operation.\n */\nshaka.media.MediaSourceEngine.Operation;\n\n\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.util.LanguageUtils');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.util.ManifestParserUtils');\n\n\n/**\n * @summary A set of language utility functions.\n * @final\n */\nshaka.util.LanguageUtils = class {\n  /**\n   * Check if |locale1| and |locale2| are locale-compatible.\n   *\n   * Locale-compatible is defined as all components in each locale match. Since\n   * we only respect the language and region components, we only check that\n   * the language and region components match.\n   *\n   * Examples:\n   *  Locale A | Locale B | Locale Compatible\n   *  ---------------------------------------\n   *  en-US    | en-US    | true\n   *  en       | en-US    | false\n   *  en-US    | en-CA    | false\n   *\n   * @param {string} locale1\n   * @param {string} locale2\n   * @return {boolean}\n   */\n  static areLocaleCompatible(locale1, locale2) {\n    const LanguageUtils = shaka.util.LanguageUtils;\n\n    // Even through they SHOULD already be normalized, let's just be safe and\n    // do it again.\n    locale1 = LanguageUtils.normalize(locale1);\n    locale2 = LanguageUtils.normalize(locale2);\n\n    return locale1 == locale2;\n  }\n\n  /**\n   * Check if |locale1| and |locale2| are language-compatible.\n   *\n   * Language compatible is when the language component of each locale matches.\n   * This means that no matter what region they have (or don't have) as long as\n   * the language components match, they are language-compatible.\n   *\n   * Examples:\n   *  Locale A | Locale B | Language-Compatible\n   *  -----------------------------------------\n   *  en-US    | en-US    | true\n   *  en-US    | en       | true\n   *  en-US    | en-CA    | true\n   *  en-CA    | fr-CA    | false\n   *\n   * @param {string} locale1\n   * @param {string} locale2\n   * @return {boolean}\n   */\n  static areLanguageCompatible(locale1, locale2) {\n    const LanguageUtils = shaka.util.LanguageUtils;\n\n    // Even through they SHOULD already be normalized, let's just be safe and\n    // do it again.\n    locale1 = LanguageUtils.normalize(locale1);\n    locale2 = LanguageUtils.normalize(locale2);\n\n    // Get all components. This should only be language and region\n    // since we do not support dialect.\n    /** @type {!Array.<string>} */\n    const locale1Components = LanguageUtils.disassembleLocale_(locale1);\n    /** @type {!Array.<string>} */\n    const locale2Components = LanguageUtils.disassembleLocale_(locale2);\n\n    // We are language compatible if we have the same language.\n    return locale1Components[0] == locale2Components[0];\n  }\n\n  /**\n   * Check if |possibleParent| is the parent locale of |possibleChild|. Because\n   * we do not support dialects, the parent-child relationship is a lot simpler.\n   * In a parent child relationship:\n   *    - The parent and child have the same language-component\n   *    - The parent has no region-component\n   *    - The child has a region-component\n   *\n   * Example:\n   *  Locale A | Locale B | Is A The parent of B?\n   *  --------------------------------------------\n   *  en-US    | en-US    | no\n   *  en-US    | en       | no\n   *  en       | en-US    | yes\n   *  en       | en       | no\n   *  en       | fr       | no\n   *\n   * @param {string} possibleParent\n   * @param {string} possibleChild\n   * @return {boolean}\n   */\n  static isParentOf(possibleParent, possibleChild) {\n    const LanguageUtils = shaka.util.LanguageUtils;\n\n    // Even through they SHOULD already be normalized, let's just be safe and\n    // do it again.\n    possibleParent = LanguageUtils.normalize(possibleParent);\n    possibleChild = LanguageUtils.normalize(possibleChild);\n\n    // Get all components. This should only be language and region\n    // since we do not support dialect.\n    /** @type {!Array.<string>} */\n    const possibleParentComponents =\n        LanguageUtils.disassembleLocale_(possibleParent);\n    /** @type {!Array.<string>} */\n    const possibleChildComponents =\n        LanguageUtils.disassembleLocale_(possibleChild);\n\n    return possibleParentComponents[0] == possibleChildComponents[0] &&\n           possibleParentComponents.length == 1 &&\n           possibleChildComponents.length == 2;\n  }\n\n  /**\n   * Check if |localeA| shares the same parent with |localeB|. Since we don't\n   * support dialect, we will only look at language and region. For two locales\n   * to be siblings:\n   *    - Both must have language-components\n   *    - Both must have region-components\n   *    - Both must have the same language-component\n   *\n   * Example:\n   *  Locale A | Locale B | Siblings?\n   *  --------------------------------------------\n   *  en-US    | en-US    | yes\n   *  en-US    | en-CA    | yes\n   *  en-US    | en       | no\n   *  en       | en-US    | no\n   *  en       | en       | no\n   *  en       | fr       | no\n   *\n   * @param {string} localeA\n   * @param {string} localeB\n   * @return {boolean}\n   */\n  static isSiblingOf(localeA, localeB) {\n    const LanguageUtils = shaka.util.LanguageUtils;\n\n    // Even through they SHOULD already be normalized, let's just be safe and\n    // do it again.\n    localeA = LanguageUtils.normalize(localeA);\n    localeB = LanguageUtils.normalize(localeB);\n\n    // Get all components. This should only be language and region\n    // since we do not support dialect.\n    /** @type {!Array.<string>} */\n    const localeAComponents = LanguageUtils.disassembleLocale_(localeA);\n    /** @type {!Array.<string>} */\n    const localeBComponents = LanguageUtils.disassembleLocale_(localeB);\n\n    return localeAComponents.length == 2 &&\n           localeBComponents.length == 2 &&\n           localeAComponents[0] == localeBComponents[0];\n  }\n\n  /**\n   * Normalize a locale. This will take a locale and canonicalize it to a state\n   * that we are prepared to work with.\n   *\n   * We only support with:\n   *   - language\n   *   - language-REGION\n   *\n   * If given a dialect, we will discard it. We will convert any 3-character\n   * codes to 2-character codes. We will force language codes to lowercase and\n   * region codes to uppercase.\n   *\n   * @param {string} locale\n   * @return {string}\n   */\n  static normalize(locale) {\n    const LanguageUtils = shaka.util.LanguageUtils;\n\n    const components = locale.split('-');\n\n    // We are only going to use the language and the region. If there was\n    // a dialect or anything else, we are throwing it a way.\n    let language = components[0] || '';\n    let region = components[1] || '';\n\n    // Convert the language to lower case. It is standard for the language code\n    // to be in lower case, but it will also make the map look-up easier.\n    language = language.toLowerCase();\n    language = LanguageUtils.isoMap_.get(language) || language;\n\n    // Convert the region to upper case. It is standard for the region to be in\n    // upper case. If there is no upper code, then it will be an empty string\n    // and this will be a no-op.\n    region = region.toUpperCase();\n\n    return region ?\n           language + '-' + region :\n           language;\n  }\n\n  /**\n   * Check if two language codes are siblings. Language codes are siblings if\n   * they share the same base language while neither one is the base language.\n   *\n   * For example, \"en-US\" and \"en-CA\" are siblings but \"en-US\" and \"en\" are not\n   * siblings.\n   *\n   * @param {string} a\n   * @param {string} b\n   * @return {boolean}\n   */\n  static areSiblings(a, b) {\n    const LanguageUtils = shaka.util.LanguageUtils;\n\n    const baseA = LanguageUtils.getBase(a);\n    const baseB = LanguageUtils.getBase(b);\n\n    return a != baseA && b != baseB && baseA == baseB;\n  }\n\n  /**\n   * Compute a numerical relatedness for language codes.  Language codes with a\n   * higher relatedness are a better match.  Unrelated language codes have a\n   * relatedness score of 0.\n   *\n   * @param {string} target\n   * @param {string} candidate\n   * @return {number}\n   */\n  static relatedness(target, candidate) {\n    const LanguageUtils = shaka.util.LanguageUtils;\n\n    target = LanguageUtils.normalize(target);\n    candidate = LanguageUtils.normalize(candidate);\n\n    // An exact match is the top score.\n    if (candidate == target) {\n      return 4;\n    }\n\n    // Next is a parent of the target language.\n    if (LanguageUtils.isParentOf(candidate, target)) {\n      return 3;\n    }\n\n    // Next is a sibling of the target language.\n    if (LanguageUtils.isSiblingOf(candidate, target)) {\n      return 2;\n    }\n\n    // Next is a child of the target language.\n    if (LanguageUtils.isParentOf(target, candidate)) {\n      return 1;\n    }\n\n    // Otherwise, they are unrelated.\n    return 0;\n  }\n\n  /**\n   * Get the normalized base language for a language code.\n   *\n   * @param {string} lang\n   * @return {string}\n   */\n  static getBase(lang) {\n    const LanguageUtils = shaka.util.LanguageUtils;\n\n    const splitAt = lang.indexOf('-');\n    let major;\n\n    if (splitAt >= 0) {\n      major = lang.substring(0, splitAt);\n    } else {\n      major = lang;\n    }\n\n    // Convert the major code to lower case. It is standard for the major code\n    // to be in lower case, but it will also make the map look-up easier.\n    major = major.toLowerCase();\n    major = LanguageUtils.isoMap_.get(major) || major;\n\n    return major;\n  }\n\n  /**\n   * Get the normalized language of the given text stream. Will return 'und' if\n   * a language is not found on the text stream.\n   *\n   * This should always be used to get the language from a text stream.\n   *\n   * @param {shaka.extern.Stream} stream\n   * @return {string}\n   */\n  static getLocaleForText(stream) {\n    const LanguageUtils = shaka.util.LanguageUtils;\n\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n    goog.asserts.assert(\n        stream.type == ContentType.TEXT,\n        'Can only get language from text streams');\n\n    const language = stream.language || 'und';\n    return LanguageUtils.normalize(language);\n  }\n\n  /**\n   * Get the normalized locale for the given variant. This will look through\n   * the variant to find the locale that represents the content in the variant.\n   * This will return 'und' if no language can be found.\n   *\n   * This should always be used to get the locale from a variant.\n   *\n   * @param {shaka.extern.Variant} variant\n   * @return {string}\n   */\n  static getLocaleForVariant(variant) {\n    const LanguageUtils = shaka.util.LanguageUtils;\n\n    // Our preference order is:\n    //  1. Variant\n    //  2. Audio Stream\n    //  3. Video Stream\n    //\n    // We are going to consider all falsy strings to be invalid locales, this\n    // will include empty strings.\n    if (variant.language) {\n      return LanguageUtils.normalize(variant.language);\n    }\n\n    if (variant.audio && variant.audio.language) {\n      return LanguageUtils.normalize(variant.audio.language);\n    }\n\n    if (variant.video && variant.video.language) {\n      return LanguageUtils.normalize(variant.video.language);\n    }\n\n    // No language was found, but we still want to return a valid string.\n    return 'und';\n  }\n\n  /**\n   * Find the locale in |searchSpace| that comes closest to |target|. If no\n   * locale is found to be close to |target|, then |null| will be returned.\n   *\n   * @param {string} target\n   * @param {!Iterable.<string>} searchSpace\n   * @return {?string}\n   */\n  static findClosestLocale(target, searchSpace) {\n    const LanguageUtils = shaka.util.LanguageUtils;\n\n    /** @type {string} */\n    const safeTarget = LanguageUtils.normalize(target);\n    /** @type {!Set.<string>} */\n    const safeSearchSpace = new Set();\n    for (const option of searchSpace) {\n      safeSearchSpace.add(LanguageUtils.normalize(option));\n    }\n\n    // Preference 1 - The option is an exact match. For example, \"en-US\" is an\n    //    exact match of \"en-US\". So if there is an option that is an exact\n    //    match, it would be the best match possible.\n    for (const option of safeSearchSpace) {\n      if (option == safeTarget) {\n        return option;\n      }\n    }\n\n    // Preference 2 - The option is the parent of the target. For example,\n    //    \"en\" is the parent of \"en-US\". So if there is an option with\n    //    \"en\", it should be good enough when our preference is \"en-US\".\n    for (const option of safeSearchSpace) {\n      if (LanguageUtils.isParentOf(option, safeTarget)) {\n        return option;\n      }\n    }\n\n    // Preference 3 - The option is a sibling of the target. For example,\n    //    \"en-US\" is a sibling of \"en-CA\". So if there is an option with\n    //    \"en_CA\", it should be good enough when our preference is \"en-US\".\n    for (const option of safeSearchSpace) {\n      if (LanguageUtils.isSiblingOf(option, safeTarget)) {\n        return option;\n      }\n    }\n\n    // Preference 4 - The option is a child of the target. For example,\n    //    \"en-US\" is the child of \"en\". SO it there is an option with\n    //    \"en-US\", it should be good enough when our preference is \"en\".\n    for (const option of safeSearchSpace) {\n      if (LanguageUtils.isParentOf(safeTarget, option)) {\n        return option;\n      }\n    }\n\n    // Failed to find anything.\n    return null;\n  }\n\n  /**\n   * Take a locale string and break it into its component. Check that each\n   * component matches what we would expect internally for locales. This\n   * should ONLY be used to verify locales that have been normalized.\n   *\n   * @param {string} locale\n   * @return {!Array.<string>}\n   * @private\n   */\n  static disassembleLocale_(locale) {\n    const components = locale.split('-');\n\n    goog.asserts.assert(\n        components.length <= 2,\n        [\n          'Locales should not have more than 2 components. ',\n          locale,\n          ' has too many components.',\n        ].join());\n\n    return components;\n  }\n};\n\n\n/**\n * A map from 3-letter language codes (ISO 639-2) to 2-letter language codes\n * (ISO 639-1) for all languages which have both in the registry.\n *\n * @const {!Map.<string, string>}\n * @private\n */\nshaka.util.LanguageUtils.isoMap_ = new Map([\n  ['aar', 'aa'], ['abk', 'ab'], ['afr', 'af'], ['aka', 'ak'], ['alb', 'sq'],\n  ['amh', 'am'], ['ara', 'ar'], ['arg', 'an'], ['arm', 'hy'], ['asm', 'as'],\n  ['ava', 'av'], ['ave', 'ae'], ['aym', 'ay'], ['aze', 'az'], ['bak', 'ba'],\n  ['bam', 'bm'], ['baq', 'eu'], ['bel', 'be'], ['ben', 'bn'], ['bih', 'bh'],\n  ['bis', 'bi'], ['bod', 'bo'], ['bos', 'bs'], ['bre', 'br'], ['bul', 'bg'],\n  ['bur', 'my'], ['cat', 'ca'], ['ces', 'cs'], ['cha', 'ch'], ['che', 'ce'],\n  ['chi', 'zh'], ['chu', 'cu'], ['chv', 'cv'], ['cor', 'kw'], ['cos', 'co'],\n  ['cre', 'cr'], ['cym', 'cy'], ['cze', 'cs'], ['dan', 'da'], ['deu', 'de'],\n  ['div', 'dv'], ['dut', 'nl'], ['dzo', 'dz'], ['ell', 'el'], ['eng', 'en'],\n  ['epo', 'eo'], ['est', 'et'], ['eus', 'eu'], ['ewe', 'ee'], ['fao', 'fo'],\n  ['fas', 'fa'], ['fij', 'fj'], ['fin', 'fi'], ['fra', 'fr'], ['fre', 'fr'],\n  ['fry', 'fy'], ['ful', 'ff'], ['geo', 'ka'], ['ger', 'de'], ['gla', 'gd'],\n  ['gle', 'ga'], ['glg', 'gl'], ['glv', 'gv'], ['gre', 'el'], ['grn', 'gn'],\n  ['guj', 'gu'], ['hat', 'ht'], ['hau', 'ha'], ['heb', 'he'], ['her', 'hz'],\n  ['hin', 'hi'], ['hmo', 'ho'], ['hrv', 'hr'], ['hun', 'hu'], ['hye', 'hy'],\n  ['ibo', 'ig'], ['ice', 'is'], ['ido', 'io'], ['iii', 'ii'], ['iku', 'iu'],\n  ['ile', 'ie'], ['ina', 'ia'], ['ind', 'id'], ['ipk', 'ik'], ['isl', 'is'],\n  ['ita', 'it'], ['jav', 'jv'], ['jpn', 'ja'], ['kal', 'kl'], ['kan', 'kn'],\n  ['kas', 'ks'], ['kat', 'ka'], ['kau', 'kr'], ['kaz', 'kk'], ['khm', 'km'],\n  ['kik', 'ki'], ['kin', 'rw'], ['kir', 'ky'], ['kom', 'kv'], ['kon', 'kg'],\n  ['kor', 'ko'], ['kua', 'kj'], ['kur', 'ku'], ['lao', 'lo'], ['lat', 'la'],\n  ['lav', 'lv'], ['lim', 'li'], ['lin', 'ln'], ['lit', 'lt'], ['ltz', 'lb'],\n  ['lub', 'lu'], ['lug', 'lg'], ['mac', 'mk'], ['mah', 'mh'], ['mal', 'ml'],\n  ['mao', 'mi'], ['mar', 'mr'], ['may', 'ms'], ['mkd', 'mk'], ['mlg', 'mg'],\n  ['mlt', 'mt'], ['mon', 'mn'], ['mri', 'mi'], ['msa', 'ms'], ['mya', 'my'],\n  ['nau', 'na'], ['nav', 'nv'], ['nbl', 'nr'], ['nde', 'nd'], ['ndo', 'ng'],\n  ['nep', 'ne'], ['nld', 'nl'], ['nno', 'nn'], ['nob', 'nb'], ['nor', 'no'],\n  ['nya', 'ny'], ['oci', 'oc'], ['oji', 'oj'], ['ori', 'or'], ['orm', 'om'],\n  ['oss', 'os'], ['pan', 'pa'], ['per', 'fa'], ['pli', 'pi'], ['pol', 'pl'],\n  ['por', 'pt'], ['pus', 'ps'], ['que', 'qu'], ['roh', 'rm'], ['ron', 'ro'],\n  ['rum', 'ro'], ['run', 'rn'], ['rus', 'ru'], ['sag', 'sg'], ['san', 'sa'],\n  ['sin', 'si'], ['slk', 'sk'], ['slo', 'sk'], ['slv', 'sl'], ['sme', 'se'],\n  ['smo', 'sm'], ['sna', 'sn'], ['snd', 'sd'], ['som', 'so'], ['sot', 'st'],\n  ['spa', 'es'], ['sqi', 'sq'], ['srd', 'sc'], ['srp', 'sr'], ['ssw', 'ss'],\n  ['sun', 'su'], ['swa', 'sw'], ['swe', 'sv'], ['tah', 'ty'], ['tam', 'ta'],\n  ['tat', 'tt'], ['tel', 'te'], ['tgk', 'tg'], ['tgl', 'tl'], ['tha', 'th'],\n  ['tib', 'bo'], ['tir', 'ti'], ['ton', 'to'], ['tsn', 'tn'], ['tso', 'ts'],\n  ['tuk', 'tk'], ['tur', 'tr'], ['twi', 'tw'], ['uig', 'ug'], ['ukr', 'uk'],\n  ['urd', 'ur'], ['uzb', 'uz'], ['ven', 've'], ['vie', 'vi'], ['vol', 'vo'],\n  ['wel', 'cy'], ['wln', 'wa'], ['wol', 'wo'], ['xho', 'xh'], ['yid', 'yi'],\n  ['yor', 'yo'], ['zha', 'za'], ['zho', 'zh'], ['zul', 'zu'],\n]);\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.util.StreamUtils');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.media.DrmEngine');\ngoog.require('shaka.media.MediaSourceEngine');\ngoog.require('shaka.text.TextEngine');\ngoog.require('shaka.util.Functional');\ngoog.require('shaka.util.LanguageUtils');\ngoog.require('shaka.util.ManifestParserUtils');\ngoog.require('shaka.util.MimeUtils');\ngoog.require('shaka.util.MultiMap');\n\n\n/**\n * @summary A set of utility functions for dealing with Streams and Manifests.\n */\nshaka.util.StreamUtils = class {\n  /**\n   * In case of multiple usable codecs, choose one based on lowest average\n   * bandwidth and filter out the rest.\n   * Also filters out variants that have too many audio channels.\n   * @param {!shaka.extern.Manifest} manifest\n   * @param {number} preferredAudioChannelCount\n   */\n  static chooseCodecsAndFilterManifest(manifest, preferredAudioChannelCount) {\n    const MimeUtils = shaka.util.MimeUtils;\n\n    // To start, consider a subset of variants based on audio channel\n    // preferences.\n    // For some content (#1013), surround-sound variants will use a different\n    // codec than stereo variants, so it is important to choose codecs **after**\n    // considering the audio channel config.\n    const variants = shaka.util.StreamUtils.filterVariantsByAudioChannelCount(\n        manifest.variants, preferredAudioChannelCount);\n\n    function variantCodecs(variant) {\n      // Only consider the base of the codec string.  For example, these should\n      // both be considered the same codec: avc1.42c01e, avc1.4d401f\n      let baseVideoCodec = '';\n      if (variant.video) {\n        baseVideoCodec = MimeUtils.getCodecBase(variant.video.codecs);\n      }\n\n      let baseAudioCodec = '';\n      if (variant.audio) {\n        baseAudioCodec = MimeUtils.getCodecBase(variant.audio.codecs);\n      }\n\n      return baseVideoCodec + '-' + baseAudioCodec;\n    }\n\n    // Now organize variants into buckets by codecs.\n    /** @type {!shaka.util.MultiMap.<shaka.extern.Variant>} */\n    const variantsByCodecs = new shaka.util.MultiMap();\n    for (const variant of variants) {\n      const group = variantCodecs(variant);\n      variantsByCodecs.push(group, variant);\n    }\n\n    // Compute the average bandwidth for each group of variants.\n    // Choose the lowest-bandwidth codecs.\n    let bestCodecs = null;\n    let lowestAverageBandwidth = Infinity;\n    variantsByCodecs.forEach((codecs, variants) => {\n      let sum = 0;\n      let num = 0;\n      for (const variant of variants) {\n        sum += variant.bandwidth || 0;\n        ++num;\n      }\n      const averageBandwidth = sum / num;\n      shaka.log.debug('codecs', codecs, 'avg bandwidth', averageBandwidth);\n\n      if (averageBandwidth < lowestAverageBandwidth) {\n        bestCodecs = codecs;\n        lowestAverageBandwidth = averageBandwidth;\n      }\n    });\n    goog.asserts.assert(bestCodecs != null, 'Should have chosen codecs!');\n    goog.asserts.assert(!isNaN(lowestAverageBandwidth),\n        'Bandwidth should be a number!');\n\n    // Filter out any variants that don't match, forcing AbrManager to choose\n    // from the most efficient variants possible.\n    manifest.variants = manifest.variants.filter((variant) => {\n      const codecs = variantCodecs(variant);\n      if (codecs == bestCodecs) {\n        return true;\n      }\n\n      shaka.log.debug('Dropping Variant (better codec available)', variant);\n      return false;\n    });\n  }\n\n  /**\n   * @param {shaka.extern.Variant} variant\n   * @param {shaka.extern.Restrictions} restrictions\n   *   Configured restrictions from the user.\n   * @param {{width: number, height: number}} maxHwRes\n   *   The maximum resolution the hardware can handle.\n   *   This is applied separately from user restrictions because the setting\n   *   should not be easily replaced by the user's configuration.\n   * @return {boolean}\n   */\n  static meetsRestrictions(variant, restrictions, maxHwRes) {\n    /** @type {function(number, number, number):boolean} */\n    const inRange = (x, min, max) => {\n      return x >= min && x <= max;\n    };\n\n    const video = variant.video;\n\n    // |video.width| and |video.height| can be undefined, which breaks\n    // the math, so make sure they are there first.\n    if (video && video.width && video.height) {\n      if (!inRange(video.width,\n          restrictions.minWidth,\n          Math.min(restrictions.maxWidth, maxHwRes.width))) {\n        return false;\n      }\n\n      if (!inRange(video.height,\n          restrictions.minHeight,\n          Math.min(restrictions.maxHeight, maxHwRes.height))) {\n        return false;\n      }\n\n      if (!inRange(video.width * video.height,\n          restrictions.minPixels,\n          restrictions.maxPixels)) {\n        return false;\n      }\n    }\n\n    // |variant.frameRate| can be undefined, which breaks\n    // the math, so make sure they are there first.\n    if (variant && variant.video && variant.video.frameRate) {\n      if (!inRange(variant.video.frameRate,\n          restrictions.minFrameRate,\n          restrictions.maxFrameRate)) {\n        return false;\n      }\n    }\n\n    if (!inRange(variant.bandwidth,\n        restrictions.minBandwidth,\n        restrictions.maxBandwidth)) {\n      return false;\n    }\n\n    return true;\n  }\n\n\n  /**\n   * @param {!Array.<shaka.extern.Variant>} variants\n   * @param {shaka.extern.Restrictions} restrictions\n   * @param {{width: number, height: number}} maxHwRes\n   * @return {boolean} Whether the tracks changed.\n   */\n  static applyRestrictions(variants, restrictions, maxHwRes) {\n    let tracksChanged = false;\n\n    for (const variant of variants) {\n      const originalAllowed = variant.allowedByApplication;\n      variant.allowedByApplication = shaka.util.StreamUtils.meetsRestrictions(\n          variant, restrictions, maxHwRes);\n\n      if (originalAllowed != variant.allowedByApplication) {\n        tracksChanged = true;\n      }\n    }\n\n    return tracksChanged;\n  }\n\n\n  /**\n   * Alters the given Manifest to filter out any unplayable streams.\n   *\n   * @param {shaka.media.DrmEngine} drmEngine\n   * @param {?shaka.extern.Variant} currentVariant\n   * @param {shaka.extern.Manifest} manifest\n   */\n  static filterManifest(drmEngine, currentVariant, manifest) {\n    const StreamUtils = shaka.util.StreamUtils;\n\n    // Filter variants.\n    manifest.variants = manifest.variants.filter((variant) => {\n      if (drmEngine && drmEngine.initialized()) {\n        if (!drmEngine.supportsVariant(variant)) {\n          shaka.log.debug('Dropping variant - not compatible with key system',\n              variant);\n          return false;\n        }\n      }\n\n      const audio = variant.audio;\n      const video = variant.video;\n\n      if (audio && !shaka.media.MediaSourceEngine.isStreamSupported(audio)) {\n        shaka.log.debug('Dropping variant - audio not compatible with platform',\n            StreamUtils.getStreamSummaryString_(audio));\n        return false;\n      }\n\n      if (video && !shaka.media.MediaSourceEngine.isStreamSupported(video)) {\n        shaka.log.debug('Dropping variant - video not compatible with platform',\n            StreamUtils.getStreamSummaryString_(video));\n        return false;\n      }\n\n      if (audio && currentVariant && currentVariant.audio) {\n        if (!StreamUtils.areStreamsCompatible_(audio, currentVariant.audio)) {\n          shaka.log.debug('Droping variant - not compatible with active audio',\n              'active audio',\n              StreamUtils.getStreamSummaryString_(currentVariant.audio),\n              'variant.audio',\n              StreamUtils.getStreamSummaryString_(audio));\n          return false;\n        }\n      }\n\n      if (video && currentVariant && currentVariant.video) {\n        if (!StreamUtils.areStreamsCompatible_(video, currentVariant.video)) {\n          shaka.log.debug('Droping variant - not compatible with active video',\n              'active video',\n              StreamUtils.getStreamSummaryString_(currentVariant.video),\n              'variant.video',\n              StreamUtils.getStreamSummaryString_(video));\n          return false;\n        }\n      }\n\n      return true;\n    });\n\n    // Filter text streams.\n    manifest.textStreams = manifest.textStreams.filter((stream) => {\n      const fullMimeType = shaka.util.MimeUtils.getFullType(\n          stream.mimeType, stream.codecs);\n      const keep = shaka.text.TextEngine.isTypeSupported(fullMimeType);\n\n      if (!keep) {\n        shaka.log.debug('Dropping text stream. Is not supported by the ' +\n                        'platform.', stream);\n      }\n\n      return keep;\n    });\n  }\n\n\n  /**\n   * @param {shaka.extern.Stream} s0\n   * @param {shaka.extern.Stream} s1\n   * @return {boolean}\n   * @private\n   */\n  static areStreamsCompatible_(s0, s1) {\n    // Basic mime types and basic codecs need to match.\n    // For example, we can't adapt between WebM and MP4,\n    // nor can we adapt between mp4a.* to ec-3.\n    // We can switch between text types on the fly,\n    // so don't run this check on text.\n    if (s0.mimeType != s1.mimeType) {\n      return false;\n    }\n\n    if (s0.codecs.split('.')[0] != s1.codecs.split('.')[0]) {\n      return false;\n    }\n\n    return true;\n  }\n\n\n  /**\n   * @param {shaka.extern.Variant} variant\n   * @return {shaka.extern.Track}\n   */\n  static variantToTrack(variant) {\n    /** @type {?shaka.extern.Stream} */\n    const audio = variant.audio;\n    /** @type {?shaka.extern.Stream} */\n    const video = variant.video;\n\n    /** @type {?string} */\n    const audioCodec = audio ? audio.codecs : null;\n    /** @type {?string} */\n    const videoCodec = video ? video.codecs : null;\n\n    /** @type {!Array.<string>} */\n    const codecs = [];\n    if (videoCodec) {\n      codecs.push(videoCodec);\n    }\n    if (audioCodec) {\n      codecs.push(audioCodec);\n    }\n\n    /** @type {!Array.<string>} */\n    const mimeTypes = [];\n    if (video) {\n      mimeTypes.push(video.mimeType);\n    }\n    if (audio) {\n      mimeTypes.push(audio.mimeType);\n    }\n    /** @type {?string} */\n    const mimeType = mimeTypes[0] || null;\n\n    /** @type {!Array.<string>} */\n    const kinds = [];\n    if (audio) {\n      kinds.push(audio.kind);\n    }\n    if (video) {\n      kinds.push(video.kind);\n    }\n    /** @type {?string} */\n    const kind = kinds[0] || null;\n\n    /** @type {!Set.<string>} */\n    const roles = new Set();\n    if (audio) {\n      for (const role of audio.roles) {\n        roles.add(role);\n      }\n    }\n    if (video) {\n      for (const role of video.roles) {\n        roles.add(role);\n      }\n    }\n\n    /** @type {shaka.extern.Track} */\n    const track = {\n      id: variant.id,\n      active: false,\n      type: 'variant',\n      bandwidth: variant.bandwidth,\n      language: variant.language,\n      label: null,\n      kind: kind,\n      width: null,\n      height: null,\n      frameRate: null,\n      pixelAspectRatio: null,\n      mimeType: mimeType,\n      codecs: codecs.join(', '),\n      audioCodec: audioCodec,\n      videoCodec: videoCodec,\n      primary: variant.primary,\n      roles: Array.from(roles),\n      audioRoles: null,\n      videoId: null,\n      audioId: null,\n      channelsCount: null,\n      audioSamplingRate: null,\n      audioBandwidth: null,\n      videoBandwidth: null,\n      originalVideoId: null,\n      originalAudioId: null,\n      originalTextId: null,\n    };\n\n    if (video) {\n      track.videoId = video.id;\n      track.originalVideoId = video.originalId;\n      track.width = video.width || null;\n      track.height = video.height || null;\n      track.frameRate = video.frameRate || null;\n      track.pixelAspectRatio = video.pixelAspectRatio || null;\n      track.videoBandwidth = video.bandwidth || null;\n    }\n\n    if (audio) {\n      track.audioId = audio.id;\n      track.originalAudioId = audio.originalId;\n      track.channelsCount = audio.channelsCount;\n      track.audioSamplingRate = audio.audioSamplingRate;\n      track.audioBandwidth = audio.bandwidth || null;\n      track.label = audio.label;\n      track.audioRoles = audio.roles;\n    }\n\n    return track;\n  }\n\n\n  /**\n   * @param {shaka.extern.Stream} stream\n   * @return {shaka.extern.Track}\n   */\n  static textStreamToTrack(stream) {\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n\n    /** @type {shaka.extern.Track} */\n    const track = {\n      id: stream.id,\n      active: false,\n      type: ContentType.TEXT,\n      bandwidth: 0,\n      language: stream.language,\n      label: stream.label,\n      kind: stream.kind || null,\n      width: null,\n      height: null,\n      frameRate: null,\n      pixelAspectRatio: null,\n      mimeType: stream.mimeType,\n      codecs: stream.codecs || null,\n      audioCodec: null,\n      videoCodec: null,\n      primary: stream.primary,\n      roles: stream.roles,\n      audioRoles: null,\n      videoId: null,\n      audioId: null,\n      channelsCount: null,\n      audioSamplingRate: null,\n      audioBandwidth: null,\n      videoBandwidth: null,\n      originalVideoId: null,\n      originalAudioId: null,\n      originalTextId: stream.originalId,\n    };\n\n    return track;\n  }\n\n\n  /**\n   * Generate and return an ID for this track, since the ID field is optional.\n   *\n   * @param {TextTrack|AudioTrack} html5Track\n   * @return {number} The generated ID.\n   */\n  static html5TrackId(html5Track) {\n    if (!html5Track['__shaka_id']) {\n      html5Track['__shaka_id'] = shaka.util.StreamUtils.nextTrackId_++;\n    }\n    return html5Track['__shaka_id'];\n  }\n\n\n  /**\n   * @param {TextTrack} textTrack\n   * @return {shaka.extern.Track}\n   */\n  static html5TextTrackToTrack(textTrack) {\n    const CLOSED_CAPTION_MIMETYPE =\n        shaka.util.MimeUtils.CLOSED_CAPTION_MIMETYPE;\n    const StreamUtils = shaka.util.StreamUtils;\n\n    /** @type {shaka.extern.Track} */\n    const track = StreamUtils.html5TrackToGenericShakaTrack_(textTrack);\n    track.active = textTrack.mode != 'disabled';\n    track.type = 'text';\n    track.originalTextId = textTrack.id;\n    if (textTrack.kind == 'captions') {\n      track.mimeType = CLOSED_CAPTION_MIMETYPE;\n    }\n    if (textTrack.kind) {\n      track.roles = [textTrack.kind];\n    }\n\n    return track;\n  }\n\n\n  /**\n   * @param {AudioTrack} audioTrack\n   * @return {shaka.extern.Track}\n   */\n  static html5AudioTrackToTrack(audioTrack) {\n    const StreamUtils = shaka.util.StreamUtils;\n\n    /** @type {shaka.extern.Track} */\n    const track = StreamUtils.html5TrackToGenericShakaTrack_(audioTrack);\n    track.active = audioTrack.enabled;\n    track.type = 'variant';\n    track.originalAudioId = audioTrack.id;\n\n    if (audioTrack.kind == 'main') {\n      track.primary = true;\n    }\n    if (audioTrack.kind) {\n      track.roles = [audioTrack.kind];\n      track.audioRoles = [audioTrack.kind];\n    }\n\n    return track;\n  }\n\n\n  /**\n   * Creates a Track object with non-type specific fields filled out.  The\n   * caller is responsible for completing the Track object with any\n   * type-specific information (audio or text).\n   *\n   * @param {TextTrack|AudioTrack} html5Track\n   * @return {shaka.extern.Track}\n   * @private\n   */\n  static html5TrackToGenericShakaTrack_(html5Track) {\n    /** @type {shaka.extern.Track} */\n    const track = {\n      id: shaka.util.StreamUtils.html5TrackId(html5Track),\n      active: false,\n      type: '',\n      bandwidth: 0,\n      language: shaka.util.LanguageUtils.normalize(html5Track.language),\n      label: html5Track.label,\n      kind: html5Track.kind,\n      width: null,\n      height: null,\n      frameRate: null,\n      pixelAspectRatio: null,\n      mimeType: null,\n      codecs: null,\n      audioCodec: null,\n      videoCodec: null,\n      primary: false,\n      roles: [],\n      audioRoles: null,\n      videoId: null,\n      audioId: null,\n      channelsCount: null,\n      audioSamplingRate: null,\n      audioBandwidth: null,\n      videoBandwidth: null,\n      originalVideoId: null,\n      originalAudioId: null,\n      originalTextId: null,\n    };\n\n    return track;\n  }\n\n\n  /**\n   * Determines if the given variant is playable.\n   * @param {!shaka.extern.Variant} variant\n   * @return {boolean}\n   */\n  static isPlayable(variant) {\n    return variant.allowedByApplication && variant.allowedByKeySystem;\n  }\n\n\n  /**\n   * Filters out unplayable variants.\n   * @param {!Array.<!shaka.extern.Variant>} variants\n   * @return {!Array.<!shaka.extern.Variant>}\n   */\n  static getPlayableVariants(variants) {\n    return variants.filter((variant) => {\n      return shaka.util.StreamUtils.isPlayable(variant);\n    });\n  }\n\n\n  /**\n   * Filters variants according to the given audio channel count config.\n   *\n   * @param {!Array.<shaka.extern.Variant>} variants\n   * @param {number} preferredAudioChannelCount\n   * @return {!Array.<!shaka.extern.Variant>}\n   */\n  static filterVariantsByAudioChannelCount(\n      variants, preferredAudioChannelCount) {\n    // Group variants by their audio channel counts.\n    const variantsWithChannelCounts =\n        variants.filter((v) => v.audio && v.audio.channelsCount);\n\n    /** @type {!Map.<number, !Array.<shaka.extern.Variant>>} */\n    const variantsByChannelCount = new Map();\n    for (const variant of variantsWithChannelCounts) {\n      const count = variant.audio.channelsCount;\n      goog.asserts.assert(count != null, 'Must have count after filtering!');\n      if (!variantsByChannelCount.has(count)) {\n        variantsByChannelCount.set(count, []);\n      }\n      variantsByChannelCount.get(count).push(variant);\n    }\n\n    /** @type {!Array.<number>} */\n    const channelCounts = Array.from(variantsByChannelCount.keys());\n\n    // If no variant has audio channel count info, return the original variants.\n    if (channelCounts.length == 0) {\n      return variants;\n    }\n\n    // Choose the variants with the largest number of audio channels less than\n    // or equal to the configured number of audio channels.\n    const countLessThanOrEqualtoConfig =\n        channelCounts.filter((count) => count <= preferredAudioChannelCount);\n    if (countLessThanOrEqualtoConfig.length) {\n      return variantsByChannelCount.get(\n          Math.max(...countLessThanOrEqualtoConfig));\n    }\n\n    // If all variants have more audio channels than the config, choose the\n    // variants with the fewest audio channels.\n    return variantsByChannelCount.get(Math.min(...channelCounts));\n  }\n\n  /**\n   * Chooses streams according to the given config.\n   *\n   * @param {!Array.<shaka.extern.Stream>} streams\n   * @param {string} preferredLanguage\n   * @param {string} preferredRole\n   * @return {!Array.<!shaka.extern.Stream>}\n   */\n  static filterStreamsByLanguageAndRole(\n      streams, preferredLanguage, preferredRole) {\n    const LanguageUtils = shaka.util.LanguageUtils;\n\n    /** @type {!Array.<!shaka.extern.Stream>} */\n    let chosen = streams;\n\n    // Start with the set of primary streams.\n    /** @type {!Array.<!shaka.extern.Stream>} */\n    const primary = streams.filter((stream) => {\n      return stream.primary;\n    });\n\n    if (primary.length) {\n      chosen = primary;\n    }\n\n    // Now reduce the set to one language.  This covers both arbitrary language\n    // choice and the reduction of the \"primary\" stream set to one language.\n    const firstLanguage = chosen.length ? chosen[0].language : '';\n    chosen = chosen.filter((stream) => {\n      return stream.language == firstLanguage;\n    });\n\n    // Find the streams that best match our language preference. This will\n    // override previous selections.\n    if (preferredLanguage) {\n      const closestLocale = LanguageUtils.findClosestLocale(\n          LanguageUtils.normalize(preferredLanguage),\n          streams.map((stream) => stream.language));\n\n      // Only replace |chosen| if we found a locale that is close to our\n      // preference.\n      if (closestLocale) {\n        chosen = streams.filter((stream) => {\n          const locale = LanguageUtils.normalize(stream.language);\n          return locale == closestLocale;\n        });\n      }\n    }\n\n    // Now refine the choice based on role preference.\n    if (preferredRole) {\n      const roleMatches = shaka.util.StreamUtils.filterTextStreamsByRole_(\n          chosen, preferredRole);\n      if (roleMatches.length) {\n        return roleMatches;\n      } else {\n        shaka.log.warning('No exact match for the text role could be found.');\n      }\n    } else {\n      // Prefer text streams with no roles, if they exist.\n      const noRoleMatches = chosen.filter((stream) => {\n        return stream.roles.length == 0;\n      });\n      if (noRoleMatches.length) {\n        return noRoleMatches;\n      }\n    }\n\n    // Either there was no role preference, or it could not be satisfied.\n    // Choose an arbitrary role, if there are any, and filter out any other\n    // roles. This ensures we never adapt between roles.\n\n    const allRoles = chosen.map((stream) => {\n      return stream.roles;\n    }).reduce(shaka.util.Functional.collapseArrays, []);\n\n    if (!allRoles.length) {\n      return chosen;\n    }\n    return shaka.util.StreamUtils.filterTextStreamsByRole_(chosen, allRoles[0]);\n  }\n\n\n  /**\n   * Filter text Streams by role.\n   *\n   * @param {!Array.<shaka.extern.Stream>} textStreams\n   * @param {string} preferredRole\n   * @return {!Array.<shaka.extern.Stream>}\n   * @private\n   */\n  static filterTextStreamsByRole_(textStreams, preferredRole) {\n    return textStreams.filter((stream) => {\n      return stream.roles.includes(preferredRole);\n    });\n  }\n\n\n  /**\n   * Checks if the given stream is an audio stream.\n   *\n   * @param {shaka.extern.Stream} stream\n   * @return {boolean}\n   */\n  static isAudio(stream) {\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n    return stream.type == ContentType.AUDIO;\n  }\n\n\n  /**\n   * Checks if the given stream is a video stream.\n   *\n   * @param {shaka.extern.Stream} stream\n   * @return {boolean}\n   */\n  static isVideo(stream) {\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n    return stream.type == ContentType.VIDEO;\n  }\n\n\n  /**\n   * Get all non-null streams in the variant as an array.\n   *\n   * @param {shaka.extern.Variant} variant\n   * @return {!Array.<shaka.extern.Stream>}\n   */\n  static getVariantStreams(variant) {\n    const streams = [];\n\n    if (variant.audio) {\n      streams.push(variant.audio);\n    }\n    if (variant.video) {\n      streams.push(variant.video);\n    }\n\n    return streams;\n  }\n\n\n  /**\n   * @param {shaka.extern.Stream} stream\n   * @return {string}\n   * @private\n   */\n  static getStreamSummaryString_(stream) {\n    // Accepted parameters for Chromecast can be found (internally) at\n    // go/cast-mime-params\n\n    if (shaka.util.StreamUtils.isAudio(stream)) {\n      return 'type=audio' +\n             ' codecs=' + stream.codecs +\n             ' bandwidth='+ stream.bandwidth +\n             ' channelsCount=' + stream.channelsCount +\n             ' audioSamplingRate=' + stream.audioSamplingRate;\n    }\n\n    if (shaka.util.StreamUtils.isVideo(stream)) {\n      return 'type=video' +\n             ' codecs=' + stream.codecs +\n             ' bandwidth=' + stream.bandwidth +\n             ' frameRate=' + stream.frameRate +\n             ' width=' + stream.width +\n             ' height=' + stream.height;\n    }\n\n    return 'unexpected stream type';\n  }\n};\n\n\n/** @private {number} */\nshaka.util.StreamUtils.nextTrackId_ = 0;\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.abr.SimpleAbrManager');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.abr.EwmaBandwidthEstimator');\ngoog.require('shaka.log');\ngoog.require('shaka.util.Iterables');\ngoog.require('shaka.util.StreamUtils');\n\n\n/**\n * @summary\n * <p>\n * This defines the default ABR manager for the Player.  An instance of this\n * class is used when no ABR manager is given.\n * </p>\n * <p>\n * The behavior of this class is to take throughput samples using\n * segmentDownloaded to estimate the current network bandwidth.  Then it will\n * use that to choose the streams that best fit the current bandwidth.  It will\n * always pick the highest bandwidth variant it thinks can be played.\n * </p>\n * <p>\n * After initial choices are made, this class will call switchCallback() when\n * there is a better choice.  switchCallback() will not be called more than once\n * per ({@link shaka.abr.SimpleAbrManager.SWITCH_INTERVAL_MS}).\n * </p>\n *\n * @implements {shaka.extern.AbrManager}\n * @export\n */\nshaka.abr.SimpleAbrManager = class {\n  constructor() {\n    /** @private {?shaka.extern.AbrManager.SwitchCallback} */\n    this.switch_ = null;\n\n    /** @private {boolean} */\n    this.enabled_ = false;\n\n    /** @private {shaka.abr.EwmaBandwidthEstimator} */\n    this.bandwidthEstimator_ = new shaka.abr.EwmaBandwidthEstimator();\n    // TODO: Consider using NetworkInformation's change event to throw out an\n    // old estimate based on changing network types, such as wifi => 3g.\n\n    /**\n     * A filtered list of Variants to choose from.\n     * @private {!Array.<!shaka.extern.Variant>}\n     */\n    this.variants_ = [];\n\n    /** @private {number} */\n    this.playbackRate_ = 1;\n\n    /** @private {boolean} */\n    this.startupComplete_ = false;\n\n    /**\n     * The last wall-clock time, in milliseconds, when streams were chosen.\n     *\n     * @private {?number}\n     */\n    this.lastTimeChosenMs_ = null;\n\n    /** @private {?shaka.extern.AbrConfiguration} */\n    this.config_ = null;\n  }\n\n\n  /**\n   * @override\n   * @export\n   */\n  stop() {\n    this.switch_ = null;\n    this.enabled_ = false;\n    this.variants_ = [];\n    this.playbackRate_ = 1;\n    this.lastTimeChosenMs_ = null;\n\n    // Don't reset |startupComplete_|: if we've left the startup interval, we\n    // can start using bandwidth estimates right away after init() is called.\n  }\n\n\n  /**\n   * @override\n   * @export\n   */\n  init(switchCallback) {\n    this.switch_ = switchCallback;\n  }\n\n\n  /**\n   * @override\n   * @export\n   */\n  chooseVariant() {\n    const SimpleAbrManager = shaka.abr.SimpleAbrManager;\n\n    // Get sorted Variants.\n    let sortedVariants = SimpleAbrManager.filterAndSortVariants_(\n        this.config_.restrictions, this.variants_);\n    const currentBandwidth = this.bandwidthEstimator_.getBandwidthEstimate(\n        this.config_.defaultBandwidthEstimate);\n\n    if (this.variants_.length && !sortedVariants.length) {\n      // If we couldn't meet the ABR restrictions, we should still play\n      // something.\n      // These restrictions are not \"hard\" restrictions in the way that\n      // top-level or DRM-based restrictions are.  Sort the variants without\n      // restrictions and keep just the first (lowest-bandwidth) one.\n      shaka.log.warning('No variants met the ABR restrictions. ' +\n                        'Choosing a variant by lowest bandwidth.');\n      sortedVariants = SimpleAbrManager.filterAndSortVariants_(\n          /* restrictions= */ null, this.variants_);\n      sortedVariants = [sortedVariants[0]];\n    }\n\n    // Start by assuming that we will use the first Stream.\n    let chosen = sortedVariants[0] || null;\n\n    const enumerate = (it) => shaka.util.Iterables.enumerate(it);\n    for (const {item, next} of enumerate(sortedVariants)) {\n      const playbackRate =\n          !isNaN(this.playbackRate_) ? Math.abs(this.playbackRate_) : 1;\n      const itemBandwidth = playbackRate * item.bandwidth;\n      const minBandwidth =\n          itemBandwidth / this.config_.bandwidthDowngradeTarget;\n      const nextBandwidth =\n          playbackRate * (next || {bandwidth: Infinity}).bandwidth;\n      const maxBandwidth = nextBandwidth / this.config_.bandwidthUpgradeTarget;\n      shaka.log.v2('Bandwidth ranges:',\n          (itemBandwidth / 1e6).toFixed(3),\n          (minBandwidth / 1e6).toFixed(3),\n          (maxBandwidth / 1e6).toFixed(3));\n\n      if (currentBandwidth >= minBandwidth &&\n          currentBandwidth <= maxBandwidth) {\n        chosen = item;\n      }\n    }\n\n    this.lastTimeChosenMs_ = Date.now();\n    return chosen;\n  }\n\n\n  /**\n   * @override\n   * @export\n   */\n  enable() {\n    this.enabled_ = true;\n  }\n\n\n  /**\n   * @override\n   * @export\n   */\n  disable() {\n    this.enabled_ = false;\n  }\n\n\n  /**\n   * @override\n   * @export\n   */\n  segmentDownloaded(deltaTimeMs, numBytes) {\n    shaka.log.v2('Segment downloaded:',\n        'deltaTimeMs=' + deltaTimeMs,\n        'numBytes=' + numBytes,\n        'lastTimeChosenMs=' + this.lastTimeChosenMs_,\n        'enabled=' + this.enabled_);\n    goog.asserts.assert(deltaTimeMs >= 0, 'expected a non-negative duration');\n    this.bandwidthEstimator_.sample(deltaTimeMs, numBytes);\n\n    if ((this.lastTimeChosenMs_ != null) && this.enabled_) {\n      this.suggestStreams_();\n    }\n  }\n\n\n  /**\n   * @override\n   * @export\n   */\n  getBandwidthEstimate() {\n    return this.bandwidthEstimator_.getBandwidthEstimate(\n        this.config_.defaultBandwidthEstimate);\n  }\n\n\n  /**\n   * @override\n   * @export\n   */\n  setVariants(variants) {\n    this.variants_ = variants;\n  }\n\n\n  /**\n   * @override\n   * @export\n   */\n  playbackRateChanged(rate) {\n    this.playbackRate_ = rate;\n  }\n\n\n  /**\n   * @override\n   * @export\n   */\n  configure(config) {\n    this.config_ = config;\n  }\n\n\n  /**\n   * Calls switch_() with the variant chosen by chooseVariant().\n   *\n   * @private\n   */\n  suggestStreams_() {\n    shaka.log.v2('Suggesting Streams...');\n    goog.asserts.assert(this.lastTimeChosenMs_ != null,\n        'lastTimeChosenMs_ should not be null');\n\n    if (!this.startupComplete_) {\n      // Check if we've got enough data yet.\n      if (!this.bandwidthEstimator_.hasGoodEstimate()) {\n        shaka.log.v2('Still waiting for a good estimate...');\n        return;\n      }\n      this.startupComplete_ = true;\n    } else {\n      // Check if we've left the switch interval.\n      const now = Date.now();\n      const delta = now - this.lastTimeChosenMs_;\n      if (delta < this.config_.switchInterval * 1000) {\n        shaka.log.v2('Still within switch interval...');\n        return;\n      }\n    }\n\n    const chosenVariant = this.chooseVariant();\n    const bandwidthEstimate = this.bandwidthEstimator_.getBandwidthEstimate(\n        this.config_.defaultBandwidthEstimate);\n    const currentBandwidthKbps = Math.round(bandwidthEstimate / 1000.0);\n\n    if (chosenVariant) {\n      shaka.log.debug(\n          'Calling switch_(), bandwidth=' + currentBandwidthKbps + ' kbps');\n      // If any of these chosen streams are already chosen, Player will filter\n      // them out before passing the choices on to StreamingEngine.\n      this.switch_(chosenVariant);\n    }\n  }\n\n\n  /**\n   * @param {?shaka.extern.Restrictions} restrictions\n   * @param {!Array.<shaka.extern.Variant>} variants\n   * @return {!Array.<shaka.extern.Variant>} variants filtered according to\n   *   |restrictions| and sorted in ascending order of bandwidth.\n   * @private\n   */\n  static filterAndSortVariants_(restrictions, variants) {\n    if (restrictions) {\n      variants = variants.filter((variant) => {\n        // This was already checked in another scope, but the compiler doesn't\n        // seem to understand that.\n        goog.asserts.assert(restrictions, 'Restrictions should exist!');\n\n        return shaka.util.StreamUtils.meetsRestrictions(\n            variant, restrictions,\n            /* maxHwRes= */ {width: Infinity, height: Infinity});\n      });\n    }\n\n    return variants.sort((v1, v2) => {\n      return v1.bandwidth - v2.bandwidth;\n    });\n  }\n};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.media.AdaptationSet');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.util.Iterables');\ngoog.require('shaka.util.MimeUtils');\n\n\n/**\n * A set of variants that we want to adapt between.\n *\n * @final\n */\nshaka.media.AdaptationSet = class {\n  /**\n   * @param {shaka.extern.Variant} root\n   *    The variant that all other variants will be tested against when being\n   *    added to the adaptation set. If a variant is not compatible with the\n   *    root, it will not be added.\n   * @param {!Iterable.<shaka.extern.Variant>=} candidates\n   *    Variants that may be compatible with the root and should be added if\n   *    compatible. If a candidate is not compatible, it will not end up in the\n   *    adaptation set.\n   */\n  constructor(root, candidates) {\n    /** @private {shaka.extern.Variant} */\n    this.root_ = root;\n    /** @private {!Set.<shaka.extern.Variant>} */\n    this.variants_ = new Set([root]);\n\n    // Try to add all the candidates. If they cannot be added (because they\n    // are not compatible with the root, they will be rejected by |add|.\n    candidates = candidates || [];\n    for (const candidate of candidates) {\n      this.add(candidate);\n    }\n  }\n\n  /**\n   * @param {shaka.extern.Variant} variant\n   * @return {boolean}\n   */\n  add(variant) {\n    if (this.canInclude(variant)) {\n      this.variants_.add(variant);\n      return true;\n    }\n\n    // To be nice, issue a warning if someone is trying to add something that\n    // they shouldn't.\n    shaka.log.warning('Rejecting variant - not compatible with root.');\n    return false;\n  }\n\n  /**\n   * Check if |variant| can be included with the set. If |canInclude| returns\n   * |false|, calling |add| will result in it being ignored.\n   *\n   * @param {shaka.extern.Variant} variant\n   * @return {boolean}\n   */\n  canInclude(variant) {\n    return shaka.media.AdaptationSet.areAdaptable(this.root_, variant);\n  }\n\n  /**\n   * @param {shaka.extern.Variant} a\n   * @param {shaka.extern.Variant} b\n   * @return {boolean}\n   */\n  static areAdaptable(a, b) {\n    const AdaptationSet = shaka.media.AdaptationSet;\n\n    // All variants should have audio or should all not have audio.\n    if (!!a.audio != !!b.audio) {\n      return false;\n    }\n\n    // All variants should have video or should all not have video.\n    if (!!a.video != !!b.video) {\n      return false;\n    }\n\n    // If the languages don't match, we should not adapt between them.\n    if (a.language != b.language) {\n      return false;\n    }\n\n    goog.asserts.assert(\n        !!a.audio == !!b.audio,\n        'Both should either have audio or not have audio.');\n    if (a.audio && b.audio &&\n        !AdaptationSet.areAudiosCompatible_(a.audio, b.audio)) {\n      return false;\n    }\n\n    goog.asserts.assert(\n        !!a.video == !!b.video,\n        'Both should either have video or not have video.');\n    if (a.video && b.video &&\n        !AdaptationSet.areVideosCompatible_(a.video, b.video)) {\n      return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * @return {!Iterable.<shaka.extern.Variant>}\n   */\n  values() {\n    return this.variants_.values();\n  }\n\n  /**\n   * Check if we can switch between two audio streams.\n   *\n   * @param {shaka.extern.Stream} a\n   * @param {shaka.extern.Stream} b\n   * @return {boolean}\n   * @private\n   */\n  static areAudiosCompatible_(a, b) {\n    const AdaptationSet = shaka.media.AdaptationSet;\n\n    // Audio channel counts must not change between adaptations.\n    if (a.channelsCount != b.channelsCount) {\n      return false;\n    }\n\n    // We can only adapt between base-codecs.\n    if (!AdaptationSet.canTransitionBetween_(a, b)) {\n      return false;\n    }\n\n    // Audio roles must not change between adaptations.\n    if (!AdaptationSet.areRolesEqual_(a.roles, b.roles)) {\n      return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Check if we can switch between two video streams.\n   *\n   * @param {shaka.extern.Stream} a\n   * @param {shaka.extern.Stream} b\n   * @return {boolean}\n   * @private\n   */\n  static areVideosCompatible_(a, b) {\n    const AdaptationSet = shaka.media.AdaptationSet;\n\n    // We can only adapt between base-codecs.\n    if (!AdaptationSet.canTransitionBetween_(a, b)) {\n      return false;\n    }\n\n    // Video roles must not change between adaptations.\n    if (!AdaptationSet.areRolesEqual_(a.roles, b.roles)) {\n      return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Check if we can switch between two streams based on their codec and mime\n   * type.\n   *\n   * @param {shaka.extern.Stream} a\n   * @param {shaka.extern.Stream} b\n   * @return {boolean}\n   * @private\n   */\n  static canTransitionBetween_(a, b) {\n    if (a.mimeType != b.mimeType) {\n      return false;\n    }\n\n\n    // Get the base codec of each codec in each stream.\n    const codecsA = shaka.util.MimeUtils.splitCodecs(a.codecs).map((codec) => {\n      return shaka.util.MimeUtils.getCodecBase(codec);\n    });\n    const codecsB = shaka.util.MimeUtils.splitCodecs(b.codecs).map((codec) => {\n      return shaka.util.MimeUtils.getCodecBase(codec);\n    });\n\n    // We don't want to allow switching between transmuxed and non-transmuxed\n    // content so the number of codecs should be the same.\n    //\n    // To avoid the case where an codec is used for audio and video we will\n    // codecs using arrays (not sets). While at this time, there are no codecs\n    // that work for audio and video, it is possible for \"raw\" codecs to be\n    // which would share the same name.\n    if (codecsA.length != codecsB.length) {\n      return false;\n    }\n\n    // Sort them so that we can walk through them and compare them\n    // element-by-element.\n    codecsA.sort();\n    codecsB.sort();\n\n    for (const i of shaka.util.Iterables.range(codecsA.length)) {\n      if (codecsA[i] != codecsB[i]) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  /**\n   * Check if two role lists are the equal. This will take into account all\n   * unique behaviours when comparing roles.\n   *\n   * @param {!Iterable.<string>} a\n   * @param {!Iterable.<string>} b\n   * @return {boolean}\n   * @private\n   */\n  static areRolesEqual_(a, b) {\n    const aSet = new Set(a);\n    const bSet = new Set(b);\n\n    // Remove the main role from the role lists (we expect to see them only\n    // in dash manifests).\n    const mainRole = 'main';\n    aSet.delete(mainRole);\n    bSet.delete(mainRole);\n\n    // Make sure that we have the same number roles in each list. Make sure to\n    // do it after correcting for 'main'.\n    if (aSet.size != bSet.size) {\n      return false;\n    }\n\n    // Because we know the two sets are the same size, if any item is missing\n    // if means that they are not the same.\n    for (const x of aSet) {\n      if (!bSet.has(x)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.media.AdaptationSetCriteria');\ngoog.provide('shaka.media.ExampleBasedCriteria');\ngoog.provide('shaka.media.PreferenceBasedCriteria');\n\ngoog.require('shaka.log');\ngoog.require('shaka.media.AdaptationSet');\ngoog.require('shaka.util.LanguageUtils');\ngoog.require('shaka.util.StreamUtils');\n\n\n/**\n * An adaptation set criteria is a unit of logic that can take a set of\n * variants and return a subset of variants that should (and can) be\n * adapted between.\n *\n * @interface\n */\nshaka.media.AdaptationSetCriteria = class {\n  /**\n   * Take a set of variants, and return a subset of variants that can be\n   * adapted between.\n   *\n   * @param {!Array.<shaka.extern.Variant>} variants\n   * @return {!shaka.media.AdaptationSet}\n   */\n  create(variants) {}\n};\n\n\n/**\n * @implements {shaka.media.AdaptationSetCriteria}\n * @final\n */\nshaka.media.ExampleBasedCriteria = class {\n  /**\n   * @param {shaka.extern.Variant} example\n   */\n  constructor(example) {\n    /** @private {shaka.extern.Variant} */\n    this.example_ = example;\n\n    // We can't know if role and label are really important, so we don't use\n    // role and label for this.\n    const role = '';\n    const label = '';\n    const channelCount = example.audio && example.audio.channelsCount ?\n                         example.audio.channelsCount :\n                         0;\n\n    /** @private {!shaka.media.AdaptationSetCriteria} */\n    this.fallback_ = new shaka.media.PreferenceBasedCriteria(\n        example.language, role, channelCount, label);\n  }\n\n  /** @override */\n  create(variants) {\n    // We can't assume that the example is in |variants| because it could\n    // actually be from another period.\n    const shortList = variants.filter((variant) => {\n      return shaka.media.AdaptationSet.areAdaptable(this.example_, variant);\n    });\n\n    if (shortList.length) {\n      // Use the first item in the short list as the root. It should not matter\n      // which element we use as all items in the short list should already be\n      // compatible.\n      return new shaka.media.AdaptationSet(shortList[0], shortList);\n    } else {\n      return this.fallback_.create(variants);\n    }\n  }\n};\n\n\n/**\n * @implements {shaka.media.AdaptationSetCriteria}\n * @final\n */\nshaka.media.PreferenceBasedCriteria = class {\n  /**\n   * @param {string} language\n   * @param {string} role\n   * @param {number} channelCount\n   * @param {string=} label\n   */\n  constructor(language, role, channelCount, label = '') {\n    /** @private {string} */\n    this.language_ = language;\n    /** @private {string} */\n    this.role_ = role;\n    /** @private {number} */\n    this.channelCount_ = channelCount;\n    /** @private {string} */\n    this.label_ = label;\n  }\n\n  /** @override */\n  create(variants) {\n    const Class = shaka.media.PreferenceBasedCriteria;\n    const StreamUtils = shaka.util.StreamUtils;\n\n    let current = [];\n\n    const byLanguage = Class.filterByLanguage_(variants, this.language_);\n    const byPrimary = variants.filter((variant) => variant.primary);\n\n    if (byLanguage.length) {\n      current = byLanguage;\n    } else if (byPrimary.length) {\n      current = byPrimary;\n    } else {\n      current = variants;\n    }\n\n    // Now refine the choice based on role preference.  Even the empty string\n    // works here, and will match variants without any roles.\n    const byRole = Class.filterVariantsByRole_(current, this.role_);\n    if (byRole.length) {\n      current = byRole;\n    } else {\n      shaka.log.warning('No exact match for variant role could be found.');\n    }\n\n    if (this.channelCount_) {\n      const byChannel = StreamUtils.filterVariantsByAudioChannelCount(\n          current, this.channelCount_);\n      if (byChannel.length) {\n        current = byChannel;\n      } else {\n        shaka.log.warning(\n            'No exact match for the channel count could be found.');\n      }\n    }\n\n    if (this.label_) {\n      const byLabel = Class.filterVariantsByLabel_(current, this.label_);\n      if (byLabel.length) {\n        current = byLabel;\n      } else {\n        shaka.log.warning('No exact match for variant label could be found.');\n      }\n    }\n\n    // Make sure we only return a valid adaptation set.\n    const set = new shaka.media.AdaptationSet(current[0]);\n    for (const variant of current) {\n      if (set.canInclude(variant)) {\n        set.add(variant);\n      }\n    }\n\n    return set;\n  }\n\n  /**\n   * @param {!Array.<shaka.extern.Variant>} variants\n   * @param {string} preferredLanguage\n   * @return {!Array.<shaka.extern.Variant>}\n   * @private\n   */\n  static filterByLanguage_(variants, preferredLanguage) {\n    const LanguageUtils = shaka.util.LanguageUtils;\n\n    /** @type {string} */\n    const preferredLocale = LanguageUtils.normalize(preferredLanguage);\n\n    /** @type {?string} */\n    const closestLocale = LanguageUtils.findClosestLocale(\n        preferredLocale,\n        variants.map((variant) => LanguageUtils.getLocaleForVariant(variant)));\n\n    // There were no locales close to what we preferred.\n    if (!closestLocale) {\n      return [];\n    }\n\n    // Find the variants that use the closest variant.\n    return variants.filter((variant) => {\n      return closestLocale == LanguageUtils.getLocaleForVariant(variant);\n    });\n  }\n\n  /**\n   * Filter Variants by role.\n   *\n   * @param {!Array.<shaka.extern.Variant>} variants\n   * @param {string} preferredRole\n   * @return {!Array.<shaka.extern.Variant>}\n   * @private\n   */\n  static filterVariantsByRole_(variants, preferredRole) {\n    return variants.filter((variant) => {\n      if (!variant.audio) {\n        return false;\n      }\n\n      if (preferredRole) {\n        return variant.audio.roles.includes(preferredRole);\n      } else {\n        return variant.audio.roles.length == 0;\n      }\n    });\n  }\n\n  /**\n   * Filter Variants by label.\n   *\n   * @param {!Array.<shaka.extern.Variant>} variants\n   * @param {string} preferredLabel\n   * @return {!Array.<shaka.extern.Variant>}\n   * @private\n   */\n  static filterVariantsByLabel_(variants, preferredLabel) {\n    return variants.filter((variant) => {\n      if (!variant.audio) {\n        return false;\n      }\n\n      const label1 = variant.audio.label.toLowerCase();\n      const label2 = preferredLabel.toLowerCase();\n      return label1 == label2;\n    });\n  }\n};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.media.BufferingObserver');\n\n\n/**\n * The buffering observer watches how much content has been buffered and raises\n * events when the state changes (enough => not enough or vice versa).\n *\n * @final\n */\nshaka.media.BufferingObserver = class {\n  /**\n   * @param {number} thresholdWhenStarving\n   * @param {number} thresholdWhenSatisfied\n   */\n  constructor(thresholdWhenStarving, thresholdWhenSatisfied) {\n    const State = shaka.media.BufferingObserver.State;\n\n    /** @private {shaka.media.BufferingObserver.State} */\n    this.previousState_ = State.SATISFIED;\n\n    /** @private {!Map.<shaka.media.BufferingObserver.State, number>} */\n    this.thresholds_ = new Map()\n        .set(State.SATISFIED, thresholdWhenSatisfied)\n        .set(State.STARVING, thresholdWhenStarving);\n  }\n\n  /**\n   * @param {number} thresholdWhenStarving\n   * @param {number} thresholdWhenSatisfied\n   */\n  setThresholds(thresholdWhenStarving, thresholdWhenSatisfied) {\n    const State = shaka.media.BufferingObserver.State;\n    this.thresholds_\n        .set(State.SATISFIED, thresholdWhenSatisfied)\n        .set(State.STARVING, thresholdWhenStarving);\n  }\n\n  /**\n   * Update the observer by telling it how much content has been buffered (in\n   * seconds) and if we are buffered to the end of the presentation. If the\n   * controller believes the state has changed, it will return |true|.\n   *\n   * @param {number} bufferLead\n   * @param {boolean} bufferedToEnd\n   * @return {boolean}\n   */\n  update(bufferLead, bufferedToEnd) {\n    const State = shaka.media.BufferingObserver.State;\n\n    /**\n     * Our threshold for how much we need before we declare ourselves as\n     * starving is based on whether or not we were just starving. If we\n     * were just starving, we are more likely to starve again, so we require\n     * more content to be buffered than if we were not just starving.\n     *\n     * @type {number}\n     */\n    const threshold = this.thresholds_.get(this.previousState_);\n\n    const oldState = this.previousState_;\n    const newState = (bufferedToEnd || bufferLead >= threshold) ?\n                     (State.SATISFIED) :\n                     (State.STARVING);\n\n    // Save the new state now so that calls to |getState| from any callbacks\n    // will be accurate.\n    this.previousState_ = newState;\n\n    // Return |true| only when the state has changed.\n    return oldState != newState;\n  }\n\n  /**\n   * Set which state that the observer should think playback was in.\n   *\n   * @param {shaka.media.BufferingObserver.State} state\n   */\n  setState(state) {\n    this.previousState_ = state;\n  }\n\n  /**\n   * Get the state that the observer last thought playback was in.\n   *\n   * @return {shaka.media.BufferingObserver.State}\n   */\n  getState() {\n    return this.previousState_;\n  }\n};\n\n/**\n * Rather than using booleans to communicate what state we are in, we have this\n * enum.\n *\n * @enum {number}\n */\nshaka.media.BufferingObserver.State = {\n  STARVING: 0,\n  SATISFIED: 1,\n};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.Player');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.Deprecate');\ngoog.require('shaka.log');\ngoog.require('shaka.media.AdaptationSetCriteria');\ngoog.require('shaka.media.BufferingObserver');\ngoog.require('shaka.media.DrmEngine');\ngoog.require('shaka.media.ExampleBasedCriteria');\ngoog.require('shaka.media.ManifestParser');\ngoog.require('shaka.media.MediaSourceEngine');\ngoog.require('shaka.media.MediaSourcePlayhead');\ngoog.require('shaka.media.MetaSegmentIndex');\ngoog.require('shaka.media.MuxJSClosedCaptionParser');\ngoog.require('shaka.media.NoopCaptionParser');\ngoog.require('shaka.media.PlayRateController');\ngoog.require('shaka.media.Playhead');\ngoog.require('shaka.media.PlayheadObserverManager');\ngoog.require('shaka.media.PreferenceBasedCriteria');\ngoog.require('shaka.media.RegionObserver');\ngoog.require('shaka.media.RegionTimeline');\ngoog.require('shaka.media.SegmentIndex');\ngoog.require('shaka.media.SrcEqualsPlayhead');\ngoog.require('shaka.media.StreamingEngine');\ngoog.require('shaka.media.TimeRangesUtils');\ngoog.require('shaka.net.NetworkingEngine');\ngoog.require('shaka.routing.Walker');\ngoog.require('shaka.text.SimpleTextDisplayer');\ngoog.require('shaka.text.UITextDisplayer');\ngoog.require('shaka.util.AbortableOperation');\ngoog.require('shaka.util.ConfigUtils');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.EventManager');\ngoog.require('shaka.util.FakeEvent');\ngoog.require('shaka.util.FakeEventTarget');\ngoog.require('shaka.util.Functional');\ngoog.require('shaka.util.IDestroyable');\ngoog.require('shaka.util.LanguageUtils');\ngoog.require('shaka.util.ManifestParserUtils');\ngoog.require('shaka.util.MediaReadyState');\ngoog.require('shaka.util.MimeUtils');\ngoog.require('shaka.util.ObjectUtils');\ngoog.require('shaka.util.Platform');\ngoog.require('shaka.util.PlayerConfiguration');\ngoog.require('shaka.util.PublicPromise');\ngoog.require('shaka.util.Stats');\ngoog.require('shaka.util.StreamUtils');\ngoog.require('shaka.util.Timer');\ngoog.requireType('shaka.media.IClosedCaptionParser');\ngoog.requireType('shaka.media.PresentationTimeline');\ngoog.requireType('shaka.routing.Node');\ngoog.requireType('shaka.routing.Payload');\n\n\n/**\n * @event shaka.Player.ErrorEvent\n * @description Fired when a playback error occurs.\n * @property {string} type\n *   'error'\n * @property {!shaka.util.Error} detail\n *   An object which contains details on the error.  The error's\n *   <code>category</code> and <code>code</code> properties will identify the\n *   specific error that occurred.  In an uncompiled build, you can also use the\n *   <code>message</code> and <code>stack</code> properties to debug.\n * @exportDoc\n */\n\n/**\n * @event shaka.Player.StateChangeEvent\n * @description Fired when the player changes load states.\n * @property {string} type\n *    'onstatechange'\n * @property {string} state\n *    The name of the state that the player just entered.\n * @exportDoc\n */\n\n/**\n * @event shaka.Player.StateIdleEvent\n * @description Fired when the player has stopped changing states and will\n *    remain idle until a new state change request (e.g. <code>load</code>,\n *    <code>attach</code>, etc.) is made.\n * @property {string} type\n *    'onstateidle'\n * @property {string} state\n *    The name of the state that the player stopped in.\n * @exportDoc\n */\n\n/**\n * @event shaka.Player.EmsgEvent\n * @description Fired when a non-typical emsg is found in a segment.\n * @property {string} type\n *   'emsg'\n * @property {shaka.extern.EmsgInfo} detail\n *   An object which contains the content of the emsg box.\n * @exportDoc\n */\n\n\n/**\n * @event shaka.Player.DrmSessionUpdateEvent\n * @description Fired when the CDM has accepted the license response.\n * @property {string} type\n *   'drmsessionupdate'\n * @exportDoc\n */\n\n\n/**\n * @event shaka.Player.TimelineRegionAddedEvent\n * @description Fired when a media timeline region is added.\n * @property {string} type\n *   'timelineregionadded'\n * @property {shaka.extern.TimelineRegionInfo} detail\n *   An object which contains a description of the region.\n * @exportDoc\n */\n\n\n/**\n * @event shaka.Player.TimelineRegionEnterEvent\n * @description Fired when the playhead enters a timeline region.\n * @property {string} type\n *   'timelineregionenter'\n * @property {shaka.extern.TimelineRegionInfo} detail\n *   An object which contains a description of the region.\n * @exportDoc\n */\n\n\n/**\n * @event shaka.Player.TimelineRegionExitEvent\n * @description Fired when the playhead exits a timeline region.\n * @property {string} type\n *   'timelineregionexit'\n * @property {shaka.extern.TimelineRegionInfo} detail\n *   An object which contains a description of the region.\n * @exportDoc\n */\n\n\n/**\n * @event shaka.Player.BufferingEvent\n * @description Fired when the player's buffering state changes.\n * @property {string} type\n *   'buffering'\n * @property {boolean} buffering\n *   True when the Player enters the buffering state.\n *   False when the Player leaves the buffering state.\n * @exportDoc\n */\n\n\n/**\n * @event shaka.Player.LoadingEvent\n * @description Fired when the player begins loading. The start of loading is\n *   defined as when the user has communicated intent to load content (i.e.\n *   <code>Player.load</code> has been called).\n * @property {string} type\n *   'loading'\n * @exportDoc\n */\n\n\n/**\n * @event shaka.Player.LoadedEvent\n * @description Fired when the player ends the load.\n * @property {string} type\n *   'loaded'\n * @exportDoc\n */\n\n\n/**\n * @event shaka.Player.UnloadingEvent\n * @description Fired when the player unloads or fails to load.\n *   Used by the Cast receiver to determine idle state.\n * @property {string} type\n *   'unloading'\n * @exportDoc\n */\n\n\n/**\n * @event shaka.Player.TextTrackVisibilityEvent\n * @description Fired when text track visibility changes.\n * @property {string} type\n *   'texttrackvisibility'\n * @exportDoc\n */\n\n\n/**\n * @event shaka.Player.TracksChangedEvent\n * @description Fired when the list of tracks changes.  For example, this will\n *   happen when new tracks are added/removed or when track restrictions change.\n * @property {string} type\n *   'trackschanged'\n * @exportDoc\n */\n\n\n/**\n * @event shaka.Player.AdaptationEvent\n * @description Fired when an automatic adaptation causes the active tracks\n *   to change.  Does not fire when the application calls\n *   <code>selectVariantTrack()</code>, <code>selectTextTrack()</code>,\n *   <code>selectAudioLanguage()</code>, or <code>selectTextLanguage()</code>.\n * @property {string} type\n *   'adaptation'\n * @exportDoc\n */\n\n\n/**\n * @event shaka.Player.VariantChangedEvent\n * @description Fired when a call from the application caused a variant change.\n *  Can be triggered by calls to <code>selectVariantTrack()</code> or\n *  <code>selectAudioLanguage()</code>. Does not fire when an automatic\n *  adaptation causes a variant change.\n * @property {string} type\n *   'variantchanged'\n * @exportDoc\n */\n\n\n/**\n * @event shaka.Player.TextChangedEvent\n * @description Fired when a call from the application caused a text stream\n *  change. Can be triggered by calls to <code>selectTextTrack()</code> or\n *  <code>selectTextLanguage()</code>.\n * @property {string} type\n *   'textchanged'\n * @exportDoc\n */\n\n\n/**\n * @event shaka.Player.ExpirationUpdatedEvent\n * @description Fired when there is a change in the expiration times of an\n *   EME session.\n * @property {string} type\n *   'expirationupdated'\n * @exportDoc\n */\n\n\n/**\n * @event shaka.Player.LargeGapEvent\n * @description Fired when the playhead enters a large gap.  If the\n *   <code>streaming.jumpLargeGaps</code> configuration is set, the default\n *   action of this event is to jump the gap; this can be prevented by calling\n *   <code>preventDefault()</code> on the event object.\n * @property {string} type\n *   'largegap'\n * @property {number} currentTime\n *   The current time of the playhead.\n * @property {number} gapSize\n *   The size of the gap, in seconds.\n * @exportDoc\n */\n\n\n/**\n * @event shaka.Player.ManifestParsedEvent\n * @description Fired after the manifest has been parsed, but before anything\n *   else happens. The manifest may contain streams that will be filtered out,\n *   at this stage of the loading process.\n * @property {string} type\n *   'manifestparsed'\n * @exportDoc\n */\n\n\n/**\n * @event shaka.Player.MetadataEvent\n * @description Triggers after metadata associated with the stream is found.\n *   Usually they are metadata of type ID3.\n * @property {string} type\n *   'metadata'\n * @property {number} startTime\n *   The time that describes the beginning of the range of the metadata to\n *   which the cue applies.\n * @property {?number} endTime\n *   The time that describes the end of the range of the metadata to which\n *   the cue applies.\n * @property {string} metadataType\n *   Type of metadata. Eg: org.id3 or org.mp4ra\n * @property {shaka.extern.ID3Metadata} payload\n *   The metadata itself\n * @exportDoc\n */\n\n\n/**\n * @event shaka.Player.StreamingEvent\n * @description Fired after the manifest has been parsed and track information\n *   is available, but before streams have been chosen and before any segments\n *   have been fetched.  You may use this event to configure the player based on\n *   information found in the manifest.\n * @property {string} type\n *   'streaming'\n * @exportDoc\n */\n\n\n/**\n * @event shaka.Player.AbrStatusChangedEvent\n * @description Fired when the state of abr has been changed.\n *    (Enabled or disabled).\n * @property {string} type\n *   'abrstatuschanged'\n * @property {boolean} newStatus\n *  The new status of the application. True for 'is enabled' and\n *  false otherwise.\n * @exportDoc\n */\n\n\n/**\n * @event shaka.Player.RateChangeEvent\n * @description Fired when the video's playback rate changes.\n *    This allows the PlayRateController to update it's internal rate field,\n *    before the UI updates playback button with the newest playback rate.\n * @property {string} type\n *    'ratechange'\n * @exportDoc\n */\n\n\n/**\n * @summary The main player object for Shaka Player.\n *\n * @implements {shaka.util.IDestroyable}\n * @export\n */\nshaka.Player = class extends shaka.util.FakeEventTarget {\n  /**\n   * @param {HTMLMediaElement=} mediaElement\n   *    When provided, the player will attach to <code>mediaElement</code>,\n   *    similar to calling <code>attach</code>. When not provided, the player\n   *    will remain detached.\n   * @param {function(shaka.Player)=} dependencyInjector Optional callback\n   *   which is called to inject mocks into the Player.  Used for testing.\n   */\n  constructor(mediaElement, dependencyInjector) {\n    super();\n\n    /** @private {shaka.Player.LoadMode} */\n    this.loadMode_ = shaka.Player.LoadMode.NOT_LOADED;\n\n    /** @private {HTMLMediaElement} */\n    this.video_ = null;\n\n    /** @private {HTMLElement} */\n    this.videoContainer_ = null;\n\n    /**\n     * Since we may not always have a text displayer created (e.g. before |load|\n     * is called), we need to track what text visibility SHOULD be so that we\n     * can ensure that when we create the text displayer. When we create our\n     * text displayer, we will use this to show (or not show) text as per the\n     * user's requests.\n     *\n     * @private {boolean}\n     */\n    this.isTextVisible_ = false;\n\n    /** @private {shaka.util.EventManager} */\n    this.eventManager_ = new shaka.util.EventManager();\n\n    /** @private {shaka.net.NetworkingEngine} */\n    this.networkingEngine_ = null;\n\n    /** @private {shaka.media.DrmEngine} */\n    this.drmEngine_ = null;\n\n    /** @private {shaka.media.MediaSourceEngine} */\n    this.mediaSourceEngine_ = null;\n\n    /** @private {shaka.media.Playhead} */\n    this.playhead_ = null;\n\n    /**\n     * The playhead observers are used to monitor the position of the playhead\n     * and some other source of data (e.g. buffered content), and raise events.\n     *\n     * @private {shaka.media.PlayheadObserverManager}\n     */\n    this.playheadObservers_ = null;\n\n    /**\n     * This is our control over the playback rate of the media element. This\n     * provides the missing functionality that we need to provide trick play,\n     * for example a negative playback rate.\n     *\n     * @private {shaka.media.PlayRateController}\n     */\n    this.playRateController_ = null;\n\n    // We use the buffering observer and timer to track when we move from having\n    // enough buffered content to not enough. They only exist when content has\n    // been loaded and are not re-used between loads.\n    /** @private {shaka.util.Timer} */\n    this.bufferPoller_ = null;\n\n    /** @private {shaka.media.BufferingObserver} */\n    this.bufferObserver_ = null;\n\n    /** @private {shaka.media.RegionTimeline} */\n    this.regionTimeline_ = null;\n\n    /** @private {shaka.media.StreamingEngine} */\n    this.streamingEngine_ = null;\n\n    /** @private {shaka.extern.ManifestParser} */\n    this.parser_ = null;\n\n    /** @private {?shaka.extern.ManifestParser.Factory} */\n    this.parserFactory_ = null;\n\n    /** @private {?shaka.extern.Manifest} */\n    this.manifest_ = null;\n\n    /** @private {?string} */\n    this.assetUri_ = null;\n\n    /** @private {shaka.extern.AbrManager} */\n    this.abrManager_ = null;\n\n    /**\n     * The factory that was used to create the abrManager_ instance.\n     * @private {?shaka.extern.AbrManager.Factory}\n     */\n    this.abrManagerFactory_ = null;\n\n    /**\n     * Contains an ID for use with creating streams.  The manifest parser should\n     * start with small IDs, so this starts with a large one.\n     * @private {number}\n     */\n    this.nextExternalStreamId_ = 1e9;\n\n    /** @private {?shaka.extern.PlayerConfiguration} */\n    this.config_ = this.defaultConfig_();\n\n    /**\n     * The TextDisplayerFactory that was last used to make a text displayer.\n     * Stored so that we can tell if a new type of text displayer is desired.\n     * @private {?shaka.extern.TextDisplayer.Factory}\n     */\n    this.lastTextFactory_;\n\n    /** @private {{width: number, height: number}} */\n    this.maxHwRes_ = {width: Infinity, height: Infinity};\n\n    /** @private {shaka.util.Stats} */\n    this.stats_ = null;\n\n    /** @private {!shaka.media.AdaptationSetCriteria} */\n    this.currentAdaptationSetCriteria_ =\n        new shaka.media.PreferenceBasedCriteria(\n            this.config_.preferredAudioLanguage,\n            this.config_.preferredVariantRole,\n            this.config_.preferredAudioChannelCount);\n\n    /** @private {string} */\n    this.currentTextLanguage_ = this.config_.preferredTextLanguage;\n\n    /** @private {string} */\n    this.currentTextRole_ = this.config_.preferredTextRole;\n\n    /** @private {!Array.<function():(!Promise|undefined)>} */\n    this.cleanupOnUnload_ = [];\n\n    if (dependencyInjector) {\n      dependencyInjector(this);\n    }\n\n    this.networkingEngine_ = this.createNetworkingEngine();\n\n    /** @private {shaka.extern.IAdManager} */\n    this.adManager_ = null;\n\n    if (shaka.Player.adManagerFactory_) {\n      this.adManager_ =\n          shaka.util.Functional.callFactory(shaka.Player.adManagerFactory_);\n    }\n\n    // If the browser comes back online after being offline, then try to play\n    // again.\n    this.eventManager_.listen(window, 'online', () => {\n      this.retryStreaming();\n    });\n\n    /** @private {shaka.routing.Node} */\n    this.detachNode_ = {name: 'detach'};\n    /** @private {shaka.routing.Node} */\n    this.attachNode_ = {name: 'attach'};\n    /** @private {shaka.routing.Node} */\n    this.unloadNode_ = {name: 'unload'};\n    /** @private {shaka.routing.Node} */\n    this.parserNode_ = {name: 'manifest-parser'};\n    /** @private {shaka.routing.Node} */\n    this.manifestNode_ = {name: 'manifest'};\n    /** @private {shaka.routing.Node} */\n    this.mediaSourceNode_ = {name: 'media-source'};\n    /** @private {shaka.routing.Node} */\n    this.drmNode_ = {name: 'drm-engine'};\n    /** @private {shaka.routing.Node} */\n    this.loadNode_ = {name: 'load'};\n    /** @private {shaka.routing.Node} */\n    this.srcEqualsDrmNode_ = {name: 'src-equals-drm-engine'};\n    /** @private {shaka.routing.Node} */\n    this.srcEqualsNode_ = {name: 'src-equals'};\n\n    const AbortableOperation = shaka.util.AbortableOperation;\n\n    const actions = new Map();\n    actions.set(this.attachNode_, (has, wants) => {\n      return AbortableOperation.notAbortable(this.onAttach_(has, wants));\n    });\n    actions.set(this.detachNode_, (has, wants) => {\n      return AbortableOperation.notAbortable(this.onDetach_(has, wants));\n    });\n    actions.set(this.unloadNode_, (has, wants) => {\n      return AbortableOperation.notAbortable(this.onUnload_(has, wants));\n    });\n    actions.set(this.mediaSourceNode_, (has, wants) => {\n      const p = this.onInitializeMediaSourceEngine_(has, wants);\n      return AbortableOperation.notAbortable(p);\n    });\n    actions.set(this.parserNode_, (has, wants) => {\n      const p = this.onInitializeParser_(has, wants);\n      return AbortableOperation.notAbortable(p);\n    });\n    actions.set(this.manifestNode_, (has, wants) => {\n      // This action is actually abortable, so unlike the other callbacks, this\n      // one will return an abortable operation.\n      return this.onParseManifest_(has, wants);\n    });\n    actions.set(this.drmNode_, (has, wants) => {\n      const p = this.onInitializeDrm_(has, wants);\n      return AbortableOperation.notAbortable(p);\n    });\n    actions.set(this.loadNode_, (has, wants) => {\n      return AbortableOperation.notAbortable(this.onLoad_(has, wants));\n    });\n\n    actions.set(this.srcEqualsDrmNode_, (has, wants) => {\n      const p = this.onInitializeSrcEqualsDrm_(has, wants);\n      return AbortableOperation.notAbortable(p);\n    });\n    actions.set(this.srcEqualsNode_, (has, wants) => {\n      return this.onSrcEquals_(has, wants);\n    });\n\n    /** @private {shaka.routing.Walker.Implementation} */\n    const walkerImplementation = {\n      getNext: (at, has, goingTo, wants) => {\n        return this.getNextStep_(at, has, goingTo, wants);\n      },\n      enterNode: (node, has, wants) => {\n        this.dispatchEvent(this.makeEvent_(\n            /* name= */ shaka.Player.EventName.OnStateChange,\n            /* data= */ {'state': node.name}));\n\n        const action = actions.get(node);\n        return action(has, wants);\n      },\n      handleError: async (has, error) => {\n        shaka.log.warning('The walker saw an error:');\n        if (error instanceof shaka.util.Error) {\n          shaka.log.warning('Error Code:', error.code);\n        } else {\n          shaka.log.warning('Error Message:', error.message);\n          shaka.log.warning('Error Stack:', error.stack);\n        }\n\n        // Regardless of what state we were in, if there is an error, we unload.\n        // This ensures that any initialized system will be torn-down and we\n        // will go back to a safe foundation. We assume that the media element\n        // is always safe to use after an error.\n        await this.onUnload_(has, shaka.Player.createEmptyPayload_());\n\n        // There are only two nodes that come before we start loading content,\n        // attach and detach. If we have a media element, it means we were\n        // attached to the element, and we can safely return to the attach state\n        // (we assume that the video element is always re-usable). We favor\n        // returning to the attach node since it means that the app won't need\n        // to re-attach if it saw an error.\n        return has.mediaElement ? this.attachNode_ : this.detachNode_;\n      },\n      onIdle: (node) => {\n        this.dispatchEvent(this.makeEvent_(\n            /* name= */ shaka.Player.EventName.OnStateIdle,\n            /* data= */ {'state': node.name}));\n      },\n    };\n\n    /** @private {shaka.routing.Walker} */\n    this.walker_ = new shaka.routing.Walker(\n        this.detachNode_,\n        shaka.Player.createEmptyPayload_(),\n        walkerImplementation);\n\n    // Even though |attach| will start in later interpreter cycles, it should be\n    // the LAST thing we do in the constructor because conceptually it relies on\n    // player having been initialized.\n    if (mediaElement) {\n      this.attach(mediaElement, /* initializeMediaSource= */ true);\n    }\n  }\n\n  /**\n   * @param {!shaka.Player.EventName} name\n   * @param {Object=} data\n   * @return {!shaka.util.FakeEvent}\n   * @private\n   */\n  makeEvent_(name, data) {\n    return new shaka.util.FakeEvent(name, data);\n  }\n\n  /**\n   * After destruction, a Player object cannot be used again.\n   *\n   * @override\n   * @export\n   */\n  async destroy() {\n    // Make sure we only execute the destroy logic once.\n    if (this.loadMode_ == shaka.Player.LoadMode.DESTROYED) {\n      return;\n    }\n\n    // Mark as \"dead\". This should stop external-facing calls from changing our\n    // internal state any more. This will stop calls to |attach|, |detach|, etc.\n    // from interrupting our final move to the detached state.\n    this.loadMode_ = shaka.Player.LoadMode.DESTROYED;\n\n    // Because we have set |loadMode_| to |DESTROYED| we can't call |detach|. We\n    // must talk to |this.walker_| directly.\n    const events = this.walker_.startNewRoute((currentPayload) => {\n      return {\n        node: this.detachNode_,\n        payload: shaka.Player.createEmptyPayload_(),\n        interruptible: false,\n      };\n    });\n\n    // Wait until the detach has finished so that we don't interrupt it by\n    // calling |destroy| on |this.walker_|. To avoid failing here, we always\n    // resolve the promise.\n    await new Promise((resolve) => {\n      events.onStart = () => {\n        shaka.log.info('Preparing to destroy walker...');\n      };\n      events.onEnd = () => {\n        resolve();\n      };\n      events.onCancel = () => {\n        goog.asserts.assert(false,\n            'Our final detach call should never be cancelled.');\n        resolve();\n      };\n      events.onError = () => {\n        goog.asserts.assert(false,\n            'Our final detach call should never see an error');\n        resolve();\n      };\n      events.onSkip = () => {\n        goog.asserts.assert(false,\n            'Our final detach call should never be skipped');\n        resolve();\n      };\n    });\n    await this.walker_.destroy();\n\n    // Tear-down the event manager to ensure messages stop moving around.\n    if (this.eventManager_) {\n      this.eventManager_.release();\n      this.eventManager_ = null;\n    }\n\n    this.abrManagerFactory_ = null;\n    this.abrManager_ = null;\n    this.config_ = null;\n    this.stats_ = null;\n    this.videoContainer_ = null;\n\n    if (this.networkingEngine_) {\n      await this.networkingEngine_.destroy();\n      this.networkingEngine_ = null;\n    }\n  }\n\n  /**\n   * Registers a plugin callback that will be called with\n   * <code>support()</code>.  The callback will return the value that will be\n   * stored in the return value from <code>support()</code>.\n   *\n   * @param {string} name\n   * @param {function():*} callback\n   * @export\n   */\n  static registerSupportPlugin(name, callback) {\n    shaka.Player.supportPlugins_[name] = callback;\n  }\n\n  /**\n   * Set a factory to create an ad manager during player construction time.\n   * This method needs to be called bafore instantiating the Player class.\n   *\n   * @param {!shaka.extern.IAdManager.Factory} factory\n   * @export\n   */\n  static setAdManagerFactory(factory) {\n    shaka.Player.adManagerFactory_ = factory;\n  }\n\n  /**\n   * Return whether the browser provides basic support.  If this returns false,\n   * Shaka Player cannot be used at all.  In this case, do not construct a\n   * Player instance and do not use the library.\n   *\n   * @return {boolean}\n   * @export\n   */\n  static isBrowserSupported() {\n    // Basic features needed for the library to be usable.\n    const basicSupport = !!window.Promise && !!window.Uint8Array &&\n                         // eslint-disable-next-line no-restricted-syntax\n                         !!Array.prototype.forEach;\n    if (!basicSupport) {\n      return false;\n    }\n\n    // We do not support iOS 9, 10, or 11, nor those same versions of desktop\n    // Safari.\n    const safariVersion = shaka.util.Platform.safariVersion();\n    if (safariVersion && safariVersion < 12) {\n      return false;\n    }\n\n    // DRM support is not strictly necessary, but the APIs at least need to be\n    // there.  Our no-op DRM polyfill should handle that.\n    // TODO(#1017): Consider making even DrmEngine optional.\n    const drmSupport = shaka.media.DrmEngine.isBrowserSupported();\n    if (!drmSupport) {\n      return false;\n    }\n\n    // If we have MediaSource (MSE) support, we should be able to use Shaka.\n    if (shaka.util.Platform.supportsMediaSource()) {\n      return true;\n    }\n\n    // If we don't have MSE, we _may_ be able to use Shaka.  Look for native HLS\n    // support, and call this platform usable if we have it.\n    return shaka.util.Platform.supportsMediaType('application/x-mpegurl');\n  }\n\n  /**\n   * Probes the browser to determine what features are supported.  This makes a\n   * number of requests to EME/MSE/etc which may result in user prompts.  This\n   * should only be used for diagnostics.\n   *\n   * <p>\n   * NOTE: This may show a request to the user for permission.\n   *\n   * @see https://bit.ly/2ywccmH\n   * @return {!Promise.<shaka.extern.SupportType>}\n   * @export\n   */\n  static async probeSupport() {\n    goog.asserts.assert(shaka.Player.isBrowserSupported(),\n        'Must have basic support');\n    const drm = await shaka.media.DrmEngine.probeSupport();\n    const manifest = shaka.media.ManifestParser.probeSupport();\n    const media = shaka.media.MediaSourceEngine.probeSupport();\n    const ret = {\n      manifest: manifest,\n      media: media,\n      drm: drm,\n    };\n\n    const plugins = shaka.Player.supportPlugins_;\n    for (const name in plugins) {\n      ret[name] = plugins[name]();\n    }\n\n    return ret;\n  }\n\n  /**\n   * Tell the player to use <code>mediaElement</code> for all <code>load</code>\n   * requests until <code>detach</code> or <code>destroy</code> are called.\n   *\n   * <p>\n   * Calling <code>attach</code> with <code>initializedMediaSource=true</code>\n   * will tell the player to take the initial load step and initialize media\n   * source.\n   *\n   * <p>\n   * Calls to <code>attach</code> will interrupt any in-progress calls to\n   * <code>load</code> but cannot interrupt calls to <code>attach</code>,\n   * <code>detach</code>, or <code>unload</code>.\n   *\n   * @param {!HTMLMediaElement} mediaElement\n   * @param {boolean=} initializeMediaSource\n   * @return {!Promise}\n   * @export\n   */\n  attach(mediaElement, initializeMediaSource = true) {\n    // Do not allow the player to be used after |destroy| is called.\n    if (this.loadMode_ == shaka.Player.LoadMode.DESTROYED) {\n      return Promise.reject(this.createAbortLoadError_());\n    }\n\n    const payload = shaka.Player.createEmptyPayload_();\n    payload.mediaElement = mediaElement;\n\n    // If the platform does not support media source, we will never want to\n    // initialize media source.\n    if (!shaka.util.Platform.supportsMediaSource()) {\n      initializeMediaSource = false;\n    }\n\n    const destination = initializeMediaSource ?\n                        this.mediaSourceNode_ :\n                        this.attachNode_;\n\n    // Do not allow this route to be interrupted because calls after this attach\n    // call will depend on the media element being attached.\n    const events = this.walker_.startNewRoute((currentPayload) => {\n      return {\n        node: destination,\n        payload: payload,\n        interruptible: false,\n      };\n    });\n\n    // List to the events that can occur with our request.\n    events.onStart = () => shaka.log.info('Starting attach...');\n    return this.wrapWalkerListenersWithPromise_(events);\n  }\n\n  /**\n   * Tell the player to stop using its current media element. If the player is:\n   * <ul>\n   *  <li>detached, this will do nothing,\n   *  <li>attached, this will release the media element,\n   *  <li>loading, this will abort loading, unload, and release the media\n   *      element,\n   *  <li>playing content, this will stop playback, unload, and release the\n   *      media element.\n   * </ul>\n   *\n   * <p>\n   * Calls to <code>detach</code> will interrupt any in-progress calls to\n   * <code>load</code> but cannot interrupt calls to <code>attach</code>,\n   * <code>detach</code>, or <code>unload</code>.\n   *\n   * @return {!Promise}\n   * @export\n   */\n  detach() {\n    // Do not allow the player to be used after |destroy| is called.\n    if (this.loadMode_ == shaka.Player.LoadMode.DESTROYED) {\n      return Promise.reject(this.createAbortLoadError_());\n    }\n\n    // Tell the walker to go \"detached\", but do not allow it to be interrupted.\n    // If it could be interrupted it means that our media element could fall out\n    // of sync.\n    const events = this.walker_.startNewRoute((currentPayload) => {\n      return {\n        node: this.detachNode_,\n        payload: shaka.Player.createEmptyPayload_(),\n        interruptible: false,\n      };\n    });\n\n    events.onStart = () => shaka.log.info('Starting detach...');\n    return this.wrapWalkerListenersWithPromise_(events);\n  }\n\n  /**\n   * Tell the player to either return to:\n   * <ul>\n   *   <li>detached (when it does not have a media element),\n   *   <li>attached (when it has a media element and\n   *     <code>initializedMediaSource=false</code>)\n   *   <li>media source initialized (when it has a media element and\n   *     <code>initializedMediaSource=true</code>)\n   * </ul>\n   *\n   * <p>\n   * Calls to <code>unload</code> will interrupt any in-progress calls to\n   * <code>load</code> but cannot interrupt calls to <code>attach</code>,\n   * <code>detach</code>, or <code>unload</code>.\n   *\n   * @param {boolean=} initializeMediaSource\n   * @return {!Promise}\n   * @export\n   */\n  unload(initializeMediaSource = true) {\n    // Do not allow the player to be used after |destroy| is called.\n    if (this.loadMode_ == shaka.Player.LoadMode.DESTROYED) {\n      return Promise.reject(this.createAbortLoadError_());\n    }\n\n    // If the platform does not support media source, we will never want to\n    // initialize media source.\n    if (!shaka.util.Platform.supportsMediaSource()) {\n      initializeMediaSource = false;\n    }\n\n    // Since we are going either to attached or detached (through unloaded), we\n    // can't allow it to be interrupted or else we could lose track of what\n    // media element we are suppose to use.\n    //\n    // Using the current payload, we can determine which node we want to go to.\n    // If we have a media element, we want to go back to attached. If we have no\n    // media element, we want to go back to detached.\n    const payload = shaka.Player.createEmptyPayload_();\n\n    const events = this.walker_.startNewRoute((currentPayload) => {\n      // When someone calls |unload| we can either be before attached or\n      // detached (there is nothing stopping someone from calling |detach| when\n      // we are already detached).\n      //\n      // If we are attached to the correct element, we can tear down the\n      // previous playback components and go to the attached media source node\n      // depending on whether or not the caller wants to pre-init media source.\n      //\n      // If we don't have a media element, we assume that we are already at the\n      // detached node - but only the walker knows that. To ensure we are\n      // actually there, we tell the walker to go to detach. While this is\n      // technically unnecessary, it ensures that we are in the state we want\n      // to be in and ready for the next request.\n      let destination = null;\n\n      if (currentPayload.mediaElement && initializeMediaSource) {\n        destination = this.mediaSourceNode_;\n      } else if (currentPayload.mediaElement) {\n        destination = this.attachNode_;\n      } else {\n        destination = this.detachNode_;\n      }\n\n      goog.asserts.assert(destination, 'We should have picked a destination.');\n\n      // Copy over the media element because we want to keep using the same\n      // element - the other values don't matter.\n      payload.mediaElement = currentPayload.mediaElement;\n\n      return {\n        node: destination,\n        payload: payload,\n        interruptible: false,\n      };\n    });\n\n    events.onStart = () => shaka.log.info('Starting unload...');\n    return this.wrapWalkerListenersWithPromise_(events);\n  }\n\n  /**\n   * Tell the player to load the content at <code>assetUri</code> and start\n   * playback at <code>startTime</code>. Before calling <code>load</code>,\n   * a call to <code>attach</code> must have succeeded.\n   *\n   * <p>\n   * Calls to <code>load</code> will interrupt any in-progress calls to\n   * <code>load</code> but cannot interrupt calls to <code>attach</code>,\n   * <code>detach</code>, or <code>unload</code>.\n   *\n   * @param {string} assetUri\n   * @param {?number=} startTime\n   *    When <code>startTime</code> is <code>null</code> or\n   *    <code>undefined</code>, playback will start at the default start time (0\n   *    for VOD and liveEdge for LIVE).\n   * @param {string=} mimeType\n   * @return {!Promise}\n   * @export\n   */\n  load(assetUri, startTime, mimeType) {\n    // Do not allow the player to be used after |destroy| is called.\n    if (this.loadMode_ == shaka.Player.LoadMode.DESTROYED) {\n      return Promise.reject(this.createAbortLoadError_());\n    }\n\n    // We dispatch the loading event when someone calls |load| because we want\n    // to surface the user intent.\n    this.dispatchEvent(this.makeEvent_(shaka.Player.EventName.Loading));\n\n    // Right away we know what the asset uri and start-of-load time are. We will\n    // fill-in the rest of the information later.\n    const payload = shaka.Player.createEmptyPayload_();\n    payload.uri = assetUri;\n    payload.startTimeOfLoad = Date.now() / 1000;\n    if (mimeType) {\n      payload.mimeType = mimeType;\n    }\n\n    // Because we allow |startTime| to be optional, it means that it will be\n    // |undefined| when not provided. This means that we need to re-map\n    // |undefined| to |null| while preserving |0| as a meaningful value.\n    if (startTime !== undefined) {\n      payload.startTime = startTime;\n    }\n\n    // TODO: Refactor to determine whether it's a manifest or not, and whether\n    // or not we can play it.  Then we could return a better error than\n    // UNABLE_TO_GUESS_MANIFEST_TYPE for WebM in Safari.\n    const useSrcEquals = this.shouldUseSrcEquals_(payload);\n    const destination = useSrcEquals ? this.srcEqualsNode_ : this.loadNode_;\n\n    // Allow this request to be interrupted, this will allow other requests to\n    // cancel a load and quickly start a new load.\n    const events = this.walker_.startNewRoute((currentPayload) => {\n      if (currentPayload.mediaElement == null) {\n        // Because we return null, this \"new route\" will not be used.\n        return null;\n      }\n\n      // Keep using whatever media element we have right now.\n      payload.mediaElement = currentPayload.mediaElement;\n\n      return {\n        node: destination,\n        payload: payload,\n        interruptible: true,\n      };\n    });\n\n    // Stats are for a single playback/load session. Stats must be initialized\n    // before we allow calls to |updateStateHistory|.\n    this.stats_ = new shaka.util.Stats();\n\n    // Load's request is a little different, so we can't use our normal\n    // listeners-to-promise method. It is the only request where we may skip the\n    // request, so we need to set the on skip callback to reject with a specific\n    // error.\n    events.onStart =\n        () => shaka.log.info('Starting load of ' + assetUri + '...');\n    return new Promise((resolve, reject) => {\n      events.onSkip = () => reject(new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.PLAYER,\n          shaka.util.Error.Code.NO_VIDEO_ELEMENT));\n\n      events.onEnd = () => {\n        resolve();\n        // We dispatch the loaded event when the load promise is resolved\n        this.dispatchEvent(this.makeEvent_(shaka.Player.EventName.Loaded));\n      };\n      events.onCancel = () => reject(this.createAbortLoadError_());\n      events.onError = (e) => reject(e);\n    });\n  }\n\n  /**\n   * Check if src= should be used to load the asset at |uri|. Assume that media\n   * source is the default option, and that src= is for special cases.\n   *\n   * @param {shaka.routing.Payload} payload\n   * @return {boolean}\n   *    |true| if the content should be loaded with src=, |false| if the content\n   *    should be loaded with MediaSource.\n   * @private\n   */\n  shouldUseSrcEquals_(payload) {\n    const Platform = shaka.util.Platform;\n\n    // If we are using a platform that does not support media source, we will\n    // fall back to src= to handle all playback.\n    if (!Platform.supportsMediaSource()) {\n      return true;\n    }\n\n    // The most accurate way to tell the player how to load the content is via\n    // MIME type.  We can fall back to features of the URI if needed.\n    let mimeType = payload.mimeType;\n    const uri = payload.uri || '';\n\n    // If we don't have a MIME type, try to guess based on the file extension.\n    // TODO: Too generic to belong to ManifestParser now.  Refactor.\n    if (!mimeType) {\n      // Try using the uri extension.\n      const extension = shaka.media.ManifestParser.getExtension(uri);\n      mimeType = {\n        'mp4': 'video/mp4',\n        'm4v': 'video/mp4',\n        'm4a': 'audio/mp4',\n        'webm': 'video/webm',\n        'weba': 'audio/webm',\n        'mkv': 'video/webm', // Chromium browsers supports it.\n        'ts': 'video/mp2t',\n        'ogv': 'video/ogg',\n        'ogg': 'audio/ogg',\n        'mpg': 'video/mpeg',\n        'mpeg': 'video/mpeg',\n        'm3u8': 'application/x-mpegurl',\n        'mp3': 'audio/mpeg',\n        'aac': 'audio/aac',\n        'flac': 'audio/flac',\n        'wav': 'audio/wav',\n      }[extension];\n    }\n\n    // TODO: The load graph system has a design limitation that requires routing\n    // destination to be chosen synchronously.  This means we can only make the\n    // right choice about src= consistently if we have a well-known file\n    // extension or API-provided MIME type.  Detection of MIME type from a HEAD\n    // request (as is done for manifest types) can't be done yet.\n\n    if (mimeType) {\n      // If we have a MIME type, check if the browser can play it natively.\n      // This will cover both single files and native HLS.\n      const mediaElement = payload.mediaElement || Platform.anyMediaElement();\n      const canPlayNatively = mediaElement.canPlayType(mimeType) != '';\n\n      // If we can't play natively, then src= isn't an option.\n      if (!canPlayNatively) {\n        return false;\n      }\n\n      const canPlayMediaSource =\n          shaka.media.ManifestParser.isSupported(uri, mimeType);\n\n      // If MediaSource isn't an option, the native option is our only chance.\n      if (!canPlayMediaSource) {\n        return true;\n      }\n\n      // If we land here, both are feasible.\n      goog.asserts.assert(canPlayNatively && canPlayMediaSource,\n          'Both native and MSE playback should be possible!');\n\n      // We would prefer MediaSource in some cases, and src= in others.  For\n      // example, Android has native HLS, but we'd prefer our own MediaSource\n      // version there.  For Safari, the choice is governed by the\n      // useNativeHlsOnSafari setting of the streaming config.\n      return Platform.isApple() && this.config_.streaming.useNativeHlsOnSafari;\n    }\n\n    // Unless there are good reasons to use src= (single-file playback or native\n    // HLS), we prefer MediaSource.  So the final return value for choosing src=\n    // is false.\n    return false;\n  }\n\n  /**\n   * This should only be called by the load graph when it is time to attach to\n   * a media element. The only times this may be called are when we are being\n   * asked to re-attach to the current media element, or attach to a new media\n   * element while not attached to a media element.\n   *\n   * This method assumes that it is safe for it to execute, the load-graph is\n   * responsible for ensuring all assumptions are true.\n   *\n   * Attaching to a media element is defined as:\n   *  - Registering error listeners to the media element.\n   *  - Caching the video element for use outside of the load graph.\n   *\n   * @param {shaka.routing.Payload} has\n   * @param {shaka.routing.Payload} wants\n   * @return {!Promise}\n   * @private\n   */\n  onAttach_(has, wants) {\n    // If we don't have a media element yet, it means we are entering\n    // \"attach\" from another node.\n    //\n    // If we have a media element, it should match |wants.mediaElement|\n    // because it means we are going from \"attach\" to \"attach\".\n    //\n    // These constraints should be maintained and guaranteed by the routing\n    // logic in |getNextStep_|.\n    goog.asserts.assert(\n        has.mediaElement == null || has.mediaElement == wants.mediaElement,\n        'The routing logic failed. MediaElement requirement failed.');\n\n    if (has.mediaElement == null) {\n      has.mediaElement = wants.mediaElement;\n\n      const onError = (error) => this.onVideoError_(error);\n      this.eventManager_.listen(has.mediaElement, 'error', onError);\n    }\n\n    this.video_ = has.mediaElement;\n\n    return Promise.resolve();\n  }\n\n  /**\n   * This should only be called by the load graph when it is time to detach from\n   * a media element. The only times this may be called are when we are being\n   * asked to detach from the current media element, or detach when we are\n   * already detached.\n   *\n   * This method assumes that it is safe for it to execute, the load-graph is\n   * responsible for ensuring all assumptions are true.\n   *\n   * Detaching from a media element is defined as:\n   *  - Removing error listeners from the media element.\n   *  - Dropping the cached reference to the video element.\n   *\n   * @param {shaka.routing.Payload} has\n   * @param {shaka.routing.Payload} wants\n   * @return {!Promise}\n   * @private\n   */\n  onDetach_(has, wants) {\n    // If we are going from \"detached\" to \"detached\" we wouldn't have\n    // a media element to detach from.\n    if (has.mediaElement) {\n      this.eventManager_.unlisten(has.mediaElement, 'error');\n      has.mediaElement = null;\n    }\n\n    // Clear our cached copy of the media element.\n    this.video_ = null;\n\n    return Promise.resolve();\n  }\n\n  /**\n   * This should only be called by the load graph when it is time to unload all\n   * currently initialized playback components. Unlike the other load actions,\n   * this action is built to be more general. We need to do this because we\n   * don't know what state the player will be in before unloading (including\n   * after an error occurred in the middle of a transition).\n   *\n   * This method assumes that any component could be |null| and should be safe\n   * to call from any point in the load graph.\n   *\n   * @param {shaka.routing.Payload} has\n   * @param {shaka.routing.Payload} wants\n   * @return {!Promise}\n   * @private\n   */\n  async onUnload_(has, wants) {\n    // Set the load mode to unload right away so that all the public methods\n    // will stop using the internal components. We need to make sure that we\n    // are not overriding the destroyed state because we will unload when we are\n    // destroying the player.\n    if (this.loadMode_ != shaka.Player.LoadMode.DESTROYED) {\n      this.loadMode_ = shaka.Player.LoadMode.NOT_LOADED;\n    }\n\n    // Run any general cleanup tasks now.  This should be here at the top, right\n    // after setting loadMode_, so that internal components still exist as they\n    // did when the cleanup tasks were registered in the array.\n    const cleanupTasks = this.cleanupOnUnload_.map((cb) => cb());\n    this.cleanupOnUnload_ = [];\n    await Promise.all(cleanupTasks);\n\n    // Dispatch the unloading event.\n    this.dispatchEvent(this.makeEvent_(shaka.Player.EventName.Unloading));\n\n    // Remove everything that has to do with loading content from our payload\n    // since we are releasing everything that depended on it.\n    has.mimeType = null;\n    has.startTime = null;\n    has.uri = null;\n\n    // In most cases we should have a media element. The one exception would\n    // be if there was an error and we, by chance, did not have a media element.\n    if (has.mediaElement) {\n      this.eventManager_.unlisten(has.mediaElement, 'loadedmetadata');\n      this.eventManager_.unlisten(has.mediaElement, 'playing');\n      this.eventManager_.unlisten(has.mediaElement, 'pause');\n      this.eventManager_.unlisten(has.mediaElement, 'ended');\n      this.eventManager_.unlisten(has.mediaElement, 'ratechange');\n    }\n\n    // Some observers use some playback components, shutting down the observers\n    // first ensures that they don't try to use the playback components\n    // mid-destroy.\n    if (this.playheadObservers_) {\n      this.playheadObservers_.release();\n      this.playheadObservers_ = null;\n    }\n\n    if (this.bufferPoller_) {\n      this.bufferPoller_.stop();\n      this.bufferPoller_ = null;\n    }\n\n    // Stop the parser early. Since it is at the start of the pipeline, it\n    // should be start early to avoid is pushing new data downstream.\n    if (this.parser_) {\n      await this.parser_.stop();\n      this.parser_ = null;\n      this.parserFactory_ = null;\n    }\n\n    // Abr Manager will tell streaming engine what to do, so we need to stop\n    // it before we destroy streaming engine. Unlike with the other components,\n    // we do not release the instance, we will reuse it in later loads.\n    if (this.abrManager_) {\n      await this.abrManager_.stop();\n    }\n\n    // Streaming engine will push new data to media source engine, so we need\n    // to shut it down before destroy media source engine.\n    if (this.streamingEngine_) {\n      await this.streamingEngine_.destroy();\n      this.streamingEngine_ = null;\n    }\n\n    if (this.playRateController_) {\n      this.playRateController_.release();\n      this.playRateController_ = null;\n    }\n\n    // Playhead is used by StreamingEngine, so we can't destroy this until after\n    // StreamingEngine has stopped.\n    if (this.playhead_) {\n      this.playhead_.release();\n      this.playhead_ = null;\n    }\n\n    // Media source engine holds onto the media element, and in order to detach\n    // the media keys (with drm engine), we need to break the connection between\n    // media source engine and the media element.\n    if (this.mediaSourceEngine_) {\n      await this.mediaSourceEngine_.destroy();\n      this.mediaSourceEngine_ = null;\n    }\n\n    if (this.adManager_) {\n      this.adManager_.onAssetUnload();\n    }\n\n    // In order to unload a media element, we need to remove the src attribute\n    // and then load again. When we destroy media source engine, this will be\n    // done for us, but for src=, we need to do it here.\n    //\n    // DrmEngine requires this to be done before we destroy DrmEngine itself.\n    if (has.mediaElement && has.mediaElement.src) {\n      // TODO: Investigate this more.  Only reproduces on Firefox 69.\n      // Introduce a delay before detaching the video source.  We are seeing\n      // spurious Promise rejections involving an AbortError in our tests\n      // otherwise.\n      await new Promise(\n          (resolve) => new shaka.util.Timer(resolve).tickAfter(0.1));\n\n      has.mediaElement.removeAttribute('src');\n      has.mediaElement.load();\n    }\n\n    if (this.drmEngine_) {\n      await this.drmEngine_.destroy();\n      this.drmEngine_ = null;\n    }\n\n    this.assetUri_ = null;\n    this.bufferObserver_ = null;\n\n    if (this.manifest_) {\n      for (const variant of this.manifest_.variants) {\n        for (const stream of [variant.audio, variant.video]) {\n          if (stream && stream.segmentIndex) {\n            stream.segmentIndex.release();\n          }\n        }\n      }\n      for (const stream of this.manifest_.textStreams) {\n        if (stream.segmentIndex) {\n          stream.segmentIndex.release();\n        }\n      }\n    }\n\n    this.manifest_ = null;\n    this.stats_ = new shaka.util.Stats(); // Replace with a clean stats object.\n    this.lastTextFactory_ = null;\n\n    // Make sure that the app knows of the new buffering state.\n    this.updateBufferState_();\n  }\n\n  /**\n   * This should only be called by the load graph when it is time to initialize\n   * media source engine. The only time this may be called is when we are\n   * attached to the same media element as in the request.\n   *\n   * This method assumes that it is safe for it to execute. The load-graph is\n   * responsible for ensuring all assumptions are true.\n   *\n   * @param {shaka.routing.Payload} has\n   * @param {shaka.routing.Payload} wants\n   *\n   * @return {!Promise}\n   * @private\n   */\n  async onInitializeMediaSourceEngine_(has, wants) {\n    goog.asserts.assert(\n        shaka.util.Platform.supportsMediaSource(),\n        'We should not be initializing media source on a platform that does ' +\n            'not support media source.');\n    goog.asserts.assert(\n        has.mediaElement,\n        'We should have a media element when initializing media source.');\n    goog.asserts.assert(\n        has.mediaElement == wants.mediaElement,\n        '|has| and |wants| should have the same media element when ' +\n            'initializing media source.');\n\n    goog.asserts.assert(\n        this.mediaSourceEngine_ == null,\n        'We should not have a media source engine yet.');\n\n    const closedCaptionsParser =\n        shaka.media.MuxJSClosedCaptionParser.isSupported() ?\n        new shaka.media.MuxJSClosedCaptionParser() :\n        new shaka.media.NoopCaptionParser();\n\n    // When changing text visibility we need to update both the text displayer\n    // and streaming engine because we don't always stream text. To ensure that\n    // text displayer and streaming engine are always in sync, wait until they\n    // are both initialized before setting the initial value.\n    const textDisplayerFactory = this.config_.textDisplayFactory;\n    const textDisplayer =\n        shaka.util.Functional.callFactory(textDisplayerFactory);\n    this.lastTextFactory_ = textDisplayerFactory;\n\n    const mediaSourceEngine = this.createMediaSourceEngine(\n        has.mediaElement,\n        closedCaptionsParser,\n        textDisplayer,\n        (metadata, offset, endTime) => {\n          this.processTimedMetadataMediaSrc_(metadata, offset, endTime);\n        });\n\n    // Wait for media source engine to finish opening. This promise should\n    // NEVER be rejected as per the media source engine implementation.\n    await mediaSourceEngine.open();\n\n    // Wait until it is ready to actually store the reference.\n    this.mediaSourceEngine_ = mediaSourceEngine;\n  }\n\n  /**\n   * Create the parser for the asset located at |wants.uri|. This should only be\n   * called as part of the load graph.\n   *\n   * This method assumes that it is safe for it to execute, the load-graph is\n   * responsible for ensuring all assumptions are true.\n   *\n   * @param {shaka.routing.Payload} has\n   * @param {shaka.routing.Payload} wants\n   * @return {!Promise}\n   * @private\n   */\n  async onInitializeParser_(has, wants) {\n    goog.asserts.assert(\n        has.mediaElement,\n        'We should have a media element when initializing the parser.');\n    goog.asserts.assert(\n        has.mediaElement == wants.mediaElement,\n        '|has| and |wants| should have the same media element when ' +\n            'initializing the parser.');\n\n    goog.asserts.assert(\n        this.networkingEngine_,\n        'Need networking engine when initializing the parser.');\n    goog.asserts.assert(\n        this.config_,\n        'Need player config when initializing the parser.');\n\n    // We are going to \"lock-in\" the mime type and uri since they are\n    // what we are going to use to create our parser and parse the manifest.\n    has.mimeType = wants.mimeType;\n    has.uri = wants.uri;\n\n    goog.asserts.assert(\n        has.uri,\n        'We should have an asset uri when initializing the parsing.');\n\n    // Store references to things we asserted so that we don't need to reassert\n    // them again later.\n    const assetUri = has.uri;\n    const networkingEngine = this.networkingEngine_;\n\n    // Save the uri so that it can be used outside of the load-graph.\n    this.assetUri_ = assetUri;\n\n    // Create the parser that we will use to parse the manifest.\n    this.parserFactory_ = await shaka.media.ManifestParser.getFactory(\n        assetUri,\n        networkingEngine,\n        this.config_.manifest.retryParameters,\n        has.mimeType);\n    goog.asserts.assert(this.parserFactory_, 'Must have manifest parser');\n    this.parser_ = shaka.util.Functional.callFactory(this.parserFactory_);\n\n    const manifestConfig =\n        shaka.util.ObjectUtils.cloneObject(this.config_.manifest);\n    // Don't read video segments if the player is attached to an audio element\n    if (wants.mediaElement && wants.mediaElement.nodeName === 'AUDIO') {\n      manifestConfig.disableVideo = true;\n    }\n\n    this.parser_.configure(manifestConfig);\n  }\n\n  /**\n   * Parse the manifest at |has.uri| using the parser that should have already\n   * been created. This should only be called as part of the load graph.\n   *\n   * This method assumes that it is safe for it to execute, the load-graph is\n   * responsible for ensuring all assumptions are true.\n   *\n   * @param {shaka.routing.Payload} has\n   * @param {shaka.routing.Payload} wants\n   * @return {!shaka.util.AbortableOperation}\n   * @private\n   */\n  onParseManifest_(has, wants) {\n    goog.asserts.assert(\n        has.mimeType == wants.mimeType,\n        '|has| and |wants| should have the same mime type when parsing.');\n    goog.asserts.assert(\n        has.uri == wants.uri,\n        '|has| and |wants| should have the same uri when parsing.');\n\n    goog.asserts.assert(\n        has.uri,\n        '|has| should have a valid uri when parsing.');\n    goog.asserts.assert(\n        has.uri == this.assetUri_,\n        '|has.uri| should match the cached asset uri.');\n\n    goog.asserts.assert(\n        this.networkingEngine_,\n        'Need networking engine to parse manifest.');\n    goog.asserts.assert(\n        this.config_,\n        'Need player config to parse manifest.');\n\n    goog.asserts.assert(\n        this.parser_,\n        '|this.parser_| should have been set in an earlier step.');\n\n    // Store references to things we asserted so that we don't need to reassert\n    // them again later.\n    const assetUri = has.uri;\n    const networkingEngine = this.networkingEngine_;\n\n    // This will be needed by the parser once it starts parsing, so we will\n    // initialize it now even through it appears a little out-of-place.\n    this.regionTimeline_ =\n        new shaka.media.RegionTimeline(() => this.seekRange());\n    this.regionTimeline_.setListeners(/* onRegionAdded= */ (region) => {\n      this.onRegionEvent_(shaka.Player.EventName.TimelineRegionAdded, region);\n      if (this.adManager_) {\n        this.adManager_.onDashTimedMetadata(region);\n      }\n    });\n\n    // TODO (#1391): Once filterManifest_ is async, remove this eslint disable.\n    /* eslint-disable require-await */\n    const playerInterface = {\n      networkingEngine: networkingEngine,\n      filter: async (manifest) => this.filterManifest_(manifest),\n      makeTextStreamsForClosedCaptions: (manifest) => {\n        return this.makeTextStreamsForClosedCaptions_(manifest);\n      },\n\n      // Called when the parser finds a timeline region. This can be called\n      // before we start playback or during playback (live/in-progress\n      // manifest).\n      onTimelineRegionAdded: (region) => this.regionTimeline_.addRegion(region),\n\n      onEvent: (event) => this.dispatchEvent(event),\n      onError: (error) => this.onError_(error),\n    };\n    /* eslint-enable require-await */\n\n    const startTime = Date.now() / 1000;\n\n    return new shaka.util.AbortableOperation(/* promise= */ (async () => {\n      this.manifest_ = await this.parser_.start(assetUri, playerInterface);\n\n      // This event is fired after the manifest is parsed, but before any\n      // filtering takes place.\n      const event = this.makeEvent_(shaka.Player.EventName.ManifestParsed);\n      this.dispatchEvent(event);\n\n      // We require all manifests to have at least one variant.\n      if (this.manifest_.variants.length == 0) {\n        throw new shaka.util.Error(\n            shaka.util.Error.Severity.CRITICAL,\n            shaka.util.Error.Category.MANIFEST,\n            shaka.util.Error.Code.NO_VARIANTS);\n      }\n\n      // Make sure that all variants are either: audio-only, video-only, or\n      // audio-video.\n      shaka.Player.filterForAVVariants_(this.manifest_);\n\n      const now = Date.now() / 1000;\n      const delta = now - startTime;\n      this.stats_.setManifestTime(delta);\n    })(), /* onAbort= */ () => {\n      shaka.log.info('Aborting parser step...');\n      return this.parser_.stop();\n    });\n  }\n\n  /**\n   * This should only be called by the load graph when it is time to initialize\n   * drmEngine. The only time this may be called is when we are attached a\n   * media element and have parsed a manifest.\n   *\n   * The load-graph is responsible for ensuring all assumptions made by this\n   * method are valid before executing it.\n   *\n   * @param {shaka.routing.Payload} has\n   * @param {shaka.routing.Payload} wants\n   * @return {!Promise}\n   * @private\n   */\n  async onInitializeDrm_(has, wants) {\n    goog.asserts.assert(\n        has.mimeType == wants.mimeType,\n        'The load graph should have ensured the mime types matched.');\n    goog.asserts.assert(\n        has.uri == wants.uri,\n        'The load graph should have ensured the uris matched');\n\n    goog.asserts.assert(\n        this.networkingEngine_,\n        '|onInitializeDrm_| should never be called after |destroy|');\n    goog.asserts.assert(\n        this.config_,\n        '|onInitializeDrm_| should never be called after |destroy|');\n    goog.asserts.assert(\n        this.manifest_,\n        '|this.manifest_| should have been set in an earlier step.');\n\n    const startTime = Date.now() / 1000;\n    let firstEvent = true;\n\n    this.drmEngine_ = this.createDrmEngine({\n      netEngine: this.networkingEngine_,\n      onError: (e) => {\n        this.onError_(e);\n      },\n      onKeyStatus: (map) => {\n        this.onKeyStatus_(map);\n      },\n      onExpirationUpdated: (id, expiration) => {\n        this.onExpirationUpdated_(id, expiration);\n      },\n      onEvent: (e) => {\n        this.dispatchEvent(e);\n        if (e.type == shaka.Player.EventName.DrmSessionUpdate && firstEvent) {\n          firstEvent = false;\n          const now = Date.now() / 1000;\n          const delta = now - startTime;\n          this.stats_.setDrmTime(delta);\n        }\n      },\n    });\n\n    this.drmEngine_.configure(this.config_.drm);\n\n    await this.drmEngine_.initForPlayback(\n        this.manifest_.variants,\n        this.manifest_.offlineSessionIds);\n\n    // Now that we have drm information, filter the manifest (again) so that we\n    // can ensure we only use variants with the selected key system.\n    this.filterManifest_(this.manifest_);\n  }\n\n  /**\n   * This should only be called by the load graph when it is time to load all\n   * playback components needed for playback. The only times this may be called\n   * is when we are attached to the same media element as in the request.\n   *\n   * This method assumes that it is safe for it to execute, the load-graph is\n   * responsible for ensuring all assumptions are true.\n   *\n   * Loading is defined as:\n   *  - Attaching all playback-related listeners to the media element\n   *  - Initializing playback and observers\n   *  - Initializing ABR Manager\n   *  - Initializing Streaming Engine\n   *  - Starting playback at |wants.startTime|\n   *\n   * @param {shaka.routing.Payload} has\n   * @param {shaka.routing.Payload} wants\n   * @private\n   */\n  async onLoad_(has, wants) {\n    goog.asserts.assert(\n        has.mimeType == wants.mimeType,\n        '|has| and |wants| should have the same mime type when loading.');\n    goog.asserts.assert(\n        has.uri == wants.uri,\n        '|has| and |wants| should have the same uri when loading.');\n\n    goog.asserts.assert(\n        has.mediaElement,\n        'We should have a media element when loading.');\n    goog.asserts.assert(\n        !isNaN(wants.startTimeOfLoad),\n        '|wants| should tell us when the load was originally requested');\n\n    // Since we are about to start playback, we will lock in the start time as\n    // something we are now depending on.\n    has.startTime = wants.startTime;\n\n    // Store a reference to values in |has| after asserting so that closure will\n    // know that they will still be non-null between calls to await.\n    const mediaElement = has.mediaElement;\n    const assetUri = has.uri;\n\n    // Save the uri so that it can be used outside of the load-graph.\n    this.assetUri_ = assetUri;\n\n    this.playRateController_ = new shaka.media.PlayRateController({\n      getRate: () => has.mediaElement.playbackRate,\n      setRate: (rate) => { has.mediaElement.playbackRate = rate; },\n      movePlayhead: (delta) => { has.mediaElement.currentTime += delta; },\n    });\n\n    const updateStateHistory = () => this.updateStateHistory_();\n    const onRateChange = () => this.onRateChange_();\n    this.eventManager_.listen(mediaElement, 'playing', updateStateHistory);\n    this.eventManager_.listen(mediaElement, 'pause', updateStateHistory);\n    this.eventManager_.listen(mediaElement, 'ended', updateStateHistory);\n    this.eventManager_.listen(mediaElement, 'ratechange', onRateChange);\n\n    const abrFactory = this.config_.abrFactory;\n    if (!this.abrManager_ || this.abrManagerFactory_ != abrFactory) {\n      this.abrManagerFactory_ = abrFactory;\n      this.abrManager_ = shaka.util.Functional.callFactory(abrFactory);\n      if (typeof this.abrManager_.playbackRateChanged != 'function') {\n        shaka.Deprecate.deprecateFeature(4,\n            'AbrManager',\n            'Please use an AbrManager with playbackRateChanged function.');\n        this.abrManager_.playbackRateChanged = (rate) => {};\n      }\n      this.abrManager_.configure(this.config_.abr);\n    }\n\n    // Copy preferred languages from the config again, in case the config was\n    // changed between construction and playback.\n    this.currentAdaptationSetCriteria_ =\n        new shaka.media.PreferenceBasedCriteria(\n            this.config_.preferredAudioLanguage,\n            this.config_.preferredVariantRole,\n            this.config_.preferredAudioChannelCount);\n\n    this.currentTextLanguage_ = this.config_.preferredTextLanguage;\n\n    shaka.Player.applyPlayRange_(this.manifest_.presentationTimeline,\n        this.config_.playRangeStart,\n        this.config_.playRangeEnd);\n\n    await this.drmEngine_.attach(mediaElement);\n\n    this.abrManager_.init((variant, clearBuffer, safeMargin) => {\n      return this.switch_(variant, clearBuffer, safeMargin);\n    });\n\n    this.playhead_ = this.createPlayhead(has.startTime);\n    this.playheadObservers_ = this.createPlayheadObserversForMSE_();\n\n    // We need to start the buffer management code near the end because it will\n    // set the initial buffering state and that depends on other components\n    // being initialized.\n    const rebufferThreshold = Math.max(\n        this.manifest_.minBufferTime, this.config_.streaming.rebufferingGoal);\n    this.startBufferManagement_(rebufferThreshold);\n\n    // If the content is multi-codec and the browser can play more than one of\n    // them, choose codecs now before we initialize streaming.\n    shaka.util.StreamUtils.chooseCodecsAndFilterManifest(\n        this.manifest_, this.config_.preferredAudioChannelCount);\n\n    this.streamingEngine_ = this.createStreamingEngine();\n    this.streamingEngine_.configure(this.config_.streaming);\n\n    // Set the load mode to \"loaded with media source\" as late as possible so\n    // that public methods won't try to access internal components until\n    // they're all initialized. We MUST switch to loaded before calling\n    // \"streaming\" so that they can access internal information.\n    this.loadMode_ = shaka.Player.LoadMode.MEDIA_SOURCE;\n\n    // The event must be fired after we filter by restrictions but before the\n    // active stream is picked to allow those listening for the \"streaming\"\n    // event to make changes before streaming starts.\n    this.dispatchEvent(this.makeEvent_(shaka.Player.EventName.Streaming));\n\n    // Pick the initial streams to play.\n    const initialVariant = this.chooseVariant_();\n    goog.asserts.assert(initialVariant, 'Must choose an initial variant!');\n    this.addVariantToSwitchHistory_(\n        initialVariant, /* fromAdaptation= */ true);\n    this.streamingEngine_.switchVariant(\n        initialVariant, /* clearBuffer= */ false, /* safeMargin= */ 0);\n\n    // Decide if text should be shown automatically.\n    const initialTextStream = this.chooseTextStream_();\n    if (initialTextStream) {\n      this.addTextStreamToSwitchHistory_(\n          initialTextStream, /* fromAdaptation= */ true);\n    }\n\n    this.setInitialTextState_(initialVariant, initialTextStream);\n    // Don't initialize with a text stream unless we should be streaming text.\n    if (initialTextStream && this.shouldStreamText_()) {\n      this.streamingEngine_.switchTextStream(initialTextStream);\n    }\n\n    // Now that we have initial streams, we may adjust the start time to align\n    // to a segment boundary.\n    if (this.config_.streaming.startAtSegmentBoundary) {\n      const startTime = this.playhead_.getTime();\n      const adjustedTime =\n          await this.adjustStartTime_(initialVariant, startTime);\n\n      this.playhead_.setStartTime(adjustedTime);\n    }\n\n    // Start streaming content. This will start the flow of content down to\n    // media source.\n    await this.streamingEngine_.start();\n\n    if (this.config_.abr.enabled) {\n      this.abrManager_.enable();\n      this.onAbrStatusChanged_();\n    }\n\n    // Re-filter the manifest after streams have been chosen.\n    this.filterManifest_(this.manifest_);\n    // Dispatch a 'trackschanged' event now that all initial filtering is done.\n    this.onTracksChanged_();\n    // Since the first streams just became active, send an adaptation event.\n    this.onAdaptation_();\n\n    // Now that we've filtered out variants that aren't compatible with the\n    // active one, update abr manager with filtered variants.\n    // NOTE: This may be unnecessary.  We've already chosen one codec in\n    // chooseCodecsAndFilterManifest_ before we started streaming.  But it\n    // doesn't hurt, and this will all change when we start using\n    // MediaCapabilities and codec switching.\n    // TODO(#1391): Re-evaluate with MediaCapabilities and codec switching.\n    this.updateAbrManagerVariants_();\n\n    const hasPrimary = this.manifest_.variants.some((v) => v.primary);\n    if (!this.config_.preferredAudioLanguage && !hasPrimary) {\n      shaka.log.warning('No preferred audio language set.  We have chosen an ' +\n                        'arbitrary language initially');\n    }\n\n    // Wait for the 'loadedmetadata' event to measure load() latency.\n    this.eventManager_.listenOnce(mediaElement, 'loadedmetadata', () => {\n      const now = Date.now() / 1000;\n      const delta = now - wants.startTimeOfLoad;\n      this.stats_.setLoadLatency(delta);\n    });\n  }\n\n  /**\n   * This should only be called by the load graph when it is time to initialize\n   * drmEngine for src= playbacks.\n   *\n   * The load-graph is responsible for ensuring all assumptions made by this\n   * method are valid before executing it.\n   *\n   * @param {shaka.routing.Payload} has\n   * @param {shaka.routing.Payload} wants\n   * @return {!Promise}\n   * @private\n   */\n  async onInitializeSrcEqualsDrm_(has, wants) {\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n\n    goog.asserts.assert(\n        this.networkingEngine_,\n        '|onInitializeSrcEqualsDrm_| should never be called after |destroy|');\n    goog.asserts.assert(\n        this.config_,\n        '|onInitializeSrcEqualsDrm_| should never be called after |destroy|');\n\n    const startTime = Date.now() / 1000;\n    let firstEvent = true;\n\n    this.drmEngine_ = this.createDrmEngine({\n      netEngine: this.networkingEngine_,\n      onError: (e) => {\n        this.onError_(e);\n      },\n      onKeyStatus: (map) => {\n        this.onKeyStatus_(map);\n      },\n      onExpirationUpdated: (id, expiration) => {\n        this.onExpirationUpdated_(id, expiration);\n      },\n      onEvent: (e) => {\n        this.dispatchEvent(e);\n        if (e.type == shaka.Player.EventName.DrmSessionUpdate && firstEvent) {\n          firstEvent = false;\n          const now = Date.now() / 1000;\n          const delta = now - startTime;\n          this.stats_.setDrmTime(delta);\n        }\n      },\n    });\n\n    this.drmEngine_.configure(this.config_.drm);\n\n    // TODO: Instead of feeding DrmEngine with Variants, we should refactor\n    // DrmEngine so that it takes a minimal config derived from Variants.  In\n    // cases like this one or in removal of stored content, the details are\n    // largely unimportant.  We should have a saner way to initialize DrmEngine.\n    // That would also insulate DrmEngine from manifest changes in the future.\n    // For now, that is time-consuming and this synthetic Variant is easy, so\n    // I'm putting it off.  Since this is only expected to be used for native\n    // HLS in Safari, this should be safe. -JCP\n    /** @type {shaka.extern.Variant} */\n    const variant = {\n      id: 0,\n      language: 'und',\n      primary: false,\n      audio: null,\n      video: {\n        id: 0,\n        originalId: null,\n        createSegmentIndex: () => Promise.resolve(),\n        segmentIndex: null,\n        mimeType: 'video/mp4',\n        codecs: '',\n        encrypted: true,\n        drmInfos: [],  // Filled in by DrmEngine config.\n        keyIds: new Set(),\n        language: 'und',\n        label: null,\n        type: ContentType.VIDEO,\n        primary: false,\n        trickModeVideo: null,\n        emsgSchemeIdUris: null,\n        roles: [],\n        channelsCount: null,\n        audioSamplingRate: null,\n        closedCaptions: null,\n      },\n      bandwidth: 100,\n      allowedByApplication: true,\n      allowedByKeySystem: true,\n    };\n\n    await this.drmEngine_.initForPlayback(\n        [variant], /* offlineSessionIds= */ []);\n    await this.drmEngine_.attach(has.mediaElement);\n  }\n\n  /**\n   * This should only be called by the load graph when it is time to set-up the\n   * media element to play content using src=. The only times this may be called\n   * is when we are attached to the same media element as in the request.\n   *\n   * This method assumes that it is safe for it to execute, the load-graph is\n   * responsible for ensuring all assumptions are true.\n   *\n   * @param {shaka.routing.Payload} has\n   * @param {shaka.routing.Payload} wants\n   * @return {!shaka.util.AbortableOperation}\n   *\n   * @private\n   */\n  onSrcEquals_(has, wants) {\n    goog.asserts.assert(\n        has.mediaElement,\n        'We should have a media element when loading.');\n    goog.asserts.assert(\n        wants.uri,\n        '|has| should have a valid uri when loading.');\n    goog.asserts.assert(\n        !isNaN(wants.startTimeOfLoad),\n        '|wants| should tell us when the load was originally requested');\n    goog.asserts.assert(\n        this.video_ == has.mediaElement,\n        'The video element should match our media element');\n\n    // Lock-in the values that we are using so that the routing logic knows what\n    // we have.\n    has.uri = wants.uri;\n    has.startTime = wants.startTime;\n\n    // Save the uri so that it can be used outside of the load-graph.\n    this.assetUri_ = has.uri;\n\n    this.playhead_ = new shaka.media.SrcEqualsPlayhead(has.mediaElement);\n\n    if (has.startTime != null) {\n      this.playhead_.setStartTime(has.startTime);\n    }\n\n    this.playRateController_ = new shaka.media.PlayRateController({\n      getRate: () => has.mediaElement.playbackRate,\n      setRate: (rate) => { has.mediaElement.playbackRate = rate; },\n      movePlayhead: (delta) => { has.mediaElement.currentTime += delta; },\n    });\n\n    // We need to start the buffer management code near the end because it will\n    // set the initial buffering state and that depends on other components\n    // being initialized.\n    const rebufferThreshold = this.config_.streaming.rebufferingGoal;\n    this.startBufferManagement_(rebufferThreshold);\n\n    // Add all media element listeners.\n    const updateStateHistory = () => this.updateStateHistory_();\n    const onRateChange = () => this.onRateChange_();\n    this.eventManager_.listen(has.mediaElement, 'playing', updateStateHistory);\n    this.eventManager_.listen(has.mediaElement, 'pause', updateStateHistory);\n    this.eventManager_.listen(has.mediaElement, 'ended', updateStateHistory);\n    this.eventManager_.listen(has.mediaElement, 'ratechange', onRateChange);\n\n    // Wait for the 'loadedmetadata' event to measure load() latency, but only\n    // if preload is set in a way that would result in this event firing\n    // automatically.  See https://github.com/google/shaka-player/issues/2483\n    if (this.video_.preload != 'none') {\n      this.eventManager_.listenOnce(this.video_, 'loadedmetadata', () => {\n        const now = Date.now() / 1000;\n        const delta = now - wants.startTimeOfLoad;\n        this.stats_.setLoadLatency(delta);\n      });\n    }\n\n    // The audio tracks are only available on Safari at the moment, but this\n    // drives the tracks API for Safari's native HLS. So when they change,\n    // fire the corresponding Shaka Player event.\n    if (this.video_.audioTracks) {\n      this.eventManager_.listen(\n          this.video_.audioTracks, 'addtrack', () => this.onTracksChanged_());\n      this.eventManager_.listen(\n          this.video_.audioTracks, 'removetrack',\n          () => this.onTracksChanged_());\n      this.eventManager_.listen(\n          this.video_.audioTracks, 'change', () => this.onTracksChanged_());\n    }\n    if (this.video_.textTracks) {\n      this.eventManager_.listen(this.video_.textTracks, 'addtrack', (e) => {\n        this.onTracksChanged_();\n        this.processTimedMetadataSrcEqls_(/** @type {!TrackEvent} */(e));\n      });\n      this.eventManager_.listen(\n          this.video_.textTracks, 'removetrack', () => this.onTracksChanged_());\n      this.eventManager_.listen(\n          this.video_.textTracks, 'change', () => this.onTracksChanged_());\n    }\n\n    // By setting |src| we are done \"loading\" with src=. We don't need to set\n    // the current time because |playhead| will do that for us.\n    has.mediaElement.src = has.uri;\n\n    // Tizen 3 / WebOS won't load anything unless you call load() explicitly,\n    // no matter the value of the preload attribute.  This is harmful on some\n    // other platforms by triggering unbounded loading of media data, but is\n    // necessary here.\n    if (shaka.util.Platform.isTizen() || shaka.util.Platform.isWebOS()) {\n      has.mediaElement.load();\n    }\n\n    // Set the load mode last so that we know that all our components are\n    // initialized.\n    this.loadMode_ = shaka.Player.LoadMode.SRC_EQUALS;\n\n    // The event doesn't mean as much for src= playback, since we don't control\n    // streaming.  But we should fire it in this path anyway since some\n    // applications may be expecting it as a life-cycle event.\n    this.dispatchEvent(this.makeEvent_(shaka.Player.EventName.Streaming));\n\n    // The \"load\" Promise is resolved when we have loaded the metadata.  If we\n    // wait for the full data, that won't happen on Safari until the play button\n    // is hit.\n    const fullyLoaded = new shaka.util.PublicPromise();\n    shaka.util.MediaReadyState.waitForReadyState(this.video_,\n        HTMLMediaElement.HAVE_METADATA,\n        this.eventManager_,\n        () => {\n          fullyLoaded.resolve();\n        });\n\n    // This flag is used below in the language preference setup to check if this\n    // load was canceled before the necessary events fire.\n    let unloaded = false;\n    this.cleanupOnUnload_.push(() => {\n      unloaded = true;\n    });\n\n    // We can't switch to preferred languages, though, until the data is loaded.\n    shaka.util.MediaReadyState.waitForReadyState(this.video_,\n        HTMLMediaElement.HAVE_CURRENT_DATA,\n        this.eventManager_,\n        async () => {\n          // If we have moved on to another piece of content while waiting for\n          // the above event, we should not change tracks here.\n          if (unloaded) {\n            return;\n          }\n\n          this.setupPreferredAudioOnSrc_();\n\n          // Applying the text preference too soon can result in it being\n          // reverted.  Wait for native HLS to pick something first.\n          const textTracks = this.getFilteredTextTracks_();\n          if (!textTracks.find((t) => t.mode != 'disabled')) {\n            await new Promise((resolve) => {\n              this.eventManager_.listenOnce(\n                  this.video_.textTracks, 'change', resolve);\n              // We expect the event to fire because it does on Safari.\n              // But in case it doesn't on some other platform or future\n              // version, move on in 1 second no matter what.  This keeps the\n              // language settings from being completely ignored if something\n              // goes wrong.\n              new shaka.util.Timer(resolve).tickAfter(1);\n            });\n          }\n\n          // If we have moved on to another piece of content while waiting for\n          // the above event/timer, we should not change tracks here.\n          if (unloaded) {\n            return;\n          }\n\n          this.setupPreferredTextOnSrc_();\n        });\n\n    if (this.video_.error) {\n      // Already failed!\n      fullyLoaded.reject(this.videoErrorToShakaError_());\n    } else if (this.video_.preload == 'none') {\n      shaka.log.alwaysWarn(\n          'With <video preload=\"none\">, the browser will not load anything ' +\n          'until play() is called. We are unable to measure load latency in ' +\n          'a meaningful way, and we cannot provide track info yet. Please do ' +\n          'not use preload=\"none\" with Shaka Player.');\n      // We can't wait for an event load loadedmetadata, since that will be\n      // blocked until a user interaction.  So resolve the Promise now.\n      fullyLoaded.resolve();\n    }\n\n    this.eventManager_.listenOnce(this.video_, 'error', () => {\n      fullyLoaded.reject(this.videoErrorToShakaError_());\n    });\n\n    return new shaka.util.AbortableOperation(fullyLoaded, /* onAbort= */ () => {\n      const abortedError = new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.PLAYER,\n          shaka.util.Error.Code.OPERATION_ABORTED);\n      fullyLoaded.reject(abortedError);\n      return Promise.resolve();  // Abort complete.\n    });\n  }\n\n  /**\n   * This method setup the preferred audio using src=..\n   *\n   * @private\n   */\n  setupPreferredAudioOnSrc_() {\n    const preferredAudioLanguage = this.config_.preferredAudioLanguage;\n\n    // If the user has not selected a preference, the browser preference is\n    // left.\n    if (preferredAudioLanguage == '') {\n      return;\n    }\n\n    this.selectAudioLanguage(preferredAudioLanguage);\n\n    const preferredVariantRole = this.config_.preferredVariantRole;\n\n    // If the user has not selected a role preference, the previous match is\n    // selected.\n    if (preferredVariantRole == '') {\n      return;\n    }\n\n    this.selectAudioLanguage(preferredAudioLanguage, preferredVariantRole);\n  }\n\n  /**\n   * This method setup the preferred text using src=.\n   *\n   * @private\n   */\n  setupPreferredTextOnSrc_() {\n    const preferredTextLanguage = this.config_.preferredTextLanguage;\n\n    // If the user has not selected a preference, the browser preference is\n    // left.\n    if (preferredTextLanguage == '') {\n      return;\n    }\n\n    this.selectTextLanguage(preferredTextLanguage);\n\n    const preferredTextRole = this.config_.preferredTextRole;\n\n    // If the user has not selected a role preference, the previous match is\n    // selected.\n    if (preferredTextRole == '') {\n      return;\n    }\n\n    this.selectTextLanguage(preferredTextLanguage, preferredTextRole);\n  }\n\n  /**\n   * We're looking for metadata tracks to process id3 tags. One of the uses is\n   * for ad info on LIVE streams\n   *\n   * @param {!TrackEvent} event\n   * @private\n   */\n  processTimedMetadataSrcEqls_(event) {\n    const track = event.track;\n    goog.asserts.assert(track instanceof TextTrack, 'Wrong track type!');\n\n    if (track.kind != 'metadata') {\n      return;\n    }\n\n    // Hidden mode is required for the cuechange event to launch correctly\n    track.mode = 'hidden';\n    this.eventManager_.listen(track, 'cuechange', () => {\n      if (!track.activeCues) {\n        return;\n      }\n\n      for (const cue of track.activeCues) {\n        this.dispatchMetadataEvent_(cue.startTime, cue.endTime,\n            cue.type, cue.value);\n\n        if (this.adManager_) {\n          this.adManager_.onCueMetadataChange(cue.value);\n        }\n      }\n    });\n\n    // In Safari the initial assignment does not always work, so we schedule\n    // this process to be repeated several times to ensure that it has been put\n    // in the correct mode.\n    new shaka.util.Timer(() => {\n      const textTracks = this.getMetadataTracks_();\n      for (const textTrack of textTracks) {\n        textTrack.mode = 'hidden';\n      }\n    }).tickNow().tickAfter(/* seconds= */ 0.5);\n  }\n\n\n  /**\n   * @param {!Array.<shaka.extern.ID3Metadata>} metadata\n   * @param {number} offset\n   * @param {?number} segmentEndTime\n   * @private\n   */\n  processTimedMetadataMediaSrc_(metadata, offset, segmentEndTime) {\n    for (const sample of metadata) {\n      if (sample['data'] && sample['cueTime'] && sample['frames']) {\n        const start = sample['cueTime'] + offset;\n        const end = segmentEndTime;\n        const metadataType = 'ID3';\n        for (const frame of sample['frames']) {\n          const payload = frame;\n          this.dispatchMetadataEvent_(start, end, metadataType, payload);\n        }\n\n        if (this.adManager_) {\n          this.adManager_.onHlsTimedMetadata(sample, start);\n        }\n      }\n    }\n  }\n\n\n  /**\n   * Construct and fire a Player.Metadata event\n   *\n   * @param {number} startTime\n   * @param {?number} endTime\n   * @param {string} metadataType\n   * @param {shaka.extern.ID3Metadata} payload\n   * @private\n   */\n  dispatchMetadataEvent_(startTime, endTime, metadataType, payload) {\n    goog.asserts.assert(!endTime || startTime <= endTime,\n        'Metadata start time should be less or equal to the end time!');\n    const eventName = shaka.Player.EventName.Metadata;\n    const data = {\n      startTime: startTime,\n      endTime: endTime,\n      metadataType: metadataType,\n      payload: payload,\n    };\n    this.dispatchEvent(this.makeEvent_(eventName, data));\n  }\n\n  /**\n   * Take a series of variants and ensure that they only contain one type of\n   * variant. The different options are:\n   *  1. Audio-Video\n   *  2. Audio-Only\n   *  3. Video-Only\n   *\n   * A manifest can only contain a single type because once we initialize media\n   * source to expect specific streams, it must always have content for those\n   * streams. If we were to start with audio+video and switch to an audio-only\n   * variant, media source would block waiting for video content.\n   *\n   * @param {shaka.extern.Manifest} manifest\n   * @private\n   */\n  static filterForAVVariants_(manifest) {\n    const isAVVariant = (variant) => {\n      // Audio-video variants may include both streams separately or may be\n      // single multiplexed streams with multiple codecs.\n      return (variant.video && variant.audio) ||\n             (variant.video && variant.video.codecs.includes(','));\n    };\n    if (manifest.variants.some(isAVVariant)) {\n      shaka.log.debug('Found variant with audio and video content, ' +\n          'so filtering out audio-only content.');\n      manifest.variants = manifest.variants.filter(isAVVariant);\n    }\n  }\n\n  /**\n   * Create a new DrmEngine instance. This may be replaced by tests to create\n   * fake instances. Configuration and initialization will be handled after\n   * |createDrmEngine|.\n   *\n   * @param {shaka.media.DrmEngine.PlayerInterface} playerInterface\n   * @return {!shaka.media.DrmEngine}\n   */\n  createDrmEngine(playerInterface) {\n    const updateExpirationTime = this.config_.drm.updateExpirationTime;\n    return new shaka.media.DrmEngine(playerInterface, updateExpirationTime);\n  }\n\n  /**\n   * Creates a new instance of NetworkingEngine.  This can be replaced by tests\n   * to create fake instances instead.\n   *\n   * @return {!shaka.net.NetworkingEngine}\n   */\n  createNetworkingEngine() {\n    /** @type {function(number, number)} */\n    const onProgressUpdated_ = (deltaTimeMs, bytesDownloaded) => {\n      // In some situations, such as during offline storage, the abr manager\n      // might not yet exist. Therefore, we need to check if abr manager has\n      // been initialized before using it.\n      if (this.abrManager_) {\n        this.abrManager_.segmentDownloaded(deltaTimeMs, bytesDownloaded);\n      }\n    };\n\n    return new shaka.net.NetworkingEngine(onProgressUpdated_);\n  }\n\n  /**\n   * Creates a new instance of Playhead.  This can be replaced by tests to\n   * create fake instances instead.\n   *\n   * @param {?number} startTime\n   * @return {!shaka.media.Playhead}\n   */\n  createPlayhead(startTime) {\n    goog.asserts.assert(this.manifest_, 'Must have manifest');\n    goog.asserts.assert(this.video_, 'Must have video');\n    return new shaka.media.MediaSourcePlayhead(\n        this.video_,\n        this.manifest_,\n        this.config_.streaming,\n        startTime,\n        () => this.onSeek_(),\n        (event) => this.dispatchEvent(event));\n  }\n\n  /**\n   * Create the observers for MSE playback. These observers are responsible for\n   * notifying the app and player of specific events during MSE playback.\n   *\n   * @return {!shaka.media.PlayheadObserverManager}\n   * @private\n   */\n  createPlayheadObserversForMSE_() {\n    goog.asserts.assert(this.manifest_, 'Must have manifest');\n    goog.asserts.assert(this.regionTimeline_, 'Must have region timeline');\n    goog.asserts.assert(this.video_, 'Must have video element');\n\n    // Create the region observer. This will allow us to notify the app when we\n    // move in and out of timeline regions.\n    const regionObserver = new shaka.media.RegionObserver(this.regionTimeline_);\n    const onEnterRegion = (region, seeking) => {\n      this.onRegionEvent_(shaka.Player.EventName.TimelineRegionEnter, region);\n    };\n    const onExitRegion = (region, seeking) => {\n      this.onRegionEvent_(shaka.Player.EventName.TimelineRegionExit, region);\n    };\n    const onSkipRegion = (region, seeking) => {\n      // If we are seeking, we don't want to surface the enter/exit events since\n      // they didn't play through them.\n      if (!seeking) {\n        this.onRegionEvent_(shaka.Player.EventName.TimelineRegionEnter, region);\n        this.onRegionEvent_(shaka.Player.EventName.TimelineRegionExit, region);\n      }\n    };\n    regionObserver.setListeners(onEnterRegion, onExitRegion, onSkipRegion);\n\n    // Now that we have all our observers, create a manager for them.\n    const manager = new shaka.media.PlayheadObserverManager(this.video_);\n    manager.manage(regionObserver);\n\n    return manager;\n  }\n\n  /**\n   * Initialize and start the buffering system (observer and timer) so that we\n   * can monitor our buffer lead during playback.\n   *\n   * @param {number} rebufferingGoal\n   * @private\n   */\n  startBufferManagement_(rebufferingGoal) {\n    goog.asserts.assert(\n        !this.bufferObserver_,\n        'No buffering observer should exist before initialization.');\n\n    goog.asserts.assert(\n        !this.bufferPoller_,\n        'No buffer timer should exist before initialization.');\n\n    // Give dummy values, will be updated below.\n    this.bufferObserver_ = new shaka.media.BufferingObserver(1, 2);\n\n    // Force us back to a buffering state. This ensure everything is starting in\n    // the same state.\n    this.bufferObserver_.setState(shaka.media.BufferingObserver.State.STARVING);\n    this.updateBufferingSettings_(rebufferingGoal);\n    this.updateBufferState_();\n\n    // TODO: We should take some time to look into the effects of our\n    //       quarter-second refresh practice. We often use a quarter-second\n    //       but we have no documentation about why.\n    this.bufferPoller_ = new shaka.util.Timer(() => {\n      this.pollBufferState_();\n    }).tickEvery(/* seconds= */ 0.25);\n  }\n\n  /**\n   * Updates the buffering thresholds based on the new rebuffering goal.\n   *\n   * @param {number} rebufferingGoal\n   * @private\n   */\n  updateBufferingSettings_(rebufferingGoal) {\n    // The threshold to transition back to satisfied when starving.\n    const starvingThreshold = rebufferingGoal;\n    // The threshold to transition into starving when satisfied.\n    // We use a \"typical\" threshold, unless the rebufferingGoal is unusually\n    // low.\n    // Then we force the value down to half the rebufferingGoal, since\n    // starvingThreshold must be strictly larger than satisfiedThreshold for the\n    // logic in BufferingObserver to work correctly.\n    const satisfiedThreshold = Math.min(\n        shaka.Player.TYPICAL_BUFFERING_THRESHOLD_, rebufferingGoal / 2);\n\n    this.bufferObserver_.setThresholds(starvingThreshold, satisfiedThreshold);\n  }\n\n  /**\n   * This method is called periodically to check what the buffering observer\n   * says so that we can update the rest of the buffering behaviours.\n   *\n   * @private\n   */\n  pollBufferState_() {\n    goog.asserts.assert(\n        this.video_,\n        'Need a media element to update the buffering observer');\n\n    goog.asserts.assert(\n        this.bufferObserver_,\n        'Need a buffering observer to update');\n\n    let bufferedToEnd;\n    switch (this.loadMode_) {\n      case shaka.Player.LoadMode.SRC_EQUALS:\n        bufferedToEnd = this.isBufferedToEndSrc_();\n        break;\n      case shaka.Player.LoadMode.MEDIA_SOURCE:\n        bufferedToEnd = this.isBufferedToEndMS_();\n        break;\n      default:\n        bufferedToEnd = false;\n        break;\n    }\n\n    const bufferLead = shaka.media.TimeRangesUtils.bufferedAheadOf(\n        this.video_.buffered,\n        this.video_.currentTime);\n\n    const stateChanged = this.bufferObserver_.update(bufferLead, bufferedToEnd);\n\n    // If the state changed, we need to surface the event.\n    if (stateChanged) {\n      this.updateBufferState_();\n    }\n  }\n\n  /**\n   * Create a new media source engine. This will ONLY be replaced by tests as a\n   * way to inject fake media source engine instances.\n   *\n   * @param {!HTMLMediaElement} mediaElement\n   * @param {!shaka.media.IClosedCaptionParser} closedCaptionsParser\n   * @param {!shaka.extern.TextDisplayer} textDisplayer\n   * @param {!function(!Array.<shaka.extern.ID3Metadata>, number, ?number)}\n   *  onMetadata\n   *\n   * @return {!shaka.media.MediaSourceEngine}\n   */\n  createMediaSourceEngine(mediaElement, closedCaptionsParser, textDisplayer,\n      onMetadata) {\n    return new shaka.media.MediaSourceEngine(\n        mediaElement, closedCaptionsParser, textDisplayer, onMetadata);\n  }\n\n  /**\n   * Creates a new instance of StreamingEngine.  This can be replaced by tests\n   * to create fake instances instead.\n   *\n   * @return {!shaka.media.StreamingEngine}\n   */\n  createStreamingEngine() {\n    goog.asserts.assert(\n        this.playhead_ && this.abrManager_ && this.mediaSourceEngine_ &&\n        this.manifest_,\n        'Must not be destroyed');\n\n    /** @type {shaka.media.StreamingEngine.PlayerInterface} */\n    const playerInterface = {\n      getPresentationTime: () => this.playhead_.getTime(),\n      getBandwidthEstimate: () => this.abrManager_.getBandwidthEstimate(),\n      mediaSourceEngine: this.mediaSourceEngine_,\n      netEngine: this.networkingEngine_,\n      onError: (error) => this.onError_(error),\n      onEvent: (event) => this.dispatchEvent(event),\n      onManifestUpdate: () => this.onManifestUpdate_(),\n      onSegmentAppended: () => this.onSegmentAppended_(),\n    };\n\n    return new shaka.media.StreamingEngine(this.manifest_, playerInterface);\n  }\n\n  /**\n   * Changes configuration settings on the Player.  This checks the names of\n   * keys and the types of values to avoid coding errors.  If there are errors,\n   * this logs them to the console and returns false.  Correct fields are still\n   * applied even if there are other errors.  You can pass an explicit\n   * <code>undefined</code> value to restore the default value.  This has two\n   * modes of operation:\n   *\n   * <p>\n   * First, this can be passed a single \"plain\" object.  This object should\n   * follow the {@link shaka.extern.PlayerConfiguration} object.  Not all fields\n   * need to be set; unset fields retain their old values.\n   *\n   * <p>\n   * Second, this can be passed two arguments.  The first is the name of the key\n   * to set.  This should be a '.' separated path to the key.  For example,\n   * <code>'streaming.alwaysStreamText'</code>.  The second argument is the\n   * value to set.\n   *\n   * @param {string|!Object} config This should either be a field name or an\n   *   object.\n   * @param {*=} value In the second mode, this is the value to set.\n   * @return {boolean} True if the passed config object was valid, false if\n   *   there were invalid entries.\n   * @export\n   */\n  configure(config, value) {\n    goog.asserts.assert(this.config_, 'Config must not be null!');\n    goog.asserts.assert(typeof(config) == 'object' || arguments.length == 2,\n        'String configs should have values!');\n\n    // ('fieldName', value) format\n    if (arguments.length == 2 && typeof(config) == 'string') {\n      config = shaka.util.ConfigUtils.convertToConfigObject(config, value);\n    }\n\n    goog.asserts.assert(typeof(config) == 'object', 'Should be an object!');\n\n    // Deprecate 'manifest.dash.defaultPresentationDelay' configuration.\n    if (config['manifest'] && config['manifest']['dash'] &&\n          'defaultPresentationDelay' in config['manifest']['dash']) {\n      shaka.Deprecate.deprecateFeature(4,\n          'manifest.dash.defaultPresentationDelay configuration',\n          'Please Use manifest.defaultPresentationDelay instead.');\n      config['manifest']['defaultPresentationDelay'] =\n          config['manifest']['dash']['defaultPresentationDelay'];\n      delete config['manifest']['dash']['defaultPresentationDelay'];\n    }\n\n    const ret = shaka.util.PlayerConfiguration.mergeConfigObjects(\n        this.config_, config, this.defaultConfig_());\n\n    this.applyConfig_();\n    return ret;\n  }\n\n  /**\n   * Apply config changes.\n   * @private\n   */\n  applyConfig_() {\n    if (this.parser_) {\n      const manifestConfig =\n          shaka.util.ObjectUtils.cloneObject(this.config_.manifest);\n      // Don't read video segments if the player is attached to an audio element\n      if (this.video_ && this.video_.nodeName === 'AUDIO') {\n        manifestConfig.disableVideo = true;\n      }\n      this.parser_.configure(manifestConfig);\n    }\n    if (this.drmEngine_) {\n      this.drmEngine_.configure(this.config_.drm);\n    }\n    if (this.streamingEngine_) {\n      this.streamingEngine_.configure(this.config_.streaming);\n\n      // Need to apply the restrictions.\n      try {\n        // this.filterManifest_() may throw.\n        this.filterManifest_(this.manifest_);\n      } catch (error) {\n        this.onError_(error);\n      }\n\n      if (this.abrManager_) {\n        // Update AbrManager variants to match these new settings.\n        this.updateAbrManagerVariants_();\n      }\n\n      // If the streams we are playing are restricted, we need to switch.\n      const activeVariant = this.streamingEngine_.getCurrentVariant();\n      if (activeVariant) {\n        if (!activeVariant.allowedByApplication ||\n            !activeVariant.allowedByKeySystem) {\n          shaka.log.debug('Choosing new variant after changing configuration');\n          this.chooseVariantAndSwitch_();\n        }\n      }\n    }\n\n    if (this.mediaSourceEngine_) {\n      const textDisplayerFactory = this.config_.textDisplayFactory;\n      if (this.lastTextFactory_ != textDisplayerFactory) {\n        const displayer =\n            shaka.util.Functional.callFactory(textDisplayerFactory);\n        this.mediaSourceEngine_.setTextDisplayer(displayer);\n        this.lastTextFactory_ = textDisplayerFactory;\n\n        if (this.streamingEngine_) {\n          // Reload the text stream, so the cues will load again.\n          this.streamingEngine_.reloadTextStream();\n        }\n      }\n    }\n    if (this.abrManager_) {\n      this.abrManager_.configure(this.config_.abr);\n      // Simply enable/disable ABR with each call, since multiple calls to these\n      // methods have no effect.\n      if (this.config_.abr.enabled) {\n        this.abrManager_.enable();\n      } else {\n        this.abrManager_.disable();\n      }\n\n      this.onAbrStatusChanged_();\n    }\n    if (this.bufferObserver_) {\n      let rebufferThreshold = this.config_.streaming.rebufferingGoal;\n      if (this.manifest_) {\n        rebufferThreshold =\n            Math.max(rebufferThreshold, this.manifest_.minBufferTime);\n      }\n      this.updateBufferingSettings_(rebufferThreshold);\n    }\n  }\n\n  /**\n   * Return a copy of the current configuration.  Modifications of the returned\n   * value will not affect the Player's active configuration.  You must call\n   * <code>player.configure()</code> to make changes.\n   *\n   * @return {shaka.extern.PlayerConfiguration}\n   * @export\n   */\n  getConfiguration() {\n    goog.asserts.assert(this.config_, 'Config must not be null!');\n\n    const ret = this.defaultConfig_();\n    shaka.util.PlayerConfiguration.mergeConfigObjects(\n        ret, this.config_, this.defaultConfig_());\n    return ret;\n  }\n\n  /**\n   * Return a reference to the current configuration. Modifications to the\n   * returned value will affect the Player's active configuration. This method\n   * is not exported as sharing configuration with external objects is not\n   * supported.\n   *\n   * @return {shaka.extern.PlayerConfiguration}\n   */\n  getSharedConfiguration() {\n    goog.asserts.assert(\n        this.config_, 'Cannot call getSharedConfiguration after call destroy!');\n    return this.config_;\n  }\n\n  /**\n   * Reset configuration to default.\n   * @export\n   */\n  resetConfiguration() {\n    goog.asserts.assert(this.config_, 'Cannot be destroyed');\n    // Remove the old keys so we remove open-ended dictionaries like drm.servers\n    // but keeps the same object reference.\n    for (const key in this.config_) {\n      delete this.config_[key];\n    }\n\n    shaka.util.PlayerConfiguration.mergeConfigObjects(\n        this.config_, this.defaultConfig_(), this.defaultConfig_());\n    this.applyConfig_();\n  }\n\n  /**\n   * Get the current load mode.\n   *\n   * @return {shaka.Player.LoadMode}\n   * @export\n   */\n  getLoadMode() {\n    return this.loadMode_;\n  }\n\n  /**\n   * Get the media element that the player is currently using to play loaded\n   * content. If the player has not loaded content, this will return\n   * <code>null</code>.\n   *\n   * @return {HTMLMediaElement}\n   * @export\n   */\n  getMediaElement() {\n    return this.video_;\n  }\n\n  /**\n   * @return {shaka.net.NetworkingEngine} A reference to the Player's networking\n   *     engine.  Applications may use this to make requests through Shaka's\n   *     networking plugins.\n   * @export\n   */\n  getNetworkingEngine() {\n    return this.networkingEngine_;\n  }\n\n  /**\n   * Get the uri to the asset that the player has loaded. If the player has not\n   * loaded content, this will return <code>null</code>.\n   *\n   * @return {?string}\n   * @export\n   */\n  getAssetUri() {\n    return this.assetUri_;\n  }\n\n  /**\n   * Returns a shaka.ads.AdManager instance, responsible for Dynamic\n   * Ad Insertion functionality.\n   *\n   * NOTE: Ad features are currently in BETA and are NOT yet covered by semantic\n   * versioning compatibility guarantees.  The API may change at any time!\n   *\n   * @return {shaka.extern.IAdManager}\n   * @export\n   */\n  getAdManager() {\n    shaka.log.warnOnce('getAdManager',\n        'Shaka Player\\'s ad features are currently in BETA and are NOT yet ' +\n        'covered by semantic versioning compatibility guarantees.  The API ' +\n        'may change at any time!');\n    return this.adManager_;\n  }\n\n  /**\n   * Get if the player is playing live content. If the player has not loaded\n   * content, this will return <code>false</code>.\n   *\n   * @return {boolean}\n   * @export\n   */\n  isLive() {\n    if (this.manifest_) {\n      return this.manifest_.presentationTimeline.isLive();\n    }\n\n    // For native HLS, the duration for live streams seems to be Infinity.\n    if (this.video_ && this.video_.src) {\n      return this.video_.duration == Infinity;\n    }\n\n    return false;\n  }\n\n  /**\n   * Get if the player is playing in-progress content. If the player has not\n   * loaded content, this will return <code>false</code>.\n   *\n   * @return {boolean}\n   * @export\n   */\n  isInProgress() {\n    return this.manifest_ ?\n           this.manifest_.presentationTimeline.isInProgress() :\n           false;\n  }\n\n  /**\n   * Check if the manifest contains only audio-only content. If the player has\n   * not loaded content, this will return <code>false</code>.\n   *\n   * <p>\n   * The player does not support content that contain more than one type of\n   * variants (i.e. mixing audio-only, video-only, audio-video). Content will be\n   * filtered to only contain one type of variant.\n   *\n   * @return {boolean}\n   * @export\n   */\n  isAudioOnly() {\n    if (this.manifest_) {\n      const variants = this.manifest_.variants;\n      if (!variants.length) {\n        return false;\n      }\n\n      // Note that if there are some audio-only variants and some audio-video\n      // variants, the audio-only variants are removed during filtering.\n      // Therefore if the first variant has no video, that's sufficient to say\n      // it is audio-only content.\n      return !variants[0].video;\n    } else if (this.video_ && this.video_.src) {\n      // If we have video track info, use that.  It will be the least\n      // error-prone way with native HLS.  In contrast, videoHeight might be\n      // unset until the first frame is loaded.  Since isAudioOnly is queried\n      // by the UI on the 'trackschanged' event, the videoTracks info should be\n      // up-to-date.\n      if (this.video_.videoTracks) {\n        return this.video_.videoTracks.length == 0;\n      }\n\n      // We cast to the more specific HTMLVideoElement to access videoHeight.\n      // This might be an audio element, though, in which case videoHeight will\n      // be undefined at runtime.  For audio elements, this will always return\n      // true.\n      const video = /** @type {HTMLVideoElement} */(this.video_);\n      return video.videoHeight == 0;\n    } else {\n      return false;\n    }\n  }\n\n  /**\n   * Get the range of time (in seconds) that seeking is allowed. If the player\n   * has not loaded content, this will return a range from 0 to 0.\n   *\n   * @return {{start: number, end: number}}\n   * @export\n   */\n  seekRange() {\n    if (this.manifest_) {\n      const timeline = this.manifest_.presentationTimeline;\n\n      return {\n        'start': timeline.getSeekRangeStart(),\n        'end': timeline.getSeekRangeEnd(),\n      };\n    }\n\n    // If we have loaded content with src=, we ask the video element for its\n    // seekable range.  This covers both plain mp4s and native HLS playbacks.\n    if (this.video_ && this.video_.src) {\n      const seekable = this.video_.seekable;\n      if (seekable.length) {\n        return {\n          'start': seekable.start(0),\n          'end': seekable.end(seekable.length - 1),\n        };\n      }\n    }\n\n    return {'start': 0, 'end': 0};\n  }\n\n  /**\n   * Get the key system currently used by EME. If EME is not being used, this\n   * will return an empty string. If the player has not loaded content, this\n   * will return an empty string.\n   *\n   * @return {string}\n   * @export\n   */\n  keySystem() {\n    return shaka.media.DrmEngine.keySystem(this.drmInfo());\n  }\n\n  /**\n   * Get the drm info used to initialize EME. If EME is not being used, this\n   * will return <code>null</code>. If the player is idle or has not initialized\n   * EME yet, this will return <code>null</code>.\n   *\n   * @return {?shaka.extern.DrmInfo}\n   * @export\n   */\n  drmInfo() {\n    return this.drmEngine_ ? this.drmEngine_.getDrmInfo() : null;\n  }\n\n  /**\n   * Get the next known expiration time for any EME session. If the session\n   * never expires, this will return <code>Infinity</code>. If there are no EME\n   * sessions, this will return <code>Infinity</code>. If the player has not\n   * loaded content, this will return <code>Infinity</code>.\n   *\n   * @return {number}\n   * @export\n   */\n  getExpiration() {\n    return this.drmEngine_ ? this.drmEngine_.getExpiration() : Infinity;\n  }\n\n  /**\n   * Check if the player is currently in a buffering state (has too little\n   * content to play smoothly). If the player has not loaded content, this will\n   * return <code>false</code>.\n   *\n   * @return {boolean}\n   * @export\n   */\n  isBuffering() {\n    const State = shaka.media.BufferingObserver.State;\n    return this.bufferObserver_ ?\n           this.bufferObserver_.getState() == State.STARVING :\n           false;\n  }\n\n  /**\n   * Get the playback rate of what is playing right now. If we are using trick\n   * play, this will return the trick play rate.\n   * If no content is playing, this will return 0.\n   * If content is buffering, this will return the expected playback rate once\n   * the video starts playing.\n   *\n   * <p>\n   * If the player has not loaded content, this will return a playback rate of\n   * 0.\n   *\n   * @return {number}\n   * @export\n   */\n  getPlaybackRate() {\n    if (!this.video_) {\n      return 0;\n    }\n    return this.playRateController_ ?\n           this.playRateController_.getRealRate() :\n           1;\n  }\n\n  /**\n   * Enable trick play to skip through content without playing by repeatedly\n   * seeking. For example, a rate of 2.5 would result in 2.5 seconds of content\n   * being skipped every second. A negative rate will result in moving\n   * backwards.\n   *\n   * <p>\n   * If the player has not loaded content or is still loading content this will\n   * be a no-op. Wait until <code>load</code> has completed before calling.\n   *\n   * <p>\n   * Trick play will be canceled automatically if the playhead hits the\n   * beginning or end of the seekable range for the content.\n   *\n   * @param {number} rate\n   * @export\n   */\n  trickPlay(rate) {\n    // A playbackRate of 0 is used internally when we are in a buffering state,\n    // and doesn't make sense for trick play.  If you set a rate of 0 for trick\n    // play, we will reject it and issue a warning.  If it happens during a\n    // test, we will fail the test through this assertion.\n    goog.asserts.assert(rate != 0, 'Should never set a trick play rate of 0!');\n    if (rate == 0) {\n      shaka.log.alwaysWarn('A trick play rate of 0 is unsupported!');\n      return;\n    }\n\n    if (this.video_.paused) {\n      // Our fast forward is implemented with playbackRate and needs the video\n      // to be playing (to not be paused) to take immediate effect.\n      // If the video is paused, \"unpause\" it.\n      this.video_.play();\n    }\n    this.playRateController_.set(rate);\n\n    if (this.loadMode_ == shaka.Player.LoadMode.MEDIA_SOURCE) {\n      this.abrManager_.playbackRateChanged(rate);\n      this.streamingEngine_.setTrickPlay(Math.abs(rate) > 1);\n    }\n  }\n\n  /**\n   * Cancel trick-play. If the player has not loaded content or is still loading\n   * content this will be a no-op.\n   *\n   * @export\n   */\n  cancelTrickPlay() {\n    if (this.loadMode_ == shaka.Player.LoadMode.SRC_EQUALS) {\n      this.playRateController_.set(1);\n    }\n\n    if (this.loadMode_ == shaka.Player.LoadMode.MEDIA_SOURCE) {\n      this.playRateController_.set(1);\n      this.abrManager_.playbackRateChanged(1);\n      this.streamingEngine_.setTrickPlay(false);\n    }\n  }\n\n  /**\n   * Return a list of variant tracks that can be switched to.\n   *\n   * <p>\n   * If the player has not loaded content, this will return an empty list.\n   *\n   * @return {!Array.<shaka.extern.Track>}\n   * @export\n   */\n  getVariantTracks() {\n    if (this.manifest_) {\n      const currentVariant = this.streamingEngine_ ?\n          this.streamingEngine_.getCurrentVariant() : null;\n\n      const tracks = [];\n\n      // Convert each variant to a track.\n      for (const variant of this.manifest_.variants) {\n        if (!shaka.util.StreamUtils.isPlayable(variant)) {\n          continue;\n        }\n\n        const track = shaka.util.StreamUtils.variantToTrack(variant);\n        track.active = variant == currentVariant;\n\n        tracks.push(track);\n      }\n\n      return tracks;\n    } else if (this.video_ && this.video_.audioTracks) {\n      // Safari's native HLS always shows a single element in videoTracks.\n      // You can't use that API to change resolutions.  But we can use\n      // audioTracks to generate a variant list that is usable for changing\n      // languages.\n      const audioTracks = Array.from(this.video_.audioTracks);\n      return audioTracks.map((audio) =>\n        shaka.util.StreamUtils.html5AudioTrackToTrack(audio));\n    } else {\n      return [];\n    }\n  }\n\n  /**\n   * Return a list of text tracks that can be switched to.\n   *\n   * <p>\n   * If the player has not loaded content, this will return an empty list.\n   *\n   * @return {!Array.<shaka.extern.Track>}\n   * @export\n   */\n  getTextTracks() {\n    if (this.manifest_) {\n      const currentTextStream = this.streamingEngine_ ?\n          this.streamingEngine_.getCurrentTextStream() : null;\n      const tracks = [];\n\n      // Convert all selectable text streams to tracks.\n      for (const text of this.manifest_.textStreams) {\n        const track = shaka.util.StreamUtils.textStreamToTrack(text);\n        track.active = text == currentTextStream;\n\n        tracks.push(track);\n      }\n\n      return tracks;\n    } else if (this.video_ && this.video_.src && this.video_.textTracks) {\n      const textTracks = this.getFilteredTextTracks_();\n      const StreamUtils = shaka.util.StreamUtils;\n      return textTracks.map((text) => StreamUtils.html5TextTrackToTrack(text));\n    } else {\n      return [];\n    }\n  }\n\n  /**\n   * Select a specific text track. <code>track</code> should come from a call to\n   * <code>getTextTracks</code>. If the track is not found, this will be a\n   * no-op. If the player has not loaded content, this will be a no-op.\n   *\n   * <p>\n   * Note that <code>AdaptationEvents</code> are not fired for manual track\n   * selections.\n   *\n   * @param {shaka.extern.Track} track\n   * @export\n   */\n  selectTextTrack(track) {\n    if (this.manifest_ && this.streamingEngine_) {\n      const stream = this.manifest_.textStreams.find(\n          (stream) => stream.id == track.id);\n\n      if (!stream) {\n        shaka.log.error('No stream with id', track.id);\n        return;\n      }\n\n      if (stream == this.streamingEngine_.getCurrentTextStream()) {\n        shaka.log.debug('Text track already selected.');\n        return;\n      }\n\n      // Add entries to the history.\n      this.addTextStreamToSwitchHistory_(stream, /* fromAdaptation= */ false);\n      this.streamingEngine_.switchTextStream(stream);\n      this.onTextChanged_();\n\n      // Workaround for https://github.com/google/shaka-player/issues/1299\n      // When track is selected, back-propagate the language to\n      // currentTextLanguage_.\n      this.currentTextLanguage_ = stream.language;\n    } else if (this.video_ && this.video_.src && this.video_.textTracks) {\n      const textTracks = this.getFilteredTextTracks_();\n      for (const textTrack of textTracks) {\n        if (shaka.util.StreamUtils.html5TrackId(textTrack) == track.id) {\n          // Leave the track in 'hidden' if it's selected but not showing.\n          textTrack.mode = this.isTextVisible_ ? 'showing' : 'hidden';\n        } else {\n          // Safari allows multiple text tracks to have mode == 'showing', so be\n          // explicit in resetting the others.\n          textTrack.mode = 'disabled';\n        }\n      }\n      this.onTextChanged_();\n    }\n  }\n\n  /**\n   * Select a specific variant track to play.  <code>track</code> should come\n   * from a call to <code>getVariantTracks</code>. If <code>track</code> cannot\n   * be found, this will be a no-op. If the player has not loaded content, this\n   * will be a no-op.\n   *\n   * <p>\n   * Changing variants will take effect once the currently buffered content has\n   * been played. To force the change to happen sooner, use\n   * <code>clearBuffer</code> with <code>safeMargin</code>. Setting\n   * <code>clearBuffer</code> to <code>true</code> will clear all buffered\n   * content after <code>safeMargin</code>, allowing the new variant to start\n   * playing sooner.\n   *\n   * <p>\n   * Note that <code>AdaptationEvents</code> are not fired for manual track\n   * selections.\n   *\n   * @param {shaka.extern.Track} track\n   * @param {boolean=} clearBuffer\n   * @param {number=} safeMargin Optional amount of buffer (in seconds) to\n   *   retain when clearing the buffer. Useful for switching variant quickly\n   *   without causing a buffering event. Defaults to 0 if not provided. Ignored\n   *   if clearBuffer is false. Can cause hiccups on some browsers if chosen too\n   *   small, e.g. The amount of two segments is a fair minimum to consider as\n   *   safeMargin value.\n   * @export\n   */\n  selectVariantTrack(track, clearBuffer = false, safeMargin = 0) {\n    if (this.manifest_ && this.streamingEngine_) {\n      if (this.config_.abr.enabled) {\n        shaka.log.alwaysWarn('Changing tracks while abr manager is enabled ' +\n                             'will likely result in the selected track ' +\n                             'being overriden. Consider disabling abr before ' +\n                             'calling selectVariantTrack().');\n      }\n\n      const variant = this.manifest_.variants.find(\n          (variant) => variant.id == track.id);\n      if (!variant) {\n        shaka.log.error('No variant with id', track.id);\n        return;\n      }\n\n      // Double check that the track is allowed to be played. The track list\n      // should only contain playable variants, but if restrictions change and\n      // |selectVariantTrack| is called before the track list is updated, we\n      // could get a now-restricted variant.\n      if (!shaka.util.StreamUtils.isPlayable(variant)) {\n        shaka.log.error('Unable to switch to restricted track', track.id);\n        return;\n      }\n\n      if (variant == this.streamingEngine_.getCurrentVariant()) {\n        shaka.log.debug('Variant already selected.');\n        return;\n      }\n\n      // Add entries to the history.\n      this.addVariantToSwitchHistory_(variant, /* fromAdaptation= */ false);\n      this.streamingEngine_.switchVariant(variant, clearBuffer, safeMargin);\n      // Dispatch a 'variantchanged' event\n      this.onVariantChanged_();\n\n      // Workaround for https://github.com/google/shaka-player/issues/1299\n      // When track is selected, back-propagate the language to\n      // currentAudioLanguage_.\n      this.currentAdaptationSetCriteria_ = new shaka.media.ExampleBasedCriteria(\n          variant);\n\n      // Update AbrManager variants to match these new settings.\n      this.updateAbrManagerVariants_();\n    } else if (this.video_ && this.video_.audioTracks) {\n      // Safari's native HLS won't let you choose an explicit variant, though\n      // you can choose audio languages this way.\n      const audioTracks = Array.from(this.video_.audioTracks);\n      for (const audioTrack of audioTracks) {\n        if (shaka.util.StreamUtils.html5TrackId(audioTrack) == track.id) {\n          // This will reset the \"enabled\" of other tracks to false.\n          audioTrack.enabled = true;\n        }\n      }\n      this.onVariantChanged_();\n    }\n  }\n\n  /**\n   * Return a list of audio language-role combinations available.  If the\n   * player has not loaded any content, this will return an empty list.\n   *\n   * @return {!Array.<shaka.extern.LanguageRole>}\n   * @export\n   */\n  getAudioLanguagesAndRoles() {\n    return shaka.Player.getLanguageAndRolesFrom_(this.getVariantTracks());\n  }\n\n  /**\n   * Return a list of text language-role combinations available.  If the player\n   * has not loaded any content, this will be return an empty list.\n   *\n   * @return {!Array.<shaka.extern.LanguageRole>}\n   * @export\n   */\n  getTextLanguagesAndRoles() {\n    return shaka.Player.getLanguageAndRolesFrom_(this.getTextTracks());\n  }\n\n  /**\n   * Return a list of audio languages available. If the player has not loaded\n   * any content, this will return an empty list.\n   *\n   * @return {!Array.<string>}\n   * @export\n   */\n  getAudioLanguages() {\n    return Array.from(shaka.Player.getLanguagesFrom_(this.getVariantTracks()));\n  }\n\n  /**\n   * Return a list of text languages available. If the player has not loaded\n   * any content, this will return an empty list.\n   *\n   * @return {!Array.<string>}\n   * @export\n   */\n  getTextLanguages() {\n    return Array.from(shaka.Player.getLanguagesFrom_(this.getTextTracks()));\n  }\n\n  /**\n   * Sets the current audio language and current variant role to the selected\n   * language and role, and chooses a new variant if need be. If the player has\n   * not loaded any content, this will be a no-op.\n   *\n   * @param {string} language\n   * @param {string=} role\n   * @export\n   */\n  selectAudioLanguage(language, role) {\n    const LanguageUtils = shaka.util.LanguageUtils;\n\n    if (this.manifest_ && this.playhead_) {\n      this.currentAdaptationSetCriteria_ =\n          new shaka.media.PreferenceBasedCriteria(language, role || '',\n          /* channelCount= */ 0, /* label= */ '');\n\n      this.chooseVariantAndSwitch_();\n    } else if (this.video_ && this.video_.audioTracks) {\n      const audioTracks = Array.from(this.video_.audioTracks);\n      const selectedLanguage = LanguageUtils.normalize(language);\n\n      let languageMatch = null;\n      let languageAndRoleMatch = null;\n\n      for (const audioTrack of audioTracks) {\n        const track = shaka.util.StreamUtils.html5AudioTrackToTrack(audioTrack);\n\n        if (LanguageUtils.normalize(track.language) == selectedLanguage) {\n          languageMatch = audioTrack;\n\n          if (role) {\n            if (track.roles.includes(role)) {\n              languageAndRoleMatch = audioTrack;\n            }\n          } else {  // no role\n            if (track.roles.length == 0) {\n              languageAndRoleMatch = audioTrack;\n            }\n          }\n        }\n      }\n\n      // This will reset the \"enabled\" of other tracks to false.\n      if (languageAndRoleMatch) {\n        languageAndRoleMatch.enabled = true;\n        this.onVariantChanged_();\n      } else if (languageMatch) {\n        languageMatch.enabled = true;\n        this.onVariantChanged_();\n      }\n    }\n  }\n\n  /**\n   * Sets the current text language and current text role to the selected\n   * language and role, and chooses a new variant if need be. If the player has\n   * not loaded any content, this will be a no-op.\n   *\n   * @param {string} language\n   * @param {string=} role\n   * @export\n   */\n  selectTextLanguage(language, role) {\n    const LanguageUtils = shaka.util.LanguageUtils;\n\n    if (this.manifest_ && this.playhead_) {\n      this.currentTextLanguage_ = language;\n      this.currentTextRole_ = role || '';\n\n      const chosenText = this.chooseTextStream_();\n      if (chosenText) {\n        if (chosenText == this.streamingEngine_.getCurrentTextStream()) {\n          shaka.log.debug('Text track already selected.');\n          return;\n        }\n\n        this.addTextStreamToSwitchHistory_(\n            chosenText, /* fromAdaptation= */ false);\n        if (this.shouldStreamText_()) {\n          this.streamingEngine_.switchTextStream(chosenText);\n          this.onTextChanged_();\n        }\n      }\n    } else {\n      const selectedLanguage = LanguageUtils.normalize(language);\n\n      const track = this.getTextTracks().find((t) => {\n        return LanguageUtils.normalize(t.language) == selectedLanguage &&\n          (!role || t.roles.includes(role));\n      });\n\n      if (track) {\n        this.selectTextTrack(track);\n      }\n    }\n  }\n\n  /**\n   * Select variant tracks that have a given label. This assumes the\n   * label uniquely identifies an audio stream, so all the variants\n   * are expected to have the same variant.audio.\n   *\n   * @param {string} label\n   * @export\n   */\n  selectVariantsByLabel(label) {\n    if (this.manifest_ && this.playhead_) {\n      let firstVariantWithLabel = null;\n      for (const variant of this.manifest_.variants) {\n        if (variant.audio.label == label) {\n          firstVariantWithLabel = variant;\n          break;\n        }\n      }\n\n      if (firstVariantWithLabel == null) {\n        shaka.log.warning('No variants were found with label: ' +\n            label + '. Ignoring the request to switch.');\n\n        return;\n      }\n\n      // Label is a unique identifier of a variant's audio stream.\n      // Because of that we assume that all the variants with the same\n      // label have the same language.\n      this.currentAdaptationSetCriteria_ =\n          new shaka.media.PreferenceBasedCriteria(\n              firstVariantWithLabel.language, '', 0, label);\n\n      this.chooseVariantAndSwitch_();\n    }\n  }\n\n  /**\n   * Check if the text displayer is enabled.\n   *\n   * @return {boolean}\n   * @export\n   */\n  isTextTrackVisible() {\n    const expected = this.isTextVisible_;\n\n    if (this.mediaSourceEngine_) {\n      // Make sure our values are still in-sync.\n      const actual = this.mediaSourceEngine_.getTextDisplayer().isTextVisible();\n      goog.asserts.assert(\n          actual == expected, 'text visibility has fallen out of sync');\n\n      // Always return the actual value so that the app has the most accurate\n      // information (in the case that the values come out of sync in prod).\n      return actual;\n    } else if (this.video_ && this.video_.src && this.video_.textTracks) {\n      const textTracks = this.getFilteredTextTracks_();\n      return textTracks.some((t) => t.mode == 'showing');\n    }\n\n    return expected;\n  }\n\n  /**\n   * Ignore the TextTracks with the 'metadata' or 'chapters' kind, or the one\n   * generated by the SimpleTextDisplayer.\n   *\n   * @return {!Array.<TextTrack>}\n   * @private\n   */\n  getFilteredTextTracks_() {\n    goog.asserts.assert(this.video_.textTracks,\n        'TextTracks should be valid.');\n    return Array.from(this.video_.textTracks)\n        .filter((t) => t.kind != 'metadata' && t.kind != 'chapters' &&\n                       t.label != shaka.Player.TextTrackLabel);\n  }\n\n  /**\n   * Get the TextTracks with the 'metadata' kind.\n   *\n   * @return {!Array.<TextTrack>}\n   * @private\n   */\n  getMetadataTracks_() {\n    goog.asserts.assert(this.video_.textTracks,\n        'TextTracks should be valid.');\n    return Array.from(this.video_.textTracks)\n        .filter((t) => t.kind == 'metadata');\n  }\n\n  /**\n   * Enable or disable the text displayer.  If the player is in an unloaded\n   * state, the request will be applied next time content is loaded.\n   *\n   * @param {boolean} isVisible\n   * @export\n   */\n  setTextTrackVisibility(isVisible) {\n    const oldVisibilty = this.isTextVisible_;\n    // Convert to boolean in case apps pass 0/1 instead false/true.\n    const newVisibility = !!isVisible;\n\n    if (oldVisibilty == newVisibility) {\n      return;\n    }\n\n    this.isTextVisible_ = newVisibility;\n\n    // Hold of on setting the text visibility until we have all the components\n    // we need. This ensures that they stay in-sync.\n    if (this.loadMode_ == shaka.Player.LoadMode.MEDIA_SOURCE) {\n      this.mediaSourceEngine_.getTextDisplayer()\n          .setTextVisibility(newVisibility);\n\n      // When the user wants to see captions, we stream captions. When the user\n      // doesn't want to see captions, we don't stream captions. This is to\n      // avoid bandwidth consumption by an unused resource. The app developer\n      // can override this and configure us to always stream captions.\n      if (!this.config_.streaming.alwaysStreamText) {\n        if (newVisibility) {\n          if (this.streamingEngine_.getCurrentTextStream()) {\n            // We already have a selected text stream.\n          } else {\n            // Find the text stream that best matches the user's preferences.\n            const streams =\n                shaka.util.StreamUtils.filterStreamsByLanguageAndRole(\n                    this.manifest_.textStreams,\n                    this.currentTextLanguage_,\n                    this.currentTextRole_);\n\n            // It is possible that there are no streams to play.\n            if (streams.length > 0) {\n              this.streamingEngine_.switchTextStream(streams[0]);\n              this.onTextChanged_();\n            }\n          }\n        } else {\n          this.streamingEngine_.unloadTextStream();\n        }\n      }\n    } else if (this.video_ && this.video_.src && this.video_.textTracks) {\n      const textTracks = this.getFilteredTextTracks_();\n      // Find the active track by looking for one which is not disabled.  This\n      // is the only way to identify the track which is currently displayed.\n      // Set it to 'showing' or 'hidden' based on newVisibility.\n      for (const textTrack of textTracks) {\n        if (textTrack.mode != 'disabled') {\n          textTrack.mode = newVisibility ? 'showing' : 'hidden';\n        }\n      }\n    }\n\n    // We need to fire the event after we have updated everything so that\n    // everything will be in a stable state when the app responds to the\n    // event.\n    this.onTextTrackVisibility_();\n  }\n\n  /**\n   * Get the current playhead position as a date. This should only be called\n   * when the player has loaded a live stream. If the player has not loaded a\n   * live stream, this will return <code>null</code>.\n   *\n   * @return {Date}\n   * @export\n   */\n  getPlayheadTimeAsDate() {\n    if (!this.isLive()) {\n      shaka.log.warning('getPlayheadTimeAsDate is for live streams!');\n      return null;\n    }\n\n    const walkerPayload = this.walker_.getCurrentPayload();\n\n    let presentationTime = 0;\n    if (this.playhead_) {\n      presentationTime = this.playhead_.getTime();\n    } else if (walkerPayload) {\n      if (walkerPayload.startTime == null) {\n        // A live stream with no requested start time and no playhead yet.  We\n        // would start at the live edge, but we don't have that yet, so return\n        // the current date & time.\n        return new Date();\n      } else {\n        // A specific start time has been requested.  This is what Playhead will\n        // use once it is created.\n        presentationTime = walkerPayload.startTime;\n      }\n    }\n\n    if (this.manifest_) {\n      const timeline = this.manifest_.presentationTimeline;\n      const startTime = timeline.getPresentationStartTime();\n      return new Date(/* ms= */ (startTime + presentationTime) * 1000);\n    } else if (this.video_ && this.video_.getStartDate) {\n      // Apple's native HLS gives us getStartDate(), which is only available if\n      // EXT-X-PROGRAM-DATETIME is in the playlist.\n      const startDate = this.video_.getStartDate();\n      if (isNaN(startDate.getTime())) {\n        shaka.log.warning(\n            'EXT-X-PROGRAM-DATETIME required to get playhead time as Date!');\n        return null;\n      }\n      return new Date(startDate.getTime() + (presentationTime * 1000));\n    } else {\n      shaka.log.warning('No way to get playhead time as Date!');\n      return null;\n    }\n  }\n\n  /**\n   * Get the presentation start time as a date. This should only be called when\n   * the player has loaded a live stream. If the player has not loaded a live\n   * stream, this will return <code>null</code>.\n   *\n   * @return {Date}\n   * @export\n   */\n  getPresentationStartTimeAsDate() {\n    if (!this.isLive()) {\n      shaka.log.warning('getPresentationStartTimeAsDate is for live streams!');\n      return null;\n    }\n\n    if (this.manifest_) {\n      const timeline = this.manifest_.presentationTimeline;\n      const startTime = timeline.getPresentationStartTime();\n      goog.asserts.assert(startTime != null,\n          'Presentation start time should not be null!');\n      return new Date(/* ms= */ startTime * 1000);\n    } else if (this.video_ && this.video_.getStartDate) {\n      // Apple's native HLS gives us getStartDate(), which is only available if\n      // EXT-X-PROGRAM-DATETIME is in the playlist.\n      const startDate = this.video_.getStartDate();\n      if (isNaN(startDate.getTime())) {\n        shaka.log.warning(\n            'EXT-X-PROGRAM-DATETIME required to get presentation start time ' +\n            'as Date!');\n        return null;\n      }\n      return startDate;\n    } else {\n      shaka.log.warning('No way to get presentation start time as Date!');\n      return null;\n    }\n  }\n\n  /**\n   * Get information about what the player has buffered. If the player has not\n   * loaded content or is currently loading content, the buffered content will\n   * be empty.\n   *\n   * @return {shaka.extern.BufferedInfo}\n   * @export\n   */\n  getBufferedInfo() {\n    if (this.loadMode_ == shaka.Player.LoadMode.MEDIA_SOURCE) {\n      return this.mediaSourceEngine_.getBufferedInfo();\n    }\n\n    const info = {\n      total: [],\n      audio: [],\n      video: [],\n      text: [],\n    };\n\n    if (this.loadMode_ == shaka.Player.LoadMode.SRC_EQUALS) {\n      const TimeRangesUtils = shaka.media.TimeRangesUtils;\n      info.total = TimeRangesUtils.getBufferedInfo(this.video_.buffered);\n    }\n\n    return info;\n  }\n\n  /**\n   * Get statistics for the current playback session. If the player is not\n   * playing content, this will return an empty stats object.\n   *\n   * @return {shaka.extern.Stats}\n   * @export\n   */\n  getStats() {\n    // If the Player is not in a fully-loaded state, then return an empty stats\n    // blob so that this call will never fail.\n    const loaded = this.loadMode_ == shaka.Player.LoadMode.MEDIA_SOURCE ||\n                   this.loadMode_ == shaka.Player.LoadMode.SRC_EQUALS;\n    if (!loaded) {\n      return shaka.util.Stats.getEmptyBlob();\n    }\n\n    this.updateStateHistory_();\n\n    goog.asserts.assert(this.video_, 'If we have stats, we should have video_');\n    const element = /** @type {!HTMLVideoElement} */ (this.video_);\n\n    if (element.getVideoPlaybackQuality) {\n      const info = element.getVideoPlaybackQuality();\n\n      this.stats_.setDroppedFrames(\n          Number(info.droppedVideoFrames),\n          Number(info.totalVideoFrames));\n      this.stats_.setCorruptedFrames(Number(info.corruptedVideoFrames));\n    }\n\n    const licenseSeconds =\n        this.drmEngine_ ? this.drmEngine_.getLicenseTime() : NaN;\n    this.stats_.setLicenseTime(licenseSeconds);\n\n    if (this.loadMode_ == shaka.Player.LoadMode.MEDIA_SOURCE) {\n      // Event through we are loaded, it is still possible that we don't have a\n      // variant yet because we set the load mode before we select the first\n      // variant to stream.\n      const variant = this.streamingEngine_.getCurrentVariant();\n\n      if (variant) {\n        const rate = this.playRateController_ ?\n           this.playRateController_.getRealRate() : 1;\n        const variantBandwidth = rate * variant.bandwidth;\n        // TODO: Should include text bandwidth if it enabled.\n        const currentStreamBandwidth = variantBandwidth;\n        this.stats_.setCurrentStreamBandwidth(currentStreamBandwidth);\n      }\n\n      if (variant && variant.video) {\n        this.stats_.setResolution(\n            /* width= */ variant.video.width || NaN,\n            /* height= */ variant.video.height || NaN);\n      }\n\n      if (this.isLive()) {\n        const now = this.getPresentationStartTimeAsDate().valueOf() +\n            this.seekRange().end * 1000;\n        const latency = (Date.now() - now) / 1000;\n        this.stats_.setLiveLatency(latency);\n      }\n\n      if (this.manifest_ && this.manifest_.presentationTimeline) {\n        const maxSegmentDuration =\n            this.manifest_.presentationTimeline.getMaxSegmentDuration();\n        this.stats_.setMaxSegmentDuration(maxSegmentDuration);\n      }\n\n      const estimate = this.abrManager_.getBandwidthEstimate();\n      this.stats_.setBandwidthEstimate(estimate);\n    }\n\n    return this.stats_.getBlob();\n  }\n\n  /**\n   * Adds the given text track to the loaded manifest.  <code>load()</code> must\n   * resolve before calling.  The presentation must have a duration.\n   *\n   * This returns the created track, which can immediately be selected by the\n   * application.  The track will not be automatically selected.\n   *\n   * @param {string} uri\n   * @param {string} language\n   * @param {string} kind\n   * @param {string} mime\n   * @param {string=} codec\n   * @param {string=} label\n   * @return {shaka.extern.Track}\n   * @export\n   */\n  addTextTrack(uri, language, kind, mime, codec, label) {\n    // TODO: Add an actual error for this.\n    if (this.loadMode_ == shaka.Player.LoadMode.SRC_EQUALS) {\n      shaka.log.error('Cannot add text when loaded with src=');\n      throw new Error('State error!');\n    }\n    if (this.loadMode_ != shaka.Player.LoadMode.MEDIA_SOURCE) {\n      shaka.log.error(\n          'Must call load() and wait for it to resolve before adding text ' +\n          'tracks.');\n      throw new Error('State error!');\n    }\n\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n\n    const duration = this.manifest_.presentationTimeline.getDuration();\n    if (duration == Infinity) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.RECOVERABLE,\n          shaka.util.Error.Category.MANIFEST,\n          shaka.util.Error.Code.CANNOT_ADD_EXTERNAL_TEXT_TO_LIVE_STREAM);\n    }\n\n    /** @type {shaka.extern.Stream} */\n    const stream = {\n      id: this.nextExternalStreamId_++,\n      originalId: null,\n      createSegmentIndex: () => Promise.resolve(),\n      segmentIndex: shaka.media.SegmentIndex.forSingleSegment(\n          /* startTime= */ 0,\n          /* duration= */ duration,\n          /* uris= */ [uri]),\n      mimeType: mime,\n      codecs: codec || '',\n      kind: kind,\n      encrypted: false,\n      drmInfos: [],\n      keyIds: new Set(),\n      language: language,\n      label: label || null,\n      type: ContentType.TEXT,\n      primary: false,\n      trickModeVideo: null,\n      emsgSchemeIdUris: null,\n      roles: [],\n      channelsCount: null,\n      audioSamplingRate: null,\n      closedCaptions: null,\n    };\n\n    this.manifest_.textStreams.push(stream);\n    this.onTracksChanged_();\n    return shaka.util.StreamUtils.textStreamToTrack(stream);\n  }\n\n  /**\n   * Set the maximum resolution that the platform's hardware can handle.\n   * This will be called automatically by <code>shaka.cast.CastReceiver</code>\n   * to enforce limitations of the Chromecast hardware.\n   *\n   * @param {number} width\n   * @param {number} height\n   * @export\n   */\n  setMaxHardwareResolution(width, height) {\n    this.maxHwRes_.width = width;\n    this.maxHwRes_.height = height;\n  }\n\n  /**\n   * Retry streaming after a streaming failure has occurred. When the player has\n   * not loaded content or is loading content, this will be a no-op and will\n   * return <code>false</code>.\n   *\n   * <p>\n   * If the player has loaded content, and streaming has not seen an error, this\n   * will return <code>false</code>.\n   *\n   * <p>\n   * If the player has loaded content, and streaming seen an error, but the\n   * could not resume streaming, this will return <code>false</code>.\n   *\n   * @return {boolean}\n   * @export\n   */\n  retryStreaming() {\n    return this.loadMode_ == shaka.Player.LoadMode.MEDIA_SOURCE ?\n           this.streamingEngine_.retry() :\n           false;\n  }\n\n  /**\n   * Get the manifest that the player has loaded. If the player has not loaded\n   * any content, this will return <code>null</code>.\n   *\n   * NOTE: This structure is NOT covered by semantic versioning compatibility\n   * guarantees.  It may change at any time!\n   *\n   * This is marked as deprecated to warn Closure Compiler users at compile-time\n   * to avoid using this method.\n   *\n   * @return {?shaka.extern.Manifest}\n   * @export\n   * @deprecated\n   */\n  getManifest() {\n    shaka.log.alwaysWarn(\n        'Shaka Player\\'s internal Manifest structure is NOT covered by ' +\n        'semantic versioning compatibility guarantees.  It may change at any ' +\n        'time!  Please consider filing a feature request for whatever you ' +\n        'use getManifest() for.');\n    return this.manifest_;\n  }\n\n  /**\n   * Get the type of manifest parser that the player is using. If the player has\n   * not loaded any content, this will return <code>null</code>.\n   *\n   * @return {?shaka.extern.ManifestParser.Factory}\n   * @export\n   */\n  getManifestParserFactory() {\n    return this.parserFactory_;\n  }\n\n  /**\n   * @param {shaka.extern.Variant} variant\n   * @param {boolean} fromAdaptation\n   * @private\n   */\n  addVariantToSwitchHistory_(variant, fromAdaptation) {\n    const switchHistory = this.stats_.getSwitchHistory();\n    switchHistory.updateCurrentVariant(variant, fromAdaptation);\n  }\n\n  /**\n   * @param {shaka.extern.Stream} textStream\n   * @param {boolean} fromAdaptation\n   * @private\n   */\n  addTextStreamToSwitchHistory_(textStream, fromAdaptation) {\n    const switchHistory = this.stats_.getSwitchHistory();\n    switchHistory.updateCurrentText(textStream, fromAdaptation);\n  }\n\n  /**\n   * @return {shaka.extern.PlayerConfiguration}\n   * @private\n   */\n  defaultConfig_() {\n    const config = shaka.util.PlayerConfiguration.createDefault();\n\n    config.streaming.failureCallback = (error) => {\n      this.defaultStreamingFailureCallback_(error);\n    };\n\n    // Because this.video_ may not be set when the config is built, the default\n    // TextDisplay factory must capture a reference to \"this\".\n    config.textDisplayFactory = () => {\n      if (this.videoContainer_) {\n        return new shaka.text.UITextDisplayer(\n            this.video_, this.videoContainer_);\n      } else {\n        return new shaka.text.SimpleTextDisplayer(this.video_);\n      }\n    };\n    return config;\n  }\n\n  /**\n   * Set the videoContainer to construct UITextDisplayer.\n   * @param {HTMLElement} videoContainer\n   * @export\n   */\n  setVideoContainer(videoContainer) {\n    this.videoContainer_ = videoContainer;\n  }\n\n  /**\n   * @param {!shaka.util.Error} error\n   * @private\n   */\n  defaultStreamingFailureCallback_(error) {\n    const retryErrorCodes = [\n      shaka.util.Error.Code.BAD_HTTP_STATUS,\n      shaka.util.Error.Code.HTTP_ERROR,\n      shaka.util.Error.Code.TIMEOUT,\n    ];\n\n    if (this.isLive() && retryErrorCodes.includes(error.code)) {\n      error.severity = shaka.util.Error.Severity.RECOVERABLE;\n\n      shaka.log.warning('Live streaming error.  Retrying automatically...');\n      this.retryStreaming();\n    }\n  }\n\n  /**\n   * For CEA closed captions embedded in the video streams, create dummy text\n   * stream.  This can be safely called again on existing manifests, for\n   * manifest updates.\n   * @param {!shaka.extern.Manifest} manifest\n   * @private\n   */\n  makeTextStreamsForClosedCaptions_(manifest) {\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n    const MimeUtils = shaka.util.MimeUtils;\n    const TextStreamKind = shaka.util.ManifestParserUtils.TextStreamKind;\n\n    // A set, to make sure we don't create two text streams for the same video.\n    const closedCaptionsSet = new Set();\n    for (const textStream of manifest.textStreams) {\n      if (textStream.mimeType == MimeUtils.CLOSED_CAPTION_MIMETYPE) {\n        // This function might be called on a manifest update, so don't make a\n        // new text stream for closed caption streams we have seen before.\n        closedCaptionsSet.add(textStream.originalId);\n      }\n    }\n    for (const variant of manifest.variants) {\n      const video = variant.video;\n      if (video && video.closedCaptions) {\n        for (const id of video.closedCaptions.keys()) {\n          if (!closedCaptionsSet.has(id)) {\n            // Add an empty segmentIndex, for the benefit of the period combiner\n            // in our builtin DASH parser.\n            const segmentIndex = new shaka.media.MetaSegmentIndex();\n            const textStream = {\n              id: this.nextExternalStreamId_++,  // A globally unique ID.\n              originalId: id, // The CC ID string, like 'CC1', 'CC3', etc.\n              createSegmentIndex: () => Promise.resolve(),\n              segmentIndex,\n              mimeType: MimeUtils.CLOSED_CAPTION_MIMETYPE,\n              codecs: '',\n              kind: TextStreamKind.CLOSED_CAPTION,\n              encrypted: false,\n              drmInfos: [],\n              keyIds: new Set(),\n              language: video.closedCaptions.get(id),\n              label: null,\n              type: ContentType.TEXT,\n              primary: false,\n              trickModeVideo: null,\n              emsgSchemeIdUris: null,\n              roles: video.roles,\n              channelsCount: null,\n              audioSamplingRate: null,\n              closedCaptions: null,\n            };\n            manifest.textStreams.push(textStream);\n            closedCaptionsSet.add(id);\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Filters a manifest, removing unplayable streams/variants.\n   *\n   * @param {?shaka.extern.Manifest} manifest\n   * @private\n   */\n  filterManifest_(manifest) {\n    goog.asserts.assert(manifest, 'Manifest should exist!');\n    goog.asserts.assert(this.video_, 'Must not be destroyed');\n    const StreamUtils = shaka.util.StreamUtils;\n\n    /** @type {?shaka.extern.Variant} */\n    const currentVariant = this.streamingEngine_ ?\n        this.streamingEngine_.getCurrentVariant() : null;\n\n    StreamUtils.filterManifest(\n        this.drmEngine_, currentVariant, manifest);\n\n    const valid = manifest.variants.some(StreamUtils.isPlayable);\n\n    // If none of the variants are playable, throw\n    // CONTENT_UNSUPPORTED_BY_BROWSER.\n    if (!valid) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.MANIFEST,\n          shaka.util.Error.Code.CONTENT_UNSUPPORTED_BY_BROWSER);\n    }\n\n    const tracksChanged = shaka.util.StreamUtils.applyRestrictions(\n        manifest.variants, this.config_.restrictions, this.maxHwRes_);\n    if (tracksChanged && this.streamingEngine_) {\n      this.onTracksChanged_();\n    }\n\n    // We may need to create new sessions for any new init data.\n    const curDrmInfo = this.drmEngine_ ? this.drmEngine_.getDrmInfo() : null;\n    if (curDrmInfo) {\n      for (const variant of manifest.variants) {\n        const videoDrmInfos = variant.video ? variant.video.drmInfos : [];\n        const audioDrmInfos = variant.audio ? variant.audio.drmInfos : [];\n        const drmInfos = videoDrmInfos.concat(audioDrmInfos);\n        for (const drmInfo of drmInfos) {\n          // Ignore any data for different key systems.\n          if (drmInfo.keySystem == curDrmInfo.keySystem) {\n            for (const initData of (drmInfo.initData || [])) {\n              this.drmEngine_.newInitData(\n                  initData.initDataType, initData.initData);\n            }\n          }\n        }\n      }\n    }\n\n    this.checkRestrictedVariants_(manifest);\n  }\n\n  /**\n   * @param {shaka.extern.Variant} initialVariant\n   * @param {number} time\n   * @return {!Promise.<number>}\n   * @private\n   */\n  async adjustStartTime_(initialVariant, time) {\n    /** @type {?shaka.extern.Stream} */\n    const activeAudio = initialVariant.audio;\n    /** @type {?shaka.extern.Stream} */\n    const activeVideo = initialVariant.video;\n\n    /**\n     * @param {?shaka.extern.Stream} stream\n     * @param {number} time\n     * @return {!Promise.<?number>}\n     */\n    const getAdjustedTime = async (stream, time) => {\n      if (!stream) {\n        return null;\n      }\n\n      await stream.createSegmentIndex();\n      const ref = stream.segmentIndex[Symbol.iterator]().seek(time);\n      if (!ref) {\n        return null;\n      }\n\n      const refTime = ref.startTime;\n      goog.asserts.assert(refTime <= time,\n          'Segment should start before target time!');\n      return refTime;\n    };\n\n    const audioStartTime = await getAdjustedTime(activeAudio, time);\n    const videoStartTime = await getAdjustedTime(activeVideo, time);\n\n    // If we have both video and audio times, pick the larger one.  If we picked\n    // the smaller one, that one will download an entire segment to buffer the\n    // difference.\n    if (videoStartTime != null && audioStartTime != null) {\n      return Math.max(videoStartTime, audioStartTime);\n    } else if (videoStartTime != null) {\n      return videoStartTime;\n    } else if (audioStartTime != null) {\n      return audioStartTime;\n    } else {\n      return time;\n    }\n  }\n\n  /**\n   * Update the buffering state to be either \"we are buffering\" or \"we are not\n   * buffering\", firing events to the app as needed.\n   *\n   * @private\n   */\n  updateBufferState_() {\n    const isBuffering = this.isBuffering();\n    shaka.log.v2('Player changing buffering state to', isBuffering);\n\n    // Make sure we have all the components we need before we consider ourselves\n    // as being loaded.\n    // TODO: Make the check for \"loaded\" simpler.\n    const loaded = this.stats_ && this.bufferObserver_ && this.playhead_;\n\n    if (loaded) {\n      this.playRateController_.setBuffering(isBuffering);\n      this.updateStateHistory_();\n    }\n\n    // Surface the buffering event so that the app knows if/when we are\n    // buffering.\n    const eventName = shaka.Player.EventName.Buffering;\n    this.dispatchEvent(this.makeEvent_(eventName, {'buffering': isBuffering}));\n  }\n\n  /**\n   * A callback for when the playback rate changes. We need to watch the\n   * playback rate so that if the playback rate on the media element changes\n   * (that was not caused by our play rate controller) we can notify the\n   * controller so that it can stay in-sync with the change.\n   *\n   * @private\n   */\n  onRateChange_() {\n    /** @type {number} */\n    const newRate = this.video_.playbackRate;\n\n    // On Edge, when someone seeks using the native controls, it will set the\n    // playback rate to zero until they finish seeking, after which it will\n    // return the playback rate.\n    //\n    // If the playback rate changes while seeking, Edge will cache the playback\n    // rate and use it after seeking.\n    //\n    // https://github.com/google/shaka-player/issues/951\n    if (newRate == 0) {\n      return;\n    }\n\n    if (this.playRateController_) {\n      // The playback rate has changed. This could be us or someone else.\n      // If this was us, setting the rate again will be a no-op.\n      this.playRateController_.set(newRate);\n    }\n\n    const event = this.makeEvent_(shaka.Player.EventName.RateChange);\n    this.dispatchEvent(event);\n  }\n\n  /**\n   * Try updating the state history. If the player has not finished\n   * initializing, this will be a no-op.\n   *\n   * @private\n   */\n  updateStateHistory_() {\n    // If we have not finish initializing, this will be a no-op.\n    if (!this.stats_) {\n      return;\n    }\n    if (!this.bufferObserver_) {\n      return;\n    }\n\n    const State = shaka.media.BufferingObserver.State;\n\n    const history = this.stats_.getStateHistory();\n\n    if (this.bufferObserver_.getState() == State.STARVING) {\n      history.update('buffering');\n    } else if (this.video_.paused) {\n      history.update('paused');\n    } else if (this.video_.ended) {\n      history.update('ended');\n    } else {\n      history.update('playing');\n    }\n  }\n\n  /**\n   * Callback from Playhead.\n   *\n   * @private\n   */\n  onSeek_() {\n    if (this.playheadObservers_) {\n      this.playheadObservers_.notifyOfSeek();\n    }\n    if (this.streamingEngine_) {\n      this.streamingEngine_.seeked();\n    }\n    if (this.bufferObserver_) {\n      // If we seek into an unbuffered range, we should fire a 'buffering' event\n      // immediately.  If StreamingEngine can buffer fast enough, we may not\n      // update our buffering tracking otherwise.\n      this.pollBufferState_();\n    }\n  }\n\n  /**\n   * Update AbrManager with variants while taking into account restrictions,\n   * preferences, and ABR.\n   *\n   * On error, this dispatches an error event and returns false.\n   *\n   * @return {boolean} True if successful.\n   * @private\n   */\n  updateAbrManagerVariants_() {\n    try {\n      goog.asserts.assert(this.manifest_, 'Manifest should exist by now!');\n      this.checkRestrictedVariants_(this.manifest_);\n    } catch (e) {\n      this.onError_(e);\n      return false;\n    }\n\n    const playableVariants = this.manifest_.variants.filter((variant) => {\n      return shaka.util.StreamUtils.isPlayable(variant);\n    });\n\n    // Update the abr manager with newly filtered variants.\n    const adaptationSet = this.currentAdaptationSetCriteria_.create(\n        playableVariants);\n    this.abrManager_.setVariants(Array.from(adaptationSet.values()));\n    return true;\n  }\n\n  /**\n   * Chooses a variant from all possible variants while taking into account\n   * restrictions, preferences, and ABR.\n   *\n   * On error, this dispatches an error event and returns null.\n   *\n   * @return {?shaka.extern.Variant}\n   * @private\n   */\n  chooseVariant_() {\n    if (this.updateAbrManagerVariants_()) {\n      return this.abrManager_.chooseVariant();\n    } else {\n      return null;\n    }\n  }\n\n  /**\n   * Choose a text stream from all possible text streams while taking into\n   * account user preference.\n   *\n   * @return {?shaka.extern.Stream}\n   * @private\n   */\n  chooseTextStream_() {\n    const subset = shaka.util.StreamUtils.filterStreamsByLanguageAndRole(\n        this.manifest_.textStreams,\n        this.currentTextLanguage_,\n        this.currentTextRole_);\n    return subset[0] || null;\n  }\n\n  /**\n   * Chooses a new Variant.  If the new variant differs from the old one, it\n   * adds the new one to the switch history and switches to it.\n   *\n   * Called after a config change, a key status event, or an explicit language\n   * change.\n   *\n   * @private\n   */\n  chooseVariantAndSwitch_() {\n    goog.asserts.assert(this.config_, 'Must not be destroyed');\n\n    // Because we're running this after a config change (manual language\n    // change) or a key status event, it is always okay to clear the buffer\n    // here.\n    const chosenVariant = this.chooseVariant_();\n    if (chosenVariant) {\n      if (chosenVariant == this.streamingEngine_.getCurrentVariant()) {\n        shaka.log.debug('Variant already selected.');\n        return;\n      }\n\n      this.addVariantToSwitchHistory_(\n          chosenVariant, /* fromAdaptation= */ true);\n      this.streamingEngine_.switchVariant(\n          chosenVariant, /* clearBuffers= */ true, /* safeMargin= */ 0);\n      // Dispatch a 'variantchanged' event\n      this.onVariantChanged_();\n    }\n\n    // Send an adaptation event so that the UI can show the new\n    // language/tracks.\n    this.onAdaptation_();\n  }\n\n  /**\n   * Decide during startup if text should be streamed/shown.\n   * @private\n   */\n  setInitialTextState_(initialVariant, initialTextStream) {\n    // Check if we should show text (based on difference between audio and text\n    // languages).\n    if (initialTextStream) {\n      if (initialVariant.audio && this.shouldInitiallyShowText_(\n          initialVariant.audio, initialTextStream)) {\n        this.isTextVisible_ = true;\n      }\n      if (this.isTextVisible_) {\n        // If the cached value says to show text, then update the text displayer\n        // since it defaults to not shown.\n        this.mediaSourceEngine_.getTextDisplayer().setTextVisibility(true);\n        goog.asserts.assert(this.shouldStreamText_(),\n            'Should be streaming text');\n      }\n      this.onTextTrackVisibility_();\n    } else {\n      this.isTextVisible_ = false;\n    }\n  }\n\n  /**\n   * Check if we should show text on screen automatically.\n   *\n   * The text should automatically be shown if the text is language-compatible\n   * with the user's text language preference, but not compatible with the\n   * audio.\n   *\n   * For example:\n   *   preferred | chosen | chosen |\n   *   text      | text   | audio  | show\n   *   -----------------------------------\n   *   en-CA     | en     | jp     | true\n   *   en        | en-US  | fr     | true\n   *   fr-CA     | en-US  | jp     | false\n   *   en-CA     | en-US  | en-US  | false\n   *\n   * @param {shaka.extern.Stream} audioStream\n   * @param {shaka.extern.Stream} textStream\n   * @return {boolean}\n   * @private\n   */\n  shouldInitiallyShowText_(audioStream, textStream) {\n    const LanguageUtils = shaka.util.LanguageUtils;\n\n    /** @type {string} */\n    const preferredTextLocale =\n        LanguageUtils.normalize(this.config_.preferredTextLanguage);\n    /** @type {string} */\n    const audioLocale = LanguageUtils.normalize(audioStream.language);\n    /** @type {string} */\n    const textLocale = LanguageUtils.normalize(textStream.language);\n\n    return (\n      LanguageUtils.areLanguageCompatible(textLocale, preferredTextLocale) &&\n      !LanguageUtils.areLanguageCompatible(audioLocale, textLocale));\n  }\n\n  /**\n   * Callback from StreamingEngine.\n   *\n   * @private\n   */\n  onManifestUpdate_() {\n    if (this.parser_ && this.parser_.update) {\n      this.parser_.update();\n    }\n  }\n\n  /**\n   * Callback from StreamingEngine.\n   *\n   * @private\n   */\n  onSegmentAppended_() {\n    // When we append a segment to media source (via streaming engine) we are\n    // changing what data we have buffered, so notify the playhead of the\n    // change.\n    if (this.playhead_) {\n      this.playhead_.notifyOfBufferingChange();\n    }\n    this.pollBufferState_();\n  }\n\n  /**\n   * Callback from AbrManager.\n   *\n   * @param {shaka.extern.Variant} variant\n   * @param {boolean=} clearBuffer\n   * @param {number=} safeMargin Optional amount of buffer (in seconds) to\n   *   retain when clearing the buffer.\n   *   Defaults to 0 if not provided. Ignored if clearBuffer is false.\n   * @private\n   */\n  switch_(variant, clearBuffer = false, safeMargin = 0) {\n    shaka.log.debug('switch_');\n    goog.asserts.assert(this.config_.abr.enabled,\n        'AbrManager should not call switch while disabled!');\n    goog.asserts.assert(this.manifest_, 'We need a manifest to switch ' +\n                                        'variants.');\n\n    if (!this.streamingEngine_) {\n      // There's no way to change it.\n      return;\n    }\n\n    if (variant == this.streamingEngine_.getCurrentVariant()) {\n      // This isn't a change.\n      return;\n    }\n\n    this.addVariantToSwitchHistory_(variant, /* fromAdaptation= */ true);\n    this.streamingEngine_.switchVariant(variant, clearBuffer, safeMargin);\n    this.onAdaptation_();\n  }\n\n  /**\n   * Dispatches an 'adaptation' event.\n   * @private\n   */\n  onAdaptation_() {\n    // Delay the 'adaptation' event so that StreamingEngine has time to absorb\n    // the changes before the user tries to query it.\n    const event = this.makeEvent_(shaka.Player.EventName.Adaptation);\n    this.delayDispatchEvent_(event);\n  }\n\n  /**\n   * Dispatches a 'trackschanged' event.\n   * @private\n   */\n  onTracksChanged_() {\n    // Delay the 'trackschanged' event so StreamingEngine has time to absorb the\n    // changes before the user tries to query it.\n    const event = this.makeEvent_(shaka.Player.EventName.TracksChanged);\n    this.delayDispatchEvent_(event);\n  }\n\n  /**\n   * Dispatches a 'variantchanged' event.\n   * @private\n   */\n  onVariantChanged_() {\n    // Delay the 'variantchanged' event so StreamingEngine has time to absorb\n    // the changes before the user tries to query it.\n    const event = this.makeEvent_(shaka.Player.EventName.VariantChanged);\n    this.delayDispatchEvent_(event);\n  }\n\n  /**\n   * Dispatches a 'textchanged' event.\n   * @private\n   */\n  onTextChanged_() {\n    // Delay the 'textchanged' event so StreamingEngine time to absorb the\n    // changes before the user tries to query it.\n    const event = this.makeEvent_(shaka.Player.EventName.TextChanged);\n    this.delayDispatchEvent_(event);\n  }\n\n  /** @private */\n  onTextTrackVisibility_() {\n    const event = this.makeEvent_(shaka.Player.EventName.TextTrackVisibility);\n    this.delayDispatchEvent_(event);\n  }\n\n  /** @private */\n  onAbrStatusChanged_() {\n    const event = this.makeEvent_(shaka.Player.EventName.AbrStatusChanged, {\n      newStatus: this.config_.abr.enabled,\n    });\n    this.delayDispatchEvent_(event);\n  }\n\n  /**\n   * @param {!shaka.util.Error} error\n   * @private\n   */\n  onError_(error) {\n    goog.asserts.assert(error instanceof shaka.util.Error, 'Wrong error type!');\n\n    // Errors dispatched after |destroy| is called are not meaningful and should\n    // be safe to ignore.\n    if (this.loadMode_ == shaka.Player.LoadMode.DESTROYED) {\n      return;\n    }\n\n    const eventName = shaka.Player.EventName.Error;\n    const event = this.makeEvent_(eventName, {'detail': error});\n    this.dispatchEvent(event);\n    if (event.defaultPrevented) {\n      error.handled = true;\n    }\n  }\n\n  /**\n   * When we fire region events, we need to copy the information out of the\n   * region to break the connection with the player's internal data. We do the\n   * copy here because this is the transition point between the player and the\n   * app.\n   *\n   * @param {!shaka.Player.EventName} eventName\n   * @param {shaka.extern.TimelineRegionInfo} region\n   *\n   * @private\n   */\n  onRegionEvent_(eventName, region) {\n    // Always make a copy to avoid exposing our internal data to the app.\n    const clone = {\n      schemeIdUri: region.schemeIdUri,\n      value: region.value,\n      startTime: region.startTime,\n      endTime: region.endTime,\n      id: region.id,\n      eventElement: region.eventElement,\n    };\n\n    this.dispatchEvent(this.makeEvent_(eventName, {detail: clone}));\n  }\n\n  /**\n   * Turn the media element's error object into a Shaka Player error object.\n   *\n   * @return {shaka.util.Error}\n   * @private\n   */\n  videoErrorToShakaError_() {\n    goog.asserts.assert(this.video_.error,\n        'Video error expected, but missing!');\n    if (!this.video_.error) {\n      return null;\n    }\n\n    const code = this.video_.error.code;\n    if (code == 1 /* MEDIA_ERR_ABORTED */) {\n      // Ignore this error code, which should only occur when navigating away or\n      // deliberately stopping playback of HTTP content.\n      return null;\n    }\n\n    // Extra error information from MS Edge and IE11:\n    let extended = this.video_.error.msExtendedCode;\n    if (extended) {\n      // Convert to unsigned:\n      if (extended < 0) {\n        extended += Math.pow(2, 32);\n      }\n      // Format as hex:\n      extended = extended.toString(16);\n    }\n\n    // Extra error information from Chrome:\n    const message = this.video_.error.message;\n\n    return new shaka.util.Error(\n        shaka.util.Error.Severity.CRITICAL,\n        shaka.util.Error.Category.MEDIA,\n        shaka.util.Error.Code.VIDEO_ERROR,\n        code, extended, message);\n  }\n\n  /**\n   * @param {!Event} event\n   * @private\n   */\n  onVideoError_(event) {\n    const error = this.videoErrorToShakaError_();\n    if (!error) {\n      return;\n    }\n    this.onError_(error);\n  }\n\n  /**\n   * @param {!Object.<string, string>} keyStatusMap A map of hex key IDs to\n   *   statuses.\n   * @private\n   */\n  onKeyStatus_(keyStatusMap) {\n    if (!this.streamingEngine_) {\n      // We can't use this info to manage restrictions in src= mode, so ignore\n      // it.\n      return;\n    }\n\n    const keyIds = Object.keys(keyStatusMap);\n    if (keyIds.length == 0) {\n      shaka.log.warning(\n          'Got a key status event without any key statuses, so we don\\'t ' +\n          'know the real key statuses. If we don\\'t have all the keys, ' +\n          'you\\'ll need to set restrictions so we don\\'t select those tracks.');\n    }\n\n    // If EME is using a synthetic key ID, the only key ID is '00' (a single 0\n    // byte).  In this case, it is only used to report global success/failure.\n    // See note about old platforms in: https://bit.ly/2tpez5Z\n    const isGlobalStatus = keyIds.length == 1 && keyIds[0] == '00';\n    if (isGlobalStatus) {\n      shaka.log.warning(\n          'Got a synthetic key status event, so we don\\'t know the real key ' +\n          'statuses. If we don\\'t have all the keys, you\\'ll need to set ' +\n          'restrictions so we don\\'t select those tracks.');\n    }\n\n    const restrictedStatuses = shaka.Player.restrictedStatuses_;\n    let tracksChanged = false;\n\n    // Only filter tracks for keys if we have some key statuses to look at.\n    if (keyIds.length) {\n      for (const variant of this.manifest_.variants) {\n        const streams = shaka.util.StreamUtils.getVariantStreams(variant);\n\n        for (const stream of streams) {\n          const originalAllowed = variant.allowedByKeySystem;\n\n          // Only update if we have key IDs for the stream.  If the keys aren't\n          // all present, then the track should be restricted.\n          if (stream.keyIds.size) {\n            variant.allowedByKeySystem = true;\n\n            for (const keyId of stream.keyIds) {\n              const keyStatus = keyStatusMap[isGlobalStatus ? '00' : keyId];\n              variant.allowedByKeySystem = variant.allowedByKeySystem &&\n                  !!keyStatus && !restrictedStatuses.includes(keyStatus);\n            }\n          }\n\n          if (originalAllowed != variant.allowedByKeySystem) {\n            tracksChanged = true;\n          }\n        }  // for (const stream of streams)\n      }  // for (const variant of this.manifest_.variants)\n    }  // if (keyIds.size)\n\n    if (tracksChanged) {\n      this.updateAbrManagerVariants_();\n    }\n\n    const currentVariant = this.streamingEngine_.getCurrentVariant();\n    if (currentVariant && !currentVariant.allowedByKeySystem) {\n      shaka.log.debug('Choosing new streams after key status changed');\n      this.chooseVariantAndSwitch_();\n    }\n\n    if (tracksChanged) {\n      this.onTracksChanged_();\n    }\n  }\n\n  /**\n   * Callback from DrmEngine\n   * @param {string} keyId\n   * @param {number} expiration\n   * @private\n   */\n  onExpirationUpdated_(keyId, expiration) {\n    if (this.parser_ && this.parser_.onExpirationUpdated) {\n      this.parser_.onExpirationUpdated(keyId, expiration);\n    }\n\n    const event = this.makeEvent_(shaka.Player.EventName.ExpirationUpdated);\n    this.dispatchEvent(event);\n  }\n\n  /**\n   * @return {boolean} true if we should stream text right now.\n   * @private\n   */\n  shouldStreamText_() {\n    return this.config_.streaming.alwaysStreamText || this.isTextTrackVisible();\n  }\n\n  /**\n   * Applies playRangeStart and playRangeEnd to the given timeline. This will\n   * only affect non-live content.\n   *\n   * @param {shaka.media.PresentationTimeline} timeline\n   * @param {number} playRangeStart\n   * @param {number} playRangeEnd\n   *\n   * @private\n   */\n  static applyPlayRange_(timeline, playRangeStart, playRangeEnd) {\n    if (playRangeStart > 0) {\n      if (timeline.isLive()) {\n        shaka.log.warning(\n            '|playRangeStart| has been configured for live content. ' +\n            'Ignoring the setting.');\n      } else {\n        timeline.setUserSeekStart(playRangeStart);\n      }\n    }\n\n    // If the playback has been configured to end before the end of the\n    // presentation, update the duration unless it's live content.\n    const fullDuration = timeline.getDuration();\n    if (playRangeEnd < fullDuration) {\n      if (timeline.isLive()) {\n        shaka.log.warning(\n            '|playRangeEnd| has been configured for live content. ' +\n            'Ignoring the setting.');\n      } else {\n        timeline.setDuration(playRangeEnd);\n      }\n    }\n  }\n\n  /**\n   * Checks if the variants are all restricted, and throw an appropriate\n   * exception if so.\n   *\n   * @param {shaka.extern.Manifest} manifest\n   *\n   * @private\n   */\n  checkRestrictedVariants_(manifest) {\n    const restrictedStatuses = shaka.Player.restrictedStatuses_;\n    const keyStatusMap =\n        this.drmEngine_ ? this.drmEngine_.getKeyStatuses() : {};\n    const keyIds = Object.keys(keyStatusMap);\n    const isGlobalStatus = keyIds.length && keyIds[0] == '00';\n\n    let hasPlayable = false;\n    let hasAppRestrictions = false;\n\n    /** @type {!Set.<string>} */\n    const missingKeys = new Set();\n\n    /** @type {!Set.<string>} */\n    const badKeyStatuses = new Set();\n\n    for (const variant of manifest.variants) {\n      // TODO: Combine with onKeyStatus_.\n      const streams = [];\n      if (variant.audio) {\n        streams.push(variant.audio);\n      }\n      if (variant.video) {\n        streams.push(variant.video);\n      }\n\n      for (const stream of streams) {\n        if (stream.keyIds.size) {\n          for (const keyId of stream.keyIds) {\n            const keyStatus = keyStatusMap[isGlobalStatus ? '00' : keyId];\n            if (!keyStatus) {\n              missingKeys.add(keyId);\n            } else if (restrictedStatuses.includes(keyStatus)) {\n              badKeyStatuses.add(keyStatus);\n            }\n          }\n        }  // if (stream.keyIds.size)\n      }\n\n      if (!variant.allowedByApplication) {\n        hasAppRestrictions = true;\n      } else if (variant.allowedByKeySystem) {\n        hasPlayable = true;\n      }\n    }\n\n    if (!hasPlayable) {\n      /** @type {shaka.extern.RestrictionInfo} */\n      const data = {\n        hasAppRestrictions,\n        missingKeys: Array.from(missingKeys),\n        restrictedKeyStatuses: Array.from(badKeyStatuses),\n      };\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.MANIFEST,\n          shaka.util.Error.Code.RESTRICTIONS_CANNOT_BE_MET,\n          data);\n    }\n  }\n\n  /**\n   * Fire an event, but wait a little bit so that the immediate execution can\n   * complete before the event is handled.\n   *\n   * @param {!shaka.util.FakeEvent} event\n   * @private\n   */\n  async delayDispatchEvent_(event) {\n    // Wait until the next interpreter cycle.\n    await Promise.resolve();\n\n    // Only dispatch the event if we are still alive.\n    if (this.loadMode_ != shaka.Player.LoadMode.DESTROYED) {\n      this.dispatchEvent(event);\n    }\n  }\n\n  /**\n   * Get the normalized languages for a group of tracks.\n   *\n   * @param {!Array.<?shaka.extern.Track>} tracks\n   * @return {!Set.<string>}\n   * @private\n   */\n  static getLanguagesFrom_(tracks) {\n    const languages = new Set();\n\n    for (const track of tracks) {\n      if (track.language) {\n        languages.add(shaka.util.LanguageUtils.normalize(track.language));\n      } else {\n        languages.add('und');\n      }\n    }\n\n    return languages;\n  }\n\n  /**\n   * Get all permutations of normalized languages and role for a group of\n   * tracks.\n   *\n   * @param {!Array.<?shaka.extern.Track>} tracks\n   * @return {!Array.<shaka.extern.LanguageRole>}\n   * @private\n   */\n  static getLanguageAndRolesFrom_(tracks) {\n    /** @type {!Map.<string, !Set>} */\n    const languageToRoles = new Map();\n\n    for (const track of tracks) {\n      let language = 'und';\n      let roles = [];\n\n      if (track.language) {\n        language = shaka.util.LanguageUtils.normalize(track.language);\n      }\n\n      if (track.type == 'variant') {\n        roles = track.audioRoles;\n      } else {\n        roles = track.roles;\n      }\n\n      if (!roles || !roles.length) {\n        // We must have an empty role so that we will still get a language-role\n        // entry from our Map.\n        roles = [''];\n      }\n\n      if (!languageToRoles.has(language)) {\n        languageToRoles.set(language, new Set());\n      }\n\n      for (const role of roles) {\n        languageToRoles.get(language).add(role);\n      }\n    }\n\n    // Flatten our map to an array of language-role pairs.\n    const pairings = [];\n    languageToRoles.forEach((roles, language) => {\n      for (const role of roles) {\n        pairings.push({\n          language: language,\n          role: role,\n        });\n      }\n    });\n    return pairings;\n  }\n\n  /**\n   * Assuming the player is playing content with media source, check if the\n   * player has buffered enough content to make it to the end of the\n   * presentation.\n   *\n   * @return {boolean}\n   * @private\n   */\n  isBufferedToEndMS_() {\n    goog.asserts.assert(\n        this.video_,\n        'We need a video element to get buffering information');\n    goog.asserts.assert(\n        this.mediaSourceEngine_,\n        'We need a media source engine to get buffering information');\n    goog.asserts.assert(\n        this.manifest_,\n        'We need a manifest to get buffering information');\n\n    // This is a strong guarantee that we are buffered to the end, because it\n    // means the playhead is already at that end.\n    if (this.video_.ended) {\n      return true;\n    }\n\n    // This means that MediaSource has buffered the final segment in all\n    // SourceBuffers and is no longer accepting additional segments.\n    if (this.mediaSourceEngine_.ended()) {\n      return true;\n    }\n\n    // Live streams are \"buffered to the end\" when they have buffered to the\n    // live edge or beyond (into the region covered by the presentation delay).\n    if (this.manifest_.presentationTimeline.isLive()) {\n      const liveEdge =\n          this.manifest_.presentationTimeline.getSegmentAvailabilityEnd();\n      const bufferEnd =\n          shaka.media.TimeRangesUtils.bufferEnd(this.video_.buffered);\n\n      if (bufferEnd != null && bufferEnd >= liveEdge) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * Assuming the player is playing content with src=, check if the player has\n   * buffered enough content to make it to the end of the presentation.\n   *\n   * @return {boolean}\n   * @private\n   */\n  isBufferedToEndSrc_() {\n    goog.asserts.assert(\n        this.video_,\n        'We need a video element to get buffering information');\n\n    // This is a strong guarantee that we are buffered to the end, because it\n    // means the playhead is already at that end.\n    if (this.video_.ended) {\n      return true;\n    }\n\n    // If we have buffered to the duration of the content, it means we will have\n    // enough content to buffer to the end of the presentation.\n    const bufferEnd =\n        shaka.media.TimeRangesUtils.bufferEnd(this.video_.buffered);\n\n    // Because Safari's native HLS reports slightly inaccurate values for\n    // bufferEnd here, we use a fudge factor.  Without this, we can end up in a\n    // buffering state at the end of the stream.  See issue #2117.\n    // TODO: Try to remove the fudge here once we no longer manage buffering\n    // state above the browser with playbackRate=0.\n    const fudge = 1;  // 1000 ms\n    return bufferEnd != null && bufferEnd >= this.video_.duration - fudge;\n  }\n\n  /**\n   * Create an error for when we purposely interrupt a load operation.\n   *\n   * @return {!shaka.util.Error}\n   * @private\n   */\n  createAbortLoadError_() {\n    return new shaka.util.Error(\n        shaka.util.Error.Severity.CRITICAL,\n        shaka.util.Error.Category.PLAYER,\n        shaka.util.Error.Code.LOAD_INTERRUPTED);\n  }\n\n  /**\n   * Key\n   * ----------------------\n   * D   : Detach Node\n   * A   : Attach Node\n   * MS  : Media Source Node\n   * P   : Manifest Parser Node\n   * M   : Manifest Node\n   * DRM : Drm Engine Node\n   * L   : Load Node\n   * U   : Unloading Node\n   * SRC : Src Equals Node\n   *\n   * Graph Topology\n   * ----------------------\n   *\n   *        [SRC]-----+\n   *         ^        |\n   *         |        v\n   * [D]<-->[A]<-----[U]\n   *         |        ^\n   *         v        |\n   *        [MS]------+\n   *         |        |\n   *         v        |\n   *        [P]-------+\n   *         |        |\n   *         v        |\n   *        [M]-------+\n   *         |        |\n   *         v        |\n   *        [DRM]-----+\n   *         |        |\n   *         v        |\n   *        [L]-------+\n   *\n   * @param {!shaka.routing.Node} currentlyAt\n   * @param {shaka.routing.Payload} currentlyWith\n   * @param {!shaka.routing.Node} wantsToBeAt\n   * @param {shaka.routing.Payload} wantsToHave\n   * @return {?shaka.routing.Node}\n   * @private\n   */\n  getNextStep_(currentlyAt, currentlyWith, wantsToBeAt, wantsToHave) {\n    let next = null;\n\n    // Detach is very simple, either stay in detach (because |detach| was called\n    // while in detached) or go somewhere that requires us to attach to an\n    // element.\n    if (currentlyAt == this.detachNode_) {\n      next = wantsToBeAt == this.detachNode_ ?\n             this.detachNode_ :\n             this.attachNode_;\n    }\n\n    if (currentlyAt == this.attachNode_) {\n      next = this.getNextAfterAttach_(wantsToBeAt, currentlyWith, wantsToHave);\n    }\n\n    if (currentlyAt == this.mediaSourceNode_) {\n      next = this.getNextAfterMediaSource_(\n          wantsToBeAt, currentlyWith, wantsToHave);\n    }\n\n    if (currentlyAt == this.parserNode_) {\n      next = this.getNextMatchingAllDependencies_(\n          /* destination= */ this.loadNode_,\n          /* next= */ this.manifestNode_,\n          /* reset= */ this.unloadNode_,\n          /* goingTo= */ wantsToBeAt,\n          /* has= */ currentlyWith,\n          /* wants= */ wantsToHave);\n    }\n\n    if (currentlyAt == this.manifestNode_) {\n      next = this.getNextMatchingAllDependencies_(\n          /* destination= */ this.loadNode_,\n          /* next= */ this.drmNode_,\n          /* reset= */ this.unloadNode_,\n          /* goingTo= */ wantsToBeAt,\n          /* has= */ currentlyWith,\n          /* wants= */ wantsToHave);\n    }\n\n    // For DRM, we have two options \"load\" or \"unload\". If all our constraints\n    // are met, we can go to \"load\". If anything is off, we must go back to\n    // \"unload\" to reset.\n    if (currentlyAt == this.drmNode_) {\n      next = this.getNextMatchingAllDependencies_(\n          /* destination= */ this.loadNode_,\n          /* next= */ this.loadNode_,\n          /* reset= */ this.unloadNode_,\n          /* goingTo= */ wantsToBeAt,\n          /* has= */ currentlyWith,\n          /* wants= */ wantsToHave);\n    }\n\n    // For DRM w/ src= playback, we only care about destination and media\n    // element.\n    if (currentlyAt == this.srcEqualsDrmNode_) {\n      if (wantsToBeAt == this.srcEqualsNode_ &&\n          currentlyWith.mediaElement == wantsToHave.mediaElement) {\n        next = this.srcEqualsNode_;\n      } else {\n        next = this.unloadNode_;\n      }\n    }\n\n    // After we load content, always go through unload because we can't safely\n    // use components after we have started playback.\n    if (currentlyAt == this.loadNode_ || currentlyAt == this.srcEqualsNode_) {\n      next = this.unloadNode_;\n    }\n\n    if (currentlyAt == this.unloadNode_) {\n      next = this.getNextAfterUnload_(wantsToBeAt, currentlyWith, wantsToHave);\n    }\n\n    goog.asserts.assert(next, 'Missing next step!');\n    return next;\n  }\n\n  /**\n   * @param {!shaka.routing.Node} goingTo\n   * @param {shaka.routing.Payload} has\n   * @param {shaka.routing.Payload} wants\n   * @return {?shaka.routing.Node}\n   * @private\n   */\n  getNextAfterAttach_(goingTo, has, wants) {\n    // Attach and detach are the only two nodes that we can directly go\n    // back-and-forth between.\n    if (goingTo == this.detachNode_) {\n      return this.detachNode_;\n    }\n\n    // If we are going anywhere other than detach, then we need the media\n    // element to match, if they don't match, we need to go through detach\n    // first.\n    if (has.mediaElement != wants.mediaElement) {\n      return this.detachNode_;\n    }\n\n    // If we are already in attached, and someone calls |attach| again (to the\n    // same video element), we can handle the redundant request by re-entering\n    // our current state.\n    if (goingTo == this.attachNode_) {\n      return this.attachNode_;\n    }\n\n    // The next step from attached to loaded is through media source.\n    if (goingTo == this.mediaSourceNode_ || goingTo == this.loadNode_) {\n      return this.mediaSourceNode_;\n    }\n\n    // If we are going to src=, then we should set up DRM first.  This will\n    // support cases like FairPlay HLS on Safari.\n    if (goingTo == this.srcEqualsNode_) {\n      return this.srcEqualsDrmNode_;\n    }\n\n    // We are missing a rule, the null will get caught by a common check in\n    // the routing system.\n    return null;\n  }\n\n  /**\n   * @param {!shaka.routing.Node} goingTo\n   * @param {shaka.routing.Payload} has\n   * @param {shaka.routing.Payload} wants\n   * @return {?shaka.routing.Node}\n   * @private\n   */\n  getNextAfterMediaSource_(goingTo, has, wants) {\n    // We can only go to parse manifest or unload. If we want to go to load and\n    // we have the right media element, we can go to parse manifest. If we\n    // don't, no matter where we want to go, we must go through unload.\n    if (goingTo == this.loadNode_ && has.mediaElement == wants.mediaElement) {\n      return this.parserNode_;\n    }\n\n    // Right now the unload node is responsible for tearing down all playback\n    // components (including media source). So since we have created media\n    // source, we need to unload since our dependencies are not compatible.\n    //\n    // TODO: We are structured this way to maintain a historic structure. Going\n    //       forward, there is no reason to restrict ourselves to this. Going\n    //       forward we should explore breaking apart |onUnload| and develop\n    //       more meaningful terminology around tearing down playback resources.\n    return this.unloadNode_;\n  }\n\n  /**\n   * After unload there are only two options, attached or detached. This choice\n   * is based on whether or not we have a media element. If we have a media\n   * element, then we go to attach. If we don't have a media element, we go to\n   * detach.\n   *\n   * @param {!shaka.routing.Node} goingTo\n   * @param {shaka.routing.Payload} has\n   * @param {shaka.routing.Payload} wants\n   * @return {?shaka.routing.Node}\n   * @private\n   */\n  getNextAfterUnload_(goingTo, has, wants) {\n    // If we don't want a media element, detach.\n    // If we have the wrong media element, detach.\n    // Otherwise it means we want to attach to a media element and it is safe to\n    // do so.\n    return !wants.mediaElement || has.mediaElement != wants.mediaElement ?\n           this.detachNode_ :\n           this.attachNode_;\n  }\n\n  /**\n   * A general method used to handle routing when we can either than one step\n   * toward our destination (while all our dependencies match) or go to a node\n   * that will reset us so we can try again.\n   *\n   * @param {!shaka.routing.Node} destinationNode\n   *   What |goingTo| must be for us to step toward |nextNode|. Otherwise we\n   *   will go to |resetNode|.\n   * @param {!shaka.routing.Node} nextNode\n   *   The node we will go to next if |goingTo == destinationNode| and all\n   *   dependencies match.\n   * @param {!shaka.routing.Node} resetNode\n   *   The node we will go to next if |goingTo != destinationNode| or any\n   *   dependency does not match.\n   * @param {!shaka.routing.Node} goingTo\n   *   The node that the walker is trying to go to.\n   * @param {shaka.routing.Payload} has\n   *   The payload that the walker currently has.\n   * @param {shaka.routing.Payload} wants\n   *   The payload that the walker wants to have when iy gets to |goingTo|.\n   * @return {shaka.routing.Node}\n   * @private\n   */\n  getNextMatchingAllDependencies_(destinationNode, nextNode, resetNode, goingTo,\n      has, wants) {\n    if (goingTo == destinationNode &&\n        has.mediaElement == wants.mediaElement &&\n        has.uri == wants.uri &&\n        has.mimeType == wants.mimeType) {\n      return nextNode;\n    }\n\n    return resetNode;\n  }\n\n  /**\n   * @return {shaka.routing.Payload}\n   * @private\n   */\n  static createEmptyPayload_() {\n    return {\n      mediaElement: null,\n      mimeType: null,\n      startTime: null,\n      startTimeOfLoad: NaN,\n      uri: null,\n    };\n  }\n\n  /**\n   * Using a promise, wrap the listeners returned by |Walker.startNewRoute|.\n   * This will work for most usages in |Player| but should not be used for\n   * special cases.\n   *\n   * This will connect |onCancel|, |onEnd|, |onError|, and |onSkip| with\n   * |resolve| and |reject| but will leave |onStart| unset.\n   *\n   * @param {shaka.routing.Walker.Listeners} listeners\n   * @return {!Promise}\n   * @private\n   */\n  wrapWalkerListenersWithPromise_(listeners) {\n    return new Promise((resolve, reject) => {\n      listeners.onCancel = () => reject(this.createAbortLoadError_());\n      listeners.onEnd = () => resolve();\n      listeners.onError = (e) => reject(e);\n      listeners.onSkip = () => reject(this.createAbortLoadError_());\n    });\n  }\n};\n\n/**\n * An internal enum that contains the string values of all of the player events.\n * This exists primarily to act as an implicit list of events, for tests.\n *\n * @enum {string}\n */\nshaka.Player.EventName = {\n  AbrStatusChanged: 'abrstatuschanged',\n  Adaptation: 'adaptation',\n  Buffering: 'buffering',\n  DrmSessionUpdate: 'drmsessionupdate',\n  Emsg: 'emsg',\n  Error: 'error',\n  ExpirationUpdated: 'expirationupdated',\n  LargeGap: 'largegap',\n  Loaded: 'loaded',\n  Loading: 'loading',\n  ManifestParsed: 'manifestparsed',\n  Metadata: 'metadata',\n  OnStateChange: 'onstatechange',\n  OnStateIdle: 'onstateidle',\n  RateChange: 'ratechange',\n  Streaming: 'streaming',\n  TextChanged: 'textchanged',\n  TextTrackVisibility: 'texttrackvisibility',\n  TimelineRegionAdded: 'timelineregionadded',\n  TimelineRegionEnter: 'timelineregionenter',\n  TimelineRegionExit: 'timelineregionexit',\n  TracksChanged: 'trackschanged',\n  Unloading: 'unloading',\n  VariantChanged: 'variantchanged',\n};\n\n\n/**\n * In order to know what method of loading the player used for some content, we\n * have this enum. It lets us know if content has not been loaded, loaded with\n * media source, or loaded with src equals.\n *\n * This enum has a low resolution, because it is only meant to express the\n * outer limits of the various states that the player is in. For example, when\n * someone calls a public method on player, it should not matter if they have\n * initialized drm engine, it should only matter if they finished loading\n * content.\n *\n * @enum {number}\n * @export\n */\nshaka.Player.LoadMode = {\n  'DESTROYED': 0,\n  'NOT_LOADED': 1,\n  'MEDIA_SOURCE': 2,\n  'SRC_EQUALS': 3,\n};\n\n/**\n * The typical buffering threshold.  When we have less than this buffered (in\n * seconds), we enter a buffering state.  This specific value is based on manual\n * testing and evaluation across a variety of platforms.\n *\n * To make the buffering logic work in all cases, this \"typical\" threshold will\n * be overridden if the rebufferingGoal configuration is too low.\n *\n * @const {number}\n * @private\n */\nshaka.Player.TYPICAL_BUFFERING_THRESHOLD_ = 0.5;\n\n/**\n * @define {string} A version number taken from git at compile time.\n * @export\n */\nshaka.Player.version = 'v3.0.7-uncompiled';\n\n// Initialize the deprecation system using the version string we just set\n// on the player.\nshaka.Deprecate.init(shaka.Player.version);\n\n\n/**\n * These are the EME key statuses that represent restricted playback.\n * 'usable', 'released', 'output-downscaled', 'status-pending' are statuses\n * of the usable keys.  'expired' status is being handled separately in\n * DrmEngine.\n *\n * @const {!Array.<string>}\n * @private\n */\nshaka.Player.restrictedStatuses_ = ['output-restricted', 'internal-error'];\n\n\n/** @private {!Object.<string, function():*>} */\nshaka.Player.supportPlugins_ = {};\n\n\n/** @private {?shaka.extern.IAdManager.Factory} */\nshaka.Player.adManagerFactory_ = null;\n\n\n/**\n * @const {string}\n */\nshaka.Player.TextTrackLabel = 'Shaka Player TextTrack';\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.media.ManifestParser');\n\ngoog.require('goog.Uri');\ngoog.require('shaka.log');\ngoog.require('shaka.net.NetworkingEngine');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.Platform');\n\n\n// TODO: revisit this when Closure Compiler supports partially-exported classes.\n/**\n * @summary An interface to register manifest parsers.\n * @export\n */\nshaka.media.ManifestParser = class {\n  /**\n   * Registers a manifest parser by file extension.\n   *\n   * @param {string} extension The file extension of the manifest.\n   * @param {shaka.extern.ManifestParser.Factory} parserFactory The factory\n   *   used to create parser instances.\n   * @export\n   */\n  static registerParserByExtension(extension, parserFactory) {\n    shaka.media.ManifestParser.parsersByExtension[extension] = parserFactory;\n  }\n\n\n  /**\n   * Registers a manifest parser by MIME type.\n   *\n   * @param {string} mimeType The MIME type of the manifest.\n   * @param {shaka.extern.ManifestParser.Factory} parserFactory The factory\n   *   used to create parser instances.\n   * @export\n   */\n  static registerParserByMime(mimeType, parserFactory) {\n    shaka.media.ManifestParser.parsersByMime[mimeType] = parserFactory;\n  }\n\n  /**\n   * Unregisters a manifest parser by MIME type.\n   *\n   * @param {string} mimeType The MIME type of the manifest.\n   * @export\n   */\n  static unregisterParserByMime(mimeType) {\n    delete shaka.media.ManifestParser.parsersByMime[mimeType];\n  }\n\n\n  /**\n   * Returns a map of manifest support for well-known types.\n   *\n   * @return {!Object.<string, boolean>}\n   */\n  static probeSupport() {\n    const ManifestParser = shaka.media.ManifestParser;\n    const support = {};\n\n    // Make sure all registered parsers are shown, but only for MSE-enabled\n    // platforms where our parsers matter.\n    if (shaka.util.Platform.supportsMediaSource()) {\n      for (const type in ManifestParser.parsersByMime) {\n        support[type] = true;\n      }\n      for (const type in ManifestParser.parsersByExtension) {\n        support[type] = true;\n      }\n    }\n\n    // Make sure all well-known types are tested as well, just to show an\n    // explicit false for things people might be expecting.\n    const testMimeTypes = [\n      // DASH\n      'application/dash+xml',\n      // HLS\n      'application/x-mpegurl',\n      'application/vnd.apple.mpegurl',\n      // SmoothStreaming\n      'application/vnd.ms-sstr+xml',\n    ];\n    const testExtensions = {\n      // DASH\n      'mpd': 'application/dash+xml',\n      // HLS\n      'm3u8': 'application/x-mpegurl',\n      // SmoothStreaming\n      'ism': 'application/vnd.ms-sstr+xml',\n    };\n\n    for (const type of testMimeTypes) {\n      // Only query our parsers for MSE-enabled platforms.  Otherwise, query a\n      // temporary media element for native support for these types.\n      if (shaka.util.Platform.supportsMediaSource()) {\n        support[type] = !!ManifestParser.parsersByMime[type];\n      } else {\n        support[type] = shaka.util.Platform.supportsMediaType(type);\n      }\n    }\n\n    for (const extension in testExtensions) {\n      // Only query our parsers for MSE-enabled platforms.  Otherwise, query a\n      // temporary media element for native support for these MIME type for the\n      // extension.\n      if (shaka.util.Platform.supportsMediaSource()) {\n        support[extension] = !!ManifestParser.parsersByExtension[extension];\n      } else {\n        const type = testExtensions[extension];\n        support[extension] = shaka.util.Platform.supportsMediaType(type);\n      }\n    }\n\n    return support;\n  }\n\n\n  /**\n   * Get a factory that can create a manifest parser that should be able to\n   * parse the manifest at |uri|.\n   *\n   * @param {string} uri\n   * @param {!shaka.net.NetworkingEngine} netEngine\n   * @param {shaka.extern.RetryParameters} retryParams\n   * @param {?string} mimeType\n   * @return {!Promise.<shaka.extern.ManifestParser.Factory>}\n   */\n  static async getFactory(uri, netEngine, retryParams, mimeType) {\n    const ManifestParser = shaka.media.ManifestParser;\n\n    // Try using the MIME type we were given.\n    if (mimeType) {\n      const factory = ManifestParser.parsersByMime[mimeType.toLowerCase()];\n      if (factory) {\n        return factory;\n      }\n\n      shaka.log.warning(\n          'Could not determine manifest type using MIME type ', mimeType);\n    }\n\n    const extension = ManifestParser.getExtension(uri);\n    if (extension) {\n      const factory = ManifestParser.parsersByExtension[extension];\n      if (factory) {\n        return factory;\n      }\n\n      shaka.log.warning(\n          'Could not determine manifest type for extension ', extension);\n    } else {\n      shaka.log.warning('Could not find extension for ', uri);\n    }\n\n    if (!mimeType) {\n      mimeType = await ManifestParser.getMimeType(uri, netEngine, retryParams);\n\n      if (mimeType) {\n        const factory = shaka.media.ManifestParser.parsersByMime[mimeType];\n        if (factory) {\n          return factory;\n        }\n\n        shaka.log.warning('Could not determine manifest type using MIME type',\n            mimeType);\n      }\n    }\n\n    throw new shaka.util.Error(\n        shaka.util.Error.Severity.CRITICAL,\n        shaka.util.Error.Category.MANIFEST,\n        shaka.util.Error.Code.UNABLE_TO_GUESS_MANIFEST_TYPE,\n        uri);\n  }\n\n\n  /**\n   * @param {string} uri\n   * @param {!shaka.net.NetworkingEngine} netEngine\n   * @param {shaka.extern.RetryParameters} retryParams\n   * @return {!Promise.<string>}\n   */\n  static async getMimeType(uri, netEngine, retryParams) {\n    const type = shaka.net.NetworkingEngine.RequestType.MANIFEST;\n\n    const request = shaka.net.NetworkingEngine.makeRequest([uri], retryParams);\n    request.method = 'HEAD';\n\n    const response = await netEngine.request(type, request).promise;\n\n    // https://bit.ly/2K9s9kf says this header should always be available,\n    // but just to be safe:\n    const mimeType = response.headers['content-type'];\n    return mimeType ? mimeType.toLowerCase().split(';').shift() : '';\n  }\n\n\n  /**\n   * @param {string} uri\n   * @return {string}\n   */\n  static getExtension(uri) {\n    const uriObj = new goog.Uri(uri);\n    const uriPieces = uriObj.getPath().split('/');\n    const uriFilename = uriPieces.pop();\n    const filenamePieces = uriFilename.split('.');\n\n    // Only one piece means there is no extension.\n    if (filenamePieces.length == 1) {\n      return '';\n    }\n\n    return filenamePieces.pop().toLowerCase();\n  }\n\n\n  /**\n   * Determines whether or not this URI and MIME type are supported by our own\n   * manifest parsers on this platform.  This takes into account whether or not\n   * MediaSource is available, as well as which parsers are registered to the\n   * system.\n   *\n   * @param {string} uri\n   * @param {string} mimeType\n   * @return {boolean}\n   */\n  static isSupported(uri, mimeType) {\n    // Without MediaSource, our own parsers are useless.\n    if (!shaka.util.Platform.supportsMediaSource()) {\n      return false;\n    }\n\n    if (mimeType in shaka.media.ManifestParser.parsersByMime) {\n      return true;\n    }\n\n    const extension = shaka.media.ManifestParser.getExtension(uri);\n    if (extension in shaka.media.ManifestParser.parsersByExtension) {\n      return true;\n    }\n\n    return false;\n  }\n};\n\n\n/**\n * Contains the parser factory functions indexed by MIME type.\n *\n * @type {!Object.<string, shaka.extern.ManifestParser.Factory>}\n */\nshaka.media.ManifestParser.parsersByMime = {};\n\n\n/**\n * Contains the parser factory functions indexed by file extension.\n *\n * @type {!Object.<string, shaka.extern.ManifestParser.Factory>}\n */\nshaka.media.ManifestParser.parsersByExtension = {};\n\n\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.media.InitSegmentReference');\ngoog.provide('shaka.media.SegmentReference');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.util.ArrayUtils');\n\n\n/**\n * Creates an InitSegmentReference, which provides the location to an\n * initialization segment.\n *\n * @export\n */\nshaka.media.InitSegmentReference = class {\n  /**\n   * @param {function():!Array.<string>} uris A function that creates the URIs\n   *   of the resource containing the segment.\n   * @param {number} startByte The offset from the start of the resource to the\n   *   start of the segment.\n   * @param {?number} endByte The offset from the start of the resource to the\n   *   end of the segment, inclusive.  A value of null indicates that the\n   *   segment extends to the end of the resource.\n   */\n  constructor(uris, startByte, endByte) {\n    /** @type {function():!Array.<string>} */\n    this.getUris = uris;\n\n    /** @const {number} */\n    this.startByte = startByte;\n\n    /** @const {?number} */\n    this.endByte = endByte;\n  }\n\n  /**\n   * Returns the offset from the start of the resource to the\n   * start of the segment.\n   *\n   * @return {number}\n   * @export\n   */\n  getStartByte() {\n    return this.startByte;\n  }\n\n  /**\n   * Returns the offset from the start of the resource to the end of the\n   * segment, inclusive.  A value of null indicates that the segment extends\n   * to the end of the resource.\n   *\n   * @return {?number}\n   * @export\n   */\n  getEndByte() {\n    return this.endByte;\n  }\n\n  /**\n   * Returns the size of the init segment.\n   * @return {?number}\n   */\n  getSize() {\n    if (this.endByte) {\n      return this.endByte - this.startByte;\n    } else {\n      return null;\n    }\n  }\n\n  /**\n   * Check if two initSegmentReference have all the same values.\n   * @param {?shaka.media.InitSegmentReference} reference1\n   * @param {?shaka.media.InitSegmentReference} reference2\n   * @return {boolean}\n   */\n  static equal(reference1, reference2) {\n    const ArrayUtils = shaka.util.ArrayUtils;\n    if (!reference1 || !reference2) {\n      return reference1 == reference2;\n    } else {\n      return reference1.getStartByte() == reference2.getStartByte() &&\n          reference1.getEndByte() == reference2.getEndByte() &&\n          ArrayUtils.equal(reference1.getUris(), reference2.getUris());\n    }\n  }\n};\n\n\n/**\n * SegmentReference provides the start time, end time, and location to a media\n * segment.\n *\n * @export\n */\nshaka.media.SegmentReference = class {\n  /**\n   * @param {number} startTime The segment's start time in seconds.\n   * @param {number} endTime The segment's end time in seconds.  The segment\n   *   ends the instant before this time, so |endTime| must be strictly greater\n   *   than |startTime|.\n   * @param {function():!Array.<string>} uris\n   *   A function that creates the URIs of the resource containing the segment.\n   * @param {number} startByte The offset from the start of the resource to the\n   *   start of the segment.\n   * @param {?number} endByte The offset from the start of the resource to the\n   *   end of the segment, inclusive.  A value of null indicates that the\n   *   segment extends to the end of the resource.\n   * @param {shaka.media.InitSegmentReference} initSegmentReference\n   *   The segment's initialization segment metadata, or null if the segments\n   *   are self-initializing.\n   * @param {number} timestampOffset\n   *   The amount of time, in seconds, that must be added to the segment's\n   *   internal timestamps to align it to the presentation timeline.\n   *   <br>\n   *   For DASH, this value should equal the Period start time minus the first\n   *   presentation timestamp of the first frame/sample in the Period.  For\n   *   example, for MP4 based streams, this value should equal Period start\n   *   minus the first segment's tfdt box's 'baseMediaDecodeTime' field (after\n   *   it has been converted to seconds).\n   *   <br>\n   *   For HLS, this value should be 0 to keep the presentation time at the most\n   *   recent discontinuity minus the corresponding media time.\n   * @param {number} appendWindowStart\n   *   The start of the append window for this reference, relative to the\n   *   presentation.  Any content from before this time will be removed by\n   *   MediaSource.\n   * @param {number} appendWindowEnd\n   *   The end of the append window for this reference, relative to the\n   *   presentation.  Any content from after this time will be removed by\n   *   MediaSource.\n   */\n  constructor(\n      startTime, endTime, uris, startByte, endByte, initSegmentReference,\n      timestampOffset, appendWindowStart, appendWindowEnd) {\n    goog.asserts.assert(startTime < endTime,\n        'startTime must be less than endTime');\n    goog.asserts.assert((endByte == null) || (startByte < endByte),\n        'startByte must be < endByte');\n\n    /** @type {number} */\n    this.startTime = startTime;\n\n    /** @type {number} */\n    this.endTime = endTime;\n\n    /** @type {function():!Array.<string>} */\n    this.getUris = uris;\n\n    /** @const {number} */\n    this.startByte = startByte;\n\n    /** @const {?number} */\n    this.endByte = endByte;\n\n    /** @type {shaka.media.InitSegmentReference} */\n    this.initSegmentReference = initSegmentReference;\n\n    /** @type {number} */\n    this.timestampOffset = timestampOffset;\n\n    /** @type {number} */\n    this.appendWindowStart = appendWindowStart;\n\n    /** @type {number} */\n    this.appendWindowEnd = appendWindowEnd;\n  }\n\n  /**\n   * Returns the segment's start time in seconds.\n   *\n   * @return {number}\n   * @export\n   */\n  getStartTime() {\n    return this.startTime;\n  }\n\n  /**\n   * Returns the segment's end time in seconds.\n   *\n   * @return {number}\n   * @export\n   */\n  getEndTime() {\n    return this.endTime;\n  }\n\n  /**\n   * Returns the offset from the start of the resource to the\n   * start of the segment.\n   *\n   * @return {number}\n   * @export\n   */\n  getStartByte() {\n    return this.startByte;\n  }\n\n  /**\n   * Returns the offset from the start of the resource to the end of the\n   * segment, inclusive.  A value of null indicates that the segment extends to\n   * the end of the resource.\n   *\n   * @return {?number}\n   * @export\n   */\n  getEndByte() {\n    return this.endByte;\n  }\n\n  /**\n   * Returns the size of the segment.\n   * @return {?number}\n   */\n  getSize() {\n    if (this.endByte) {\n      return this.endByte - this.startByte;\n    } else {\n      return null;\n    }\n  }\n};\n\n\n/**\n * A convenient typedef for when either type of reference is acceptable.\n *\n * @typedef {shaka.media.InitSegmentReference|shaka.media.SegmentReference}\n */\nshaka.media.AnySegmentReference;\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.media.PresentationTimeline');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.media.SegmentReference');\n\n\n/**\n * PresentationTimeline.\n * @export\n */\nshaka.media.PresentationTimeline = class {\n  /**\n   * @param {?number} presentationStartTime The wall-clock time, in seconds,\n   *   when the presentation started or will start. Only required for live.\n   * @param {number} presentationDelay The delay to give the presentation, in\n   *   seconds.  Only required for live.\n   * @param {boolean=} autoCorrectDrift Whether to account for drift when\n   *   determining the availability window.\n   *\n   * @see {shaka.extern.Manifest}\n   * @see {@tutorial architecture}\n   */\n  constructor(presentationStartTime, presentationDelay,\n      autoCorrectDrift = true) {\n    /** @private {?number} */\n    this.presentationStartTime_ = presentationStartTime;\n\n    /** @private {number} */\n    this.presentationDelay_ = presentationDelay;\n\n    /** @private {number} */\n    this.duration_ = Infinity;\n\n    /** @private {number} */\n    this.segmentAvailabilityDuration_ = Infinity;\n\n    /**\n     * The maximum segment duration (in seconds).  Can be based on explicitly-\n     * known segments or on signalling in the manifest.\n     *\n     * @private {number}\n     */\n    this.maxSegmentDuration_ = 1;\n\n    /**\n     * The minimum segment start time (in seconds, in the presentation timeline)\n     * for segments we explicitly know about.\n     *\n     * This is null if we have no explicit descriptions of segments, such as in\n     * DASH when using SegmentTemplate w/ duration.\n     *\n     * @private {?number}\n     */\n    this.minSegmentStartTime_ = null;\n\n    /**\n     * The maximum segment end time (in seconds, in the presentation timeline)\n     * for segments we explicitly know about.\n     *\n     * This is null if we have no explicit descriptions of segments, such as in\n     * DASH when using SegmentTemplate w/ duration.  When this is non-null, the\n     * presentation start time is calculated from the segment end times.\n     *\n     * @private {?number}\n     */\n    this.maxSegmentEndTime_ = null;\n\n    /** @private {number} */\n    this.clockOffset_ = 0;\n\n    /** @private {boolean} */\n    this.static_ = true;\n\n    /** @private {number} */\n    this.userSeekStart_ = 0;\n\n    /** @private {boolean} */\n    this.autoCorrectDrift_ = autoCorrectDrift;\n  }\n\n\n  /**\n   * @return {number} The presentation's duration in seconds.\n   *   Infinity indicates that the presentation continues indefinitely.\n   * @export\n   */\n  getDuration() {\n    return this.duration_;\n  }\n\n\n  /**\n   * @return {number} The presentation's max segment duration in seconds.\n   * @export\n   */\n  getMaxSegmentDuration() {\n    return this.maxSegmentDuration_;\n  }\n\n\n  /**\n   * Sets the presentation's duration.\n   *\n   * @param {number} duration The presentation's duration in seconds.\n   *   Infinity indicates that the presentation continues indefinitely.\n   * @export\n   */\n  setDuration(duration) {\n    goog.asserts.assert(duration > 0, 'duration must be > 0');\n    this.duration_ = duration;\n  }\n\n\n  /**\n   * @return {?number} The presentation's start time in seconds.\n   * @export\n   */\n  getPresentationStartTime() {\n    return this.presentationStartTime_;\n  }\n\n\n  /**\n   * Sets the clock offset, which is the difference between the client's clock\n   * and the server's clock, in milliseconds (i.e., serverTime = Date.now() +\n   * clockOffset).\n   *\n   * @param {number} offset The clock offset, in ms.\n   * @export\n   */\n  setClockOffset(offset) {\n    this.clockOffset_ = offset;\n  }\n\n\n  /**\n   * Sets the presentation's static flag.\n   *\n   * @param {boolean} isStatic If true, the presentation is static, meaning all\n   *   segments are available at once.\n   * @export\n   */\n  setStatic(isStatic) {\n    // NOTE: the argument name is not \"static\" because that's a keyword in ES6\n    this.static_ = isStatic;\n  }\n\n\n  /**\n   * Sets the presentation's segment availability duration. The segment\n   * availability duration should only be set for live.\n   *\n   * @param {number} segmentAvailabilityDuration The presentation's new segment\n   *   availability duration in seconds.\n   * @export\n   */\n  setSegmentAvailabilityDuration(segmentAvailabilityDuration) {\n    goog.asserts.assert(segmentAvailabilityDuration >= 0,\n        'segmentAvailabilityDuration must be >= 0');\n    this.segmentAvailabilityDuration_ = segmentAvailabilityDuration;\n  }\n\n\n  /**\n   * Sets the presentation delay in seconds.\n   *\n   * @param {number} delay\n   * @export\n   */\n  setDelay(delay) {\n    // NOTE: This is no longer used internally, but is exported.\n    // So we cannot remove it without deprecating it and waiting one release\n    // cycle, or else we risk breaking custom manifest parsers.\n    goog.asserts.assert(delay >= 0, 'delay must be >= 0');\n    this.presentationDelay_ = delay;\n  }\n\n\n  /**\n   * Gets the presentation delay in seconds.\n   * @return {number}\n   * @export\n   */\n  getDelay() {\n    return this.presentationDelay_;\n  }\n\n\n  /**\n   * Gives PresentationTimeline a Stream's segments so it can size and position\n   * the segment availability window, and account for missing segment\n   * information.  This function should be called once for each Stream (no more,\n   * no less).\n   *\n   * @param {!Array.<!shaka.media.SegmentReference>} references\n   * @export\n   */\n  notifySegments(references) {\n    if (references.length == 0) {\n      return;\n    }\n\n    const firstReferenceStartTime = references[0].startTime;\n    const lastReferenceEndTime = references[references.length - 1].endTime;\n\n    this.notifyMinSegmentStartTime(firstReferenceStartTime);\n\n    this.maxSegmentDuration_ = references.reduce(\n        (max, r) => { return Math.max(max, r.endTime - r.startTime); },\n        this.maxSegmentDuration_);\n\n    this.maxSegmentEndTime_ =\n        Math.max(this.maxSegmentEndTime_, lastReferenceEndTime);\n\n    if (this.presentationStartTime_ != null && this.autoCorrectDrift_) {\n      // Since we have explicit segment end times, calculate a presentation\n      // start based on them.  This start time accounts for drift.\n      // Date.now() is in milliseconds, from which we compute \"now\" in seconds.\n      const now = (Date.now() + this.clockOffset_) / 1000.0;\n      this.presentationStartTime_ =\n          now - this.maxSegmentEndTime_ - this.maxSegmentDuration_;\n    }\n\n    shaka.log.v1('notifySegments:',\n        'maxSegmentDuration=' + this.maxSegmentDuration_);\n  }\n\n\n  /**\n   * Gives PresentationTimeline a Stream's minimum segment start time.\n   *\n   * @param {number} startTime\n   * @export\n   */\n  notifyMinSegmentStartTime(\n      startTime) {\n    if (this.minSegmentStartTime_ == null) {\n      // No data yet, and Math.min(null, startTime) is always 0.  So just store\n      // startTime.\n      this.minSegmentStartTime_ = startTime;\n    } else {\n      this.minSegmentStartTime_ =\n          Math.min(this.minSegmentStartTime_, startTime);\n    }\n  }\n\n\n  /**\n   * Gives PresentationTimeline a Stream's maximum segment duration so it can\n   * size and position the segment availability window.  This function should be\n   * called once for each Stream (no more, no less), but does not have to be\n   * called if notifySegments() is called instead for a particular stream.\n   *\n   * @param {number} maxSegmentDuration The maximum segment duration for a\n   *   particular stream.\n   * @export\n   */\n  notifyMaxSegmentDuration(maxSegmentDuration) {\n    this.maxSegmentDuration_ = Math.max(\n        this.maxSegmentDuration_, maxSegmentDuration);\n\n    shaka.log.v1('notifyNewSegmentDuration:',\n        'maxSegmentDuration=' + this.maxSegmentDuration_);\n  }\n\n\n  /**\n   * Offsets the segment times by the given amount.\n   *\n   * @param {number} offset The number of seconds to offset by.  A positive\n   *   number adjusts the segment times forward.\n   * @export\n   */\n  offset(offset) {\n    if (this.minSegmentStartTime_ != null) {\n      this.minSegmentStartTime_ += offset;\n    }\n    if (this.maxSegmentEndTime_ != null) {\n      this.maxSegmentEndTime_ += offset;\n    }\n  }\n\n\n  /**\n   * @return {boolean} True if the presentation is live; otherwise, return\n   *   false.\n   * @export\n   */\n  isLive() {\n    return this.duration_ == Infinity &&\n           !this.static_;\n  }\n\n\n  /**\n   * @return {boolean} True if the presentation is in progress (meaning not\n   *   live, but also not completely available); otherwise, return false.\n   * @export\n   */\n  isInProgress() {\n    return this.duration_ != Infinity &&\n           !this.static_;\n  }\n\n\n  /**\n   * Gets the presentation's current segment availability start time.  Segments\n   * ending at or before this time should be assumed to be unavailable.\n   *\n   * @return {number} The current segment availability start time, in seconds,\n   *   relative to the start of the presentation.\n   * @export\n   */\n  getSegmentAvailabilityStart() {\n    goog.asserts.assert(this.segmentAvailabilityDuration_ >= 0,\n        'The availability duration should be positive');\n\n    const end = this.getSegmentAvailabilityEnd();\n    const start = end - this.segmentAvailabilityDuration_;\n    return Math.max(this.userSeekStart_, start);\n  }\n\n\n  /**\n   * Sets the start time of the user-defined seek range.  This is only used for\n   * VOD content.\n   *\n   * @param {number} time\n   * @export\n   */\n  setUserSeekStart(time) {\n    this.userSeekStart_ = time;\n  }\n\n\n  /**\n   * Gets the presentation's current segment availability end time.  Segments\n   * starting after this time should be assumed to be unavailable.\n   *\n   * @return {number} The current segment availability end time, in seconds,\n   *   relative to the start of the presentation.  Always returns the\n   *   presentation's duration for video-on-demand.\n   * @export\n   */\n  getSegmentAvailabilityEnd() {\n    if (!this.isLive() && !this.isInProgress()) {\n      return this.duration_;\n    }\n\n    return Math.min(this.getLiveEdge_(), this.duration_);\n  }\n\n\n  /**\n   * Gets the seek range start time, offset by the given amount.  This is used\n   * to ensure that we don't \"fall\" back out of the seek window while we are\n   * buffering.\n   *\n   * @param {number} offset The offset to add to the start time.\n   * @return {number} The current seek start time, in seconds, relative to the\n   *   start of the presentation.\n   * @export\n   */\n  getSafeSeekRangeStart(\n      offset) {\n    // The earliest known segment time, ignoring segment availability duration.\n    const earliestSegmentTime =\n        Math.max(this.minSegmentStartTime_, this.userSeekStart_);\n    if (this.segmentAvailabilityDuration_ == Infinity) {\n      return earliestSegmentTime;\n    }\n\n    // AKA the live edge for live streams.\n    const availabilityEnd = this.getSegmentAvailabilityEnd();\n\n    // The ideal availability start, not considering known segments.\n    const availabilityStart =\n        availabilityEnd - this.segmentAvailabilityDuration_;\n\n    // Add the offset to the availability start to ensure that we don't fall\n    // outside the availability window while we buffer; we don't need to add the\n    // offset to earliestSegmentTime since that won't change over time.\n    // Also see: https://github.com/google/shaka-player/issues/692\n    const desiredStart =\n        Math.min(availabilityStart + offset, this.getSeekRangeEnd());\n    return Math.max(earliestSegmentTime, desiredStart);\n  }\n\n\n  /**\n   * Gets the seek range start time.\n   *\n   * @return {number}\n   * @export\n   */\n  getSeekRangeStart() {\n    return this.getSafeSeekRangeStart(/* offset= */ 0);\n  }\n\n\n  /**\n   * Gets the seek range end.\n   *\n   * @return {number}\n   * @export\n   */\n  getSeekRangeEnd() {\n    const useDelay = this.isLive() || this.isInProgress();\n    const delay = useDelay ? this.presentationDelay_ : 0;\n    return Math.max(0, this.getSegmentAvailabilityEnd() - delay);\n  }\n\n\n  /**\n   * True if the presentation start time is being used to calculate the live\n   * edge.\n   * Using the presentation start time means that the stream may be subject to\n   * encoder drift.  At runtime, we will avoid using the presentation start time\n   * whenever possible.\n   *\n   * @return {boolean}\n   * @export\n   */\n  usingPresentationStartTime() {\n    // If it's VOD, IPR, or an HLS \"event\", we are not using the presentation\n    // start time.\n    if (this.presentationStartTime_ == null) {\n      return false;\n    }\n\n    // If we have explicit segment times, we're not using the presentation\n    // start time.\n    if (this.maxSegmentEndTime_ != null && this.autoCorrectDrift_) {\n      return false;\n    }\n\n    return true;\n  }\n\n\n  /**\n   * @return {number} The current presentation time in seconds.\n   * @private\n   */\n  getLiveEdge_() {\n    goog.asserts.assert(this.presentationStartTime_ != null,\n        'Cannot compute timeline live edge without start time');\n    // Date.now() is in milliseconds, from which we compute \"now\" in seconds.\n    const now = (Date.now() + this.clockOffset_) / 1000.0;\n    return Math.max(\n        0, now - this.maxSegmentDuration_ - this.presentationStartTime_);\n  }\n\n  /**\n   * Debug only: assert that the timeline parameters make sense for the type\n   * of presentation (VOD, IPR, live).\n   */\n  assertIsValid() {\n    if (goog.DEBUG) {\n      if (this.isLive()) {\n        // Implied by isLive(): infinite and dynamic.\n        // Live streams should have a start time.\n        goog.asserts.assert(this.presentationStartTime_ != null,\n            'Detected as live stream, but does not match our model of live!');\n      } else if (this.isInProgress()) {\n        // Implied by isInProgress(): finite and dynamic.\n        // IPR streams should have a start time, and segments should not expire.\n        goog.asserts.assert(this.presentationStartTime_ != null &&\n                            this.segmentAvailabilityDuration_ == Infinity,\n        'Detected as IPR stream, but does not match our model of IPR!');\n      } else {  // VOD\n        // VOD segments should not expire and the presentation should be finite\n        // and static.\n        goog.asserts.assert(this.segmentAvailabilityDuration_ == Infinity &&\n                            this.duration_ != Infinity &&\n                            this.static_,\n        'Detected as VOD stream, but does not match our model of VOD!');\n      }\n    }\n  }\n};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.media.StallDetector');\ngoog.provide('shaka.media.StallDetector.Implementation');\ngoog.provide('shaka.media.StallDetector.MediaElementImplementation');\n\ngoog.require('shaka.media.TimeRangesUtils');\ngoog.require('shaka.util.IReleasable');\n\n/**\n * Some platforms/browsers can get stuck in the middle of a buffered range (e.g.\n * when seeking in a background tab). Detect when we get stuck so that the\n * player can respond.\n *\n * @implements {shaka.util.IReleasable}\n * @final\n */\nshaka.media.StallDetector = class {\n  /**\n   * @param {shaka.media.StallDetector.Implementation} implementation\n   * @param {number} stallThresholdSeconds\n   */\n  constructor(implementation, stallThresholdSeconds) {\n    /** @private {shaka.media.StallDetector.Implementation} */\n    this.implementation_ = implementation;\n\n    /** @private {boolean} */\n    this.wasMakingProgress_ = implementation.shouldBeMakingProgress();\n    /** @private {number} */\n    this.value_ = implementation.getPresentationSeconds();\n    /** @private {number} */\n    this.lastUpdateSeconds_ = implementation.getWallSeconds();\n    /** @private {boolean} */\n    this.didJump_ = false;\n\n    /**\n     * The amount of time in seconds that we must have the same value of\n     * |value_| before we declare it as a stall.\n     *\n     * @private {number}\n     */\n    this.stallThresholdSeconds_ = stallThresholdSeconds;\n\n    /** @private {function(number, number)} */\n    this.onStall_ = () => {};\n  }\n\n  /** @override */\n  release() {\n    // Drop external references to make things easier on the GC.\n    this.implementation_ = null;\n    this.onStall_ = () => {};\n  }\n\n  /**\n   * Set the callback that should be called when a stall is detected. Calling\n   * this will override any previous calls to |onStall|.\n   *\n   * @param {function(number, number)} doThis\n   */\n  onStall(doThis) {\n    this.onStall_ = doThis;\n  }\n\n  /**\n   * Have the detector update itself and fire the \"on stall\" callback if a stall\n   * was detected.\n   *\n   * @return {boolean} True if action was taken.\n   */\n  poll() {\n    const impl = this.implementation_;\n\n    const shouldBeMakingProgress = impl.shouldBeMakingProgress();\n    const value = impl.getPresentationSeconds();\n    const wallTimeSeconds = impl.getWallSeconds();\n\n    const acceptUpdate = this.value_ != value ||\n                         this.wasMakingProgress_ != shouldBeMakingProgress;\n\n    if (acceptUpdate) {\n      this.lastUpdateSeconds_ = wallTimeSeconds;\n      this.value_ = value;\n      this.wasMakingProgress_ = shouldBeMakingProgress;\n      this.didJump_ = false;\n    }\n\n    const stallSeconds = wallTimeSeconds - this.lastUpdateSeconds_;\n\n    const triggerCallback = stallSeconds >= this.stallThresholdSeconds_ &&\n                            shouldBeMakingProgress && !this.didJump_;\n\n    if (triggerCallback) {\n      this.onStall_(this.value_, stallSeconds);\n      this.didJump_ = true;\n      // If the onStall_ method updated the current time, update our stored\n      // value so we don't think that was an update.\n      this.value_ = impl.getPresentationSeconds();\n    }\n\n    return triggerCallback;\n  }\n};\n\n/**\n * @interface\n */\nshaka.media.StallDetector.Implementation = class {\n  /**\n   * Check if the presentation time should be changing. This will return |true|\n   * when we expect the presentation time to change.\n   *\n   * @return {boolean}\n   */\n  shouldBeMakingProgress() {}\n\n  /**\n   * Get the presentation time in seconds.\n   *\n   * @return {number}\n   */\n  getPresentationSeconds() {}\n\n  /**\n   * Get the time wall time in seconds.\n   *\n   * @return {number}\n   */\n  getWallSeconds() {}\n};\n\n\n/**\n * Some platforms/browsers can get stuck in the middle of a buffered range (e.g.\n * when seeking in a background tab). Force a seek to help get it going again.\n *\n * @implements {shaka.media.StallDetector.Implementation}\n * @final\n */\nshaka.media.StallDetector.MediaElementImplementation = class {\n  /**\n   * @param {!HTMLMediaElement} mediaElement\n   */\n  constructor(mediaElement) {\n    /** @private {!HTMLMediaElement} */\n    this.mediaElement_ = mediaElement;\n  }\n\n  /** @override */\n  shouldBeMakingProgress() {\n    // If we are not trying to play, the lack of change could be misidentified\n    // as a stall.\n    if (this.mediaElement_.paused) {\n      return false;\n    }\n    if (this.mediaElement_.playbackRate == 0) {\n      return false;\n    }\n\n    // If we have don't have enough content, we are not stalled, we are\n    // buffering.\n    if (this.mediaElement_.buffered.length == 0) {\n      return false;\n    }\n\n    return shaka.media.StallDetector.MediaElementImplementation.hasContentFor_(\n        this.mediaElement_.buffered,\n        /* timeInSeconds= */ this.mediaElement_.currentTime);\n  }\n\n  /** @override */\n  getPresentationSeconds() {\n    return this.mediaElement_.currentTime;\n  }\n\n  /** @override */\n  getWallSeconds() {\n    return Date.now() / 1000;\n  }\n\n  /**\n   * Check if we have buffered enough content to play at |timeInSeconds|. Ignore\n   * the end of the buffered range since it may not play any more on all\n   * platforms.\n   *\n   * @param {!TimeRanges} buffered\n   * @param {number} timeInSeconds\n   * @return {boolean}\n   * @private\n   */\n  static hasContentFor_(buffered, timeInSeconds) {\n    const TimeRangesUtils = shaka.media.TimeRangesUtils;\n    for (const {start, end} of TimeRangesUtils.getBufferedInfo(buffered)) {\n      // Can be as much as 100ms before the range\n      if (timeInSeconds < start - 0.1) {\n        continue;\n      }\n      // Must be at least 500ms inside the range\n      if (timeInSeconds > end - 0.5) {\n        continue;\n      }\n\n      return true;\n    }\n\n    return false;\n  }\n};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.media.GapJumpingController');\n\ngoog.require('shaka.log');\ngoog.require('shaka.media.PresentationTimeline');\ngoog.require('shaka.media.StallDetector');\ngoog.require('shaka.media.TimeRangesUtils');\ngoog.require('shaka.util.EventManager');\ngoog.require('shaka.util.FakeEvent');\ngoog.require('shaka.util.IReleasable');\ngoog.require('shaka.util.Timer');\n\n\n/**\n * GapJumpingController handles jumping gaps that appear within the content.\n * This will only jump gaps between two buffered ranges, so we should not have\n * to worry about the availability window.\n *\n * @implements {shaka.util.IReleasable}\n */\nshaka.media.GapJumpingController = class {\n  /**\n   * @param {!HTMLMediaElement} video\n   * @param {!shaka.media.PresentationTimeline} timeline\n   * @param {shaka.extern.StreamingConfiguration} config\n   * @param {shaka.media.StallDetector} stallDetector\n   *   The stall detector is used to keep the playhead moving while in a\n   *   playable region. The gap jumping controller takes ownership over the\n   *   stall detector.\n   *   If no stall detection logic is desired, |null| may be provided.\n   * @param {function(!Event)} onEvent Called when an event is raised to be sent\n   *   to the application.\n   */\n  constructor(video, timeline, config, stallDetector, onEvent) {\n    /** @private {HTMLMediaElement} */\n    this.video_ = video;\n\n    /** @private {?shaka.media.PresentationTimeline} */\n    this.timeline_ = timeline;\n\n    /** @private {?shaka.extern.StreamingConfiguration} */\n    this.config_ = config;\n\n    /** @private {?function(!Event)} */\n    this.onEvent_ = onEvent;\n\n    /** @private {shaka.util.EventManager} */\n    this.eventManager_ = new shaka.util.EventManager();\n\n    /** @private {boolean} */\n    this.seekingEventReceived_ = false;\n\n    /** @private {number} */\n    this.prevReadyState_ = video.readyState;\n\n    /** @private {boolean} */\n    this.didFireLargeGap_ = false;\n\n    /**\n     * The stall detector tries to keep the playhead moving forward. It is\n     * managed by the gap-jumping controller to avoid conflicts. On some\n     * platforms, the stall detector is not wanted, so it may be null.\n     *\n     * @private {shaka.media.StallDetector}\n     */\n    this.stallDetector_ = stallDetector;\n\n    /** @private {boolean} */\n    this.hadSegmentAppended_ = false;\n\n    this.eventManager_.listen(video, 'waiting', () => this.onPollGapJump_());\n\n    /**\n     * We can't trust |readyState| or 'waiting' events on all platforms. To make\n     * up for this, we poll the current time. If we think we are in a gap, jump\n     * out of it.\n     *\n     * See: https://bit.ly/2McuXxm and https://bit.ly/2K5xmJO\n     *\n     * @private {?shaka.util.Timer}\n     */\n    this.gapJumpTimer_ = new shaka.util.Timer(() => {\n      this.onPollGapJump_();\n    }).tickEvery(/* seconds= */ 0.25);\n  }\n\n\n  /** @override */\n  release() {\n    if (this.eventManager_) {\n      this.eventManager_.release();\n      this.eventManager_ = null;\n    }\n\n    if (this.gapJumpTimer_ != null) {\n      this.gapJumpTimer_.stop();\n      this.gapJumpTimer_ = null;\n    }\n\n    if (this.stallDetector_) {\n      this.stallDetector_.release();\n      this.stallDetector_ = null;\n    }\n\n    this.onEvent_ = null;\n    this.timeline_ = null;\n    this.video_ = null;\n  }\n\n\n  /**\n   * Called when a segment is appended by StreamingEngine, but not when a clear\n   * is pending. This means StreamingEngine will continue buffering forward from\n   * what is buffered.  So we know about any gaps before the start.\n   */\n  onSegmentAppended() {\n    this.hadSegmentAppended_ = true;\n    this.onPollGapJump_();\n  }\n\n\n  /** Called when a seek has started. */\n  onSeeking() {\n    this.seekingEventReceived_ = true;\n    this.hadSegmentAppended_ = false;\n    this.didFireLargeGap_ = false;\n  }\n\n\n  /**\n   * Called on a recurring timer to check for gaps in the media.  This is also\n   * called in a 'waiting' event.\n   *\n   * @private\n   */\n  onPollGapJump_() {\n    // Don't gap jump before the video is ready to play.\n    if (this.video_.readyState == 0) {\n      return;\n    }\n    // Do not gap jump if seeking has begun, but the seeking event has not\n    // yet fired for this particular seek.\n    if (this.video_.seeking) {\n      if (!this.seekingEventReceived_) {\n        return;\n      }\n    } else {\n      this.seekingEventReceived_ = false;\n    }\n    // Don't gap jump while paused, so that you don't constantly jump ahead\n    // while paused on a livestream.\n    if (this.video_.paused) {\n      return;\n    }\n\n\n    // When the ready state changes, we have moved on, so we should fire the\n    // large gap event if we see one.\n    if (this.video_.readyState != this.prevReadyState_) {\n      this.didFireLargeGap_ = false;\n      this.prevReadyState_ = this.video_.readyState;\n    }\n\n    if (this.stallDetector_ && this.stallDetector_.poll()) {\n      // Some action was taken by StallDetector, so don't do anything yet.\n      return;\n    }\n\n\n    const smallGapLimit = this.config_.smallGapLimit;\n    const currentTime = this.video_.currentTime;\n    const buffered = this.video_.buffered;\n\n    const gapIndex =\n        shaka.media.TimeRangesUtils.getGapIndex(buffered, currentTime);\n\n    // The current time is unbuffered or is too far from a gap.\n    if (gapIndex == null) {\n      return;\n    }\n\n    // If we are before the first buffered range, this could be an unbuffered\n    // seek.  So wait until a segment is appended so we are sure it is a gap.\n    if (gapIndex == 0 && !this.hadSegmentAppended_) {\n      return;\n    }\n\n    // StreamingEngine can buffer past the seek end, but still don't allow\n    // seeking past it.\n    const jumpTo = buffered.start(gapIndex);\n    const seekEnd = this.timeline_.getSeekRangeEnd();\n    if (jumpTo >= seekEnd) {\n      return;\n    }\n\n    const jumpSize = jumpTo - currentTime;\n    const isGapSmall = jumpSize <= smallGapLimit;\n    let jumpLargeGap = false;\n\n    // If we jump to exactly the gap start, we may detect a small gap due to\n    // rounding errors or browser bugs.  We can ignore these extremely small\n    // gaps since the browser should play through them for us.\n    if (jumpSize < shaka.media.GapJumpingController.BROWSER_GAP_TOLERANCE) {\n      return;\n    }\n\n    if (!isGapSmall && !this.didFireLargeGap_) {\n      this.didFireLargeGap_ = true;\n\n      // Event firing is synchronous.\n      const event = new shaka.util.FakeEvent(\n          'largegap', {'currentTime': currentTime, 'gapSize': jumpSize});\n      event.cancelable = true;\n      this.onEvent_(event);\n\n      if (this.config_.jumpLargeGaps && !event.defaultPrevented) {\n        jumpLargeGap = true;\n      } else {\n        shaka.log.info('Ignoring large gap at', currentTime, 'size', jumpSize);\n      }\n    }\n\n    if (isGapSmall || jumpLargeGap) {\n      if (gapIndex == 0) {\n        shaka.log.info(\n            'Jumping forward', jumpSize,\n            'seconds because of gap before start time of', jumpTo);\n      } else {\n        shaka.log.info(\n            'Jumping forward', jumpSize, 'seconds because of gap starting at',\n            buffered.end(gapIndex - 1), 'and ending at', jumpTo);\n      }\n\n      this.video_.currentTime = jumpTo;\n    }\n  }\n};\n\n\n/**\n * The limit, in seconds, for the gap size that we will assume the browser will\n * handle for us.\n * @const\n */\nshaka.media.GapJumpingController.BROWSER_GAP_TOLERANCE = 0.001;\n\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.util.MediaReadyState');\n\ngoog.require('shaka.util.EventManager');\n\n\nshaka.util.MediaReadyState = class {\n  /**\n   * @param {!HTMLMediaElement} mediaElement\n   * @param {number} readyState\n   * @param {shaka.util.EventManager} eventManager\n   * @param {function()} callback\n   */\n  static waitForReadyState(mediaElement, readyState, eventManager, callback) {\n    if (readyState == HTMLMediaElement.HAVE_NOTHING ||\n      mediaElement.readyState >= readyState) {\n      callback();\n    } else {\n      const MediaReadyState = shaka.util.MediaReadyState;\n      const eventName =\n          MediaReadyState.READY_STATES_TO_EVENT_NAMES_.get(readyState);\n      eventManager.listenOnce(mediaElement, eventName, callback);\n    }\n  }\n};\n\n/**\n * @const {!Map.<number, string>}\n * @private\n */\nshaka.util.MediaReadyState.READY_STATES_TO_EVENT_NAMES_ = new Map([\n  [HTMLMediaElement.HAVE_METADATA, 'loadedmetadata'],\n  [HTMLMediaElement.HAVE_CURRENT_DATA, 'loadeddata'],\n  [HTMLMediaElement.HAVE_FUTURE_DATA, 'canplay'],\n  [HTMLMediaElement.HAVE_ENOUGH_DATA, 'canplaythrough'],\n]);\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.media.VideoWrapper');\ngoog.provide('shaka.media.VideoWrapper.PlayheadMover');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.util.EventManager');\ngoog.require('shaka.util.IReleasable');\ngoog.require('shaka.util.MediaReadyState');\ngoog.require('shaka.util.Timer');\n\n\n/**\n * Creates a new VideoWrapper that manages setting current time and playback\n * rate.  This handles seeks before content is loaded and ensuring the video\n * time is set properly.  This doesn't handle repositioning within the\n * presentation window.\n *\n * @implements {shaka.util.IReleasable}\n */\nshaka.media.VideoWrapper = class {\n  /**\n   * @param {!HTMLMediaElement} video\n   * @param {function()} onSeek Called when the video seeks.\n   * @param {number} startTime The time to start at.\n   */\n  constructor(video, onSeek, startTime) {\n    /** @private {HTMLMediaElement} */\n    this.video_ = video;\n\n    /** @private {function()} */\n    this.onSeek_ = onSeek;\n\n    /** @private {number} */\n    this.startTime_ = startTime;\n\n    /** @private {boolean} */\n    this.started_ = false;\n\n    /** @private {shaka.util.EventManager} */\n    this.eventManager_ = new shaka.util.EventManager();\n\n    /** @private {shaka.media.VideoWrapper.PlayheadMover} */\n    this.mover_ = new shaka.media.VideoWrapper.PlayheadMover(\n        /* mediaElement= */ video,\n        /* maxAttempts= */ 10);\n\n    // Before we can set the start time, we must check if the video element is\n    // ready. If the video element is not ready, we cannot set the time. To work\n    // around this, we will wait for the \"loadedmetadata\" event which tells us\n    // that the media element is now ready.\n    shaka.util.MediaReadyState.waitForReadyState(this.video_,\n        HTMLMediaElement.HAVE_METADATA,\n        this.eventManager_,\n        () => {\n          this.setStartTime_(this.startTime_);\n        });\n  }\n\n\n  /** @override */\n  release() {\n    if (this.eventManager_) {\n      this.eventManager_.release();\n      this.eventManager_ = null;\n    }\n\n    if (this.mover_ != null) {\n      this.mover_.release();\n      this.mover_ = null;\n    }\n\n    this.onSeek_ = () => {};\n    this.video_ = null;\n  }\n\n\n  /**\n   * Gets the video's current (logical) position.\n   *\n   * @return {number}\n   */\n  getTime() {\n    return this.started_ ? this.video_.currentTime : this.startTime_;\n  }\n\n\n  /**\n   * Sets the current time of the video.\n   *\n   * @param {number} time\n   */\n  setTime(time) {\n    if (this.video_.readyState > 0) {\n      this.mover_.moveTo(time);\n    } else {\n      shaka.util.MediaReadyState.waitForReadyState(this.video_,\n          HTMLMediaElement.HAVE_METADATA,\n          this.eventManager_,\n          () => {\n            this.setStartTime_(this.startTime_);\n          });\n    }\n  }\n\n\n  /**\n   * Set the start time for the content. The given start time will be ignored if\n   * the content does not start at 0.\n   *\n   * @param {number} startTime\n   * @private\n   */\n  setStartTime_(startTime) {\n    // If we start close enough to our intended start time, then we won't do\n    // anything special.\n    if (Math.abs(this.video_.currentTime - startTime) < 0.001) {\n      this.startListeningToSeeks_();\n      return;\n    }\n\n    // We will need to delay adding our normal seeking listener until we have\n    // seen the first seek event. We will force the first seek event later in\n    // this method.\n    this.eventManager_.listenOnce(this.video_, 'seeking', () => {\n      this.startListeningToSeeks_();\n    });\n\n    // If the currentTime != 0, it indicates that the user has seeked after\n    // calling |Player.load|, meaning that |currentTime| is more meaningful than\n    // |startTime|.\n    //\n    // Seeking to the current time is a work around for Issue 1298. If we don't\n    // do this, the video may get stuck and not play.\n    //\n    // TODO: Need further investigation why it happens. Before and after\n    // setting the current time, video.readyState is 1, video.paused is true,\n    // and video.buffered's TimeRanges length is 0.\n    // See: https://github.com/google/shaka-player/issues/1298\n    this.mover_.moveTo(\n        this.video_.currentTime == 0 ?\n        startTime :\n        this.video_.currentTime);\n  }\n\n\n  /**\n   * Add the listener for seek-events. This will call the externally-provided\n   * |onSeek| callback whenever the media element seeks.\n   *\n   * @private\n   */\n  startListeningToSeeks_() {\n    goog.asserts.assert(\n        this.video_.readyState > 0,\n        'The media element should be ready before we listen for seeking.');\n\n    // Now that any startup seeking is complete, we can trust the video element\n    // for currentTime.\n    this.started_ = true;\n\n    this.eventManager_.listen(this.video_, 'seeking', () => this.onSeek_());\n  }\n};\n\n/**\n * A class used to move the playhead away from its current time.  Sometimes, IE\n * and Edge ignore re-seeks. After changing the current time, check every 100ms,\n * retrying if the change was not accepted.\n *\n * Delay stats over 100 runs of a re-seeking integration test:\n *   IE     -   0ms -  47%\n *   IE     - 100ms -  63%\n *   Edge   -   0ms -   2%\n *   Edge   - 100ms -  40%\n *   Edge   - 200ms -  32%\n *   Edge   - 300ms -  24%\n *   Edge   - 400ms -   2%\n *   Chrome -   0ms - 100%\n *\n * TODO: File a bug on IE/Edge about this.\n *\n * @implements {shaka.util.IReleasable}\n * @final\n */\nshaka.media.VideoWrapper.PlayheadMover = class {\n  /**\n   * @param {!HTMLMediaElement} mediaElement\n   *    The media element that the mover can manipulate.\n   *\n   * @param {number} maxAttempts\n   *    To prevent us from infinitely trying to change the current time, the\n   *    mover accepts a max attempts value. At most, the mover will check if the\n   *    video moved |maxAttempts| times. If this is zero of negative, no\n   *    attempts will be made.\n   */\n  constructor(mediaElement, maxAttempts) {\n    /** @private {HTMLMediaElement} */\n    this.mediaElement_ = mediaElement;\n\n    /** @private {number} */\n    this.maxAttempts_ = maxAttempts;\n\n    /** @private {number} */\n    this.remainingAttempts_ = 0;\n\n    /** @private {number} */\n    this.originTime_ = 0;\n\n    /** @private {number} */\n    this.targetTime_ = 0;\n\n    /** @private {shaka.util.Timer} */\n    this.timer_ = new shaka.util.Timer(() => this.onTick_());\n  }\n\n  /** @override */\n  release() {\n    if (this.timer_) {\n      this.timer_.stop();\n      this.timer_ = null;\n    }\n\n    this.mediaElement_ = null;\n  }\n\n  /**\n   * Try forcing the media element to move to |timeInSeconds|. If a previous\n   * call to |moveTo| is still in progress, this will override it.\n   *\n   * @param {number} timeInSeconds\n   */\n  moveTo(timeInSeconds) {\n    this.originTime_ = this.mediaElement_.currentTime;\n    this.targetTime_ = timeInSeconds;\n\n    this.remainingAttempts_ = this.maxAttempts_;\n\n    // Set the time and then start the timer. The timer will check if the set\n    // was successful, and retry if not.\n    this.mediaElement_.currentTime = timeInSeconds;\n    this.timer_.tickEvery(/* seconds= */ 0.1);\n  }\n\n  /**\n   * @private\n   */\n  onTick_() {\n    // Sigh... We ran out of retries...\n    if (this.remainingAttempts_ <= 0) {\n      shaka.log.warning([\n        'Failed to move playhead from', this.originTime_,\n        'to', this.targetTime_,\n      ].join(' '));\n\n      this.timer_.stop();\n      return;\n    }\n\n    // Yay! We were successful.\n    if (this.mediaElement_.currentTime != this.originTime_) {\n      this.timer_.stop();\n      return;\n    }\n\n    // Sigh... Try again...\n    this.mediaElement_.currentTime = this.targetTime_;\n    this.remainingAttempts_--;\n  }\n};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.media.MediaSourcePlayhead');\ngoog.provide('shaka.media.Playhead');\ngoog.provide('shaka.media.SrcEqualsPlayhead');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.media.GapJumpingController');\ngoog.require('shaka.media.StallDetector');\ngoog.require('shaka.media.StallDetector.MediaElementImplementation');\ngoog.require('shaka.media.TimeRangesUtils');\ngoog.require('shaka.media.VideoWrapper');\ngoog.require('shaka.util.EventManager');\ngoog.require('shaka.util.IReleasable');\ngoog.require('shaka.util.MediaReadyState');\ngoog.require('shaka.util.Timer');\ngoog.requireType('shaka.media.PresentationTimeline');\n\n\n/**\n * Creates a Playhead, which manages the video's current time.\n *\n * The Playhead provides mechanisms for setting the presentation's start time,\n * restricting seeking to valid time ranges, and stopping playback for startup\n * and re-buffering.\n *\n * @extends {shaka.util.IReleasable}\n * @interface\n */\nshaka.media.Playhead = class {\n  /**\n   * Set the start time. If the content has already started playback, this will\n   * be ignored.\n   *\n   * @param {number} startTime\n   */\n  setStartTime(startTime) {}\n\n  /**\n   * Get the current playhead position. The position will be restricted to valid\n   * time ranges.\n   *\n   * @return {number}\n   */\n  getTime() {}\n\n  /**\n   * Notify the playhead that the buffered ranges have changed.\n   */\n  notifyOfBufferingChange() {}\n};\n\n\n/**\n * A playhead implementation that only relies on the media element.\n *\n * @implements {shaka.media.Playhead}\n * @final\n */\nshaka.media.SrcEqualsPlayhead = class {\n  /**\n   * @param {!HTMLMediaElement} mediaElement\n   */\n  constructor(mediaElement) {\n    /** @private {HTMLMediaElement} */\n    this.mediaElement_ = mediaElement;\n    /** @private {boolean} */\n    this.started_ = false;\n    /** @private {?number} */\n    this.startTime_ = null;\n\n    /** @private {shaka.util.EventManager} */\n    this.eventManager_ = new shaka.util.EventManager();\n\n    // We listen for the loaded-data-event so that we know when we can\n    // interact with |currentTime|.\n    const onLoaded = () => {\n      if (this.startTime_ == null) {\n        this.started_ = true;\n      } else {\n        // Startup is complete only when the video element acknowledges the\n        // seek.\n        this.eventManager_.listenOnce(this.mediaElement_, 'seeking', () => {\n          this.started_ = true;\n        });\n        const currentTime = this.mediaElement_.currentTime;\n        // Using the currentTime allows using a negative number in Live HLS\n        const newTime = Math.max(0, currentTime + this.startTime_);\n        this.mediaElement_.currentTime = newTime;\n      }\n    };\n\n    shaka.util.MediaReadyState.waitForReadyState(this.mediaElement_,\n        HTMLMediaElement.HAVE_CURRENT_DATA,\n        this.eventManager_, () => {\n          onLoaded();\n        });\n  }\n\n  /** @override */\n  release() {\n    if (this.eventManager_) {\n      this.eventManager_.release();\n      this.eventManager_ = null;\n    }\n\n    this.mediaElement_ = null;\n  }\n\n  /** @override */\n  setStartTime(startTime) {\n    // If we have already started playback, ignore updates to the start time.\n    // This is just to make things consistent.\n    this.startTime_ = this.started_ ? this.startTime_ : startTime;\n  }\n\n  /** @override */\n  getTime() {\n    // If we have not started playback yet, return the start time. However once\n    // we start playback we assume that we can always return the current time.\n    const time = this.started_ ?\n                 this.mediaElement_.currentTime :\n                 this.startTime_;\n\n    // In the case that we have not started playback, but the start time was\n    // never set, we don't know what the start time should be. To ensure we\n    // always return a number, we will default back to 0.\n    return time || 0;\n  }\n\n  /** @override */\n  notifyOfBufferingChange() {}\n};\n\n\n/**\n * A playhead implementation that relies on the media element and a manifest.\n * When provided with a manifest, we can provide more accurate control than\n * the SrcEqualsPlayhead.\n *\n * TODO: Clean up and simplify Playhead.  There are too many layers of, methods\n *       for, and conditions on timestamp adjustment.\n *\n * @implements {shaka.media.Playhead}\n * @final\n */\nshaka.media.MediaSourcePlayhead = class {\n  /**\n   * @param {!HTMLMediaElement} mediaElement\n   * @param {shaka.extern.Manifest} manifest\n   * @param {shaka.extern.StreamingConfiguration} config\n   * @param {?number} startTime\n   *     The playhead's initial position in seconds. If null, defaults to the\n   *     start of the presentation for VOD and the live-edge for live.\n   * @param {function()} onSeek\n   *     Called when the user agent seeks to a time within the presentation\n   *     timeline.\n   * @param {function(!Event)} onEvent\n   *     Called when an event is raised to be sent to the application.\n   */\n  constructor(mediaElement, manifest, config, startTime, onSeek, onEvent) {\n    /**\n     * The seek range must be at least this number of seconds long. If it is\n     * smaller than this, change it to be this big so we don't repeatedly seek\n     * to keep within a zero-width window.\n     *\n     * This is 3s long, to account for the weaker hardware on platforms like\n     * Chromecast.\n     *\n     * @private {number}\n     */\n    this.minSeekRange_ = 3.0;\n\n    /** @private {HTMLMediaElement} */\n    this.mediaElement_ = mediaElement;\n\n    /** @private {shaka.media.PresentationTimeline} */\n    this.timeline_ = manifest.presentationTimeline;\n\n    /** @private {number} */\n    this.minBufferTime_ = manifest.minBufferTime || 0;\n\n    /** @private {?shaka.extern.StreamingConfiguration} */\n    this.config_ = config;\n\n    /** @private {function()} */\n    this.onSeek_ = onSeek;\n\n    /** @private {?number} */\n    this.lastCorrectiveSeek_ = null;\n\n    /** @private {shaka.media.GapJumpingController} */\n    this.gapController_ = new shaka.media.GapJumpingController(\n        mediaElement,\n        manifest.presentationTimeline,\n        config,\n        this.createStallDetector_(mediaElement, config),\n        onEvent);\n\n    /** @private {shaka.media.VideoWrapper} */\n    this.videoWrapper_ = new shaka.media.VideoWrapper(\n        mediaElement,\n        () => this.onSeeking_(),\n        this.getStartTime_(startTime));\n\n    /** @type {shaka.util.Timer} */\n    this.checkWindowTimer_ = new shaka.util.Timer(() => {\n      this.onPollWindow_();\n    }).tickEvery(/* seconds= */ 0.25);\n  }\n\n  /** @override */\n  release() {\n    if (this.videoWrapper_) {\n      this.videoWrapper_.release();\n      this.videoWrapper_ = null;\n    }\n\n    if (this.gapController_) {\n      this.gapController_.release();\n      this.gapController_= null;\n    }\n\n    if (this.checkWindowTimer_) {\n      this.checkWindowTimer_.stop();\n      this.checkWindowTimer_ = null;\n    }\n\n    this.config_ = null;\n    this.timeline_ = null;\n    this.videoWrapper_ = null;\n    this.mediaElement_ = null;\n\n    this.onSeek_ = () => {};\n  }\n\n  /** @override */\n  setStartTime(startTime) {\n    this.videoWrapper_.setTime(startTime);\n  }\n\n  /** @override */\n  getTime() {\n    const time = this.videoWrapper_.getTime();\n\n    // Although we restrict the video's currentTime elsewhere, clamp it here to\n    // ensure timing issues don't cause us to return a time outside the segment\n    // availability window.  E.g., the user agent seeks and calls this function\n    // before we receive the 'seeking' event.\n    //\n    // We don't buffer when the livestream video is paused and the playhead time\n    // is out of the seek range; thus, we do not clamp the current time when the\n    // video is paused.\n    // https://github.com/google/shaka-player/issues/1121\n    if (this.mediaElement_.readyState > 0 && !this.mediaElement_.paused) {\n      return this.clampTime_(time);\n    }\n\n    return time;\n  }\n\n  /**\n   * Gets the playhead's initial position in seconds.\n   *\n   * @param {?number} startTime\n   * @return {number}\n   * @private\n   */\n  getStartTime_(startTime) {\n    if (startTime == null) {\n      if (this.timeline_.getDuration() < Infinity) {\n        // If the presentation is VOD, or if the presentation is live but has\n        // finished broadcasting, then start from the beginning.\n        startTime = this.timeline_.getSeekRangeStart();\n      } else {\n        // Otherwise, start near the live-edge.\n        startTime = this.timeline_.getSeekRangeEnd();\n      }\n    } else if (startTime < 0) {\n      // For live streams, if the startTime is negative, start from a certain\n      // offset time from the live edge.  If the offset from the live edge is\n      // not available, start from the current available segment start point\n      // instead, handled by clampTime_().\n      startTime = this.timeline_.getSeekRangeEnd() + startTime;\n    }\n\n    return this.clampSeekToDuration_(this.clampTime_(startTime));\n  }\n\n  /** @override */\n  notifyOfBufferingChange() {\n    this.gapController_.onSegmentAppended();\n  }\n\n  /**\n   * Called on a recurring timer to keep the playhead from falling outside the\n   * availability window.\n   *\n   * @private\n   */\n  onPollWindow_() {\n    // Don't catch up to the seek range when we are paused or empty.\n    // The definition of \"seeking\" says that we are seeking until the buffered\n    // data intersects with the playhead.  If we fall outside of the seek range,\n    // it doesn't matter if we are in a \"seeking\" state.  We can and should go\n    // ahead and catch up while seeking.\n    if (this.mediaElement_.readyState == 0 || this.mediaElement_.paused) {\n      return;\n    }\n\n    const currentTime = this.videoWrapper_.getTime();\n    let seekStart = this.timeline_.getSeekRangeStart();\n    const seekEnd = this.timeline_.getSeekRangeEnd();\n\n    if (seekEnd - seekStart < this.minSeekRange_) {\n      seekStart = seekEnd - this.minSeekRange_;\n    }\n\n    if (currentTime < seekStart) {\n      // The seek range has moved past the playhead.  Move ahead to catch up.\n      const targetTime = this.reposition_(currentTime);\n      shaka.log.info('Jumping forward ' + (targetTime - currentTime) +\n                     ' seconds to catch up with the seek range.');\n      this.mediaElement_.currentTime = targetTime;\n    }\n  }\n\n  /**\n   * Handles when a seek happens on the video.\n   *\n   * @private\n   */\n  onSeeking_() {\n    this.gapController_.onSeeking();\n    const currentTime = this.videoWrapper_.getTime();\n    const targetTime = this.reposition_(currentTime);\n\n    const gapLimit = shaka.media.GapJumpingController.BROWSER_GAP_TOLERANCE;\n    if (Math.abs(targetTime - currentTime) > gapLimit) {\n      // You can only seek like this every so often. This is to prevent an\n      // infinite loop on systems where changing currentTime takes a significant\n      // amount of time (e.g. Chromecast).\n      const time = Date.now() / 1000;\n      if (!this.lastCorrectiveSeek_ || this.lastCorrectiveSeek_ < time - 1) {\n        this.lastCorrectiveSeek_ = time;\n        this.videoWrapper_.setTime(targetTime);\n        return;\n      }\n    }\n\n    shaka.log.v1('Seek to ' + currentTime);\n    this.onSeek_();\n  }\n\n  /**\n   * Clamp seek times and playback start times so that we never seek to the\n   * presentation duration.  Seeking to or starting at duration does not work\n   * consistently across browsers.\n   *\n   * @see https://github.com/google/shaka-player/issues/979\n   * @param {number} time\n   * @return {number} The adjusted seek time.\n   * @private\n   */\n  clampSeekToDuration_(time) {\n    const duration = this.timeline_.getDuration();\n    if (time >= duration) {\n      goog.asserts.assert(this.config_.durationBackoff >= 0,\n          'Duration backoff must be non-negative!');\n      return duration - this.config_.durationBackoff;\n    }\n    return time;\n  }\n\n  /**\n   * Computes a new playhead position that's within the presentation timeline.\n   *\n   * @param {number} currentTime\n   * @return {number} The time to reposition the playhead to.\n   * @private\n   */\n  reposition_(currentTime) {\n    goog.asserts.assert(\n        this.config_,\n        'Cannot reposition playhead when it has beeen destroyed');\n\n    /** @type {function(number)} */\n    const isBuffered = (playheadTime) => shaka.media.TimeRangesUtils.isBuffered(\n        this.mediaElement_.buffered, playheadTime);\n\n    const rebufferingGoal = Math.max(\n        this.minBufferTime_,\n        this.config_.rebufferingGoal);\n\n    const safeSeekOffset = this.config_.safeSeekOffset;\n\n    let start = this.timeline_.getSeekRangeStart();\n    const end = this.timeline_.getSeekRangeEnd();\n    const duration = this.timeline_.getDuration();\n\n    if (end - start < this.minSeekRange_) {\n      start = end - this.minSeekRange_;\n    }\n\n    // With live content, the beginning of the availability window is moving\n    // forward.  This means we cannot seek to it since we will \"fall\" outside\n    // the window while we buffer.  So we define a \"safe\" region that is far\n    // enough away.  For VOD, |safe == start|.\n    const safe = this.timeline_.getSafeSeekRangeStart(rebufferingGoal);\n\n    // These are the times to seek to rather than the exact destinations.  When\n    // we seek, we will get another event (after a slight delay) and these steps\n    // will run again.  So if we seeked directly to |start|, |start| would move\n    // on the next call and we would loop forever.\n    const seekStart = this.timeline_.getSafeSeekRangeStart(safeSeekOffset);\n    const seekSafe = this.timeline_.getSafeSeekRangeStart(\n        rebufferingGoal + safeSeekOffset);\n\n    if (currentTime >= duration) {\n      shaka.log.v1('Playhead past duration.');\n      return this.clampSeekToDuration_(currentTime);\n    }\n\n    if (currentTime > end) {\n      shaka.log.v1('Playhead past end.');\n      return end;\n    }\n\n    if (currentTime < start) {\n      if (isBuffered(seekStart)) {\n        shaka.log.v1('Playhead before start & start is buffered');\n        return seekStart;\n      } else {\n        shaka.log.v1('Playhead before start & start is unbuffered');\n        return seekSafe;\n      }\n    }\n\n    if (currentTime >= safe || isBuffered(currentTime)) {\n      shaka.log.v1('Playhead in safe region or in buffered region.');\n      return currentTime;\n    } else {\n      shaka.log.v1('Playhead outside safe region & in unbuffered region.');\n      return seekSafe;\n    }\n  }\n\n  /**\n   * Clamps the given time to the seek range.\n   *\n   * @param {number} time The time in seconds.\n   * @return {number} The clamped time in seconds.\n   * @private\n   */\n  clampTime_(time) {\n    const start = this.timeline_.getSeekRangeStart();\n    if (time < start) {\n      return start;\n    }\n\n    const end = this.timeline_.getSeekRangeEnd();\n    if (time > end) {\n      return end;\n    }\n\n    return time;\n  }\n\n  /**\n   * Create and configure a stall detector using the player's streaming\n   * configuration settings. If the player is configured to have no stall\n   * detector, this will return |null|.\n   *\n   * @param {!HTMLMediaElement} mediaElement\n   * @param {shaka.extern.StreamingConfiguration} config\n   * @return {shaka.media.StallDetector}\n   * @private\n   */\n  createStallDetector_(mediaElement, config) {\n    if (!config.stallEnabled) {\n      return null;\n    }\n\n    // Cache the values from the config so that changes to the config won't\n    // change the initialized behaviour.\n    const threshold = config.stallThreshold;\n    const skip = config.stallSkip;\n\n    // When we see a stall, we will try to \"jump-start\" playback by moving the\n    // playhead forward.\n    const detector = new shaka.media.StallDetector(\n        new shaka.media.StallDetector.MediaElementImplementation(mediaElement),\n        threshold);\n\n    detector.onStall((at, duration) => {\n      shaka.log.debug(`Stall detected at ${at} for ${duration} seconds.`);\n\n      if (skip) {\n        shaka.log.debug(`Seeking forward ${skip} seconds to break stall.`);\n        mediaElement.currentTime += skip;\n      } else {\n        shaka.log.debug('Pausing and unpausing to break stall.');\n        mediaElement.pause();\n        mediaElement.play();\n      }\n    });\n\n    return detector;\n  }\n};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.media.MetaSegmentIndex');\ngoog.provide('shaka.media.SegmentIndex');\ngoog.provide('shaka.media.SegmentIterator');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.Deprecate');\ngoog.require('shaka.media.SegmentReference');\ngoog.require('shaka.util.IReleasable');\ngoog.require('shaka.util.Timer');\n\n\n/**\n * SegmentIndex.\n *\n * @implements {shaka.util.IReleasable}\n * @implements {Iterable.<!shaka.media.SegmentReference>}\n * @export\n */\nshaka.media.SegmentIndex = class {\n  /**\n   * @param {!Array.<!shaka.media.SegmentReference>} references The list of\n   *   SegmentReferences, which must be sorted first by their start times\n   *   (ascending) and second by their end times (ascending).\n   */\n  constructor(references) {\n    if (goog.DEBUG) {\n      shaka.media.SegmentIndex.assertCorrectReferences_(references);\n    }\n\n    /** @protected {!Array.<!shaka.media.SegmentReference>} */\n    this.references = references;\n\n    /** @private {shaka.util.Timer} */\n    this.timer_ = null;\n\n    /**\n     * The number of references that have been removed from the front of the\n     * array.  Used to create stable positions in the find/get APIs.\n     *\n     * @protected {number}\n     */\n    this.numEvicted = 0;\n\n    /** @private {boolean} */\n    this.immutable_ = false;\n  }\n\n\n  /**\n   * SegmentIndex used to be an IDestroyable.  Now it is an IReleasable.\n   * This method is provided for backward compatibility.\n   *\n   * @deprecated\n   * @return {!Promise}\n   * @export\n   */\n  destroy() {\n    shaka.Deprecate.deprecateFeature(4,\n        'shaka.media.SegmentIndex',\n        'Please use release() instead of destroy().');\n    this.release();\n    return Promise.resolve();\n  }\n\n\n  /**\n   * @override\n   * @export\n   */\n  release() {\n    if (this.immutable_) {\n      return;\n    }\n\n    this.references = [];\n\n    if (this.timer_) {\n      this.timer_.stop();\n    }\n    this.timer_ = null;\n  }\n\n\n  /**\n   * Marks the index as immutable.  Segments cannot be added or removed after\n   * this point.  This doesn't affect the references themselves.  This also\n   * makes the destroy/release methods do nothing.\n   *\n   * This is mainly for testing.\n   *\n   * @export\n   */\n  markImmutable() {\n    this.immutable_ = true;\n  }\n\n\n  /**\n   * Finds the position of the segment for the given time, in seconds, relative\n   * to the start of the presentation.  Returns the position of the segment\n   * with the largest end time if more than one segment is known for the given\n   * time.\n   *\n   * @param {number} time\n   * @return {?number} The position of the segment, or null if the position of\n   *   the segment could not be determined.\n   * @export\n   */\n  find(time) {\n    // For live streams, searching from the end is faster.  For VOD, it balances\n    // out either way.  In both cases, references.length is small enough that\n    // the difference isn't huge.\n    for (let i = this.references.length - 1; i >= 0; --i) {\n      const r = this.references[i];\n      // Note that a segment ends immediately before the end time.\n      if ((time >= r.startTime) && (time < r.endTime)) {\n        return i + this.numEvicted;\n      }\n    }\n    if (this.references.length && time < this.references[0].startTime) {\n      return this.numEvicted;\n    }\n\n    return null;\n  }\n\n\n  /**\n   * Gets the SegmentReference for the segment at the given position.\n   *\n   * @param {number} position The position of the segment as returned by find().\n   * @return {shaka.media.SegmentReference} The SegmentReference, or null if\n   *   no such SegmentReference exists.\n   * @export\n   */\n  get(position) {\n    if (this.references.length == 0) {\n      return null;\n    }\n\n    const index = position - this.numEvicted;\n    if (index < 0 || index >= this.references.length) {\n      return null;\n    }\n\n    return this.references[index];\n  }\n\n\n  /**\n   * Offset all segment references by a fixed amount.\n   *\n   * @param {number} offset The amount to add to each segment's start and end\n   *   times.\n   * @export\n   */\n  offset(offset) {\n    if (!this.immutable_) {\n      for (const ref of this.references) {\n        ref.startTime += offset;\n        ref.endTime += offset;\n        ref.timestampOffset += offset;\n      }\n    }\n  }\n\n\n  /**\n   * Merges the given SegmentReferences.  Supports extending the original\n   * references only.  Will not replace old references or interleave new ones.\n   * Used, for example, by the DASH and HLS parser, where manifests may not list\n   * all available references, so we must keep available references in memory to\n   * fill the availability window.\n   *\n   * @param {!Array.<!shaka.media.SegmentReference>} references The list of\n   *   SegmentReferences, which must be sorted first by their start times\n   *   (ascending) and second by their end times (ascending).\n   * @export\n   */\n  merge(references) {\n    if (goog.DEBUG) {\n      shaka.media.SegmentIndex.assertCorrectReferences_(references);\n    }\n    if (this.immutable_) {\n      return;\n    }\n\n    const lastOldReference = this.references[this.references.length - 1];\n\n    let newReferences = [];\n    if (!this.references.length) {\n      // There are no old references, so we take all of the new ones.\n      newReferences = references;\n    } else {\n      // There are some old ones, so we only take the new ones that overlap with\n      // the last old one or come after the last old one.\n      newReferences = references.filter((r) => {\n        return r.startTime >= lastOldReference.startTime;\n      });\n    }\n\n    // It's valid to update the last reference in the old set.  If the first new\n    // ref is a match for the last old one, we'll replace the old one.\n    if (lastOldReference && newReferences.length &&\n        newReferences[0].startTime == lastOldReference.startTime) {\n      // Remove the last entry from the old set, and the first entry from the\n      // new set will replace it in push(...) below.\n      this.references.pop();\n    }\n\n    this.references.push(...newReferences);\n\n    if (goog.DEBUG) {\n      shaka.media.SegmentIndex.assertCorrectReferences_(this.references);\n    }\n  }\n\n\n  /**\n   * Removes all SegmentReferences that end before the given time.\n   *\n   * @param {number} time The time in seconds.\n   * @export\n   */\n  evict(time) {\n    if (this.immutable_) {\n      return;\n    }\n\n    const oldSize = this.references.length;\n\n    this.references = this.references.filter((ref) => ref.endTime > time);\n\n    const newSize = this.references.length;\n    const diff = oldSize - newSize;\n    // Tracking the number of evicted refs will keep their \"positions\" stable\n    // for the caller.\n    this.numEvicted += diff;\n  }\n\n\n  /**\n   * Drops references that start after windowEnd, or end before windowStart,\n   * and contracts the last reference so that it ends at windowEnd.\n   *\n   * Do not call on the last period of a live presentation (unknown duration).\n   * It is okay to call on the other periods of a live presentation, where the\n   * duration is known and another period has been added.\n   *\n   * @param {number} windowStart\n   * @param {?number} windowEnd\n   * @export\n   */\n  fit(windowStart, windowEnd) {\n    goog.asserts.assert(windowEnd != null,\n        'Content duration must be known for static content!');\n    goog.asserts.assert(windowEnd != Infinity,\n        'Content duration must be finite for static content!');\n    if (this.immutable_) {\n      return;\n    }\n\n    // Trim out references we will never use.\n    while (this.references.length) {\n      const lastReference = this.references[this.references.length - 1];\n      if (lastReference.startTime >= windowEnd) {\n        this.references.pop();\n      } else {\n        break;\n      }\n    }\n\n    while (this.references.length) {\n      const firstReference = this.references[0];\n      if (firstReference.endTime <= windowStart) {\n        this.references.shift();\n        this.numEvicted++;\n      } else {\n        break;\n      }\n    }\n\n    if (this.references.length == 0) {\n      return;\n    }\n\n    // Adjust the last SegmentReference.\n    const lastReference = this.references[this.references.length - 1];\n    this.references[this.references.length - 1] =\n        new shaka.media.SegmentReference(\n            lastReference.startTime,\n            /* endTime= */ windowEnd,\n            lastReference.getUris,\n            lastReference.startByte,\n            lastReference.endByte,\n            lastReference.initSegmentReference,\n            lastReference.timestampOffset,\n            lastReference.appendWindowStart,\n            lastReference.appendWindowEnd);\n  }\n\n\n  /**\n   * Updates the references every so often.  Stops when the references list\n   * becomes empty.\n   *\n   * @param {number} interval The interval in seconds.\n   * @param {function():!Array.<shaka.media.SegmentReference>} updateCallback\n   * @export\n   */\n  updateEvery(interval, updateCallback) {\n    goog.asserts.assert(!this.timer_, 'SegmentIndex timer already started!');\n    if (this.immutable_) {\n      return;\n    }\n    if (this.timer_) {\n      this.timer_.stop();\n    }\n\n    this.timer_ = new shaka.util.Timer(() => {\n      const references = updateCallback();\n      this.references.push(...references);\n      if (this.references.length == 0) {\n        this.timer_.stop();\n        this.timer_ = null;\n      }\n    });\n    this.timer_.tickEvery(interval);\n  }\n\n\n  /** @return {!shaka.media.SegmentIterator} */\n  [Symbol.iterator]() {\n    return this.getIteratorForTime(0);\n  }\n\n  /**\n   * Returns a new iterator that initially points to the segment that contains\n   * the given time.  Like the normal iterator, next() must be called first to\n   * get to the first element.\n   *\n   * @param {number} time\n   * @return {!shaka.media.SegmentIterator}\n   * @export\n   */\n  getIteratorForTime(time) {\n    return new shaka.media.SegmentIterator(this, this.find(time) || 0);\n  }\n\n\n  /**\n   * Create a SegmentIndex for a single segment of the given start time and\n   * duration at the given URIs.\n   *\n   * @param {number} startTime\n   * @param {number} duration\n   * @param {!Array.<string>} uris\n   * @return {!shaka.media.SegmentIndex}\n   * @export\n   */\n  static forSingleSegment(startTime, duration, uris) {\n    const reference = new shaka.media.SegmentReference(\n        /* startTime= */ startTime,\n        /* endTime= */ startTime + duration,\n        /* getUris= */ () => uris,\n        /* startByte= */ 0,\n        /* endByte= */ null,\n        /* initSegmentReference= */ null,\n        /* presentationTimeOffset= */ startTime,\n        /* appendWindowStart= */ startTime,\n        /* appendWindowEnd= */ startTime + duration);\n    return new shaka.media.SegmentIndex([reference]);\n  }\n};\n\n\nif (goog.DEBUG) {\n  /**\n   * Asserts that the given SegmentReferences are sorted.\n   *\n   * @param {!Array.<shaka.media.SegmentReference>} references\n   * @private\n   */\n  shaka.media.SegmentIndex.assertCorrectReferences_ = (references) => {\n    goog.asserts.assert(references.every((r2, i) => {\n      if (i == 0) {\n        return true;\n      }\n      const r1 = references[i - 1];\n      if (r1.startTime < r2.startTime) {\n        return true;\n      } else if (r1.startTime > r2.startTime) {\n        return false;\n      } else {\n        if (r1.endTime <= r2.endTime) {\n          return true;\n        } else {\n          return false;\n        }\n      }\n    }), 'SegmentReferences are incorrect');\n  };\n}\n\n\n/**\n * An iterator over a SegmentIndex's references.\n *\n * @implements {Iterator.<shaka.media.SegmentReference>}\n * @export\n */\nshaka.media.SegmentIterator = class {\n  /**\n   * @param {shaka.media.SegmentIndex} segmentIndex\n   * @param {number} index\n   */\n  constructor(segmentIndex, index) {\n    /** @private {shaka.media.SegmentIndex} */\n    this.segmentIndex_ = segmentIndex;\n\n    /** @private {number} */\n    this.nextPosition_ = index;\n  }\n\n  /**\n   * Move the iterator to a given timestamp in the underlying SegmentIndex.\n   *\n   * @param {number} time\n   * @return {shaka.media.SegmentReference}\n   * @export\n   */\n  seek(time) {\n    const iter = this.segmentIndex_.getIteratorForTime(time);\n    this.nextPosition_ = iter.nextPosition_;\n    return this.next().value;\n  }\n\n  /**\n   * @return {shaka.media.SegmentReference}\n   * @export\n   */\n  current() {\n    return this.segmentIndex_.get(this.nextPosition_ - 1);\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  next() {\n    const ref = this.segmentIndex_.get(this.nextPosition_++);\n    return {\n      'value': ref,\n      'done': !ref,\n    };\n  }\n};\n\n\n/**\n * A meta-SegmentIndex composed of multiple other SegmentIndexes.\n * Used in constructing multi-Period Streams for DASH.\n *\n * @extends shaka.media.SegmentIndex\n * @implements {shaka.util.IReleasable}\n * @implements {Iterable.<!shaka.media.SegmentReference>}\n * @export\n */\nshaka.media.MetaSegmentIndex = class extends shaka.media.SegmentIndex {\n  constructor() {\n    super([]);\n\n    /** @private {!Array.<!shaka.media.SegmentIndex>} */\n    this.indexes_ = [];\n  }\n\n  /**\n   * Append a SegmentIndex to this MetaSegmentIndex.  This effectively stitches\n   * the underlying Stream onto the end of the multi-Period Stream represented\n   * by this MetaSegmentIndex.\n   *\n   * @param {!shaka.media.SegmentIndex} segmentIndex\n   */\n  appendSegmentIndex(segmentIndex) {\n    this.indexes_.push(segmentIndex);\n  }\n\n  /**\n   * Create a clone of this MetaSegmentIndex containing all the same indexes.\n   *\n   * @return {!shaka.media.MetaSegmentIndex}\n   */\n  clone() {\n    const clone = new shaka.media.MetaSegmentIndex();\n    // Be careful to clone the Array.  We don't want to share the reference with\n    // our clone and affect each other accidentally.\n    clone.indexes_ = this.indexes_.slice();\n    return clone;\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  release() {\n    for (const index of this.indexes_) {\n      index.release();\n    }\n\n    this.indexes_ = [];\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  find(time) {\n    let numPassedInEarlierIndexes = 0;\n\n    for (const index of this.indexes_) {\n      const position = index.find(time);\n\n      if (position != null) {\n        return position + numPassedInEarlierIndexes;\n      }\n\n      numPassedInEarlierIndexes += index.numEvicted + index.references.length;\n    }\n\n    return null;\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  get(position) {\n    let numPassedInEarlierIndexes = 0;\n\n    for (const index of this.indexes_) {\n      const reference = index.get(position - numPassedInEarlierIndexes);\n\n      if (reference) {\n        return reference;\n      }\n\n      numPassedInEarlierIndexes += index.numEvicted + index.references.length;\n    }\n\n    return null;\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  offset(offset) {\n    // offset() is only used by HLS, and MetaSegmentIndex is only used for DASH.\n    goog.asserts.assert(\n        false, 'offset() should not be used in MetaSegmentIndex!');\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  merge(references) {\n    // merge() is only used internally by the DASH and HLS parser on\n    // SegmentIndexes, but never on MetaSegmentIndex.\n    goog.asserts.assert(\n        false, 'merge() should not be used in MetaSegmentIndex!');\n  }\n\n\n  /**\n   * @override\n   * @export\n   */\n  evict(time) {\n    // evict() is only used internally by the DASH and HLS parser on\n    // SegmentIndexes, but never on MetaSegmentIndex.\n    goog.asserts.assert(\n        false, 'evict() should not be used in MetaSegmentIndex!');\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  fit(windowStart, windowEnd) {\n    // fit() is only used internally by manifest parsers on SegmentIndexes, but\n    // never on MetaSegmentIndex.\n    goog.asserts.assert(false, 'fit() should not be used in MetaSegmentIndex!');\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  updateEvery(interval, updateCallback) {\n    // updateEvery() is only used internally by the DASH parser on\n    // SegmentIndexes, but never on MetaSegmentIndex.\n    goog.asserts.assert(\n        false, 'updateEvery() should not be used in MetaSegmentIndex!');\n  }\n};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.media.PlayRateController');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.util.IReleasable');\ngoog.require('shaka.util.Timer');\n\n/**\n * The play rate controller controls the playback rate on the media element.\n * This provides some missing functionality (e.g. negative playback rate). If\n * the playback rate on the media element can change outside of the controller,\n * the playback controller will need to be updated to stay in-sync.\n *\n * TODO: Try not to manage buffering above the browser with playbackRate=0.\n *\n * @implements {shaka.util.IReleasable}\n * @final\n */\nshaka.media.PlayRateController = class {\n  /**\n   * @param {shaka.media.PlayRateController.Harness} harness\n   */\n  constructor(harness) {\n    /** @private {?shaka.media.PlayRateController.Harness} */\n    this.harness_ = harness;\n\n    /** @private {boolean} */\n    this.isBuffering_ = false;\n\n    /** @private {number} */\n    this.rate_ = this.harness_.getRate();\n\n    /** @private {number} */\n    this.pollRate_ = 0.25;\n\n    /** @private {shaka.util.Timer} */\n    this.timer_ = new shaka.util.Timer(() => {\n      this.harness_.movePlayhead(this.rate_ * this.pollRate_);\n    });\n  }\n\n  /** @override */\n  release() {\n    if (this.timer_) {\n      this.timer_.stop();\n      this.timer_ = null;\n    }\n\n    this.harness_ = null;\n  }\n\n  /**\n   * Sets the buffering flag, which controls the effective playback rate.\n   *\n   * @param {boolean} isBuffering If true, forces playback rate to 0 internally.\n   */\n  setBuffering(isBuffering) {\n    this.isBuffering_ = isBuffering;\n    this.apply_();\n  }\n\n  /**\n   * Set the playback rate. This rate will only be used as provided when the\n   * player is not buffering. You should never set the rate to 0.\n   *\n   * @param {number} rate\n   */\n  set(rate) {\n    goog.asserts.assert(rate != 0, 'Should never set rate of 0 explicitly!');\n    this.rate_ = rate;\n    this.apply_();\n  }\n\n  /**\n   * Get the real rate of the playback. This means that if we are using trick\n   * play, this will report the trick play rate. If playback is occurring as\n   * normal, this will report 1.\n   *\n   * @return {number}\n   */\n  getRealRate() {\n    return this.rate_;\n  }\n\n  /**\n   * Reapply the effects of |this.rate_| and |this.active_| to the media\n   * element. This will only update the rate via the harness if the desired rate\n   * has changed.\n   *\n   * @private\n   */\n  apply_() {\n    // Always stop the timer. We may not start it again.\n    this.timer_.stop();\n\n    /** @type {number} */\n    const rate = this.calculateCurrentRate_();\n\n    shaka.log.v1('Changing effective playback rate to', rate);\n\n    if (rate >= 0) {\n      try {\n        this.applyRate_(rate);\n        return;\n      } catch (e) {\n        // Fall through to the next clause.\n        //\n        // Fast forward is accomplished through setting video.playbackRate.\n        // If the play rate value is not supported by the browser (too big),\n        // the browsers will throw.\n        // Use this as a cue to fall back to fast forward through repeated\n        // seeking, which is what we do for rewind as well.\n      }\n    }\n\n    // When moving backwards or forwards in large steps,\n    // set the playback rate to 0 so that we can manually\n    // seek backwards with out fighting the playhead.\n    this.timer_.tickEvery(this.pollRate_);\n    this.applyRate_(0);\n  }\n\n  /**\n   * Calculate the rate that the controller wants the media element to have\n   * based on the current state of the controller.\n   *\n   * @return {number}\n   * @private\n   */\n  calculateCurrentRate_() {\n    return this.isBuffering_ ? 0 : this.rate_;\n  }\n\n  /**\n   * If the new rate is different than the media element's playback rate, this\n   * will change the playback rate. If the rate does not need to change, it will\n   * not be set. This will avoid unnecessary ratechange events.\n   *\n   * @param {number} newRate\n   * @return {boolean}\n   * @private\n   */\n  applyRate_(newRate) {\n    const oldRate = this.harness_.getRate();\n\n    if (oldRate != newRate) {\n      this.harness_.setRate(newRate);\n    }\n\n    return oldRate != newRate;\n  }\n};\n\n\n/**\n * @typedef {{\n *   getRate: function():number,\n *   setRate: function(number),\n *   movePlayhead: function(number)\n * }}\n *\n * @description\n *   A layer of abstraction between the controller and what it is controlling.\n *   In tests this will be implemented with spies. In production this will be\n *   implemented using a media element.\n *\n * @property {function():number} getRate\n *   Get the current playback rate being seen by the user.\n *\n * @property {function(number)} setRate\n *   Set the playback rate that the user should see.\n *\n * @property {function(number)} movePlayhead\n *   Move the playhead N seconds. If N is positive, the playhead will move\n *   forward abs(N) seconds. If N is negative, the playhead will move backwards\n *   abs(N) seconds.\n */\nshaka.media.PlayRateController.Harness;\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.media.IPlayheadObserver');\ngoog.provide('shaka.media.PlayheadObserverManager');\n\ngoog.require('shaka.util.IReleasable');\ngoog.require('shaka.util.Timer');\n\n\n/**\n * A playhead observer is a system that watches for meaningful changes in state\n * that are dependent on playhead information. The observer is responsible for\n * managing its own listeners.\n *\n * @extends {shaka.util.IReleasable}\n * @interface\n */\nshaka.media.IPlayheadObserver = class {\n  /**\n   * Check again (using an update playhead summary) if an event should be fired.\n   * If an event should be fired, fire it.\n   *\n   * @param {number} positionInSeconds\n   * @param {boolean} wasSeeking\n   */\n  poll(positionInSeconds, wasSeeking) {}\n};\n\n\n/**\n * The playhead observer manager is responsible for owning playhead observer\n * instances and polling them when needed. Destroying the manager will destroy\n * all observers managed by the manager.\n *\n * @implements {shaka.util.IReleasable}\n * @final\n */\nshaka.media.PlayheadObserverManager = class {\n  /**\n   * @param {!HTMLMediaElement} mediaElement\n   */\n  constructor(mediaElement) {\n    /** @private {HTMLMediaElement} */\n    this.mediaElement_ = mediaElement;\n\n    /**\n     * The set of all observers that this manager is responsible for updating.\n     * We are using a set to ensure that we don't double update an observer if\n     * it is accidentally added twice.\n     *\n     * @private {!Set.<shaka.media.IPlayheadObserver>}\n     */\n    this.observers_ = new Set();\n\n    /**\n     * To fire events semi-accurately, poll the observers 4 times a second. This\n     * should be frequent enough to trigger an event close enough to its actual\n     * occurrence without the user noticing a delay.\n     *\n     * @private {shaka.util.Timer}\n     */\n    this.pollingLoop_ = new shaka.util.Timer(() => {\n      this.pollAllObservers_(/* seeking= */ false);\n    }).tickEvery(/* seconds= */ 0.25);\n  }\n\n  /** @override */\n  release() {\n    // We need to stop the loop or else we may try to use a released resource.\n    this.pollingLoop_.stop();\n\n    for (const observer of this.observers_) {\n      observer.release();\n    }\n\n    this.observers_.clear();\n  }\n\n  /**\n   * Have the playhead observer manager manage a new observer. This will ensure\n   * that observers are only tracked once within the manager. After this call,\n   * the manager will be responsible for the life cycle of |observer|.\n   *\n   * @param {!shaka.media.IPlayheadObserver} observer\n   */\n  manage(observer) {\n    this.observers_.add(observer);\n  }\n\n  /**\n   * Notify all the observers that we just seeked.\n   */\n  notifyOfSeek() {\n    this.pollAllObservers_(/* seeking= */ true);\n  }\n\n  /**\n   * @param {boolean} seeking\n   * @private\n   */\n  pollAllObservers_(seeking) {\n    for (const observer of this.observers_) {\n      observer.poll(\n          this.mediaElement_.currentTime,\n          seeking);\n    }\n  }\n};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.media.RegionObserver');\n\ngoog.require('shaka.media.IPlayheadObserver');\ngoog.require('shaka.media.RegionTimeline');\n\n\n/**\n * The region observer watches a region timeline and playhead, and fires events\n * (onEnter, onExit, and onSkip) as the playhead moves.\n *\n * @implements {shaka.media.IPlayheadObserver}\n * @final\n */\nshaka.media.RegionObserver = class {\n  /**\n   * Create a region observer for the given timeline. The observer does not\n   * own the timeline, only uses it. This means that the observer should NOT\n   * destroy the timeline.\n   *\n   * @param {!shaka.media.RegionTimeline} timeline\n   */\n  constructor(timeline) {\n    /** @private {shaka.media.RegionTimeline} */\n    this.timeline_ = timeline;\n\n    /**\n     * A mapping between a region and where we previously were relative to it.\n     * When the value here differs from what we calculate, it means we moved and\n     * should fire an event.\n     *\n     * @private {!Map.<shaka.extern.TimelineRegionInfo,\n     *                 shaka.media.RegionObserver.RelativePosition_>}\n     */\n    this.oldPosition_ = new Map();\n\n    /** @private {shaka.media.RegionObserver.EventListener} */\n    this.onEnter_ = (region, seeking) => {};\n    /** @private {shaka.media.RegionObserver.EventListener} */\n    this.onExit_ = (region, seeking) => {};\n    /** @private {shaka.media.RegionObserver.EventListener} */\n    this.onSkip_ = (region, seeking) => {};\n\n    // To make the rules easier to read, alias all the relative positions.\n    const RelativePosition = shaka.media.RegionObserver.RelativePosition_;\n    const BEFORE_THE_REGION = RelativePosition.BEFORE_THE_REGION;\n    const IN_THE_REGION = RelativePosition.IN_THE_REGION;\n    const AFTER_THE_REGION = RelativePosition.AFTER_THE_REGION;\n\n    /**\n     * A read-only collection of rules for what to do when we change position\n     * relative to a region.\n     *\n     * @private {!Iterable.<shaka.media.RegionObserver.Rule_>}\n     */\n    this.rules_ = [\n      {\n        weWere: null,\n        weAre: IN_THE_REGION,\n        invoke: (region, seeking) => this.onEnter_(region, seeking),\n      },\n      {\n        weWere: BEFORE_THE_REGION,\n        weAre: IN_THE_REGION,\n        invoke: (region, seeking) => this.onEnter_(region, seeking),\n      },\n      {\n        weWere: AFTER_THE_REGION,\n        weAre: IN_THE_REGION,\n        invoke: (region, seeking) => this.onEnter_(region, seeking),\n      },\n      {\n        weWere: IN_THE_REGION,\n        weAre: BEFORE_THE_REGION,\n        invoke: (region, seeking) => this.onExit_(region, seeking),\n      },\n      {\n        weWere: IN_THE_REGION,\n        weAre: AFTER_THE_REGION,\n        invoke: (region, seeking) => this.onExit_(region, seeking),\n      },\n      {\n        weWere: BEFORE_THE_REGION,\n        weAre: AFTER_THE_REGION,\n        invoke: (region, seeking) => this.onSkip_(region, seeking),\n      },\n      {\n        weWere: AFTER_THE_REGION,\n        weAre: BEFORE_THE_REGION,\n        invoke: (region, seeking) => this.onSkip_(region, seeking),\n      },\n    ];\n  }\n\n  /** @override */\n  release() {\n    this.timeline_ = null;\n\n    // Clear our maps so that we are not holding onto any more information than\n    // needed.\n    this.oldPosition_.clear();\n\n    // Clear the callbacks so that we don't hold onto any references external\n    // to this class.\n    this.onEnter_ = (region, seeking) => {};\n    this.onExit_ = (region, seeking) => {};\n    this.onSkip_ = (region, seeking) => {};\n  }\n\n  /** @override */\n  poll(positionInSeconds, wasSeeking) {\n    const RegionObserver = shaka.media.RegionObserver;\n\n    for (const region of this.timeline_.regions()) {\n      const previousPosition = this.oldPosition_.get(region);\n      const currentPosition = RegionObserver.determinePositionRelativeTo_(\n          region, positionInSeconds);\n\n      // We will only use |previousPosition| and |currentPosition|, so we can\n      // update our state now.\n      this.oldPosition_.set(region, currentPosition);\n\n      for (const rule of this.rules_) {\n        if (rule.weWere == previousPosition && rule.weAre == currentPosition) {\n          rule.invoke(region, wasSeeking);\n        }\n      }\n    }\n  }\n\n  /**\n   * Set all the listeners. This overrides any previous calls to |setListeners|.\n   *\n   * @param {shaka.media.RegionObserver.EventListener} onEnter\n   *    The callback for when we move from outside a region to inside a region.\n   * @param {shaka.media.RegionObserver.EventListener} onExit\n   *    The callback for when we move from inside a region to outside a region.\n   * @param {shaka.media.RegionObserver.EventListener} onSkip\n   *    The callback for when we move from before to after a region or from\n   *    after to before a region.\n   */\n  setListeners(onEnter, onExit, onSkip) {\n    this.onEnter_ = onEnter;\n    this.onExit_ = onExit;\n    this.onSkip_ = onSkip;\n  }\n\n  /**\n   * Get the relative position of the playhead to |region| when the playhead is\n   * at |seconds|. We treat the region's start and end times as inclusive\n   * bounds.\n   *\n   * @param {shaka.extern.TimelineRegionInfo} region\n   * @param {number} seconds\n   * @return {shaka.media.RegionObserver.RelativePosition_}\n   * @private\n   */\n  static determinePositionRelativeTo_(region, seconds) {\n    const RelativePosition = shaka.media.RegionObserver.RelativePosition_;\n\n    if (seconds < region.startTime) {\n      return RelativePosition.BEFORE_THE_REGION;\n    }\n\n    if (seconds > region.endTime) {\n      return RelativePosition.AFTER_THE_REGION;\n    }\n\n    return RelativePosition.IN_THE_REGION;\n  }\n};\n\n/**\n * An enum of relative positions between the playhead and a region. Each is\n * phrased so that it works in \"The playhead is X\" where \"X\" is any value in\n * the enum.\n *\n * @enum {number}\n * @private\n */\nshaka.media.RegionObserver.RelativePosition_ = {\n  BEFORE_THE_REGION: 1,\n  IN_THE_REGION: 2,\n  AFTER_THE_REGION: 3,\n};\n\n/**\n * All region observer events (onEnter, onExit, and onSkip) will be passed the\n * region that the playhead is interacting with and whether or not the playhead\n * moving is part of a seek event.\n *\n * @typedef {function(shaka.extern.TimelineRegionInfo, boolean)}\n */\nshaka.media.RegionObserver.EventListener;\n\n/**\n * @typedef {{\n *    weWere: ?shaka.media.RegionObserver.RelativePosition_,\n *    weAre: ?shaka.media.RegionObserver.RelativePosition_,\n *    invoke: shaka.media.RegionObserver.EventListener\n * }}\n *\n * @private\n */\nshaka.media.RegionObserver.Rule_;\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.media.RegionTimeline');\n\ngoog.require('shaka.util.IReleasable');\ngoog.require('shaka.util.Timer');\n\n\n/**\n * The region timeline is a set of unique timeline region info entries. When\n * a new entry is added, the |onAddRegion| callback will be called.\n *\n * @implements {shaka.util.IReleasable}\n * @final\n */\nshaka.media.RegionTimeline = class {\n  constructor(getSeekRange) {\n    /** @private {function(shaka.extern.TimelineRegionInfo)} */\n    this.onAddRegion_ = (region) => {};\n    /** @private {!Set.<shaka.extern.TimelineRegionInfo>} */\n    this.regions_ = new Set();\n    /** @private {!function():{start: number, end: number}} */\n    this.getSeekRange_ = getSeekRange;\n\n    /**\n     * Make sure all of the regions we're tracking are within the\n     * seek range or further in the future. We don't want to store\n     * regions that fall before the start of the seek range.\n     *\n     * @private {shaka.util.Timer}\n     */\n    this.filterTimer_ = new shaka.util.Timer(() => {\n      this.filterBySeekRange_();\n    }).tickEvery(\n        /* seconds= */ shaka.media.RegionTimeline.REGION_FILTER_INTERVAL);\n  }\n\n  /** @override */\n  release() {\n    // Prevent us from holding onto any external references via the callback.\n    this.onAddRegion_ = (region) => {};\n    this.regions_.clear();\n    this.filterTimer_.stop();\n  }\n\n  /**\n   * Set the callbacks for events. This will override any previous calls to\n   * |setListeners|.\n   *\n   * @param {function(shaka.extern.TimelineRegionInfo)} onAddRegion\n   *    Set the callback for when we add a new region. This callback will only\n   *    be called when a region is unique (we reject duplicate regions).\n   */\n  setListeners(onAddRegion) {\n    this.onAddRegion_ = onAddRegion;\n  }\n\n  /**\n   * @param {shaka.extern.TimelineRegionInfo} region\n   */\n  addRegion(region) {\n    const similarRegion = this.findSimilarRegion_(region);\n\n    // Make sure we don't add duplicate regions. We keep track of this here\n    // instead of making the parser track it.\n    if (similarRegion == null) {\n      this.regions_.add(region);\n      this.onAddRegion_(region);\n    }\n  }\n\n  /*\n   * @private\n   */\n  filterBySeekRange_() {\n    const seekRange = this.getSeekRange_();\n    for (const region of this.regions_) {\n      // Only consider the seek range start here.\n      // Future regions might become relevant eventually,\n      // but regions that are in the past and can't ever be\n      // seeked to will never come up again, and there's no\n      // reson to store or process them.\n      if (region.endTime < seekRange.start) {\n        this.regions_.delete(region);\n      }\n    }\n  }\n\n  /**\n   * Find a region in the timeline that has the same scheme id uri, event id,\n   * start time and end time. If these four parameters match, we assume it\n   * to be the same region. If no similar region can be found, |null| will be\n   * returned.\n   *\n   * @param {shaka.extern.TimelineRegionInfo} region\n   * @return {?shaka.extern.TimelineRegionInfo}\n   * @private\n   */\n  findSimilarRegion_(region) {\n    for (const existing of this.regions_) {\n      // The same scheme ID and time range means that it is similar-enough to\n      // be the same region.\n      const isSimilar = existing.schemeIdUri == region.schemeIdUri &&\n                        existing.id == region.id &&\n                        existing.startTime == region.startTime &&\n                        existing.endTime == region.endTime;\n\n      if (isSimilar) {\n        return existing;\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Get an iterable for all the regions in the timeline. This will allow\n   * others to see what regions are in the timeline while not being able to\n   * change the collection.\n   *\n   * @return {!Iterable.<shaka.extern.TimelineRegionInfo>}\n   */\n  regions() {\n    return this.regions_;\n  }\n};\n\n/** @const {number} */\nshaka.media.RegionTimeline.REGION_FILTER_INTERVAL = 2; // in seconds\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.util.DataViewReader');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.util.BufferUtils');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.StringUtils');\n\n\n/**\n  * @summary DataViewReader abstracts a DataView object.\n  * @export\n  */\nshaka.util.DataViewReader = class {\n  /**\n   * @param {BufferSource} data\n   * @param {shaka.util.DataViewReader.Endianness} endianness The endianness.\n   */\n  constructor(data, endianness) {\n    /** @private {!DataView} */\n    this.dataView_ = shaka.util.BufferUtils.toDataView(data);\n\n    /** @private {boolean} */\n    this.littleEndian_ =\n        endianness == shaka.util.DataViewReader.Endianness.LITTLE_ENDIAN;\n\n    /** @private {number} */\n    this.position_ = 0;\n  }\n\n\n  /** @return {!DataView} The underlying DataView instance. */\n  getDataView() {\n    return this.dataView_;\n  }\n\n\n  /**\n   * @return {boolean} True if the reader has more data, false otherwise.\n   * @export\n   */\n  hasMoreData() {\n    return this.position_ < this.dataView_.byteLength;\n  }\n\n\n  /**\n   * Gets the current byte position.\n   * @return {number}\n   * @export\n   */\n  getPosition() {\n    return this.position_;\n  }\n\n\n  /**\n   * Gets the byte length of the DataView.\n   * @return {number}\n   * @export\n   */\n  getLength() {\n    return this.dataView_.byteLength;\n  }\n\n\n  /**\n   * Reads an unsigned 8 bit integer, and advances the reader.\n   * @return {number} The integer.\n   * @export\n   */\n  readUint8() {\n    try {\n      const value = this.dataView_.getUint8(this.position_);\n      this.position_ += 1;\n      return value;\n    } catch (exception) {\n      throw this.outOfBounds_();\n    }\n  }\n\n\n  /**\n   * Reads an unsigned 16 bit integer, and advances the reader.\n   * @return {number} The integer.\n   * @export\n   */\n  readUint16() {\n    try {\n      const value =\n          this.dataView_.getUint16(this.position_, this.littleEndian_);\n      this.position_ += 2;\n      return value;\n    } catch (exception) {\n      throw this.outOfBounds_();\n    }\n  }\n\n\n  /**\n   * Reads an unsigned 32 bit integer, and advances the reader.\n   * @return {number} The integer.\n   * @export\n   */\n  readUint32() {\n    try {\n      const value =\n          this.dataView_.getUint32(this.position_, this.littleEndian_);\n      this.position_ += 4;\n      return value;\n    } catch (exception) {\n      throw this.outOfBounds_();\n    }\n  }\n\n\n  /**\n   * Reads a signed 32 bit integer, and advances the reader.\n   * @return {number} The integer.\n   * @export\n   */\n  readInt32() {\n    try {\n      const value = this.dataView_.getInt32(this.position_, this.littleEndian_);\n      this.position_ += 4;\n      return value;\n    } catch (exception) {\n      throw this.outOfBounds_();\n    }\n  }\n\n\n  /**\n   * Reads an unsigned 64 bit integer, and advances the reader.\n   * @return {number} The integer.\n   * @export\n   */\n  readUint64() {\n    /** @type {number} */\n    let low;\n    /** @type {number} */\n    let high;\n\n    try {\n      if (this.littleEndian_) {\n        low = this.dataView_.getUint32(this.position_, true);\n        high = this.dataView_.getUint32(this.position_ + 4, true);\n      } else {\n        high = this.dataView_.getUint32(this.position_, false);\n        low = this.dataView_.getUint32(this.position_ + 4, false);\n      }\n    } catch (exception) {\n      throw this.outOfBounds_();\n    }\n\n    if (high > 0x1FFFFF) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.MEDIA,\n          shaka.util.Error.Code.JS_INTEGER_OVERFLOW);\n    }\n\n    this.position_ += 8;\n\n    // NOTE: This is subtle, but in JavaScript you can't shift left by 32\n    // and get the full range of 53-bit values possible.\n    // You must multiply by 2^32.\n    return (high * Math.pow(2, 32)) + low;\n  }\n\n\n  /**\n   * Reads the specified number of raw bytes.\n   * @param {number} bytes The number of bytes to read.\n   * @return {!Uint8Array}\n   * @export\n   */\n  readBytes(bytes) {\n    goog.asserts.assert(bytes >= 0, 'Bad call to DataViewReader.readBytes');\n    if (this.position_ + bytes > this.dataView_.byteLength) {\n      throw this.outOfBounds_();\n    }\n\n    const value =\n        shaka.util.BufferUtils.toUint8(this.dataView_, this.position_, bytes);\n    this.position_ += bytes;\n    return value;\n  }\n\n\n  /**\n   * Skips the specified number of bytes.\n   * @param {number} bytes The number of bytes to skip.\n   * @export\n   */\n  skip(bytes) {\n    goog.asserts.assert(bytes >= 0, 'Bad call to DataViewReader.skip');\n    if (this.position_ + bytes > this.dataView_.byteLength) {\n      throw this.outOfBounds_();\n    }\n    this.position_ += bytes;\n  }\n\n\n  /**\n   * Rewinds the specified number of bytes.\n   * @param {number} bytes The number of bytes to rewind.\n   * @export\n   */\n  rewind(bytes) {\n    goog.asserts.assert(bytes >= 0, 'Bad call to DataViewReader.rewind');\n    if (this.position_ < bytes) {\n      throw this.outOfBounds_();\n    }\n    this.position_ -= bytes;\n  }\n\n\n  /**\n   * Seeks to a specified position.\n   * @param {number} position The desired byte position within the DataView.\n   * @export\n   */\n  seek(position) {\n    goog.asserts.assert(position >= 0, 'Bad call to DataViewReader.seek');\n    if (position < 0 || position > this.dataView_.byteLength) {\n      throw this.outOfBounds_();\n    }\n    this.position_ = position;\n  }\n\n\n  /**\n   * Keeps reading until it reaches a byte that equals to zero.  The text is\n   * assumed to be UTF-8.\n   * @return {string}\n   * @export\n   */\n  readTerminatedString() {\n    const start = this.position_;\n    while (this.hasMoreData()) {\n      const value = this.dataView_.getUint8(this.position_);\n      if (value == 0) {\n        break;\n      }\n      this.position_ += 1;\n    }\n\n    const ret = shaka.util.BufferUtils.toUint8(\n        this.dataView_, start, this.position_ - start);\n    // Skip string termination.\n    this.position_ += 1;\n    return shaka.util.StringUtils.fromUTF8(ret);\n  }\n\n\n  /**\n   * @return {!shaka.util.Error}\n   * @private\n   */\n  outOfBounds_() {\n    return new shaka.util.Error(\n        shaka.util.Error.Severity.CRITICAL,\n        shaka.util.Error.Category.MEDIA,\n        shaka.util.Error.Code.BUFFER_READ_OUT_OF_BOUNDS);\n  }\n};\n\n/**\n * Endianness.\n * @enum {number}\n * @export\n */\nshaka.util.DataViewReader.Endianness = {\n  'BIG_ENDIAN': 0,\n  'LITTLE_ENDIAN': 1,\n};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.util.Mp4Parser');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.util.DataViewReader');\ngoog.require('shaka.util.Functional');\ngoog.require('shaka.util.Iterables');\n\n\n/**\n * @export\n */\nshaka.util.Mp4Parser = class {\n  constructor() {\n    /** @private {!Object.<number, shaka.util.Mp4Parser.BoxType_>} */\n    this.headers_ = [];\n\n    /** @private {!Object.<number, !shaka.util.Mp4Parser.CallbackType>} */\n    this.boxDefinitions_ = [];\n\n    /** @private {boolean} */\n    this.done_ = false;\n  }\n\n\n  /**\n   * Declare a box type as a Box.\n   *\n   * @param {string} type\n   * @param {!shaka.util.Mp4Parser.CallbackType} definition\n   * @return {!shaka.util.Mp4Parser}\n   * @export\n   */\n  box(type, definition) {\n    const typeCode = shaka.util.Mp4Parser.typeFromString_(type);\n    this.headers_[typeCode] = shaka.util.Mp4Parser.BoxType_.BASIC_BOX;\n    this.boxDefinitions_[typeCode] = definition;\n    return this;\n  }\n\n\n  /**\n   * Declare a box type as a Full Box.\n   *\n   * @param {string} type\n   * @param {!shaka.util.Mp4Parser.CallbackType} definition\n   * @return {!shaka.util.Mp4Parser}\n   * @export\n   */\n  fullBox(type, definition) {\n    const typeCode = shaka.util.Mp4Parser.typeFromString_(type);\n    this.headers_[typeCode] = shaka.util.Mp4Parser.BoxType_.FULL_BOX;\n    this.boxDefinitions_[typeCode] = definition;\n    return this;\n  }\n\n\n  /**\n   * Stop parsing.  Useful for extracting information from partial segments and\n   * avoiding an out-of-bounds error once you find what you are looking for.\n   *\n   * @export\n   */\n  stop() {\n    this.done_ = true;\n  }\n\n\n  /**\n   * Parse the given data using the added callbacks.\n   *\n   * @param {!BufferSource} data\n   * @param {boolean=} partialOkay If true, allow reading partial payloads\n   *   from some boxes. If the goal is a child box, we can sometimes find it\n   *   without enough data to find all child boxes.\n   * @export\n   */\n  parse(data, partialOkay) {\n    const reader = new shaka.util.DataViewReader(\n        data, shaka.util.DataViewReader.Endianness.BIG_ENDIAN);\n\n    this.done_ = false;\n    while (reader.hasMoreData() && !this.done_) {\n      this.parseNext(0, reader, partialOkay);\n    }\n  }\n\n\n  /**\n   * Parse the next box on the current level.\n   *\n   * @param {number} absStart The absolute start position in the original\n   *   byte array.\n   * @param {!shaka.util.DataViewReader} reader\n   * @param {boolean=} partialOkay If true, allow reading partial payloads\n   *   from some boxes. If the goal is a child box, we can sometimes find it\n   *   without enough data to find all child boxes.\n   * @export\n   */\n  parseNext(absStart, reader, partialOkay) {\n    const start = reader.getPosition();\n\n    let size = reader.readUint32();\n    const type = reader.readUint32();\n    const name = shaka.util.Mp4Parser.typeToString(type);\n    shaka.log.v2('Parsing MP4 box', name);\n\n    switch (size) {\n      case 0:\n        size = reader.getLength() - start;\n        break;\n      case 1:\n        size = reader.readUint64();\n        break;\n    }\n\n    const boxDefinition = this.boxDefinitions_[type];\n\n    if (boxDefinition) {\n      let version = null;\n      let flags = null;\n\n      if (this.headers_[type] == shaka.util.Mp4Parser.BoxType_.FULL_BOX) {\n        const versionAndFlags = reader.readUint32();\n        version = versionAndFlags >>> 24;\n        flags = versionAndFlags & 0xFFFFFF;\n      }\n\n      // Read the whole payload so that the current level can be safely read\n      // regardless of how the payload is parsed.\n      let end = start + size;\n      if (partialOkay && end > reader.getLength()) {\n        // For partial reads, truncate the payload if we must.\n        end = reader.getLength();\n      }\n      const payloadSize = end - reader.getPosition();\n      const payload =\n      (payloadSize > 0) ? reader.readBytes(payloadSize) : new Uint8Array(0);\n\n      const payloadReader = new shaka.util.DataViewReader(\n          payload, shaka.util.DataViewReader.Endianness.BIG_ENDIAN);\n\n      /** @type {shaka.extern.ParsedBox} */\n      const box = {\n        parser: this,\n        partialOkay: partialOkay || false,\n        version: version,\n        flags: flags,\n        reader: payloadReader,\n        size: size,\n        start: start + absStart,\n      };\n\n      boxDefinition(box);\n    } else {\n      // Move the read head to be at the end of the box.\n      // If the box is longer than the remaining parts of the file, e.g. the\n      // mp4 is improperly formatted, or this was a partial range request that\n      // ended in the middle of a box, just skip to the end.\n      const skipLength = Math.min(\n          start + size - reader.getPosition(),\n          reader.getLength() - reader.getPosition());\n      reader.skip(skipLength);\n    }\n  }\n\n\n  /**\n   * A callback that tells the Mp4 parser to treat the body of a box as a series\n   * of boxes. The number of boxes is limited by the size of the parent box.\n   *\n   * @param {!shaka.extern.ParsedBox} box\n   * @export\n   */\n  static children(box) {\n    // The \"reader\" starts at the payload, so we need to add the header to the\n    // start position.  This is either 8 or 12 bytes depending on whether this\n    // is a full box.\n    const header = box.flags != null ? 12 : 8;\n    while (box.reader.hasMoreData() && !box.parser.done_) {\n      box.parser.parseNext(box.start + header, box.reader, box.partialOkay);\n    }\n  }\n\n\n  /**\n   * A callback that tells the Mp4 parser to treat the body of a box as a sample\n   * description. A sample description box has a fixed number of children. The\n   * number of children is represented by a 4 byte unsigned integer. Each child\n   * is a box.\n   *\n   * @param {!shaka.extern.ParsedBox} box\n   * @export\n   */\n  static sampleDescription(box) {\n    // The \"reader\" starts at the payload, so we need to add the header to the\n    // start position.  This is either 8 or 12 bytes depending on whether this\n    // is a full box.\n    const header = box.flags != null ? 12 : 8;\n    const count = box.reader.readUint32();\n    for (const _ of shaka.util.Iterables.range(count)) {\n      shaka.util.Functional.ignored(_);\n      box.parser.parseNext(box.start + header, box.reader, box.partialOkay);\n      if (box.parser.done_) {\n        break;\n      }\n    }\n  }\n\n\n  /**\n   * Create a callback that tells the Mp4 parser to treat the body of a box as a\n   * binary blob and to parse the body's contents using the provided callback.\n   *\n   * @param {function(!Uint8Array)} callback\n   * @return {!shaka.util.Mp4Parser.CallbackType}\n   * @export\n   */\n  static allData(callback) {\n    return (box) => {\n      const all = box.reader.getLength() - box.reader.getPosition();\n      callback(box.reader.readBytes(all));\n    };\n  }\n\n\n  /**\n   * Convert an ascii string name to the integer type for a box.\n   *\n   * @param {string} name The name of the box. The name must be four\n   *                      characters long.\n   * @return {number}\n   * @private\n   */\n  static typeFromString_(name) {\n    goog.asserts.assert(\n        name.length == 4,\n        'Mp4 box names must be 4 characters long');\n\n    let code = 0;\n    for (const chr of name) {\n      code = (code << 8) | chr.charCodeAt(0);\n    }\n    return code;\n  }\n\n\n  /**\n   * Convert an integer type from a box into an ascii string name.\n   * Useful for debugging.\n   *\n   * @param {number} type The type of the box, a uint32.\n   * @return {string}\n   * @export\n   */\n  static typeToString(type) {\n    const name = String.fromCharCode(\n        (type >> 24) & 0xff,\n        (type >> 16) & 0xff,\n        (type >> 8) & 0xff,\n        type & 0xff);\n    return name;\n  }\n};\n\n\n/**\n * @typedef {function(!shaka.extern.ParsedBox)}\n * @exportInterface\n */\nshaka.util.Mp4Parser.CallbackType;\n\n\n/**\n * An enum used to track the type of box so that the correct values can be\n * read from the header.\n *\n * @enum {number}\n * @private\n */\nshaka.util.Mp4Parser.BoxType_ = {\n  BASIC_BOX: 0,\n  FULL_BOX: 1,\n};\n\n\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.util.Networking');\n\ngoog.require('shaka.net.NetworkingEngine');\n\n\n/**\n * A collection of shared utilities that bridge the gap between our networking\n * code and the other parts of our code base. This is to allow\n * |shaka.net.NetworkingEngine| to remain general.\n *\n * @final\n */\nshaka.util.Networking = class {\n  /**\n   * Create a request message for a segment. Providing |start| and |end|\n   * will set the byte range. A non-zero start must be provided for |end| to\n   * be used.\n   *\n   * @param {!Array.<string>} uris\n   * @param {?number} start\n   * @param {?number} end\n   * @param {shaka.extern.RetryParameters} retryParameters\n   * @return {shaka.extern.Request}\n   */\n  static createSegmentRequest(uris, start, end, retryParameters) {\n    const request = shaka.net.NetworkingEngine.makeRequest(\n        uris, retryParameters);\n\n    if (start == 0 && end == null) {\n      // This is a request for the entire segment.  The Range header is not\n      // required.  Note that some web servers don't accept Range headers, so\n      // don't set one if it's not strictly required.\n    } else {\n      if (end) {\n        request.headers['Range'] = 'bytes=' + start + '-' + end;\n      } else {\n        request.headers['Range'] = 'bytes=' + start + '-';\n      }\n    }\n\n    return request;\n  }\n};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview\n * @suppress {missingRequire} TODO(b/152540451): this shouldn't be needed\n */\n\ngoog.provide('shaka.media.StreamingEngine');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.media.MediaSourceEngine');\ngoog.require('shaka.net.Backoff');\ngoog.require('shaka.net.NetworkingEngine');\ngoog.require('shaka.util.DelayedTick');\ngoog.require('shaka.util.Destroyer');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.FakeEvent');\ngoog.require('shaka.util.IDestroyable');\ngoog.require('shaka.util.ManifestParserUtils');\ngoog.require('shaka.util.MimeUtils');\ngoog.require('shaka.util.Mp4Parser');\ngoog.require('shaka.util.Networking');\n\n\n/**\n * @summary Creates a Streaming Engine.\n * The StreamingEngine is responsible for setting up the Manifest's Streams\n * (i.e., for calling each Stream's createSegmentIndex() function), for\n * downloading segments, for co-ordinating audio, video, and text buffering.\n * The StreamingEngine provides an interface to switch between Streams, but it\n * does not choose which Streams to switch to.\n *\n * The StreamingEngine does not need to be notified about changes to the\n * Manifest's SegmentIndexes; however, it does need to be notified when new\n * Variants are added to the Manifest.\n *\n * To start the StreamingEngine the owner must first call configure(), followed\n * by one call to switchVariant(), one optional call to switchTextStream(), and\n * finally a call to start().  After start() resolves, switch*() can be used\n * freely.\n *\n * The owner must call seeked() each time the playhead moves to a new location\n * within the presentation timeline; however, the owner may forego calling\n * seeked() when the playhead moves outside the presentation timeline.\n *\n * @implements {shaka.util.IDestroyable}\n */\nshaka.media.StreamingEngine = class {\n  /**\n   * @param {shaka.extern.Manifest} manifest\n   * @param {shaka.media.StreamingEngine.PlayerInterface} playerInterface\n   */\n  constructor(manifest, playerInterface) {\n    /** @private {?shaka.media.StreamingEngine.PlayerInterface} */\n    this.playerInterface_ = playerInterface;\n\n    /** @private {?shaka.extern.Manifest} */\n    this.manifest_ = manifest;\n\n    /** @private {?shaka.extern.StreamingConfiguration} */\n    this.config_ = null;\n\n    /** @private {number} */\n    this.bufferingGoalScale_ = 1;\n\n    /** @private {?shaka.extern.Variant} */\n    this.currentVariant_ = null;\n\n    /** @private {?shaka.extern.Stream} */\n    this.currentTextStream_ = null;\n\n    /**\n     * Maps a content type, e.g., 'audio', 'video', or 'text', to a MediaState.\n     *\n     * @private {!Map.<shaka.util.ManifestParserUtils.ContentType,\n     *                 !shaka.media.StreamingEngine.MediaState_>}\n     */\n    this.mediaStates_ = new Map();\n\n    /**\n     * Set to true once the initial media states have been created.\n     *\n     * @private {boolean}\n     */\n    this.startupComplete_ = false;\n\n    /**\n     * Used for delay and backoff of failure callbacks, so that apps do not\n     * retry instantly.\n     *\n     * @private {shaka.net.Backoff}\n     */\n    this.failureCallbackBackoff_ = null;\n\n    /**\n     * Set to true on fatal error.  Interrupts fetchAndAppend_().\n     *\n     * @private {boolean}\n     */\n    this.fatalError_ = false;\n\n    /** @private {!shaka.util.Destroyer} */\n    this.destroyer_ = new shaka.util.Destroyer(() => this.doDestroy_());\n  }\n\n  /** @override */\n  destroy() {\n    return this.destroyer_.destroy();\n  }\n\n  /**\n   * @return {!Promise}\n   * @private\n   */\n  async doDestroy_() {\n    const aborts = [];\n\n    for (const state of this.mediaStates_.values()) {\n      this.cancelUpdate_(state);\n      aborts.push(this.abortOperations_(state));\n    }\n\n    await Promise.all(aborts);\n\n    this.mediaStates_.clear();\n\n    this.playerInterface_ = null;\n    this.manifest_ = null;\n    this.config_ = null;\n  }\n\n  /**\n   * Called by the Player to provide an updated configuration any time it\n   * changes. Must be called at least once before start().\n   *\n   * @param {shaka.extern.StreamingConfiguration} config\n   */\n  configure(config) {\n    this.config_ = config;\n\n    // Create separate parameters for backoff during streaming failure.\n\n    /** @type {shaka.extern.RetryParameters} */\n    const failureRetryParams = {\n      // The term \"attempts\" includes the initial attempt, plus all retries.\n      // In order to see a delay, there would have to be at least 2 attempts.\n      maxAttempts: Math.max(config.retryParameters.maxAttempts, 2),\n      baseDelay: config.retryParameters.baseDelay,\n      backoffFactor: config.retryParameters.backoffFactor,\n      fuzzFactor: config.retryParameters.fuzzFactor,\n      timeout: 0,  // irrelevant\n    };\n\n    // We don't want to ever run out of attempts.  The application should be\n    // allowed to retry streaming infinitely if it wishes.\n    const autoReset = true;\n    this.failureCallbackBackoff_ =\n        new shaka.net.Backoff(failureRetryParams, autoReset);\n  }\n\n\n  /**\n   * Initialize and start streaming.\n   *\n   * By calling this method, StreamingEngine will start streaming the variant\n   * chosen by a prior call to switchVariant(), and optionally, the text stream\n   * chosen by a prior call to switchTextStream().  Once the Promise resolves,\n   * switch*() may be called freely.\n   *\n   * @return {!Promise}\n   */\n  async start() {\n    goog.asserts.assert(this.config_,\n        'StreamingEngine configure() must be called before init()!');\n\n    // Setup the initial set of Streams and then begin each update cycle.\n    await this.initStreams_();\n    this.destroyer_.ensureNotDestroyed();\n\n    shaka.log.debug('init: completed initial Stream setup');\n    this.startupComplete_ = true;\n  }\n\n  /**\n   * Get the current variant we are streaming.  Returns null if nothing is\n   * streaming.\n   * @return {?shaka.extern.Variant}\n   */\n  getCurrentVariant() {\n    return this.currentVariant_;\n  }\n\n  /**\n   * Get the text stream we are streaming.  Returns null if there is no text\n   * streaming.\n   * @return {?shaka.extern.Stream}\n   */\n  getCurrentTextStream() {\n    return this.currentTextStream_;\n  }\n\n  /**\n   * Start streaming text, creating a new media state.\n   *\n   * @param {shaka.extern.Stream} stream\n   * @return {!Promise}\n   * @private\n   */\n  async loadNewTextStream_(stream) {\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n    goog.asserts.assert(!this.mediaStates_.has(ContentType.TEXT),\n        'Should not call loadNewTextStream_ while streaming text!');\n\n    try {\n      // Clear MediaSource's buffered text, so that the new text stream will\n      // properly replace the old buffered text.\n      // TODO: Should this happen in unloadTextStream() instead?\n      await this.playerInterface_.mediaSourceEngine.clear(ContentType.TEXT);\n    } catch (error) {\n      if (this.playerInterface_) {\n        this.playerInterface_.onError(error);\n      }\n    }\n\n    const mimeType = shaka.util.MimeUtils.getFullType(\n        stream.mimeType, stream.codecs);\n    this.playerInterface_.mediaSourceEngine.reinitText(mimeType);\n\n    const textDisplayer =\n        this.playerInterface_.mediaSourceEngine.getTextDisplayer();\n    const streamText =\n        textDisplayer.isTextVisible() || this.config_.alwaysStreamText;\n\n    if (streamText) {\n      const state = this.createMediaState_(stream);\n      this.mediaStates_.set(ContentType.TEXT, state);\n      this.scheduleUpdate_(state, 0);\n    }\n  }\n\n\n  /**\n   * Stop fetching text stream when the user chooses to hide the captions.\n   */\n  unloadTextStream() {\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n\n    const state = this.mediaStates_.get(ContentType.TEXT);\n    if (state) {\n      this.cancelUpdate_(state);\n      this.abortOperations_(state).catch(() => {});\n      this.mediaStates_.delete(ContentType.TEXT);\n    }\n    this.currentTextStream_ = null;\n  }\n\n  /**\n   * Set trick play on or off.\n   * If trick play is on, related trick play streams will be used when possible.\n   * @param {boolean} on\n   */\n  setTrickPlay(on) {\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n\n    const mediaState = this.mediaStates_.get(ContentType.VIDEO);\n    if (!mediaState) {\n      return;\n    }\n\n    const stream = mediaState.stream;\n    if (!stream) {\n      return;\n    }\n\n    shaka.log.debug('setTrickPlay', on);\n    if (on) {\n      const trickModeVideo = stream.trickModeVideo;\n      if (!trickModeVideo) {\n        return;  // Can't engage trick play.\n      }\n\n      const normalVideo = mediaState.restoreStreamAfterTrickPlay;\n      if (normalVideo) {\n        return;  // Already in trick play.\n      }\n\n      shaka.log.debug('Engaging trick mode stream', trickModeVideo);\n      this.switchInternal_(trickModeVideo, /* clearBuffer= */ false,\n          /* safeMargin= */ 0, /* force= */ false);\n\n      mediaState.restoreStreamAfterTrickPlay = stream;\n    } else {\n      const normalVideo = mediaState.restoreStreamAfterTrickPlay;\n      if (!normalVideo) {\n        return;\n      }\n\n      shaka.log.debug('Restoring non-trick-mode stream', normalVideo);\n      mediaState.restoreStreamAfterTrickPlay = null;\n      this.switchInternal_(normalVideo, /* clearBuffer= */ true,\n          /* safeMargin= */ 0, /* force= */ false);\n    }\n  }\n\n\n  /**\n   * @param {shaka.extern.Variant} variant\n   * @param {boolean=} clearBuffer\n   * @param {number=} safeMargin\n   */\n  switchVariant(variant, clearBuffer = false, safeMargin = 0) {\n    this.currentVariant_ = variant;\n\n    if (!this.startupComplete_) {\n      // The selected variant will be used in start().\n      return;\n    }\n\n    if (variant.video) {\n      this.switchInternal_(\n          variant.video, /* clearBuffer= */ clearBuffer,\n          /* safeMargin= */ safeMargin, /* force= */ false);\n    }\n    if (variant.audio) {\n      this.switchInternal_(\n          variant.audio, /* clearBuffer= */ clearBuffer,\n          /* safeMargin= */ safeMargin, /* force= */ false);\n    }\n  }\n\n\n  /**\n   * @param {shaka.extern.Stream} textStream\n   */\n  switchTextStream(textStream) {\n    this.currentTextStream_ = textStream;\n\n    if (!this.startupComplete_) {\n      // The selected text stream will be used in start().\n      return;\n    }\n\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n    goog.asserts.assert(textStream && textStream.type == ContentType.TEXT,\n        'Wrong stream type passed to switchTextStream!');\n\n    this.switchInternal_(\n        textStream, /* clearBuffer= */ true,\n        /* safeMargin= */ 0, /* force= */ false);\n  }\n\n\n  /** Reload the current text stream. */\n  reloadTextStream() {\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n    const mediaState = this.mediaStates_.get(ContentType.TEXT);\n    if (mediaState) { // Don't reload if there's no text to begin with.\n      this.switchInternal_(\n          mediaState.stream, /* clearBuffer= */ true,\n          /* safeMargin= */ 0, /* force= */ true);\n    }\n  }\n\n\n  /**\n   * Switches to the given Stream. |stream| may be from any Variant.\n   *\n   * @param {shaka.extern.Stream} stream\n   * @param {boolean} clearBuffer\n   * @param {number} safeMargin\n   * @param {boolean} force\n   *   If true, reload the text stream even if it did not change.\n   * @private\n   */\n  switchInternal_(stream, clearBuffer, safeMargin, force) {\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n    const type = /** @type {!ContentType} */(stream.type);\n    const mediaState = this.mediaStates_.get(type);\n\n    if (!mediaState && stream.type == ContentType.TEXT) {\n      this.loadNewTextStream_(stream);\n      return;\n    }\n\n    goog.asserts.assert(mediaState, 'switch: expected mediaState to exist');\n    if (!mediaState) {\n      return;\n    }\n\n    if (mediaState.restoreStreamAfterTrickPlay) {\n      shaka.log.debug('switch during trick play mode', stream);\n\n      // Already in trick play mode, so stick with trick mode tracks if\n      // possible.\n      if (stream.trickModeVideo) {\n        // Use the trick mode stream, but revert to the new selection later.\n        mediaState.restoreStreamAfterTrickPlay = stream;\n        stream = stream.trickModeVideo;\n        shaka.log.debug('switch found trick play stream', stream);\n      } else {\n        // There is no special trick mode video for this stream!\n        mediaState.restoreStreamAfterTrickPlay = null;\n        shaka.log.debug('switch found no special trick play stream');\n      }\n    }\n\n    if (mediaState.stream == stream && !force) {\n      const streamTag = shaka.media.StreamingEngine.logPrefix_(mediaState);\n      shaka.log.debug('switch: Stream ' + streamTag + ' already active');\n      return;\n    }\n\n    if (stream.type == ContentType.TEXT) {\n      // Mime types are allowed to change for text streams.\n      // Reinitialize the text parser, but only if we are going to fetch the\n      // init segment again.\n      const fullMimeType = shaka.util.MimeUtils.getFullType(\n          stream.mimeType, stream.codecs);\n      this.playerInterface_.mediaSourceEngine.reinitText(fullMimeType);\n    }\n\n    mediaState.stream = stream;\n    mediaState.segmentIterator = null;\n\n    const streamTag = shaka.media.StreamingEngine.logPrefix_(mediaState);\n    shaka.log.debug('switch: switching to Stream ' + streamTag);\n\n    if (clearBuffer) {\n      if (mediaState.clearingBuffer) {\n        // We are already going to clear the buffer, but make sure it is also\n        // flushed.\n        mediaState.waitingToFlushBuffer = true;\n      } else if (mediaState.performingUpdate) {\n        // We are performing an update, so we have to wait until it's finished.\n        // onUpdate_() will call clearBuffer_() when the update has finished.\n        // We need to save the safe margin because its value will be needed when\n        // clearing the buffer after the update.\n        mediaState.waitingToClearBuffer = true;\n        mediaState.clearBufferSafeMargin = safeMargin;\n        mediaState.waitingToFlushBuffer = true;\n      } else {\n        // Cancel the update timer, if any.\n        this.cancelUpdate_(mediaState);\n        // Clear right away.\n        this.clearBuffer_(mediaState, /* flush= */ true, safeMargin)\n            .catch((error) => {\n              if (this.playerInterface_) {\n                goog.asserts.assert(error instanceof shaka.util.Error,\n                    'Wrong error type!');\n                this.playerInterface_.onError(error);\n              }\n            });\n      }\n    }\n\n    this.makeAbortDecision_(mediaState).catch((error) => {\n      if (this.playerInterface_) {\n        goog.asserts.assert(error instanceof shaka.util.Error,\n            'Wrong error type!');\n        this.playerInterface_.onError(error);\n      }\n    });\n  }\n\n\n  /**\n   * Decide if it makes sense to abort the current operation, and abort it if\n   * so.\n   *\n   * @param {!shaka.media.StreamingEngine.MediaState_} mediaState\n   * @private\n   */\n  async makeAbortDecision_(mediaState) {\n    // If the operation is completed, it will be set to null, and there's no\n    // need to abort the request.\n    if (!mediaState.operation) {\n      return;\n    }\n\n    const originalStream = mediaState.stream;\n    const originalOperation = mediaState.operation;\n\n    if (!originalStream.segmentIndex) {\n      // Create the new segment index so the time taken is accounted for when\n      // deciding whether to abort.\n      await originalStream.createSegmentIndex();\n    }\n\n    if (mediaState.operation != originalOperation) {\n      // The original operation completed while we were getting a segment index,\n      // so there's nothing to do now.\n      return;\n    }\n\n    if (mediaState.stream != originalStream) {\n      // The stream changed again while we were getting a segment index.  We\n      // can't carry out this check, since another one might be in progress by\n      // now.\n      return;\n    }\n\n    goog.asserts.assert(mediaState.stream.segmentIndex,\n        'Segment index should exist by now!');\n\n    if (this.shouldAbortCurrentRequest_(mediaState)) {\n      shaka.log.info('Aborting current segment request.');\n      mediaState.operation.abort();\n    }\n  }\n\n  /**\n   * Returns whether we should abort the current request.\n   *\n   * @param {!shaka.media.StreamingEngine.MediaState_} mediaState\n   * @return {boolean}\n   * @private\n   */\n  shouldAbortCurrentRequest_(mediaState) {\n    goog.asserts.assert(mediaState.operation,\n        'Abort logic requires an ongoing operation!');\n    goog.asserts.assert(mediaState.stream && mediaState.stream.segmentIndex,\n        'Abort logic requires a segment index');\n\n    const presentationTime = this.playerInterface_.getPresentationTime();\n    const bufferEnd =\n        this.playerInterface_.mediaSourceEngine.bufferEnd(mediaState.type);\n\n    // The next segment to append from the current stream.  This doesn't\n    // account for a pending network request and will likely be different from\n    // that since we just switched.\n    const timeNeeded = this.getTimeNeeded_(mediaState, presentationTime);\n    const index = mediaState.stream.segmentIndex.find(timeNeeded);\n    const newSegment =\n        index == null ? null : mediaState.stream.segmentIndex.get(index);\n\n    let newSegmentSize = newSegment ? newSegment.getSize() : null;\n    if (newSegment && !newSegmentSize) {\n      // compute approximate segment size using stream bandwidth\n      const duration = newSegment.getEndTime() - newSegment.getStartTime();\n      const bandwidth = mediaState.stream.bandwidth || 0;\n      // bandwidth is in bits per second, and the size is in bytes\n      newSegmentSize = duration * bandwidth / 8;\n    }\n\n    if (!newSegmentSize) {\n      return false;\n    }\n\n    // When switching, we'll need to download the init segment.\n    const init = newSegment.initSegmentReference;\n    if (init) {\n      newSegmentSize += init.getSize() || 0;\n    }\n\n    const bandwidthEstimate = this.playerInterface_.getBandwidthEstimate();\n\n    // The estimate is in bits per second, and the size is in bytes.  The time\n    // remaining is in seconds after this calculation.\n    const timeToFetchNewSegment = (newSegmentSize * 8) / bandwidthEstimate;\n\n    // If the new segment can be finished in time without risking a buffer\n    // underflow, we should abort the old one and switch.\n    const bufferedAhead = (bufferEnd || 0) - presentationTime;\n    const safetyBuffer = Math.max(\n        this.manifest_.minBufferTime || 0,\n        this.config_.rebufferingGoal);\n    const safeBufferedAhead = bufferedAhead - safetyBuffer;\n    if (timeToFetchNewSegment < safeBufferedAhead) {\n      return true;\n    }\n\n    // If the thing we want to switch to will be done more quickly than what\n    // we've got in progress, we should abort the old one and switch.\n    const bytesRemaining = mediaState.operation.getBytesRemaining();\n    if (bytesRemaining > newSegmentSize) {\n      return true;\n    }\n\n    // Otherwise, complete the operation in progress.\n    return false;\n  }\n\n\n  /**\n   * Notifies the StreamingEngine that the playhead has moved to a valid time\n   * within the presentation timeline.\n   */\n  seeked() {\n    const presentationTime = this.playerInterface_.getPresentationTime();\n    const smallGapLimit = this.config_.smallGapLimit;\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n    const newTimeIsBuffered = (type) => {\n      return this.playerInterface_.mediaSourceEngine.isBuffered(\n          type, presentationTime, smallGapLimit);\n    };\n\n    let streamCleared = false;\n    for (const type of this.mediaStates_.keys()) {\n      const mediaState = this.mediaStates_.get(type);\n      const logPrefix = shaka.media.StreamingEngine.logPrefix_(mediaState);\n\n      // Always clear the iterator since we need to start streaming from the\n      // new time.  This also happens in clearBuffer_, but if we don't clear,\n      // we still want to reset the iterator.\n      mediaState.segmentIterator = null;\n\n      if (!newTimeIsBuffered(type)) {\n        const bufferEnd =\n            this.playerInterface_.mediaSourceEngine.bufferEnd(type);\n        const somethingBuffered = bufferEnd != null;\n\n        // Don't clear the buffer unless something is buffered.  This extra\n        // check prevents extra, useless calls to clear the buffer.\n        if (somethingBuffered) {\n          this.forceClearBuffer_(mediaState);\n          streamCleared = true;\n        }\n\n        // If there is an operation in progress, stop it now.\n        if (mediaState.operation) {\n          mediaState.operation.abort();\n          shaka.log.debug(logPrefix, 'Aborting operation due to seek');\n          mediaState.operation = null;\n        }\n\n        // The pts has shifted from the seek, invalidating captions currently\n        // in the text buffer. Thus, clear and reset the caption parser.\n        if (type === ContentType.TEXT) {\n          this.playerInterface_.mediaSourceEngine.resetCaptionParser();\n        }\n      }\n    }\n\n    if (!streamCleared) {\n      shaka.log.debug(\n          '(all): seeked: buffered seek: presentationTime=' + presentationTime);\n    }\n  }\n\n\n  /**\n   * Clear the buffer for a given stream.  Unlike clearBuffer_, this will handle\n   * cases where a MediaState is performing an update.  After this runs, every\n   * MediaState will have a pending update.\n   * @param {!shaka.media.StreamingEngine.MediaState_} mediaState\n   * @private\n   */\n  forceClearBuffer_(mediaState) {\n    const logPrefix = shaka.media.StreamingEngine.logPrefix_(mediaState);\n\n    if (mediaState.clearingBuffer) {\n      // We're already clearing the buffer, so we don't need to clear the\n      // buffer again.\n      shaka.log.debug(logPrefix, 'clear: already clearing the buffer');\n      return;\n    }\n\n    if (mediaState.waitingToClearBuffer) {\n      // May not be performing an update, but an update will still happen.\n      // See: https://github.com/google/shaka-player/issues/334\n      shaka.log.debug(logPrefix, 'clear: already waiting');\n      return;\n    }\n\n    if (mediaState.performingUpdate) {\n      // We are performing an update, so we have to wait until it's finished.\n      // onUpdate_() will call clearBuffer_() when the update has finished.\n      shaka.log.debug(logPrefix, 'clear: currently updating');\n      mediaState.waitingToClearBuffer = true;\n      // We can set the offset to zero to remember that this was a call to\n      // clearAllBuffers.\n      mediaState.clearBufferSafeMargin = 0;\n      return;\n    }\n\n    const type = mediaState.type;\n    if (this.playerInterface_.mediaSourceEngine.bufferStart(type) == null) {\n      // Nothing buffered.\n      shaka.log.debug(logPrefix, 'clear: nothing buffered');\n      if (mediaState.updateTimer == null) {\n        // Note: an update cycle stops when we buffer to the end of the\n        // presentation, or when we raise an error.\n        this.scheduleUpdate_(mediaState, 0);\n      }\n      return;\n    }\n\n    // An update may be scheduled, but we can just cancel it and clear the\n    // buffer right away. Note: clearBuffer_() will schedule the next update.\n    shaka.log.debug(logPrefix, 'clear: handling right now');\n    this.cancelUpdate_(mediaState);\n    this.clearBuffer_(mediaState, /* flush= */ false, 0).catch((error) => {\n      if (this.playerInterface_) {\n        goog.asserts.assert(error instanceof shaka.util.Error,\n            'Wrong error type!');\n        this.playerInterface_.onError(error);\n      }\n    });\n  }\n\n\n  /**\n   * Initializes the initial streams and media states.  This will schedule\n   * updates for the given types.\n   *\n   * @return {!Promise}\n   * @private\n   */\n  async initStreams_() {\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n\n    goog.asserts.assert(this.config_,\n        'StreamingEngine configure() must be called before init()!');\n\n    if (!this.currentVariant_) {\n      shaka.log.error('init: no Streams chosen');\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.STREAMING,\n          shaka.util.Error.Code.STREAMING_ENGINE_STARTUP_INVALID_STATE);\n    }\n\n    /**\n     * @type {!Map.<shaka.util.ManifestParserUtils.ContentType,\n     *              shaka.extern.Stream>}\n     */\n    const streamsByType = new Map();\n    /** @type {!Set.<shaka.extern.Stream>} */\n    const streams = new Set();\n\n    if (this.currentVariant_.audio) {\n      streamsByType.set(ContentType.AUDIO, this.currentVariant_.audio);\n      streams.add(this.currentVariant_.audio);\n    }\n\n    if (this.currentVariant_.video) {\n      streamsByType.set(ContentType.VIDEO, this.currentVariant_.video);\n      streams.add(this.currentVariant_.video);\n    }\n\n    if (this.currentTextStream_) {\n      streamsByType.set(ContentType.TEXT, this.currentTextStream_);\n      streams.add(this.currentTextStream_);\n    }\n\n    // Init MediaSourceEngine.\n    const mediaSourceEngine = this.playerInterface_.mediaSourceEngine;\n    const forceTransmuxTS = this.config_.forceTransmuxTS;\n\n    await mediaSourceEngine.init(streamsByType, forceTransmuxTS);\n    this.destroyer_.ensureNotDestroyed();\n\n    this.setDuration_();\n\n    for (const type of streamsByType.keys()) {\n      const stream = streamsByType.get(type);\n      if (!this.mediaStates_.has(type)) {\n        const state = this.createMediaState_(stream);\n        this.mediaStates_.set(type, state);\n        this.scheduleUpdate_(state, 0);\n      }\n    }\n  }\n\n\n  /**\n   * Creates a media state.\n   *\n   * @param {shaka.extern.Stream} stream\n   * @return {shaka.media.StreamingEngine.MediaState_}\n   * @private\n   */\n  createMediaState_(stream) {\n    return /** @type {shaka.media.StreamingEngine.MediaState_} */ ({\n      stream,\n      type: stream.type,\n      segmentIterator: null,\n      lastSegmentReference: null,\n      lastInitSegmentReference: null,\n      lastTimestampOffset: null,\n      lastAppendWindowStart: null,\n      lastAppendWindowEnd: null,\n      restoreStreamAfterTrickPlay: null,\n      endOfStream: false,\n      performingUpdate: false,\n      updateTimer: null,\n      waitingToClearBuffer: false,\n      clearBufferSafeMargin: 0,\n      waitingToFlushBuffer: false,\n      clearingBuffer: false,\n      recovering: false,\n      hasError: false,\n      operation: null,\n    });\n  }\n\n\n  /**\n   * Sets the MediaSource's duration.\n   * @private\n   */\n  setDuration_() {\n    const duration = this.manifest_.presentationTimeline.getDuration();\n    if (duration < Infinity) {\n      this.playerInterface_.mediaSourceEngine.setDuration(duration);\n    } else {\n      // Not all platforms support infinite durations, so set a finite duration\n      // so we can append segments and so the user agent can seek.\n      this.playerInterface_.mediaSourceEngine.setDuration(Math.pow(2, 32));\n    }\n  }\n\n\n  /**\n   * Called when |mediaState|'s update timer has expired.\n   *\n   * @param {!shaka.media.StreamingEngine.MediaState_} mediaState\n   * @suppress {suspiciousCode} The compiler assumes that updateTimer can't\n   *   change during the await, and so complains about the null check.\n   * @private\n   */\n  async onUpdate_(mediaState) {\n    this.destroyer_.ensureNotDestroyed();\n\n    const logPrefix = shaka.media.StreamingEngine.logPrefix_(mediaState);\n\n    // Sanity check.\n    goog.asserts.assert(\n        !mediaState.performingUpdate && (mediaState.updateTimer != null),\n        logPrefix + ' unexpected call to onUpdate_()');\n    if (mediaState.performingUpdate || (mediaState.updateTimer == null)) {\n      return;\n    }\n\n    goog.asserts.assert(\n        !mediaState.clearingBuffer, logPrefix +\n        ' onUpdate_() should not be called when clearing the buffer');\n    if (mediaState.clearingBuffer) {\n      return;\n    }\n\n    mediaState.updateTimer = null;\n\n    // Handle pending buffer clears.\n    if (mediaState.waitingToClearBuffer) {\n      // Note: clearBuffer_() will schedule the next update.\n      shaka.log.debug(logPrefix, 'skipping update and clearing the buffer');\n      await this.clearBuffer_(\n          mediaState, mediaState.waitingToFlushBuffer,\n          mediaState.clearBufferSafeMargin);\n      return;\n    }\n\n    // Make sure the segment index exists.\n    if (!mediaState.stream.segmentIndex) {\n      const thisStream = mediaState.stream;\n\n      await mediaState.stream.createSegmentIndex();\n\n      if (thisStream != mediaState.stream) {\n        // We switched streams while in the middle of this async call to\n        // createSegmentIndex.  Abandon this update and schedule a new one if\n        // there's not already one pending.\n        if (mediaState.updateTimer == null) {\n          this.scheduleUpdate_(mediaState, 0);\n        }\n        return;\n      }\n    }\n\n    // Update the MediaState.\n    try {\n      const delay = this.update_(mediaState);\n      if (delay != null) {\n        this.scheduleUpdate_(mediaState, delay);\n        mediaState.hasError = false;\n      }\n    } catch (error) {\n      this.handleStreamingError_(error);\n      return;\n    }\n\n    const mediaStates = Array.from(this.mediaStates_.values());\n\n    // Check if we've buffered to the end of the presentation.  We delay adding\n    // the audio and video media states, so it is possible for the text stream\n    // to be the only state and buffer to the end.  So we need to wait until we\n    // have completed startup to determine if we have reached the end.\n    if (this.startupComplete_ &&\n        mediaStates.every((ms) => ms.endOfStream)) {\n      shaka.log.v1(logPrefix, 'calling endOfStream()...');\n      await this.playerInterface_.mediaSourceEngine.endOfStream();\n      this.destroyer_.ensureNotDestroyed();\n\n      // If the media segments don't reach the end, then we need to update the\n      // timeline duration to match the final media duration to avoid\n      // buffering forever at the end.\n      // We should only do this if the duration needs to shrink.\n      // Growing it by less than 1ms can actually cause buffering on\n      // replay, as in https://github.com/google/shaka-player/issues/979\n      // On some platforms, this can spuriously be 0, so ignore this case.\n      // https://github.com/google/shaka-player/issues/1967,\n      const duration = this.playerInterface_.mediaSourceEngine.getDuration();\n      if (duration != 0 &&\n          duration < this.manifest_.presentationTimeline.getDuration()) {\n        this.manifest_.presentationTimeline.setDuration(duration);\n      }\n    }\n  }\n\n\n  /**\n   * Updates the given MediaState.\n   *\n   * @param {shaka.media.StreamingEngine.MediaState_} mediaState\n   * @return {?number} The number of seconds to wait until updating again or\n   *   null if another update does not need to be scheduled.\n   * @private\n   */\n  update_(mediaState) {\n    goog.asserts.assert(this.manifest_, 'manifest_ should not be null');\n    goog.asserts.assert(this.config_, 'config_ should not be null');\n\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n\n    // Do not schedule update for closed captions text mediastate, since closed\n    // captions are embedded in video streams.\n    if (shaka.media.StreamingEngine.isEmbeddedText_(mediaState)) {\n      this.playerInterface_.mediaSourceEngine.setSelectedClosedCaptionId(\n          mediaState.stream.originalId || '');\n      return null;\n    }\n\n    const logPrefix = shaka.media.StreamingEngine.logPrefix_(mediaState);\n\n    // Compute how far we've buffered ahead of the playhead.\n    const presentationTime = this.playerInterface_.getPresentationTime();\n\n    // Get the next timestamp we need.\n    const timeNeeded = this.getTimeNeeded_(mediaState, presentationTime);\n    shaka.log.v2(logPrefix, 'timeNeeded=' + timeNeeded);\n\n    // Get the amount of content we have buffered, accounting for drift.  This\n    // is only used to determine if we have meet the buffering goal.  This\n    // should be the same method that PlayheadObserver uses.\n    const bufferedAhead =\n        this.playerInterface_.mediaSourceEngine.bufferedAheadOf(\n            mediaState.type, presentationTime);\n\n    shaka.log.v2(logPrefix,\n        'update_:',\n        'presentationTime=' + presentationTime,\n        'bufferedAhead=' + bufferedAhead);\n\n    const unscaledBufferingGoal = Math.max(\n        this.manifest_.minBufferTime || 0,\n        this.config_.rebufferingGoal,\n        this.config_.bufferingGoal);\n\n    const scaledBufferingGoal =\n        unscaledBufferingGoal * this.bufferingGoalScale_;\n\n    // Check if we've buffered to the end of the presentation.\n    if (timeNeeded >= this.manifest_.presentationTimeline.getDuration()) {\n      // We shouldn't rebuffer if the playhead is close to the end of the\n      // presentation.\n      shaka.log.debug(logPrefix, 'buffered to end of presentation');\n      mediaState.endOfStream = true;\n\n      if (mediaState.type == ContentType.VIDEO) {\n        // Since the text stream of CEA closed captions doesn't have update\n        // timer, we have to set the text endOfStream based on the video\n        // stream's endOfStream state.\n        const textState = this.mediaStates_.get(ContentType.TEXT);\n        if (textState &&\n            shaka.media.StreamingEngine.isEmbeddedText_(textState)) {\n          textState.endOfStream = true;\n        }\n      }\n      return null;\n    }\n    mediaState.endOfStream = false;\n\n    // If we've buffered to the buffering goal then schedule an update.\n    if (bufferedAhead >= scaledBufferingGoal) {\n      shaka.log.v2(logPrefix, 'buffering goal met');\n\n      // Do not try to predict the next update.  Just poll twice every second.\n      // The playback rate can change at any time, so any prediction we make now\n      // could be terribly invalid soon.\n      return 0.5;\n    }\n\n    const bufferEnd =\n        this.playerInterface_.mediaSourceEngine.bufferEnd(mediaState.type);\n    const reference = this.getSegmentReferenceNeeded_(\n        mediaState, presentationTime, bufferEnd);\n    if (!reference ||\n        !this.isSegmentReferenceAvailable_(mediaState, reference)) {\n      // The segment could not be found, does not exist, or is not available.\n      // In any case just try again... if the manifest is incomplete or is not\n      // being updated then we'll idle forever; otherwise, we'll end up getting\n      // a SegmentReference eventually.\n      return 1;\n    }\n\n    // Do not let any one stream get far ahead of any other.\n    let minTimeNeeded = Infinity;\n    const mediaStates = Array.from(this.mediaStates_.values());\n    for (const otherState of mediaStates) {\n      // Do not consider embedded captions in this calculation.  It could lead\n      // to hangs in streaming.\n      if (shaka.media.StreamingEngine.isEmbeddedText_(otherState)) {\n        continue;\n      }\n\n      const timeNeeded = this.getTimeNeeded_(otherState, presentationTime);\n      minTimeNeeded = Math.min(minTimeNeeded, timeNeeded);\n    }\n\n    const maxSegmentDuration =\n        this.manifest_.presentationTimeline.getMaxSegmentDuration();\n    const maxRunAhead = maxSegmentDuration *\n        shaka.media.StreamingEngine.MAX_RUN_AHEAD_SEGMENTS_;\n    if (timeNeeded >= minTimeNeeded + maxRunAhead) {\n      // Wait and give other media types time to catch up to this one.\n      // For example, let video buffering catch up to audio buffering before\n      // fetching another audio segment.\n      return 1;\n    }\n\n    const p = this.fetchAndAppend_(mediaState, presentationTime, reference);\n    p.catch(() => {});  // TODO(#1993): Handle asynchronous errors.\n    return null;\n  }\n\n\n  /**\n   * Gets the next timestamp needed. Returns the playhead's position if the\n   * buffer is empty; otherwise, returns the time at which the last segment\n   * appended ends.\n   *\n   * @param {shaka.media.StreamingEngine.MediaState_} mediaState\n   * @param {number} presentationTime\n   * @return {number} The next timestamp needed.\n   * @private\n   */\n  getTimeNeeded_(mediaState, presentationTime) {\n    // Get the next timestamp we need. We must use |lastSegmentReference|\n    // to determine this and not the actual buffer for two reasons:\n    //   1. Actual segments end slightly before their advertised end times, so\n    //      the next timestamp we need is actually larger than |bufferEnd|.\n    //   2. There may be drift (the timestamps in the segments are ahead/behind\n    //      of the timestamps in the manifest), but we need drift-free times\n    //      when comparing times against the presentation timeline.\n    if (!mediaState.lastSegmentReference) {\n      return presentationTime;\n    }\n\n    return mediaState.lastSegmentReference.endTime;\n  }\n\n\n  /**\n   * Gets the SegmentReference of the next segment needed.\n   *\n   * @param {shaka.media.StreamingEngine.MediaState_} mediaState\n   * @param {number} presentationTime\n   * @param {?number} bufferEnd\n   * @return {shaka.media.SegmentReference} The SegmentReference of the\n   *   next segment needed. Returns null if a segment could not be found, does\n   *   not exist, or is not available.\n   * @private\n   */\n  getSegmentReferenceNeeded_(mediaState, presentationTime, bufferEnd) {\n    const logPrefix = shaka.media.StreamingEngine.logPrefix_(mediaState);\n    goog.asserts.assert(\n        mediaState.stream.segmentIndex,\n        'segment index should have been generated already');\n\n    if (mediaState.segmentIterator) {\n      // Something is buffered from the same Stream.  Use the current position\n      // in the segment index.  This is updated via next() after each segment is\n      // appended.\n      return mediaState.segmentIterator.current();\n    } else if (mediaState.lastSegmentReference || bufferEnd) {\n      // Something is buffered from another Stream.\n      const time = mediaState.lastSegmentReference ?\n          mediaState.lastSegmentReference.endTime :\n          bufferEnd;\n      goog.asserts.assert(time != null, 'Should have a time to search');\n      shaka.log.v1(\n          logPrefix, 'looking up segment from new stream endTime:', time);\n\n      mediaState.segmentIterator =\n          mediaState.stream.segmentIndex.getIteratorForTime(time);\n      const ref = mediaState.segmentIterator.next().value;\n      if (ref == null) {\n        shaka.log.warning(logPrefix, 'cannot find segment', 'endTime:', time);\n      }\n      return ref;\n    } else {\n      // Nothing is buffered.  Start at the playhead time.\n\n      // If there's positive drift then we need to adjust the lookup time, and\n      // may wind up requesting the previous segment to be safe.\n      const maxDrift = this.config_.inaccurateManifestTolerance;\n      const lookupTime = Math.max(presentationTime - maxDrift, 0);\n\n      shaka.log.v1(logPrefix, 'looking up segment',\n          'lookupTime:', lookupTime,\n          'presentationTime:', presentationTime);\n\n      mediaState.segmentIterator =\n          mediaState.stream.segmentIndex.getIteratorForTime(lookupTime);\n      let ref = mediaState.segmentIterator.next().value;\n      if (!ref || !this.isSegmentReferenceAvailable_(mediaState, ref)) {\n        // If we can't find a valid segment with the drifted time, look for a\n        // segment with the presentation time.\n        mediaState.segmentIterator =\n            mediaState.stream.segmentIndex.getIteratorForTime(presentationTime);\n        ref = mediaState.segmentIterator.next().value;\n      }\n      if (ref == null) {\n        shaka.log.warning(logPrefix, 'cannot find segment',\n            'lookupTime:', lookupTime,\n            'presentationTime:', presentationTime);\n      }\n      return ref;\n    }\n  }\n\n  /**\n   * Checks a SegmentReference against the timeline to see if it is available.\n   * In some cases, we may have references that are not yet available or no\n   * longer available according to the timeline.  We shouldn't fetch those.\n   *\n   * @param {shaka.media.StreamingEngine.MediaState_} mediaState\n   * @param {shaka.media.SegmentReference} reference\n   * @return {boolean}\n   * @private\n   */\n  isSegmentReferenceAvailable_(mediaState, reference) {\n    const logPrefix = shaka.media.StreamingEngine.logPrefix_(mediaState);\n    const timeline = this.manifest_.presentationTimeline;\n    const availabilityStart = timeline.getSegmentAvailabilityStart();\n    const availabilityEnd = timeline.getSegmentAvailabilityEnd();\n\n    if (reference.endTime < availabilityStart ||\n        reference.startTime > availabilityEnd) {\n      shaka.log.v2(logPrefix,\n          'segment is not available:',\n          'reference.startTime=' + reference.startTime,\n          'reference.endTime=' + reference.endTime,\n          'availabilityStart=' + availabilityStart,\n          'availabilityEnd=' + availabilityEnd);\n      return false;\n    }\n\n    return true;\n  }\n\n\n  /**\n   * Fetches and appends the given segment. Sets up the given MediaState's\n   * associated SourceBuffer and evicts segments if either are required\n   * beforehand. Schedules another update after completing successfully.\n   *\n   * @param {!shaka.media.StreamingEngine.MediaState_} mediaState\n   * @param {number} presentationTime\n   * @param {!shaka.media.SegmentReference} reference\n   * @private\n   */\n  async fetchAndAppend_(mediaState, presentationTime, reference) {\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n    const StreamingEngine = shaka.media.StreamingEngine;\n    const logPrefix = StreamingEngine.logPrefix_(mediaState);\n\n    shaka.log.v1(logPrefix,\n        'fetchAndAppend_:',\n        'presentationTime=' + presentationTime,\n        'reference.startTime=' + reference.startTime,\n        'reference.endTime=' + reference.endTime);\n\n    // Subtlety: The playhead may move while asynchronous update operations are\n    // in progress, so we should avoid calling playhead.getTime() in any\n    // callbacks. Furthermore, switch() or seeked() may be called at any time,\n    // so we store the old iterator.  This allows the mediaState to change and\n    // we'll update the old iterator.\n    const stream = mediaState.stream;\n    const iter = mediaState.segmentIterator;\n\n    mediaState.performingUpdate = true;\n\n    const initSourceBuffer = this.initSourceBuffer_(mediaState, reference);\n\n    shaka.log.v2(logPrefix, 'fetching segment');\n    const fetchSegment = this.fetch_(mediaState, reference);\n\n    try {\n      const results = await Promise.all([initSourceBuffer, fetchSegment]);\n      this.destroyer_.ensureNotDestroyed();\n      if (this.fatalError_) {\n        return;\n      }\n\n      // If the text stream gets switched between fetch_() and append_(), the\n      // new text parser is initialized, but the new init segment is not\n      // fetched yet.  That would cause an error in TextParser.parseMedia().\n      // See http://b/168253400\n      if (mediaState.waitingToClearBuffer) {\n        shaka.log.info(logPrefix, 'waitingToClearBuffer, skip append');\n        mediaState.performingUpdate = false;\n        this.scheduleUpdate_(mediaState, 0);\n        return;\n      }\n\n      await this.append_(\n          mediaState, presentationTime, stream, reference, results[1]);\n      this.destroyer_.ensureNotDestroyed();\n      if (this.fatalError_) {\n        return;\n      }\n      // move to next segment after appending the current segment.\n      mediaState.lastSegmentReference = reference;\n      const newRef = iter.next().value;\n      shaka.log.v2(logPrefix, 'advancing to next segment', newRef);\n\n      mediaState.performingUpdate = false;\n      mediaState.recovering = false;\n\n      const info = this.playerInterface_.mediaSourceEngine.getBufferedInfo();\n      const buffered = info[mediaState.type];\n      // Convert the buffered object to a string capture its properties on\n      // WebOS.\n      shaka.log.v1(logPrefix, 'finished fetch and append',\n          JSON.stringify(buffered));\n\n      if (!mediaState.waitingToClearBuffer) {\n        this.playerInterface_.onSegmentAppended();\n      }\n\n      // Update right away.\n      this.scheduleUpdate_(mediaState, 0);\n    } catch (error) {\n      this.destroyer_.ensureNotDestroyed(error);\n      if (this.fatalError_) {\n        return;\n      }\n      goog.asserts.assert(error instanceof shaka.util.Error,\n          'Should only receive a Shaka error');\n\n      mediaState.performingUpdate = false;\n\n      if (mediaState.type == ContentType.TEXT &&\n          this.config_.ignoreTextStreamFailures) {\n        if (error.code == shaka.util.Error.Code.BAD_HTTP_STATUS) {\n          shaka.log.warning(logPrefix,\n              'Text stream failed to download. Proceeding without it.');\n        } else {\n          shaka.log.warning(logPrefix,\n              'Text stream failed to parse. Proceeding without it.');\n        }\n        this.mediaStates_.delete(ContentType.TEXT);\n      } else if (error.code == shaka.util.Error.Code.OPERATION_ABORTED) {\n        // If the network slows down, abort the current fetch request and start\n        // a new one, and ignore the error message.\n        mediaState.performingUpdate = false;\n        mediaState.updateTimer = null;\n        this.scheduleUpdate_(mediaState, 0);\n      } else if (error.code == shaka.util.Error.Code.QUOTA_EXCEEDED_ERROR) {\n        this.handleQuotaExceeded_(mediaState, error);\n      } else {\n        shaka.log.error(logPrefix, 'failed fetch and append: code=' +\n            error.code);\n        mediaState.hasError = true;\n\n        error.severity = shaka.util.Error.Severity.CRITICAL;\n        this.handleStreamingError_(error);\n      }\n    }\n  }\n\n\n  /**\n   * Clear per-stream error states and retry any failed streams.\n   * @return {boolean} False if unable to retry.\n   */\n  retry() {\n    if (this.destroyer_.destroyed()) {\n      shaka.log.error('Unable to retry after StreamingEngine is destroyed!');\n      return false;\n    }\n\n    if (this.fatalError_) {\n      shaka.log.error('Unable to retry after StreamingEngine encountered a ' +\n                      'fatal error!');\n      return false;\n    }\n\n    for (const mediaState of this.mediaStates_.values()) {\n      const logPrefix = shaka.media.StreamingEngine.logPrefix_(mediaState);\n      if (mediaState.hasError) {\n        shaka.log.info(logPrefix, 'Retrying after failure...');\n        mediaState.hasError = false;\n        this.scheduleUpdate_(mediaState, 0.1);\n      }\n    }\n\n    return true;\n  }\n\n\n  /**\n   * Handles a QUOTA_EXCEEDED_ERROR.\n   *\n   * @param {shaka.media.StreamingEngine.MediaState_} mediaState\n   * @param {!shaka.util.Error} error\n   * @private\n   */\n  handleQuotaExceeded_(mediaState, error) {\n    const logPrefix = shaka.media.StreamingEngine.logPrefix_(mediaState);\n\n    // The segment cannot fit into the SourceBuffer. Ideally, MediaSource would\n    // have evicted old data to accommodate the segment; however, it may have\n    // failed to do this if the segment is very large, or if it could not find\n    // a suitable time range to remove.\n    //\n    // We can overcome the latter by trying to append the segment again;\n    // however, to avoid continuous QuotaExceededErrors we must reduce the size\n    // of the buffer going forward.\n    //\n    // If we've recently reduced the buffering goals, wait until the stream\n    // which caused the first QuotaExceededError recovers. Doing this ensures\n    // we don't reduce the buffering goals too quickly.\n\n    const mediaStates = Array.from(this.mediaStates_.values());\n    const waitingForAnotherStreamToRecover = mediaStates.some((ms) => {\n      return ms != mediaState && ms.recovering;\n    });\n\n    if (!waitingForAnotherStreamToRecover) {\n      // Reduction schedule: 80%, 60%, 40%, 20%, 16%, 12%, 8%, 4%, fail.\n      // Note: percentages are used for comparisons to avoid rounding errors.\n      const percentBefore = Math.round(100 * this.bufferingGoalScale_);\n      if (percentBefore > 20) {\n        this.bufferingGoalScale_ -= 0.2;\n      } else if (percentBefore > 4) {\n        this.bufferingGoalScale_ -= 0.04;\n      } else {\n        shaka.log.error(\n            logPrefix, 'MediaSource threw QuotaExceededError too many times');\n        mediaState.hasError = true;\n        this.fatalError_ = true;\n        this.playerInterface_.onError(error);\n        return;\n      }\n      const percentAfter = Math.round(100 * this.bufferingGoalScale_);\n      shaka.log.warning(\n          logPrefix,\n          'MediaSource threw QuotaExceededError:',\n          'reducing buffering goals by ' + (100 - percentAfter) + '%');\n      mediaState.recovering = true;\n    } else {\n      shaka.log.debug(\n          logPrefix,\n          'MediaSource threw QuotaExceededError:',\n          'waiting for another stream to recover...');\n    }\n\n    // QuotaExceededError gets thrown if evication didn't help to make room\n    // for a segment. We want to wait for a while (4 seconds is just an\n    // arbitrary number) before updating to give the playhead a chance to\n    // advance, so we don't immidiately throw again.\n    this.scheduleUpdate_(mediaState, 4);\n  }\n\n\n  /**\n   * Sets the given MediaState's associated SourceBuffer's timestamp offset,\n   * append window, and init segment if they have changed. If an error occurs\n   * then neither the timestamp offset or init segment are unset, since another\n   * call to switch() will end up superseding them.\n   *\n   * @param {shaka.media.StreamingEngine.MediaState_} mediaState\n   * @param {!shaka.media.SegmentReference} reference\n   * @return {!Promise}\n   * @private\n   */\n  async initSourceBuffer_(mediaState, reference) {\n    const StreamingEngine = shaka.media.StreamingEngine;\n    const logPrefix = StreamingEngine.logPrefix_(mediaState);\n\n    /** @type {!Array.<!Promise>} */\n    const operations = [];\n\n    // Rounding issues can cause us to remove the first frame of a Period, so\n    // reduce the window start time slightly.\n    const appendWindowStart = Math.max(0,\n        reference.appendWindowStart -\n        StreamingEngine.APPEND_WINDOW_START_FUDGE_);\n    const appendWindowEnd =\n        reference.appendWindowEnd + StreamingEngine.APPEND_WINDOW_END_FUDGE_;\n\n    goog.asserts.assert(\n        reference.startTime <= appendWindowEnd,\n        logPrefix + ' segment should start before append window end');\n\n    const timestampOffset = reference.timestampOffset;\n    if (timestampOffset != mediaState.lastTimestampOffset ||\n        appendWindowStart != mediaState.lastAppendWindowStart ||\n        appendWindowEnd != mediaState.lastAppendWindowEnd) {\n      shaka.log.v1(logPrefix, 'setting timestamp offset to ' + timestampOffset);\n      shaka.log.v1(logPrefix,\n          'setting append window start to ' + appendWindowStart);\n      shaka.log.v1(logPrefix,\n          'setting append window end to ' + appendWindowEnd);\n\n      const setProperties = async () => {\n        try {\n          mediaState.lastAppendWindowStart = appendWindowStart;\n          mediaState.lastAppendWindowEnd = appendWindowEnd;\n          mediaState.lastTimestampOffset = timestampOffset;\n\n          await this.playerInterface_.mediaSourceEngine.setStreamProperties(\n              mediaState.type, timestampOffset, appendWindowStart,\n              appendWindowEnd);\n        } catch (error) {\n          mediaState.lastAppendWindowStart = null;\n          mediaState.lastAppendWindowEnd = null;\n          mediaState.lastTimestampOffset = null;\n\n          throw error;\n        }\n      };\n      operations.push(setProperties());\n    }\n\n    if (!shaka.media.InitSegmentReference.equal(\n        reference.initSegmentReference, mediaState.lastInitSegmentReference)) {\n      mediaState.lastInitSegmentReference = reference.initSegmentReference;\n\n      if (reference.initSegmentReference) {\n        shaka.log.v1(logPrefix, 'fetching init segment');\n\n        const fetchInit =\n            this.fetch_(mediaState, reference.initSegmentReference);\n        const append = async () => {\n          try {\n            const initSegment = await fetchInit;\n            this.destroyer_.ensureNotDestroyed();\n            shaka.log.v1(logPrefix, 'appending init segment');\n            const hasClosedCaptions = mediaState.stream.closedCaptions &&\n                mediaState.stream.closedCaptions.size > 0;\n            await this.playerInterface_.mediaSourceEngine.appendBuffer(\n                mediaState.type, initSegment, /* startTime= */ null,\n                /* endTime= */ null, hasClosedCaptions);\n          } catch (error) {\n            mediaState.lastInitSegmentReference = null;\n            throw error;\n          }\n        };\n        operations.push(append());\n      }\n    }\n\n    await Promise.all(operations);\n  }\n\n\n  /**\n   * Appends the given segment and evicts content if required to append.\n   *\n   * @param {!shaka.media.StreamingEngine.MediaState_} mediaState\n   * @param {number} presentationTime\n   * @param {shaka.extern.Stream} stream\n   * @param {!shaka.media.SegmentReference} reference\n   * @param {BufferSource} segment\n   * @return {!Promise}\n   * @private\n   */\n  async append_(mediaState, presentationTime, stream, reference,\n      segment) {\n    const logPrefix = shaka.media.StreamingEngine.logPrefix_(mediaState);\n\n    const hasClosedCaptions = stream.closedCaptions &&\n        stream.closedCaptions.size > 0;\n    if (stream.emsgSchemeIdUris != null && stream.emsgSchemeIdUris.length > 0) {\n      new shaka.util.Mp4Parser()\n          .fullBox(\n              'emsg',\n              (box) => this.parseEMSG_(\n                  reference, stream.emsgSchemeIdUris, box))\n          .parse(segment);\n    }\n\n    await this.evict_(mediaState, presentationTime);\n    this.destroyer_.ensureNotDestroyed();\n    shaka.log.v1(logPrefix, 'appending media segment');\n\n    await this.playerInterface_.mediaSourceEngine.appendBuffer(\n        mediaState.type,\n        segment,\n        reference.startTime,\n        reference.endTime,\n        hasClosedCaptions);\n    this.destroyer_.ensureNotDestroyed();\n    shaka.log.v2(logPrefix, 'appended media segment');\n  }\n\n\n  /**\n   * Parse the EMSG box from a MP4 container.\n   *\n   * @param {!shaka.media.SegmentReference} reference\n   * @param {?Array.<string>} emsgSchemeIdUris Array of emsg\n   *     scheme_id_uri for which emsg boxes should be parsed.\n   * @param {!shaka.extern.ParsedBox} box\n   * @private\n   */\n  parseEMSG_(reference, emsgSchemeIdUris, box) {\n    const schemeId = box.reader.readTerminatedString();\n    // Read the rest of the data.\n    const value = box.reader.readTerminatedString();\n    const timescale = box.reader.readUint32();\n    const presentationTimeDelta = box.reader.readUint32();\n    const eventDuration = box.reader.readUint32();\n    const id = box.reader.readUint32();\n    const messageData = box.reader.readBytes(\n        box.reader.getLength() - box.reader.getPosition());\n\n    const startTime = reference.startTime + (presentationTimeDelta / timescale);\n\n    // See DASH sec. 5.10.3.3.1\n    // If a DASH client detects an event message box with a scheme that is not\n    // defined in MPD, the client is expected to ignore it.\n    if (emsgSchemeIdUris.includes(schemeId)) {\n      // See DASH sec. 5.10.4.1\n      // A special scheme in DASH used to signal manifest updates.\n      if (schemeId == 'urn:mpeg:dash:event:2012') {\n        this.playerInterface_.onManifestUpdate();\n      } else {\n        /** @type {shaka.extern.EmsgInfo} */\n        const emsg = {\n          startTime: startTime,\n          endTime: startTime + (eventDuration / timescale),\n          schemeIdUri: schemeId,\n          value: value,\n          timescale: timescale,\n          presentationTimeDelta: presentationTimeDelta,\n          eventDuration: eventDuration,\n          id: id,\n          messageData: messageData,\n        };\n\n        // Dispatch an event to notify the application about the emsg box.\n        const eventName = shaka.Player.EventName.Emsg;\n        const event = new shaka.util.FakeEvent(eventName, {'detail': emsg});\n        this.playerInterface_.onEvent(event);\n      }\n    }\n  }\n\n\n  /**\n   * Evicts media to meet the max buffer behind limit.\n   *\n   * @param {shaka.media.StreamingEngine.MediaState_} mediaState\n   * @param {number} presentationTime\n   * @private\n   */\n  async evict_(mediaState, presentationTime) {\n    const logPrefix = shaka.media.StreamingEngine.logPrefix_(mediaState);\n    shaka.log.v2(logPrefix, 'checking buffer length');\n\n    // Use the max segment duration, if it is longer than the bufferBehind, to\n    // avoid accidentally clearing too much data when dealing with a manifest\n    // with a long keyframe interval.\n    const bufferBehind = Math.max(this.config_.bufferBehind,\n        this.manifest_.presentationTimeline.getMaxSegmentDuration());\n\n    const startTime =\n        this.playerInterface_.mediaSourceEngine.bufferStart(mediaState.type);\n    if (startTime == null) {\n      shaka.log.v2(logPrefix,\n          'buffer behind okay because nothing buffered:',\n          'presentationTime=' + presentationTime,\n          'bufferBehind=' + bufferBehind);\n      return;\n    }\n    const bufferedBehind = presentationTime - startTime;\n\n    const overflow = bufferedBehind - bufferBehind;\n    // See: https://github.com/google/shaka-player/issues/2982\n    if (overflow <= 0.01) {\n      shaka.log.v2(logPrefix,\n          'buffer behind okay:',\n          'presentationTime=' + presentationTime,\n          'bufferedBehind=' + bufferedBehind,\n          'bufferBehind=' + bufferBehind,\n          'underflow=' + Math.abs(overflow));\n      return;\n    }\n\n    shaka.log.v1(logPrefix,\n        'buffer behind too large:',\n        'presentationTime=' + presentationTime,\n        'bufferedBehind=' + bufferedBehind,\n        'bufferBehind=' + bufferBehind,\n        'overflow=' + overflow);\n\n    await this.playerInterface_.mediaSourceEngine.remove(mediaState.type,\n        startTime, startTime + overflow);\n\n    this.destroyer_.ensureNotDestroyed();\n    shaka.log.v1(logPrefix, 'evicted ' + overflow + ' seconds');\n  }\n\n\n  /**\n   * @param {shaka.media.StreamingEngine.MediaState_} mediaState\n   * @return {boolean}\n   * @private\n   */\n  static isEmbeddedText_(mediaState) {\n    const MimeUtils = shaka.util.MimeUtils;\n    return mediaState &&\n        mediaState.type == shaka.util.ManifestParserUtils.ContentType.TEXT &&\n        mediaState.stream.mimeType == MimeUtils.CLOSED_CAPTION_MIMETYPE;\n  }\n\n\n  /**\n   * Fetches the given segment.\n   *\n   * @param {!shaka.media.StreamingEngine.MediaState_} mediaState\n   * @param {(!shaka.media.InitSegmentReference|!shaka.media.SegmentReference)}\n   *   reference\n   *\n   * @return {!Promise.<BufferSource>}\n   * @private\n   */\n  async fetch_(mediaState, reference) {\n    const requestType = shaka.net.NetworkingEngine.RequestType.SEGMENT;\n\n    const request = shaka.util.Networking.createSegmentRequest(\n        reference.getUris(),\n        reference.startByte,\n        reference.endByte,\n        this.config_.retryParameters);\n\n    shaka.log.v2('fetching: reference=', reference);\n\n    const op = this.playerInterface_.netEngine.request(requestType, request);\n    mediaState.operation = op;\n    const response = await op.promise;\n    mediaState.operation = null;\n    return response.data;\n  }\n\n\n  /**\n   * Clears the buffer and schedules another update.\n   * The optional parameter safeMargin allows to retain a certain amount\n   * of buffer, which can help avoiding rebuffering events.\n   * The value of the safe margin should be provided by the ABR manager.\n   *\n   * @param {!shaka.media.StreamingEngine.MediaState_} mediaState\n   * @param {boolean} flush\n   * @param {number} safeMargin\n   * @private\n   */\n  async clearBuffer_(mediaState, flush, safeMargin) {\n    const logPrefix = shaka.media.StreamingEngine.logPrefix_(mediaState);\n\n    goog.asserts.assert(\n        !mediaState.performingUpdate && (mediaState.updateTimer == null),\n        logPrefix + ' unexpected call to clearBuffer_()');\n\n    mediaState.waitingToClearBuffer = false;\n    mediaState.waitingToFlushBuffer = false;\n    mediaState.clearBufferSafeMargin = 0;\n    mediaState.clearingBuffer = true;\n    mediaState.lastSegmentReference = null;\n    mediaState.lastInitSegmentReference = null;\n    mediaState.segmentIterator = null;\n\n    shaka.log.debug(logPrefix, 'clearing buffer');\n\n    if (safeMargin) {\n      const presentationTime = this.playerInterface_.getPresentationTime();\n      const duration = this.playerInterface_.mediaSourceEngine.getDuration();\n      await this.playerInterface_.mediaSourceEngine.remove(\n          mediaState.type, presentationTime + safeMargin, duration);\n    } else {\n      await this.playerInterface_.mediaSourceEngine.clear(mediaState.type);\n      this.destroyer_.ensureNotDestroyed();\n\n      if (flush) {\n        await this.playerInterface_.mediaSourceEngine.flush(\n            mediaState.type);\n      }\n    }\n    this.destroyer_.ensureNotDestroyed();\n\n    shaka.log.debug(logPrefix, 'cleared buffer');\n    mediaState.clearingBuffer = false;\n    mediaState.endOfStream = false;\n    this.scheduleUpdate_(mediaState, 0);\n  }\n\n\n  /**\n   * Schedules |mediaState|'s next update.\n   *\n   * @param {!shaka.media.StreamingEngine.MediaState_} mediaState\n   * @param {number} delay The delay in seconds.\n   * @private\n   */\n  scheduleUpdate_(mediaState, delay) {\n    const logPrefix = shaka.media.StreamingEngine.logPrefix_(mediaState);\n\n    // If the text's update is canceled and its mediaState is deleted, stop\n    // scheduling another update.\n    const type = mediaState.type;\n    if (type == shaka.util.ManifestParserUtils.ContentType.TEXT &&\n          !this.mediaStates_.has(type)) {\n      shaka.log.v1(logPrefix, 'Text stream is unloaded. No update is needed.');\n      return;\n    }\n\n    shaka.log.v2(logPrefix, 'updating in ' + delay + ' seconds');\n    goog.asserts.assert(mediaState.updateTimer == null,\n        logPrefix + ' did not expect update to be scheduled');\n\n    mediaState.updateTimer = new shaka.util.DelayedTick(async () => {\n      try {\n        await this.onUpdate_(mediaState);\n      } catch (error) {\n        if (this.playerInterface_) {\n          this.playerInterface_.onError(error);\n        }\n      }\n    }).tickAfter(delay);\n  }\n\n\n  /**\n   * If |mediaState| is scheduled to update, stop it.\n   *\n   * @param {shaka.media.StreamingEngine.MediaState_} mediaState\n   * @private\n   */\n  cancelUpdate_(mediaState) {\n    if (mediaState.updateTimer == null) {\n      return;\n    }\n\n    mediaState.updateTimer.stop();\n    mediaState.updateTimer = null;\n  }\n\n\n  /**\n   * If |mediaState| holds any in-progress operations, abort them.\n   *\n   * @return {!Promise}\n   * @private\n   */\n  async abortOperations_(mediaState) {\n    if (mediaState.operation) {\n      await mediaState.operation.abort();\n    }\n  }\n\n  /**\n   * Handle streaming errors by delaying, then notifying the application by\n   * error callback and by streaming failure callback.\n   *\n   * @param {!shaka.util.Error} error\n   * @private\n   */\n  async handleStreamingError_(error) {\n    // If we invoke the callback right away, the application could trigger a\n    // rapid retry cycle that could be very unkind to the server.  Instead,\n    // use the backoff system to delay and backoff the error handling.\n    await this.failureCallbackBackoff_.attempt();\n    this.destroyer_.ensureNotDestroyed();\n\n    // First fire an error event.\n    this.playerInterface_.onError(error);\n\n    // If the error was not handled by the application, call the failure\n    // callback.\n    if (!error.handled) {\n      this.config_.failureCallback(error);\n    }\n  }\n\n  /**\n   * @param {shaka.media.StreamingEngine.MediaState_} mediaState\n   * @return {string} A log prefix of the form ($CONTENT_TYPE:$STREAM_ID), e.g.,\n   *   \"(audio:5)\" or \"(video:hd)\".\n   * @private\n   */\n  static logPrefix_(mediaState) {\n    return '(' + mediaState.type + ':' + mediaState.stream.id + ')';\n  }\n};\n\n\n/**\n * @typedef {{\n *   getPresentationTime: function():number,\n *   getBandwidthEstimate: function():number,\n *   mediaSourceEngine: !shaka.media.MediaSourceEngine,\n *   netEngine: shaka.net.NetworkingEngine,\n *   onError: function(!shaka.util.Error),\n *   onEvent: function(!Event),\n *   onManifestUpdate: function(),\n *   onSegmentAppended: function()\n * }}\n *\n * @property {function():number} getPresentationTime\n *   Get the position in the presentation (in seconds) of the content that the\n *   viewer is seeing on screen right now.\n * @property {function():number} getBandwidthEstimate\n *   Get the estimated bandwidth in bits per second.\n * @property {!shaka.media.MediaSourceEngine} mediaSourceEngine\n *   The MediaSourceEngine. The caller retains ownership.\n * @property {shaka.net.NetworkingEngine} netEngine\n *   The NetworkingEngine instance to use. The caller retains ownership.\n * @property {function(!shaka.util.Error)} onError\n *   Called when an error occurs. If the error is recoverable (see\n *   {@link shaka.util.Error}) then the caller may invoke either\n *   StreamingEngine.switch*() or StreamingEngine.seeked() to attempt recovery.\n * @property {function(!Event)} onEvent\n *   Called when an event occurs that should be sent to the app.\n * @property {function()} onManifestUpdate\n *   Called when an embedded 'emsg' box should trigger a manifest update.\n * @property {function()} onSegmentAppended\n *   Called after a segment is successfully appended to a MediaSource.\n */\nshaka.media.StreamingEngine.PlayerInterface;\n\n\n/**\n * @typedef {{\n *   type: shaka.util.ManifestParserUtils.ContentType,\n *   stream: shaka.extern.Stream,\n *   segmentIterator: shaka.media.SegmentIterator,\n *   lastSegmentReference: shaka.media.SegmentReference,\n *   lastInitSegmentReference: shaka.media.InitSegmentReference,\n *   lastTimestampOffset: ?number,\n *   lastAppendWindowStart: ?number,\n *   lastAppendWindowEnd: ?number,\n *   restoreStreamAfterTrickPlay: ?shaka.extern.Stream,\n *   endOfStream: boolean,\n *   performingUpdate: boolean,\n *   updateTimer: shaka.util.DelayedTick,\n *   waitingToClearBuffer: boolean,\n *   waitingToFlushBuffer: boolean,\n *   clearBufferSafeMargin: number,\n *   clearingBuffer: boolean,\n *   recovering: boolean,\n *   hasError: boolean,\n *   operation: shaka.net.NetworkingEngine.PendingRequest\n * }}\n *\n * @description\n * Contains the state of a logical stream, i.e., a sequence of segmented data\n * for a particular content type. At any given time there is a Stream object\n * associated with the state of the logical stream.\n *\n * @property {shaka.util.ManifestParserUtils.ContentType} type\n *   The stream's content type, e.g., 'audio', 'video', or 'text'.\n * @property {shaka.extern.Stream} stream\n *   The current Stream.\n * @property {shaka.media.SegmentIndexIterator} segmentIterator\n *   An iterator through the segments of |stream|.\n * @property {shaka.media.SegmentReference} lastSegmentReference\n *   The SegmentReference of the last segment that was appended.\n * @property {shaka.media.InitSegmentReference} lastInitSegmentReference\n *   The InitSegmentReference of the last init segment that was appended.\n * @property {?number} lastTimestampOffset\n *   The last timestamp offset given to MediaSourceEngine for this type.\n * @property {?number} lastAppendWindowStart\n *   The last append window start given to MediaSourceEngine for this type.\n * @property {?number} lastAppendWindowEnd\n *   The last append window end given to MediaSourceEngine for this type.\n * @property {?shaka.extern.Stream} restoreStreamAfterTrickPlay\n *   The Stream to restore after trick play mode is turned off.\n * @property {boolean} endOfStream\n *   True indicates that the end of the buffer has hit the end of the\n *   presentation.\n * @property {boolean} performingUpdate\n *   True indicates that an update is in progress.\n * @property {shaka.util.DelayedTick} updateTimer\n *   A timer used to update the media state.\n * @property {boolean} waitingToClearBuffer\n *   True indicates that the buffer must be cleared after the current update\n *   finishes.\n * @property {boolean} waitingToFlushBuffer\n *   True indicates that the buffer must be flushed after it is cleared.\n * @property {number} clearBufferSafeMargin\n *   The amount of buffer to retain when clearing the buffer after the update.\n * @property {boolean} clearingBuffer\n *   True indicates that the buffer is being cleared.\n * @property {boolean} recovering\n *   True indicates that the last segment was not appended because it could not\n *   fit in the buffer.\n * @property {boolean} hasError\n *   True indicates that the stream has encountered an error and has stopped\n *   updating.\n * @property {shaka.net.NetworkingEngine.PendingRequest} operation\n *   Operation with the number of bytes to be downloaded.\n */\nshaka.media.StreamingEngine.MediaState_;\n\n\n/**\n * The fudge factor for appendWindowStart.  By adjusting the window backward, we\n * avoid rounding errors that could cause us to remove the keyframe at the start\n * of the Period.\n *\n * NOTE: This was increased as part of the solution to\n * https://github.com/google/shaka-player/issues/1281\n *\n * @const {number}\n * @private\n */\nshaka.media.StreamingEngine.APPEND_WINDOW_START_FUDGE_ = 0.1;\n\n\n/**\n * The fudge factor for appendWindowEnd.  By adjusting the window backward, we\n * avoid rounding errors that could cause us to remove the last few samples of\n * the Period.  This rounding error could then create an artificial gap and a\n * stutter when the gap-jumping logic takes over.\n *\n * https://github.com/google/shaka-player/issues/1597\n *\n * @const {number}\n * @private\n */\nshaka.media.StreamingEngine.APPEND_WINDOW_END_FUDGE_ = 0.01;\n\n\n/**\n * The maximum number of segments by which a stream can get ahead of other\n * streams.\n *\n * Introduced to keep StreamingEngine from letting one media type get too far\n * ahead of another.  For example, audio segments are typically much smaller\n * than video segments, so in the time it takes to fetch one video segment, we\n * could fetch many audio segments.  This doesn't help with buffering, though,\n * since the intersection of the two buffered ranges is what counts.\n *\n * @const {number}\n * @private\n */\nshaka.media.StreamingEngine.MAX_RUN_AHEAD_SEGMENTS_ = 1;\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.routing.Walker');\ngoog.provide('shaka.routing.Walker.Implementation');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.routing.Node');\ngoog.require('shaka.routing.Payload');\ngoog.require('shaka.util.Destroyer');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.IDestroyable');\ngoog.require('shaka.util.PublicPromise');\ngoog.requireType('shaka.util.AbortableOperation');\n\n\n/**\n * The walker moves through a graph node-by-node executing asynchronous work\n * as it enters each node.\n *\n * The walker accepts requests for where it should go next. Requests are queued\n * and executed in FIFO order. If the current request can be interrupted, it\n * will be cancelled and the next request started.\n *\n * A request says \"I want to change where we are going\". When the walker is\n * ready to change destinations, it will resolve the request, allowing the\n * destination to differ based on the current state and not the state when\n * the request was appended.\n *\n * Example (from shaka.Player):\n *  When we unload, we need to either go to the attached or detached state based\n *  on whether or not we have a video element.\n *\n *  When we are asked to unload, we don't know what other pending requests may\n *  be ahead of us (there could be attach requests or detach requests). We need\n *  to wait until its our turn to know if:\n *    - we should go to the attach state because we have a media element\n *    - we should go to the detach state because we don't have a media element\n *\n * The walker allows the caller to specify if a route can or cannot be\n * interrupted. This is to allow potentially dependent routes to wait until\n * other routes have finished.\n *\n * Example (from shaka.Player):\n *  A request to load content depends on an attach request finishing. We don't\n *  want load request to interrupt an attach request. By marking the attach\n *  request as non-interruptible we ensure that calling load before attach\n *  finishes will work.\n *\n * @implements {shaka.util.IDestroyable}\n * @final\n */\nshaka.routing.Walker = class {\n  /**\n   * Create a new walker that starts at |startingAt| and with |startingWith|.\n   * The instance of |startingWith| will be the one that the walker holds and\n   * uses for its life. No one else should reference it.\n   *\n   * The per-instance behaviour for the walker is provided via |implementation|\n   * which is used to connect this walker with the \"outside world\".\n   *\n   * @param {shaka.routing.Node} startingAt\n   * @param {shaka.routing.Payload} startingWith\n   * @param {shaka.routing.Walker.Implementation} implementation\n   */\n  constructor(startingAt, startingWith, implementation) {\n    /** @private {?shaka.routing.Walker.Implementation} */\n    this.implementation_ = implementation;\n\n    /** @private {shaka.routing.Node} */\n    this.currentlyAt_ = startingAt;\n\n    /** @private {shaka.routing.Payload} */\n    this.currentlyWith_ = startingWith;\n\n    /**\n     * When we run out of work to do, we will set this promise so that when\n     * new work is added (and this is not null) it can be resolved. The only\n     * time when this should be non-null is when we are waiting for more work.\n     *\n     * @private {shaka.util.PublicPromise}\n     */\n    this.waitForWork_ = null;\n\n    /** @private {!Array.<shaka.routing.Walker.Request_>} */\n    this.requests_ = [];\n\n    /** @private {?shaka.routing.Walker.ActiveRoute_} */\n    this.currentRoute_ = null;\n\n    /** @private {shaka.util.AbortableOperation} */\n    this.currentStep_ = null;\n\n    /**\n     * Hold a reference to the main loop's promise so that we know when it has\n     * exited. This will determine when |destroy| can resolve. Purposely make\n     * the main loop start next interpreter cycle so that the constructor will\n     * finish before it starts.\n     *\n     * @private {!Promise}\n     */\n    this.mainLoopPromise_ = Promise.resolve().then(() => this.mainLoop_());\n\n    /** @private {!shaka.util.Destroyer} */\n    this.destroyer_ = new shaka.util.Destroyer(() => this.doDestroy_());\n  }\n\n  /**\n   * Get the current routing payload.\n   *\n   * @return {shaka.routing.Payload}\n   */\n  getCurrentPayload() {\n    return this.currentlyWith_;\n  }\n\n  /** @override */\n  destroy() {\n    return this.destroyer_.destroy();\n  }\n\n  /** @private */\n  async doDestroy_() {\n    // If we are executing a current step, we want to interrupt it so that we\n    // can force the main loop to terminate.\n    if (this.currentStep_) {\n      this.currentStep_.abort();\n    }\n\n    // If we are waiting for more work, we want to wake-up the main loop so that\n    // it can exit on its own.\n    this.unblockMainLoop_();\n\n    // Wait for the main loop to terminate so that an async operation won't\n    // try and use state that we released.\n    await this.mainLoopPromise_;\n\n    // Any routes that we are not going to finish, we need to cancel. If we\n    // don't do this, those listening will be left hanging.\n    if (this.currentRoute_) {\n      this.currentRoute_.listeners.onCancel();\n    }\n    for (const request of this.requests_) {\n      request.listeners.onCancel();\n    }\n\n    // Release anything that could hold references to anything outside of this\n    // class.\n    this.currentRoute_ = null;\n    this.requests_ = [];\n    this.implementation_ = null;\n  }\n\n  /**\n   * Ask the walker to start a new route. When the walker is ready to start a\n   * new route, it will call |create| and |create| will provide the walker with\n   * a new route to execute.\n   *\n   * If any previous calls to |startNewRoute| created non-interruptible routes,\n   * |create| won't be called until all previous non-interruptible routes have\n   * finished.\n   *\n   * This method will return a collection of listeners that the caller can hook\n   * into. Any listener that the caller is interested should be assigned\n   * immediately after calling |startNewRoute| or else they could miss the event\n   * they want to listen for.\n   *\n   * @param {function(shaka.routing.Payload):?shaka.routing.Walker.Route} create\n   * @return {shaka.routing.Walker.Listeners}\n   */\n  startNewRoute(create) {\n    const listeners = {\n      onStart: () => {},\n      onEnd: () => {},\n      onCancel: () => {},\n      onError: (error) => {},\n      onSkip: () => {},\n      onEnter: () => {},\n    };\n\n    this.requests_.push({\n      create: create,\n      listeners: listeners,\n    });\n\n    // If we are in the middle of a step, try to abort it. If this is successful\n    // the main loop will error and the walker will enter recovery mode.\n    if (this.currentStep_) {\n      this.currentStep_.abort();\n    }\n\n    // Tell the main loop that new work is available. If the main loop was not\n    // blocked, this will be a no-op.\n    this.unblockMainLoop_();\n\n    return listeners;\n  }\n\n  /**\n   * @return {!Promise}\n   * @private\n   */\n  async mainLoop_() {\n    while (!this.destroyer_.destroyed()) {\n      // eslint-disable-next-line no-await-in-loop\n      await this.doOneThing_();\n    }\n  }\n\n  /**\n   * Do one thing to move the walker closer to its destination. This can be:\n   *   1. Starting a new route.\n   *   2. Taking one more step/finishing a route.\n   *   3. Wait for a new route.\n   *\n   * @return {!Promise}\n   * @private\n   */\n  doOneThing_() {\n    if (this.tryNewRoute_()) {\n      return Promise.resolve();\n    }\n\n    if (this.currentRoute_) {\n      return this.takeNextStep_();\n    }\n\n    goog.asserts.assert(this.waitForWork_ == null,\n        'We should not have a promise yet.');\n\n    // We have no more work to do. We will wait until new work has been provided\n    // via request route or until we are destroyed.\n\n    this.implementation_.onIdle(this.currentlyAt_);\n\n    // Wait on a new promise so that we can be resolved by |waitForWork|. This\n    // avoids us acting like a busy-wait.\n    this.waitForWork_ = new shaka.util.PublicPromise();\n    return this.waitForWork_;\n  }\n\n  /**\n   * Check if the walker can start a new route. There are a couple ways this can\n   * happen:\n   *  1. We have a new request but no current route\n   *  2. We have a new request and our current route can be interrupted\n   *\n   * @return {boolean}\n   *    |true| when a new route was started (regardless of reason) and |false|\n   *    when no new route was started.\n   *\n   * @private\n   */\n  tryNewRoute_() {\n    goog.asserts.assert(\n        this.currentStep_ == null,\n        'We should never have a current step between taking steps.');\n\n    if (this.requests_.length == 0) {\n      return false;\n    }\n\n    // If the current route cannot be interrupted, we can't start a new route.\n    if (this.currentRoute_ && !this.currentRoute_.interruptible) {\n      return false;\n    }\n\n    // Stop any previously active routes. Even if we don't pick-up a new route,\n    // this route should stop.\n    if (this.currentRoute_) {\n      this.currentRoute_.listeners.onCancel();\n      this.currentRoute_ = null;\n    }\n\n    // Create and start the next route. We may not take any steps because it may\n    // be interrupted by the next request.\n    const request = this.requests_.shift();\n    const newRoute = request.create(this.currentlyWith_);\n\n    // Based on the current state of |payload|, a new route may not be\n    // possible. In these cases |create| will return |null| to signal that\n    // we should just stop the current route and move onto the next request\n    // (in the next main loop iteration).\n    if (newRoute) {\n      request.listeners.onStart();\n\n      // Convert the route created from the request's create method to an\n      // active route.\n      this.currentRoute_ = {\n        node: newRoute.node,\n        payload: newRoute.payload,\n        interruptible: newRoute.interruptible,\n        listeners: request.listeners,\n      };\n    } else {\n      request.listeners.onSkip();\n    }\n\n    return true;\n  }\n\n\n  /**\n   * Move forward one step on our current route. This assumes that we have a\n   * current route. A couple things can happen when moving forward:\n   *  1. An error - if an error occurs, it will signal an error occurred,\n   *     attempt to recover, and drop the route.\n   *  2. Move - if no error occurs, we will move forward. When we arrive at\n   *     our destination, it will signal the end and drop the route.\n   *\n   * In the event of an error or arriving at the destination, we drop the\n   * current route. This allows us to pick-up a new route next time the main\n   * loop iterates.\n   *\n   * @return {!Promise}\n   * @private\n   */\n  async takeNextStep_() {\n    goog.asserts.assert(\n        this.currentRoute_,\n        'We need a current route to take the next step.');\n\n    // Figure out where we are supposed to go next.\n    this.currentlyAt_ = this.implementation_.getNext(\n        this.currentlyAt_,\n        this.currentlyWith_,\n        this.currentRoute_.node,\n        this.currentRoute_.payload);\n\n    this.currentRoute_.listeners.onEnter(this.currentlyAt_);\n\n    // Enter the new node, this is where things can go wrong since it is\n    // possible for \"supported errors\" to occur - errors that the code using\n    // the walker can't predict but can recover from.\n    try {\n      // TODO: This is probably a false-positive.  See eslint/eslint#11687.\n      // eslint-disable-next-line require-atomic-updates\n      this.currentStep_ = this.implementation_.enterNode(\n          /* node= */ this.currentlyAt_,\n          /* has= */ this.currentlyWith_,\n          /* wants= */ this.currentRoute_.payload);\n\n      await this.currentStep_.promise;\n      this.currentStep_ = null;\n\n      // If we are at the end of the route, we need to signal it and clear the\n      // route so that we will pick-up a new route next iteration.\n      if (this.currentlyAt_ == this.currentRoute_.node) {\n        this.currentRoute_.listeners.onEnd();\n        this.currentRoute_ = null;\n      }\n    } catch (error) {\n      if (error.code == shaka.util.Error.Code.OPERATION_ABORTED) {\n        goog.asserts.assert(\n            this.currentRoute_.interruptible,\n            'Do not put abortable steps in non-interruptible routes!');\n        this.currentRoute_.listeners.onCancel();\n      } else {\n        // There was an error with this route, so we going to abandon it and\n        // resolve the error. We don't reset the payload because the payload may\n        // still contain useful information.\n        this.currentRoute_.listeners.onError(error);\n      }\n\n      // The route and step are done. Clear them before we handle the error or\n      // else we may attempt to abort |currentStep_| when handling the error.\n      this.currentRoute_ = null;\n      this.currentStep_ = null;\n\n      // Still need to handle error because aborting an operation could leave us\n      // in an unexpected state.\n      this.currentlyAt_ = await this.implementation_.handleError(\n          this.currentlyWith_,\n          error);\n    }\n  }\n\n  /**\n   * If the main loop is blocked waiting for new work, then resolve the promise\n   * so that the next iteration of the main loop can execute.\n   *\n   * @private\n   */\n  unblockMainLoop_() {\n    if (this.waitForWork_) {\n      this.waitForWork_.resolve();\n      this.waitForWork_ = null;\n    }\n  }\n};\n\n/**\n * @typedef {{\n *   getNext: function(\n *       shaka.routing.Node,\n *       shaka.routing.Payload,\n *       shaka.routing.Node,\n *       shaka.routing.Payload):shaka.routing.Node,\n *   enterNode: function(\n *       shaka.routing.Node,\n *       shaka.routing.Payload,\n *       shaka.routing.Payload):!shaka.util.AbortableOperation,\n *   handleError: function(\n *       shaka.routing.Payload,\n *       !Error):!Promise.<shaka.routing.Node>,\n *   onIdle: function(shaka.routing.Node)\n * }}\n *\n * @description\n *   There are some parts of the walker that will be per-instance. This type\n *   provides those per-instance parts.\n *\n * @property {function(\n *     shaka.routing.Node,\n *     shaka.routing.Payload,\n *     shaka.routing.Node,\n *     shaka.routing.Payload):shaka.routing.Node getNext\n *   Get the next node that the walker should move to. This method will be\n *   passed (in this order) the current node, current payload, destination\n *   node, and destination payload.\n *\n * @property {function(\n *     shaka.routing.Node,\n *     shaka.routing.Payload,\n *     shaka.routing.Payload):!Promise} enterNode\n *   When the walker moves into a node, it will call |enterNode| and allow the\n *   implementation to change the current payload. This method will be passed\n *   (in this order) the node the walker is entering, the current payload, and\n *   the destination payload. This method should NOT modify the destination\n *   payload.\n *\n * @property {function(\n *     shaka.routing.Payload,\n *     !Error):!Promise.<shaka.routing.Node> handleError\n *   This is the callback for when |enterNode| fails. It is passed the current\n *   payload and the error. If a step is aborted, the error will be\n *   OPERATION_ABORTED. It should reset all external dependences, modify the\n *   payload, and return the new current node. Calls to |handleError| should\n *   always resolve and the walker should always be able to continue operating.\n *\n * @property {function(shaka.routing.Node)} onIdle\n *   This is the callback for when the walker has finished processing all route\n *   requests and needs to wait for more work. |onIdle| will be passed the\n *   current node.  After |onIdle| has been called, the walker will block until\n *   a new request is made, or the walker is destroyed.\n */\nshaka.routing.Walker.Implementation;\n\n/**\n * @typedef {{\n *   onStart: function(),\n *   onEnd: function(),\n *   onCancel: function(),\n *   onError: function(!Error),\n *   onSkip: function(),\n *   onEnter: function(shaka.routing.Node)\n * }}\n *\n * @description\n *   The collection of callbacks that the walker will call while executing a\n *   route. By setting these immediately after calling |startNewRoute|\n *   the user can react to route-specific events.\n *\n * @property {function()} onStart\n *   The callback for when the walker has accepted the route and will soon take\n *   the first step unless interrupted. Either |onStart| or |onSkip| will be\n *   called.\n *\n * @property {function()} onEnd\n *   The callback for when the walker has reached the end of the route. For\n *   every route that had |onStart| called, either |onEnd|, |onCancel|, or\n *   |onError| will be called.\n *\n * @property {function()} onCancel\n *   The callback for when the walker is stopping a route before getting to the\n *   end. This will be called either when a new route is interrupting the route,\n *   or the walker is being destroyed mid-route. |onCancel| will only be called\n *   when a route has been interrupted by another route or the walker is being\n *   destroyed.\n *\n * @property {function()} onError\n *   The callback for when the walker failed to execute the route because an\n *   unexpected error occurred. The walker will enter a recovery mode and the\n *   route will be abandoned.\n *\n * @property {function()} onSkip\n *   The callback for when the walker was ready to start the route, but the\n *   create-method returned |null|.\n *\n * @property {function()} onEnter\n *   The callback for when the walker enters a node. This will allow us to\n *   track the progress of the walker within a per-route scope.\n */\nshaka.routing.Walker.Listeners;\n\n/**\n * @typedef {{\n *   node: shaka.routing.Node,\n *   payload: shaka.routing.Payload,\n *   interruptible: boolean\n * }}\n *\n * @description\n *   The public description of where the walker should go. This is created\n *   when the callback given to |startNewRoute| is called by the walker.\n *\n * @property {shaka.routing.Node} node\n *   The node that the walker should move towards. This will be passed to\n *   |shaka.routing.Walker.Implementation.getNext| to help determine where to\n *   go next.\n *\n * @property {shaka.routing.Payload| payload\n *   The payload that the walker should have once it arrives at |node|. This\n *   will be passed to the |shaka.routing.Walker.Implementation.getNext| to\n *   help determine where to go next.\n *\n * @property {boolean} interruptible\n *   Whether or not this route can be interrupted by another request. When\n *   |true| this route will be interrupted so that a pending request can be\n *   resolved. When |false|, the route will be allowed to finished before\n *   resolving the next request.\n */\nshaka.routing.Walker.Route;\n\n/**\n * @typedef {{\n *   node: shaka.routing.Node,\n *   payload: shaka.routing.Payload,\n *   interruptible: boolean,\n *   listeners: shaka.routing.Walker.Listeners\n * }}\n *\n * @description\n *   The active route is the walker's internal representation of a route. It\n *   is the union of |shaka.routing.Walker.Request_| and the\n *   |shaka.routing.Walker.Route| created by |shaka.routing.Walker.Request_|.\n *\n * @property {shaka.routing.Node} node\n *   The node that the walker should move towards. This will be passed to\n *   |shaka.routing.Walker.Implementation.getNext| to help determine where to\n *   go next.\n *\n * @property {shaka.routing.Payload| payload\n *   The payload that the walker should have once it arrives at |node|. This\n *   will be passed to the |shaka.routing.Walker.Implementation.getNext| to\n *   help determine where to go next.\n *\n * @property {boolean} interruptible\n *   Whether or not this route can be interrupted by another request. When\n *   |true| this route will be interrupted so that a pending request can be\n *   resolved. When |false|, the route will be allowed to finished before\n *   resolving the next request.\n *\n * @property {shaka.routing.Walker.Listeners} listeners\n *   The listeners that the walker can used to communicate with whoever\n *   requested the route.\n *\n * @private\n */\nshaka.routing.Walker.ActiveRoute_;\n\n/**\n * @typedef {{\n *   create: function(shaka.routing.Payload):?shaka.routing.Walker.Route,\n *   listeners: shaka.routing.Walker.Listeners\n * }}\n *\n * @description\n *   The request is how users can talk to the walker. They can give the walker\n *   a request and when the walker is ready, it will resolve the request by\n *   calling |create|.\n *\n * @property {\n *     function(shaka.routing.Payload):?shaka.routing.Walker.Route} create\n *   The function called when the walker is ready to start a new route. This can\n *   return |null| to say that the request was not possible and should be\n *   skipped.\n *\n * @property {shaka.routing.Walker.Listeners} listeners\n *   The collection of callbacks that the walker will use to talk to whoever\n *   provided the request.\n *\n * @private\n */\nshaka.routing.Walker.Request_;\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview\n * @suppress {missingRequire} TODO(b/152540451): this shouldn't be needed\n */\n\ngoog.provide('shaka.text.SimpleTextDisplayer');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.text.Cue');\n\n\n/**\n * @summary\n * This defines the default text displayer plugin. An instance of this\n * class is used when no custom displayer is given.\n *\n * This class simply converts shaka.text.Cue objects to\n * TextTrackCues and feeds them to the browser.\n *\n * @implements {shaka.extern.TextDisplayer}\n * @export\n */\nshaka.text.SimpleTextDisplayer = class {\n  /** @param {HTMLMediaElement} video */\n  constructor(video) {\n    /** @private {TextTrack} */\n    this.textTrack_ = null;\n\n    // TODO: Test that in all cases, the built-in CC controls in the video\n    // element are toggling our TextTrack.\n\n    // If the video element has TextTracks, disable them.  If we see one that\n    // was created by a previous instance of Shaka Player, reuse it.\n    for (const track of Array.from(video.textTracks)) {\n      // NOTE: There is no API available to remove a TextTrack from a video\n      // element.\n      track.mode = 'disabled';\n\n      if (track.label == shaka.Player.TextTrackLabel) {\n        this.textTrack_ = track;\n      }\n    }\n\n    if (!this.textTrack_) {\n      // As far as I can tell, there is no observable difference between setting\n      // kind to 'subtitles' or 'captions' when creating the TextTrack object.\n      // The individual text tracks from the manifest will still have their own\n      // kinds which can be displayed in the app's UI.\n      this.textTrack_ = video.addTextTrack(\n          'subtitles', shaka.Player.TextTrackLabel);\n    }\n    this.textTrack_.mode = 'hidden';\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  remove(start, end) {\n    // Check that the displayer hasn't been destroyed.\n    if (!this.textTrack_) {\n      return false;\n    }\n\n    const removeInRange = (cue) => {\n      const inside = cue.startTime < end && cue.endTime > start;\n      return inside;\n    };\n\n    shaka.text.SimpleTextDisplayer.removeWhere_(this.textTrack_, removeInRange);\n\n    return true;\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  append(cues) {\n    // Flatten nested cue payloads recursively.  If a cue has nested cues,\n    // their contents should be combined and replace the payload of the parent.\n    const flattenPayload = (cue) => {\n      // TODO: If we want to support bold, italic, underline here, we would\n      // insert markup into the payload.\n      if (cue.spacer) {\n        // This is a vertical spacer, so insert a newline.\n        return '\\n';\n      } else if (cue.nestedCues.length) {\n        return cue.nestedCues.map(flattenPayload).join('');\n      } else {\n        // This is a real cue.\n        return cue.payload;\n      }\n    };\n\n    // We don't want to modify the array or objects passed in, since we don't\n    // technically own them.  So we build a new array and replace certain items\n    // in it if they need to be flattened.\n    const flattenedCues = cues.map((cue) => {\n      if (cue.nestedCues.length) {\n        const flatCue = cue.clone();\n        flatCue.nestedCues = [];\n        flatCue.payload = flattenPayload(cue);\n        return flatCue;\n      } else {\n        return cue;\n      }\n    });\n\n    // Convert cues.\n    const textTrackCues = [];\n    const cuesInTextTrack = this.textTrack_.cues ?\n                            Array.from(this.textTrack_.cues) : [];\n\n    for (const inCue of flattenedCues) {\n      // When a VTT cue spans a segment boundary, the cue will be duplicated\n      // into two segments.\n      // To avoid displaying duplicate cues, if the current textTrack cues\n      // list already contains the cue, skip it.\n      const containsCue = cuesInTextTrack.some((cueInTextTrack) => {\n        if (cueInTextTrack.startTime == inCue.startTime &&\n            cueInTextTrack.endTime == inCue.endTime &&\n            cueInTextTrack.text == inCue.payload) {\n          return true;\n        }\n        return false;\n      });\n\n      if (!containsCue) {\n        const cue =\n            shaka.text.SimpleTextDisplayer.convertToTextTrackCue_(inCue);\n        if (cue) {\n          textTrackCues.push(cue);\n        }\n      }\n    }\n\n    // Sort the cues based on start/end times.  Make a copy of the array so\n    // we can get the index in the original ordering.  Out of order cues are\n    // rejected by IE/Edge.  See https://bit.ly/2K9VX3s\n    const sortedCues = textTrackCues.slice().sort((a, b) => {\n      if (a.startTime != b.startTime) {\n        return a.startTime - b.startTime;\n      } else if (a.endTime != b.endTime) {\n        return a.endTime - b.startTime;\n      } else {\n        // The browser will display cues with identical time ranges from the\n        // bottom up.  Reversing the order of equal cues means the first one\n        // parsed will be at the top, as you would expect.\n        // See https://github.com/google/shaka-player/issues/848 for more info.\n        // However, this ordering behavior is part of VTTCue's \"line\" field.\n        // Some platforms don't have a real VTTCue and use a polyfill instead.\n        // When VTTCue is polyfilled or does not support \"line\", we should _not_\n        // reverse the order.  This occurs on IE11 and legacy Edge.\n        // eslint-disable-next-line no-restricted-syntax\n        if ('line' in VTTCue.prototype) {\n          // Native VTTCue\n          return textTrackCues.indexOf(b) - textTrackCues.indexOf(a);\n        } else {\n          // Polyfilled VTTCue\n          return textTrackCues.indexOf(a) - textTrackCues.indexOf(b);\n        }\n      }\n    });\n\n    for (const cue of sortedCues) {\n      this.textTrack_.addCue(cue);\n    }\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  destroy() {\n    if (this.textTrack_) {\n      const removeIt = (cue) => true;\n      shaka.text.SimpleTextDisplayer.removeWhere_(this.textTrack_, removeIt);\n\n      // NOTE: There is no API available to remove a TextTrack from a video\n      // element.\n      this.textTrack_.mode = 'disabled';\n    }\n\n    this.textTrack_ = null;\n    return Promise.resolve();\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  isTextVisible() {\n    return this.textTrack_.mode == 'showing';\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  setTextVisibility(on) {\n    this.textTrack_.mode = on ? 'showing' : 'hidden';\n  }\n\n  /**\n   * @param {!shaka.extern.Cue} shakaCue\n   * @return {TextTrackCue}\n   * @private\n   */\n  static convertToTextTrackCue_(shakaCue) {\n    if (shakaCue.startTime >= shakaCue.endTime) {\n      // IE/Edge will throw in this case.\n      // See issue #501\n      shaka.log.warning('Invalid cue times: ' + shakaCue.startTime +\n                        ' - ' + shakaCue.endTime);\n      return null;\n    }\n\n    const Cue = shaka.text.Cue;\n    /** @type {VTTCue} */\n    const vttCue = new VTTCue(shakaCue.startTime,\n        shakaCue.endTime,\n        shakaCue.payload);\n\n    // NOTE: positionAlign and lineAlign settings are not supported by Chrome\n    // at the moment, so setting them will have no effect.\n    // The bug on chromium to implement them:\n    // https://bugs.chromium.org/p/chromium/issues/detail?id=633690\n\n    vttCue.lineAlign = shakaCue.lineAlign;\n    vttCue.positionAlign = shakaCue.positionAlign;\n    if (shakaCue.size) {\n      vttCue.size = shakaCue.size;\n    }\n\n    try {\n      // Safari 10 seems to throw on align='center'.\n      vttCue.align = shakaCue.textAlign;\n    } catch (exception) {}\n\n    if (shakaCue.textAlign == 'center' && vttCue.align != 'center') {\n      // We want vttCue.position = 'auto'. By default, |position| is set to\n      // \"auto\". If we set it to \"auto\" safari will throw an exception, so we\n      // must rely on the default value.\n      vttCue.align = 'middle';\n    }\n\n    if (shakaCue.writingMode ==\n            Cue.writingMode.VERTICAL_LEFT_TO_RIGHT) {\n      vttCue.vertical = 'lr';\n    } else if (shakaCue.writingMode ==\n             Cue.writingMode.VERTICAL_RIGHT_TO_LEFT) {\n      vttCue.vertical = 'rl';\n    }\n\n    // snapToLines flag is true by default\n    if (shakaCue.lineInterpretation == Cue.lineInterpretation.PERCENTAGE) {\n      vttCue.snapToLines = false;\n    }\n\n    if (shakaCue.line != null) {\n      vttCue.line = shakaCue.line;\n    }\n\n    if (shakaCue.position != null) {\n      vttCue.position = shakaCue.position;\n    }\n\n    return vttCue;\n  }\n\n  /**\n   * Iterate over all the cues in a text track and remove all those for which\n   * |predicate(cue)| returns true.\n   *\n   * @param {!TextTrack} track\n   * @param {function(!TextTrackCue):boolean} predicate\n   * @private\n   */\n  static removeWhere_(track, predicate) {\n    // Since |track.cues| can be null if |track.mode| is \"disabled\", force it to\n    // something other than \"disabled\".\n    //\n    // If the track is already showing, then we should keep it as showing. But\n    // if it something else, we will use hidden so that we don't \"flash\" cues on\n    // the screen.\n    const oldState = track.mode;\n    const tempState = oldState == 'showing' ? 'showing' : 'hidden';\n\n    track.mode = tempState;\n\n    goog.asserts.assert(\n        track.cues,\n        'Cues should be accessible when mode is set to \"' + tempState + '\".');\n\n    // Create a copy of the list to avoid errors while iterating.\n    for (const cue of Array.from(track.cues)) {\n      if (cue && predicate(cue)) {\n        track.removeCue(cue);\n      }\n    }\n\n    track.mode = oldState;\n  }\n};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n\ngoog.provide('shaka.util.Dom');\n\ngoog.require('goog.asserts');\n\n\n// TODO: revisit this when Closure Compiler supports partially-exported classes.\n/** @export */\nshaka.util.Dom = class {\n  /**\n   * Creates an element, and cast the type from Element to HTMLElement.\n   *\n   * @param {string} tagName\n   * @return {!HTMLElement}\n   */\n  static createHTMLElement(tagName) {\n    const element =\n      /** @type {!HTMLElement} */ (document.createElement(tagName));\n    return element;\n  }\n\n\n  /**\n   * Create a \"button\" element with the correct type.\n   *\n   * The compiler is very picky about the use of the \"disabled\" property on\n   * HTMLElement, since it is only defined on certain subclasses of that.  This\n   * method merely creates a button and casts it to the correct type.\n   *\n   * @return {!HTMLButtonElement}\n   */\n  static createButton() {\n    return /** @type {!HTMLButtonElement} */(document.createElement('button'));\n  }\n\n\n  /**\n   * Cast a Node/Element to an HTMLElement\n   *\n   * @param {!Node|!Element} original\n   * @return {!HTMLElement}\n   */\n  static asHTMLElement(original) {\n    return /** @type {!HTMLElement}*/ (original);\n  }\n\n\n  /**\n   * Cast a Node/Element to an HTMLMediaElement\n   *\n   * @param {!Node|!Element} original\n   * @return {!HTMLMediaElement}\n   */\n  static asHTMLMediaElement(original) {\n    return /** @type {!HTMLMediaElement}*/ (original);\n  }\n\n\n  /**\n   * Returns the element with a given class name.\n   * Assumes the class name to be unique for a given parent.\n   *\n   * @param {string} className\n   * @param {!HTMLElement} parent\n   * @return {!HTMLElement}\n   */\n  static getElementByClassName(className, parent) {\n    const elements = parent.getElementsByClassName(className);\n    goog.asserts.assert(elements.length == 1,\n        'Should only be one element with class name ' + className);\n\n    return shaka.util.Dom.asHTMLElement(elements[0]);\n  }\n\n\n  /**\n   * Remove all of the child nodes of an element.\n   * @param {!Element} element\n   * @export\n   */\n  static removeAllChildren(element) {\n    while (element.firstChild) {\n      element.removeChild(element.firstChild);\n    }\n  }\n};\n\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n\ngoog.provide('shaka.text.UITextDisplayer');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.text.Cue');\ngoog.require('shaka.text.CueRegion');\ngoog.require('shaka.util.Dom');\ngoog.require('shaka.util.Timer');\n\n\n/**\n * @implements {shaka.extern.TextDisplayer}\n * @final\n * @export\n */\nshaka.text.UITextDisplayer = class {\n  /**\n   * Constructor.\n   * @param {HTMLMediaElement} video\n   * @param {HTMLElement} videoContainer\n   */\n  constructor(video, videoContainer) {\n    goog.asserts.assert(videoContainer, 'videoContainer should be valid.');\n\n    /** @private {boolean} */\n    this.isTextVisible_ = false;\n\n    /** @private {!Array.<!shaka.text.Cue>} */\n    this.cues_ = [];\n\n    /** @private {HTMLMediaElement} */\n    this.video_ = video;\n\n    /** @private {HTMLElement} */\n    this.videoContainer_ = videoContainer;\n\n    /** @type {HTMLElement} */\n    this.textContainer_ = shaka.util.Dom.createHTMLElement('div');\n    this.textContainer_.classList.add('shaka-text-container');\n\n    // Set the subtitles text-centered by default.\n    this.textContainer_.style.textAlign = 'center';\n\n    // Set the captions in the middle horizontally by default.\n    this.textContainer_.style.display = 'flex';\n    this.textContainer_.style.flexDirection = 'column';\n    this.textContainer_.style.alignItems = 'center';\n\n    // Set the captions at the bottom by default.\n    this.textContainer_.style.justifyContent = 'flex-end';\n\n    this.videoContainer_.appendChild(this.textContainer_);\n\n    /**\n     * The captions' update period in seconds.\n     * @private {number}\n     */\n    const updatePeriod = 0.25;\n\n    /** @private {shaka.util.Timer} */\n    this.captionsTimer_ = new shaka.util.Timer(() => {\n      this.updateCaptions_();\n    }).tickEvery(updatePeriod);\n\n    /** private {Map.<!shaka.extern.Cue, !HTMLElement>} */\n    this.currentCuesMap_ = new Map();\n  }\n\n\n  /**\n   * @override\n   * @export\n   */\n  append(cues) {\n    // Clone the cues list for performace optimization. We can avoid the cues\n    // list growing during the comparisons for duplicate cues.\n    // See: https://github.com/google/shaka-player/issues/3018\n    const cuesList = [...this.cues_];\n    for (const cue of cues) {\n      // When a VTT cue spans a segment boundary, the cue will be duplicated\n      // into two segments.\n      // To avoid displaying duplicate cues, if the current cue list already\n      // contains the cue, skip it.\n      const containsCue = cuesList.some(\n          (cueInList) => shaka.text.Cue.equal(cueInList, cue));\n      if (!containsCue) {\n        this.cues_.push(cue);\n      }\n    }\n\n    this.updateCaptions_();\n  }\n\n\n  /**\n   * @override\n   * @export\n   */\n  destroy() {\n    // Remove the text container element from the UI.\n    this.videoContainer_.removeChild(this.textContainer_);\n    this.textContainer_ = null;\n\n    this.isTextVisible_ = false;\n    this.cues_ = [];\n    if (this.captionsTimer_) {\n      this.captionsTimer_.stop();\n    }\n\n    this.currentCuesMap_.clear();\n  }\n\n\n  /**\n   * @override\n   * @export\n   */\n  remove(start, end) {\n    // Return false if destroy() has been called.\n    if (!this.textContainer_) {\n      return false;\n    }\n\n    // Remove the cues out of the time range.\n    this.cues_ = this.cues_.filter(\n        (cue) => cue.startTime < start || cue.endTime >= end);\n    this.updateCaptions_();\n\n    return true;\n  }\n\n\n  /**\n   * @override\n   * @export\n   */\n  isTextVisible() {\n    return this.isTextVisible_;\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  setTextVisibility(on) {\n    this.isTextVisible_ = on;\n  }\n\n  /**\n   * Display the current captions.\n   * @private\n   */\n  updateCaptions_() {\n    const currentTime = this.video_.currentTime;\n\n    // Return true if the cue should be displayed at the current time point.\n    const shouldCueBeDisplayed = (cue) => {\n      return this.cues_.includes(cue) && this.isTextVisible_ &&\n             cue.startTime <= currentTime && cue.endTime >= currentTime;\n    };\n\n    // For each cue in the current cues map, if the cue's end time has passed,\n    // remove the entry from the map, and remove the captions from the page.\n    for (const cue of this.currentCuesMap_.keys()) {\n      if (!shouldCueBeDisplayed(cue)) {\n        const captions = this.currentCuesMap_.get(cue);\n        this.textContainer_.removeChild(captions);\n        this.currentCuesMap_.delete(cue);\n      }\n    }\n\n    // Sometimes we don't remove a cue element correctly.  So check all the\n    // child nodes and remove any that don't have an associated cue.\n    const expectedChildren = new Set(this.currentCuesMap_.values());\n    for (const child of Array.from(this.textContainer_.childNodes)) {\n      if (!expectedChildren.has(child)) {\n        this.textContainer_.removeChild(child);\n      }\n    }\n\n    // Get the current cues that should be added to display. If the cue is not\n    // being displayed already, add it to the map, and add the captions onto the\n    // page.\n    const currentCues = this.cues_.filter((cue) => {\n      return shouldCueBeDisplayed(cue) && !this.currentCuesMap_.has(cue);\n    }).sort((a, b) => {\n      if (a.startTime != b.startTime) {\n        return a.startTime - b.startTime;\n      } else {\n        return a.endTime - b.endTime;\n      }\n    });\n\n    for (const cue of currentCues) {\n      this.displayCue_(this.textContainer_, cue);\n    }\n  }\n\n  /**\n   * Displays a nested cue\n   *\n   * @param {Element} container\n   * @param {!shaka.extern.Cue} cue\n   * @param {boolean} isNested\n   * @return {!Element} the created captions container\n   * @private\n   */\n  displayLeafCue_(container, cue, isNested) {\n    const captions = shaka.util.Dom.createHTMLElement('span');\n    if (isNested) {\n      captions.classList.add('shaka-nested-cue');\n    }\n    this.setCaptionStyles_(captions, cue, /* isLeaf= */ true);\n    container.appendChild(captions);\n\n    return captions;\n  }\n\n  /**\n   * Displays a cue\n   *\n   * @param {Element} container\n   * @param {!shaka.extern.Cue} cue\n   * @private\n   */\n  displayCue_(container, cue) {\n    if (cue.nestedCues.length) {\n      const nestedCuesContainer = shaka.util.Dom.createHTMLElement('p');\n      nestedCuesContainer.style.width = '100%';\n      this.setCaptionStyles_(nestedCuesContainer, cue, /* isLeaf= */ false);\n\n      for (let i = 0; i < cue.nestedCues.length; i++) {\n        this.displayLeafCue_(\n            nestedCuesContainer, cue.nestedCues[i], /* isNested= */ true);\n      }\n\n      container.appendChild(nestedCuesContainer);\n      this.currentCuesMap_.set(cue, nestedCuesContainer);\n    } else {\n      this.currentCuesMap_.set(cue,\n          this.displayLeafCue_(container, cue, /* isNested= */ false));\n    }\n  }\n\n  /**\n   * @param {!HTMLElement} captions\n   * @param {!shaka.extern.Cue} cue\n   * @param {boolean} isNested\n   * @private\n   */\n  setCaptionStyles_(captions, cue, isNested) {\n    const Cue = shaka.text.Cue;\n    const captionsStyle = captions.style;\n    const isLeaf = cue.nestedCues.length == 0;\n\n\n    if (cue.spacer) {\n      // This takes up a whole line on its own, but that line is 0-height,\n      // making it effectively a line-break.\n      captionsStyle.flexBasis = '100%';\n      captionsStyle.height = '0';\n      // TODO: support multiple line breaks in a row, in which case second and\n      // up need to take up vertical space.\n\n      // Line breaks have no other styles applied.\n      return;\n    }\n    // Set white-space to 'pre-line' to enable showing line breaks in the text.\n    captionsStyle.whiteSpace = 'pre-line';\n    captions.textContent = cue.payload;\n    if (isLeaf) {\n      captionsStyle.backgroundColor = cue.backgroundColor;\n    }\n    captionsStyle.border = cue.border;\n    captionsStyle.color = cue.color;\n    captionsStyle.direction = cue.direction;\n    captionsStyle.opacity = cue.opacity;\n    captionsStyle.paddingLeft = shaka.text.UITextDisplayer.convertLengthValue_(\n        cue.linePadding, cue, this.videoContainer_\n    );\n    captionsStyle.paddingRight = shaka.text.UITextDisplayer.convertLengthValue_(\n        cue.linePadding, cue, this.videoContainer_\n    );\n\n    if (cue.backgroundImage) {\n      captionsStyle.backgroundImage = 'url(\\'' + cue.backgroundImage + '\\')';\n      captionsStyle.backgroundRepeat = 'no-repeat';\n      captionsStyle.backgroundSize = 'contain';\n      captionsStyle.backgroundPosition = 'center';\n      if (cue.backgroundColor == '') {\n        captionsStyle.backgroundColor = 'transparent';\n      }\n    }\n    if (cue.backgroundImage && cue.region) {\n      const percentageUnit = shaka.text.CueRegion.units.PERCENTAGE;\n      const heightUnit = cue.region.heightUnits == percentageUnit ? '%' : 'px';\n      const widthUnit = cue.region.widthUnits == percentageUnit ? '%' : 'px';\n      captionsStyle.height = cue.region.height + heightUnit;\n      captionsStyle.width = cue.region.width + widthUnit;\n    }\n\n    // The displayAlign attribute specifys the vertical alignment of the\n    // captions inside the text container. Before means at the top of the\n    // text container, and after means at the bottom.\n    if (cue.displayAlign == Cue.displayAlign.BEFORE) {\n      captionsStyle.justifyContent = 'flex-start';\n    } else if (cue.displayAlign == Cue.displayAlign.CENTER) {\n      captionsStyle.justifyContent = 'center';\n    } else {\n      captionsStyle.justifyContent = 'flex-end';\n    }\n\n    if (isLeaf) {\n      captionsStyle.display = 'inline-block';\n    } else {\n      captionsStyle.display = 'flex';\n      captionsStyle.flexDirection = 'row';\n      captionsStyle.flexWrap = 'wrap';\n      captionsStyle.margin = '0';\n      // Setting flexDirection to \"row\" inverts the sense of align and justify.\n      // Now align is vertical and justify is horizontal.  See comments above on\n      // vertical alignment for displayAlign.\n      captionsStyle.alignItems = captionsStyle.justifyContent;\n      captionsStyle.justifyContent = 'center';\n    }\n\n    if (isNested) {\n      // Work around an IE 11 flexbox bug in which center-aligned items can\n      // overflow their container.  See\n      // https://github.com/philipwalton/flexbugs/tree/6e720da8#flexbug-2\n      captionsStyle.maxWidth = '100%';\n    }\n\n    captionsStyle.fontFamily = cue.fontFamily;\n    captionsStyle.fontWeight = cue.fontWeight.toString();\n    captionsStyle.fontStyle = cue.fontStyle;\n    captionsStyle.letterSpacing = cue.letterSpacing;\n    captionsStyle.fontSize = shaka.text.UITextDisplayer.convertLengthValue_(\n        cue.fontSize, cue, this.videoContainer_\n    );\n\n    // The line attribute defines the positioning of the text container inside\n    // the video container.\n    // - The line offsets the text container from the top, the right or left of\n    //   the video viewport as defined by the writing direction.\n    // - The value of the line is either as a number of lines, or a percentage\n    //   of the video viewport height or width.\n    // The lineAlign is an alignment for the text container's line.\n    // - The Start alignment means the text containers top side (for horizontal\n    //   cues), left side (for vertical growing right), or right side (for\n    //   vertical growing left) is aligned at the line.\n    // - The Center alignment means the text container is centered at the line\n    //   (to be implemented).\n    // - The End Alignment means The text containers bottom side (for\n    //   horizontal cues), right side (for vertical growing right), or left side\n    //   (for vertical growing left) is aligned at the line.\n    // TODO: Implement line alignment with line number.\n    // TODO: Implement lineAlignment of 'CENTER'.\n    if (cue.line) {\n      if (cue.lineInterpretation == Cue.lineInterpretation.PERCENTAGE) {\n        captionsStyle.position = 'absolute';\n        if (cue.writingMode == Cue.writingMode.HORIZONTAL_TOP_TO_BOTTOM) {\n          if (cue.lineAlign == Cue.lineAlign.START) {\n            captionsStyle.top = cue.line + '%';\n          } else if (cue.lineAlign == Cue.lineAlign.END) {\n            captionsStyle.bottom = cue.line + '%';\n          }\n        } else if (cue.writingMode == Cue.writingMode.VERTICAL_LEFT_TO_RIGHT) {\n          if (cue.lineAlign == Cue.lineAlign.START) {\n            captionsStyle.left = cue.line + '%';\n          } else if (cue.lineAlign == Cue.lineAlign.END) {\n            captionsStyle.right = cue.line + '%';\n          }\n        } else {\n          if (cue.lineAlign == Cue.lineAlign.START) {\n            captionsStyle.right = cue.line + '%';\n          } else if (cue.lineAlign == Cue.lineAlign.END) {\n            captionsStyle.left = cue.line + '%';\n          }\n        }\n      }\n    } else if (cue.region && cue.region.id && !isLeaf) {\n      const percentageUnit = shaka.text.CueRegion.units.PERCENTAGE;\n      const heightUnit = cue.region.heightUnits == percentageUnit ? '%' : 'px';\n      const widthUnit = cue.region.widthUnits == percentageUnit ? '%' : 'px';\n      const viewportAnchorUnit =\n          cue.region.viewportAnchorUnits == percentageUnit ? '%' : 'px';\n      captionsStyle.height = cue.region.height + heightUnit;\n      captionsStyle.width = cue.region.width + widthUnit;\n      captionsStyle.position = 'absolute';\n      captionsStyle.top = cue.region.viewportAnchorY + viewportAnchorUnit;\n      captionsStyle.left = cue.region.viewportAnchorX + viewportAnchorUnit;\n    }\n\n    captionsStyle.lineHeight = cue.lineHeight;\n\n    // The position defines the indent of the text container in the\n    // direction defined by the writing direction.\n    if (cue.position) {\n      if (cue.writingMode == Cue.writingMode.HORIZONTAL_TOP_TO_BOTTOM) {\n        captionsStyle.paddingLeft = cue.position;\n      } else {\n        captionsStyle.paddingTop = cue.position;\n      }\n    }\n\n    // The positionAlign attribute is an alignment for the text container in\n    // the dimension of the writing direction.\n    if (cue.positionAlign == Cue.positionAlign.LEFT) {\n      captionsStyle.cssFloat = 'left';\n    } else if (cue.positionAlign == Cue.positionAlign.RIGHT) {\n      captionsStyle.cssFloat = 'right';\n    }\n\n    captionsStyle.textAlign = cue.textAlign;\n    captionsStyle.textDecoration = cue.textDecoration.join(' ');\n    captionsStyle.writingMode = cue.writingMode;\n\n    // The size is a number giving the size of the text container, to be\n    // interpreted as a percentage of the video, as defined by the writing\n    // direction.\n    if (cue.size) {\n      if (cue.writingMode == Cue.writingMode.HORIZONTAL_TOP_TO_BOTTOM) {\n        captionsStyle.width = cue.size + '%';\n      } else {\n        captionsStyle.height = cue.size + '%';\n      }\n    }\n  }\n\n  /**\n   * Returns info about provided lengthValue\n   * @example 100px => { value: 100, unit: 'px' }\n   * @param {?string} lengthValue\n   *\n   * @return {?{ value: number, unit: string }}\n   * @private\n   */\n  static getLengthValueInfo_(lengthValue) {\n    const matches = new RegExp(/(\\d*\\.?\\d+)([a-z]+|%+)/).exec(lengthValue);\n\n    if (!matches) {\n      return null;\n    }\n\n    return {\n      value: Number(matches[1]),\n      unit: matches[2],\n    };\n  }\n\n  /**\n   * Converts length value to an absolute value in pixels.\n   * If lengthValue is already an absolute value it will not\n   * be modified. Relative lengthValue will be converted to an\n   * absolute value in pixels based on Computed Cell Size\n   *\n   * @param {string} lengthValue\n   * @param {!shaka.extern.Cue} cue\n   * @param {HTMLElement} videoContainer\n   * @return {string}\n   * @private\n  */\n  static convertLengthValue_(lengthValue, cue, videoContainer) {\n    const lengthValueInfo =\n        shaka.text.UITextDisplayer.getLengthValueInfo_(lengthValue);\n\n    if (!lengthValueInfo) {\n      return lengthValue;\n    }\n\n    const {unit, value} = lengthValueInfo;\n\n    switch (unit) {\n      case '%':\n        return shaka.text.UITextDisplayer.getAbsoluteLengthInPixels_(\n            value / 100, cue, videoContainer);\n      case 'c':\n        return shaka.text.UITextDisplayer.getAbsoluteLengthInPixels_(\n            value, cue, videoContainer);\n      default:\n        return lengthValue;\n    }\n  }\n\n  /**\n   * Returns computed absolute length value in pixels based on cell\n   * and a video container size\n   * @param {number} value\n   * @param {!shaka.extern.Cue} cue\n   * @param {HTMLElement} videoContainer\n   * @return {string}\n   *\n   * @private\n   * */\n  static getAbsoluteLengthInPixels_(value, cue, videoContainer) {\n    const containerHeight = videoContainer.clientHeight;\n\n    return (containerHeight * value / cue.cellResolution.rows) + 'px';\n  }\n};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.util.ConfigUtils');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.util.ObjectUtils');\n\n\n/** @export */\nshaka.util.ConfigUtils = class {\n  /**\n   * @param {!Object} destination\n   * @param {!Object} source\n   * @param {!Object} template supplies default values\n   * @param {!Object} overrides\n   *   Supplies override type checking.  When the current path matches\n   *   the key in this object, each sub-value must match the type in this\n   *   object. If this contains an Object, it is used as the template.\n   * @param {string} path to this part of the config\n   * @return {boolean}\n   * @export\n   */\n  static mergeConfigObjects(destination, source, template, overrides, path) {\n    goog.asserts.assert(destination, 'Destination config must not be null!');\n\n    /**\n     * @type {boolean}\n     * If true, don't validate the keys in the next level.\n     */\n    const ignoreKeys = path in overrides;\n\n    let isValid = true;\n\n    for (const k in source) {\n      const subPath = path + '.' + k;\n      const subTemplate = ignoreKeys ? overrides[path] : template[k];\n\n      // The order of these checks is important.\n      if (!ignoreKeys && !(k in template)) {\n        shaka.log.alwaysError('Invalid config, unrecognized key ' + subPath);\n        isValid = false;\n      } else if (source[k] === undefined) {\n        // An explicit 'undefined' value causes the key to be deleted from the\n        // destination config and replaced with a default from the template if\n        // possible.\n        if (subTemplate === undefined || ignoreKeys) {\n          // There is nothing in the template, so delete.\n          delete destination[k];\n        } else {\n          // There is something in the template, so go back to that.\n          destination[k] = shaka.util.ObjectUtils.cloneObject(subTemplate);\n        }\n      } else if (subTemplate.constructor == Object &&\n                 source[k] &&\n                 source[k].constructor == Object) {\n        // These are plain Objects with no other constructor.\n\n        if (!destination[k]) {\n          // Initialize the destination with the template so that normal\n          // merging and type-checking can happen.\n          destination[k] = shaka.util.ObjectUtils.cloneObject(subTemplate);\n        }\n\n        const subMergeValid = shaka.util.ConfigUtils.mergeConfigObjects(\n            destination[k], source[k], subTemplate, overrides, subPath);\n        isValid = isValid && subMergeValid;\n      } else if (typeof source[k] != typeof subTemplate ||\n                 source[k] == null ||\n                 // Function cosntructors are not informative, and differ\n                 // between sync and async functions.  So don't look at\n                 // constructor for function types.\n                 (typeof source[k] != 'function' &&\n                  source[k].constructor != subTemplate.constructor)) {\n        // The source is the wrong type.  This check allows objects to be\n        // nulled, but does not allow null for any non-object fields.\n        shaka.log.alwaysError('Invalid config, wrong type for ' + subPath);\n        isValid = false;\n      } else if (typeof template[k] == 'function' &&\n                 template[k].length != source[k].length) {\n        shaka.log.alwaysWarn(\n            'Unexpected number of arguments for ' + subPath);\n        destination[k] = source[k];\n      } else {\n        destination[k] = source[k];\n      }\n    }\n\n    return isValid;\n  }\n\n\n  /**\n   * Convert config from ('fieldName', value) format to a partial config object.\n   *\n   * E. g. from ('manifest.retryParameters.maxAttempts', 1) to\n   * { manifest: { retryParameters: { maxAttempts: 1 }}}.\n   *\n   * @param {string} fieldName\n   * @param {*} value\n   * @return {!Object}\n   * @export\n   */\n  static convertToConfigObject(fieldName, value) {\n    const configObject = {};\n    let last = configObject;\n    let searchIndex = 0;\n    let nameStart = 0;\n    while (true) {  // eslint-disable-line no-constant-condition\n      const idx = fieldName.indexOf('.', searchIndex);\n      if (idx < 0) {\n        break;\n      }\n      if (idx == 0 || fieldName[idx - 1] != '\\\\') {\n        const part = fieldName.substring(nameStart, idx).replace(/\\\\\\./g, '.');\n        last[part] = {};\n        last = last[part];\n        nameStart = idx + 1;\n      }\n      searchIndex = idx + 1;\n    }\n\n    last[fieldName.substring(nameStart).replace(/\\\\\\./g, '.')] = value;\n    return configObject;\n  }\n};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.util.PlayerConfiguration');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.abr.SimpleAbrManager');\ngoog.require('shaka.log');\ngoog.require('shaka.media.DrmEngine');\ngoog.require('shaka.net.NetworkingEngine');\ngoog.require('shaka.util.ConfigUtils');\ngoog.require('shaka.util.LanguageUtils');\ngoog.require('shaka.util.ManifestParserUtils');\ngoog.require('shaka.util.Platform');\n\n\n// TODO(vaage): Many times in our configs, we need to create an empty\n//  implementation of a method, but to avoid closure from removing unused\n//  parameters (and breaking our merge config code) we need to use each\n//  parameter. Is there a better solution to this problem than what we are\n//  doing now?\n//\n//  NOTE: Chrome App Content Security Policy prohibits usage of new Function()\n\n/**\n * @final\n * @export\n */\nshaka.util.PlayerConfiguration = class {\n  /** @return {shaka.extern.PlayerConfiguration} */\n  static createDefault() {\n    // This is a relatively safe default in the absence of clues from the\n    // browser.  For slower connections, the default estimate may be too high.\n    let bandwidthEstimate = 1e6; // 1Mbps\n\n    let abrMaxHeight = Infinity;\n\n    // Some browsers implement the Network Information API, which allows\n    // retrieving information about a user's network connection.\n    if (navigator.connection) {\n      // If it's available, get the bandwidth estimate from the browser (in\n      // megabits per second) and use it as defaultBandwidthEstimate.\n      // Tizen 3 has NetworkInformation, but not the downlink attribute.\n      if (navigator.connection.downlink) {\n        bandwidthEstimate = navigator.connection.downlink * 1e6;\n      }\n      // TODO: Move this into AbrManager, where changes to the estimate can be\n      // observed and absorbed.\n\n      // If the user has checked a box in the browser to ask it to use less\n      // data, the browser will expose this intent via connection.saveData.\n      // When that is true, we will default the max ABR height to 360p. Apps\n      // can override this if they wish.\n      //\n      // The decision to use 360p was somewhat arbitrary. We needed a default\n      // limit, and rather than restrict to a certain bandwidth, we decided to\n      // restrict resolution. This will implicitly restrict bandwidth and\n      // therefore save data. We (Shaka+Chrome) judged that:\n      //   - HD would be inappropriate\n      //   - If a user is asking their browser to save data, 360p it reasonable\n      //   - 360p would not look terrible on small mobile device screen\n      // We also found that:\n      //   - YouTube's website on mobile defaults to 360p (as of 2018)\n      //   - iPhone 6, in portrait mode, has a physical resolution big enough\n      //     for 360p widescreen, but a little smaller than 480p widescreen\n      //     (https://apple.co/2yze4es)\n      // If the content's lowest resolution is above 360p, AbrManager will use\n      // the lowest resolution.\n      if (navigator.connection.saveData) {\n        abrMaxHeight = 360;\n      }\n    }\n\n    const drm = {\n      retryParameters: shaka.net.NetworkingEngine.defaultRetryParameters(),\n      // These will all be verified by special cases in mergeConfigObjects_():\n      servers: {},    // key is arbitrary key system ID, value must be string\n      clearKeys: {},  // key is arbitrary key system ID, value must be string\n      advanced: {},    // key is arbitrary key system ID, value is a record type\n      delayLicenseRequestUntilPlayed: false,\n      initDataTransform: shaka.media.DrmEngine.defaultInitDataTransform,\n      logLicenseExchange: false,\n      updateExpirationTime: 1,\n    };\n\n    const manifest = {\n      retryParameters: shaka.net.NetworkingEngine.defaultRetryParameters(),\n      availabilityWindowOverride: NaN,\n      disableAudio: false,\n      disableVideo: false,\n      disableText: false,\n      defaultPresentationDelay: 0,\n      dash: {\n        clockSyncUri: '',\n        ignoreDrmInfo: false,\n        xlinkFailGracefully: false,\n        ignoreMinBufferTime: false,\n        autoCorrectDrift: true,\n        initialSegmentLimit: 1000,\n        ignoreSuggestedPresentationDelay: false,\n        ignoreEmptyAdaptationSet: false,\n      },\n      hls: {\n        ignoreTextStreamFailures: false,\n        useFullSegmentsForStartTime: false,\n      },\n    };\n\n    const streaming = {\n      retryParameters: shaka.net.NetworkingEngine.defaultRetryParameters(),\n      // Need some operation in the callback or else closure may remove calls\n      // to the function as it would be a no-op.  The operation can't just be a\n      // log message, because those are stripped in the compiled build.\n      failureCallback: (error) => {\n        shaka.log.error('Unhandled streaming error', error);\n        return [error];\n      },\n      rebufferingGoal: 2,\n      bufferingGoal: 10,\n      bufferBehind: 30,\n      ignoreTextStreamFailures: false,\n      alwaysStreamText: false,\n      startAtSegmentBoundary: false,\n      smallGapLimit: 0.5,\n      jumpLargeGaps: false,\n      durationBackoff: 1,\n      forceTransmuxTS: false,\n      // Offset by 5 seconds since Chromecast takes a few seconds to start\n      // playing after a seek, even when buffered.\n      safeSeekOffset: 5,\n      stallEnabled: true,\n      stallThreshold: 1 /* seconds */,\n      stallSkip: 0.1 /* seconds */,\n      useNativeHlsOnSafari: true,\n      // If we are within 2 seconds of the start of a live segment, fetch the\n      // previous one.  This allows for segment drift, but won't download an\n      // extra segment if we aren't close to the start.\n      inaccurateManifestTolerance: 2,\n    };\n\n    // WebOS, Tizen, and Chromecast have long hardware pipelines that respond\n    // slowly to seeking.  Therefore we should not seek when we detect a stall\n    // on one of these platforms.  Instead, default stallSkip to 0 to force the\n    // stall detector to pause and play instead.\n    if (shaka.util.Platform.isWebOS() ||\n        shaka.util.Platform.isTizen() ||\n        shaka.util.Platform.isChromecast()) {\n      streaming.stallSkip = 0;\n    }\n\n    const offline = {\n      // We need to set this to a throw-away implementation for now as our\n      // default implementation will need to reference other fields in the\n      // config. We will set it to our intended implementation after we have\n      // the top-level object created.\n      // eslint-disable-next-line require-await\n      trackSelectionCallback: async (tracks) => tracks,\n\n      // Need some operation in the callback or else closure may remove calls\n      // to the function as it would be a no-op.  The operation can't just be a\n      // log message, because those are stripped in the compiled build.\n      progressCallback: (content, progress) => {\n        return [content, progress];\n      },\n\n      // By default we use persistent licenses as forces errors to surface if\n      // a platform does not support offline licenses rather than causing\n      // unexpected behaviours when someone tries to plays downloaded content\n      // without a persistent license.\n      usePersistentLicense: true,\n    };\n\n    const abr = {\n      enabled: true,\n      defaultBandwidthEstimate: bandwidthEstimate,\n      switchInterval: 8,\n      bandwidthUpgradeTarget: 0.85,\n      bandwidthDowngradeTarget: 0.95,\n      restrictions: {\n        minWidth: 0,\n        maxWidth: Infinity,\n        minHeight: 0,\n        maxHeight: abrMaxHeight,\n        minPixels: 0,\n        maxPixels: Infinity,\n        minFrameRate: 0,\n        maxFrameRate: Infinity,\n        minBandwidth: 0,\n        maxBandwidth: Infinity,\n      },\n    };\n\n    /** @type {shaka.extern.PlayerConfiguration} */\n    const config = {\n      drm: drm,\n      manifest: manifest,\n      streaming: streaming,\n      offline: offline,\n      abrFactory: () => new shaka.abr.SimpleAbrManager(),\n      abr: abr,\n      preferredAudioLanguage: '',\n      preferredTextLanguage: '',\n      preferredVariantRole: '',\n      preferredTextRole: '',\n      preferredAudioChannelCount: 2,\n      restrictions: {\n        minWidth: 0,\n        maxWidth: Infinity,\n        minHeight: 0,\n        maxHeight: Infinity,\n        minPixels: 0,\n        maxPixels: Infinity,\n        minFrameRate: 0,\n        maxFrameRate: Infinity,\n        minBandwidth: 0,\n        maxBandwidth: Infinity,\n      },\n      playRangeStart: 0,\n      playRangeEnd: Infinity,\n      textDisplayFactory: () => null,\n    };\n\n    // Add this callback so that we can reference the preferred audio language\n    // through the config object so that if it gets updated, we have the\n    // updated value.\n    // eslint-disable-next-line require-await\n    offline.trackSelectionCallback = async (tracks) => {\n      return shaka.util.PlayerConfiguration.defaultTrackSelect(\n          tracks, config.preferredAudioLanguage);\n    };\n\n    return config;\n  }\n\n  /**\n   * Merges the given configuration changes into the given destination.  This\n   * uses the default Player configurations as the template.\n   *\n   * @param {shaka.extern.PlayerConfiguration} destination\n   * @param {!Object} updates\n   * @param {shaka.extern.PlayerConfiguration=} template\n   * @return {boolean}\n   * @export\n   */\n  static mergeConfigObjects(destination, updates, template) {\n    const overrides = {\n      '.drm.servers': '',\n      '.drm.clearKeys': '',\n      '.drm.advanced': {\n        distinctiveIdentifierRequired: false,\n        persistentStateRequired: false,\n        videoRobustness: '',\n        audioRobustness: '',\n        serverCertificate: new Uint8Array(0),\n        individualizationServer: '',\n      },\n    };\n    return shaka.util.ConfigUtils.mergeConfigObjects(\n        destination, updates,\n        template || shaka.util.PlayerConfiguration.createDefault(), overrides,\n        '');\n  }\n\n  /**\n   * @param {!Array.<shaka.extern.Track>} tracks\n   * @param {string} preferredAudioLanguage\n   * @return {!Array.<shaka.extern.Track>}\n   */\n  static defaultTrackSelect(tracks, preferredAudioLanguage) {\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n    const LanguageUtils = shaka.util.LanguageUtils;\n\n    /** @type {!Array.<shaka.extern.Track>} */\n    const allVariants = tracks.filter((track) => track.type == 'variant');\n\n    /** @type {!Array.<shaka.extern.Track>} */\n    let selectedVariants = [];\n\n    // Find the locale that best matches our preferred audio locale.\n    const closestLocale = LanguageUtils.findClosestLocale(\n        preferredAudioLanguage,\n        allVariants.map((variant) => variant.language));\n    // If we found a locale that was close to our preference, then only use\n    // variants that use that locale.\n    if (closestLocale) {\n      selectedVariants = allVariants.filter((variant) => {\n        const locale = LanguageUtils.normalize(variant.language);\n        return locale == closestLocale;\n      });\n    }\n\n    // If we failed to get a language match, go with primary.\n    if (selectedVariants.length == 0) {\n      selectedVariants = allVariants.filter((variant) => {\n        return variant.primary;\n      });\n    }\n\n    // Otherwise, there is no good way to choose the language, so we don't\n    // choose a language at all.\n    if (selectedVariants.length == 0) {\n      // Issue a warning, but only if the content has multiple languages.\n      // Otherwise, this warning would just be noise.\n      const languages = new Set(allVariants.map((track) => {\n        return track.language;\n      }));\n\n      if (languages.size > 1) {\n        shaka.log.warning('Could not choose a good audio track based on ' +\n                          'language preferences or primary tracks.  An ' +\n                          'arbitrary language will be stored!');\n      }\n\n      // Default back to all variants.\n      selectedVariants = allVariants;\n    }\n\n    // From previously selected variants, choose the SD ones (height <= 480).\n    const tracksByHeight = selectedVariants.filter((track) => {\n      return track.height && track.height <= 480;\n    });\n\n    // If variants don't have video or no video with height <= 480 was\n    // found, proceed with the previously selected tracks.\n    if (tracksByHeight.length) {\n      // Sort by resolution, then select all variants which match the height\n      // of the highest SD res.  There may be multiple audio bitrates for the\n      // same video resolution.\n      tracksByHeight.sort((a, b) => {\n        // The items in this list have already been screened for height, but the\n        // compiler doesn't know that.\n        goog.asserts.assert(a.height != null, 'Null height');\n        goog.asserts.assert(b.height != null, 'Null height');\n\n        return b.height - a.height;\n      });\n      selectedVariants = tracksByHeight.filter((track) => {\n        return track.height == tracksByHeight[0].height;\n      });\n    }\n\n    /** @type {!Array.<shaka.extern.Track>} */\n    const selectedTracks = [];\n\n    // If there are multiple matches at different audio bitrates, select the\n    // middle bandwidth one.\n    if (selectedVariants.length) {\n      const middleIndex = Math.floor(selectedVariants.length / 2);\n      selectedVariants.sort((a, b) => a.bandwidth - b.bandwidth);\n      selectedTracks.push(selectedVariants[middleIndex]);\n    }\n\n    // Since this default callback is used primarily by our own demo app and by\n    // app developers who haven't thought about which tracks they want, we\n    // should select all text tracks, regardless of language.  This makes for a\n    // better demo for us, and does not rely on user preferences for the\n    // unconfigured app.\n    for (const track of tracks) {\n      if (track.type == ContentType.TEXT) {\n        selectedTracks.push(track);\n      }\n    }\n\n    return selectedTracks;\n  }\n};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.util.StateHistory');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\n\n\n/**\n * This class is used to track the time spent in arbitrary states. When told of\n * a state, it will assume that state was active until a new state is provided.\n * When provided with identical states back-to-back, the existing entry will be\n * updated.\n *\n * @final\n */\nshaka.util.StateHistory = class {\n  constructor() {\n    /**\n     * The state that we think is still the current change. It is \"open\" for\n     * updating.\n     *\n     * @private {?shaka.extern.StateChange}\n     */\n    this.open_ = null;\n\n    /**\n     * The stats that are \"closed\" for updating. The \"open\" state becomes closed\n     * once we move to a new state.\n     *\n     * @private {!Array.<shaka.extern.StateChange>}\n     */\n    this.closed_ = [];\n  }\n\n  /**\n   * @param {string} state\n   */\n  update(state) {\n    // |open_| will only be |null| when we first call |update|.\n    if (this.open_ == null) {\n      this.start_(state);\n    } else {\n      this.update_(state);\n    }\n  }\n\n  /**\n   * Go through all entries in the history and count how much time was spend in\n   * the given state.\n   *\n   * @param {string} state\n   * @return {number}\n   */\n  getTimeSpentIn(state) {\n    let sum = 0;\n\n    if (this.open_ && this.open_.state == state) {\n      sum += this.open_.duration;\n    }\n\n    for (const entry of this.closed_) {\n      sum += entry.state == state ? entry.duration : 0;\n    }\n\n    return sum;\n  }\n\n  /**\n   * Get a copy of each state change entry in the history. A copy of each entry\n   * is created to break the reference to the internal data.\n   *\n   * @return {!Array.<shaka.extern.StateChange>}\n   */\n  getCopy() {\n    const clone = (entry) => {\n      return {\n        timestamp: entry.timestamp,\n        state: entry.state,\n        duration: entry.duration,\n      };\n    };\n\n    const copy = [];\n    for (const entry of this.closed_) {\n      copy.push(clone(entry));\n    }\n    if (this.open_) {\n      copy.push(clone(this.open_));\n    }\n\n    return copy;\n  }\n\n  /**\n   * @param {string} state\n   * @private\n   */\n  start_(state) {\n    goog.asserts.assert(\n        this.open_ == null,\n        'There must be no open entry in order when we start');\n    shaka.log.v1('Changing Player state to', state);\n\n    this.open_ = {\n      timestamp: this.getNowInSeconds_(),\n      state: state,\n      duration: 0,\n    };\n  }\n\n  /**\n   * @param {string} state\n   * @private\n   */\n  update_(state) {\n    goog.asserts.assert(\n        this.open_,\n        'There must be an open entry in order to update it');\n\n    const currentTimeSeconds = this.getNowInSeconds_();\n\n    // Always update the duration so that it can always be as accurate as\n    // possible.\n    this.open_.duration = currentTimeSeconds - this.open_.timestamp;\n\n    // If the state has not changed, there is no need to add a new entry.\n    if (this.open_.state == state) {\n      return;\n    }\n\n    // We have changed states, so \"close\" the open state.\n    shaka.log.v1('Changing Player state to', state);\n    this.closed_.push(this.open_);\n    this.open_ = {\n      timestamp: currentTimeSeconds,\n      state: state,\n      duration: 0,\n    };\n  }\n\n  /**\n   * Get the system time in seconds.\n   *\n   * @return {number}\n   * @private\n   */\n  getNowInSeconds_() {\n    return Date.now() / 1000;\n  }\n};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.util.SwitchHistory');\n\n\n/**\n * This class is used to track changes in variant and text selections. This\n * class will make sure that redundant switches are not recorded in the history.\n *\n * @final\n */\nshaka.util.SwitchHistory = class {\n  constructor() {\n    /** @private {?shaka.extern.Variant} */\n    this.currentVariant_ = null;\n\n    /** @private {?shaka.extern.Stream} */\n    this.currentText_ = null;\n\n    /** @private {!Array.<shaka.extern.TrackChoice>} */\n    this.history_ = [];\n  }\n\n  /**\n   * Update the history to show that we are currently playing |newVariant|. If\n   * we are already playing |newVariant|, this update will be ignored.\n   *\n   * @param {shaka.extern.Variant} newVariant\n   * @param {boolean} fromAdaptation\n   */\n  updateCurrentVariant(newVariant, fromAdaptation) {\n    if (this.currentVariant_ == newVariant) {\n      return;\n    }\n\n    this.currentVariant_ = newVariant;\n    this.history_.push({\n      timestamp: this.getNowInSeconds_(),\n      id: newVariant.id,\n      type: 'variant',\n      fromAdaptation: fromAdaptation,\n      bandwidth: newVariant.bandwidth,\n    });\n  }\n\n  /**\n   * Update the history to show that we are currently playing |newText|. If we\n   * are already playing |newText|, this update will be ignored.\n   *\n   * @param {shaka.extern.Stream} newText\n   * @param {boolean} fromAdaptation\n   */\n  updateCurrentText(newText, fromAdaptation) {\n    if (this.currentText_ == newText) {\n      return;\n    }\n\n    this.currentText_ = newText;\n    this.history_.push({\n      timestamp: this.getNowInSeconds_(),\n      id: newText.id,\n      type: 'text',\n      fromAdaptation: fromAdaptation,\n      bandwidth: null,\n    });\n  }\n\n  /**\n   * Get a copy of the switch history. This will make sure to expose no internal\n   * references.\n   *\n   * @return {!Array.<shaka.extern.TrackChoice>}\n   */\n  getCopy() {\n    const copy = [];\n\n    for (const entry of this.history_) {\n      copy.push(this.clone_(entry));\n    }\n\n    return copy;\n  }\n\n  /**\n   * Get the system time in seconds.\n   *\n   * @return {number}\n   * @private\n   */\n  getNowInSeconds_() {\n    return Date.now() / 1000;\n  }\n\n  /**\n   * @param {shaka.extern.TrackChoice} entry\n   * @return {shaka.extern.TrackChoice}\n   * @private\n   */\n  clone_(entry) {\n    return {\n      timestamp: entry.timestamp,\n      id: entry.id,\n      type: entry.type,\n      fromAdaptation: entry.fromAdaptation,\n      bandwidth: entry.bandwidth,\n    };\n  }\n};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.util.Stats');\n\ngoog.require('shaka.util.StateHistory');\ngoog.require('shaka.util.SwitchHistory');\n\n\n/**\n * This class tracks all the various components (some optional) that are used to\n * populate |shaka.extern.Stats| which is passed to the app.\n *\n * @final\n */\nshaka.util.Stats = class {\n  constructor() {\n    /** @private {number} */\n    this.width_ = NaN;\n    /** @private {number} */\n    this.height_ = NaN;\n\n    /** @private {number} */\n    this.totalDroppedFrames_ = NaN;\n    /** @private {number} */\n    this.totalDecodedFrames_ = NaN;\n    /** @private {number} */\n    this.totalCorruptedFrames_ = NaN;\n\n    /** @private {number} */\n    this.loadLatencySeconds_ = NaN;\n\n    /** @private {number} */\n    this.manifestTimeSeconds_ = NaN;\n\n    /** @private {number} */\n    this.drmTimeSeconds_ = NaN;\n\n    /** @private {number} */\n    this.licenseTimeSeconds_ = NaN;\n\n    /** @private {number} */\n    this.liveLatencySeconds_ = NaN;\n\n    /** @private {number} */\n    this.maxSegmentDurationSeconds_ = NaN;\n\n    /** @private {number} */\n    this.currentStreamBandwidth_ = NaN;\n    /** @private {number} */\n    this.bandwidthEstimate_ = NaN;\n\n    /** @private {!shaka.util.StateHistory} */\n    this.stateHistory_ = new shaka.util.StateHistory();\n\n    /** @private {!shaka.util.SwitchHistory} */\n    this.switchHistory_ = new shaka.util.SwitchHistory();\n  }\n\n  /**\n   * Update the ratio of dropped frames to total frames. This will replace the\n   * previous values.\n   *\n   * @param {number} dropped\n   * @param {number} decoded\n   */\n  setDroppedFrames(dropped, decoded) {\n    this.totalDroppedFrames_ = dropped;\n    this.totalDecodedFrames_ = decoded;\n  }\n\n\n  /**\n   * Update corrupted frames. This will replace the previous values.\n   *\n   * @param {number} corrupted\n   */\n  setCorruptedFrames(corrupted) {\n    this.totalCorruptedFrames_ = corrupted;\n  }\n\n  /**\n   * Set the width and height of the video we are currently playing.\n   *\n   * @param {number} width\n   * @param {number} height\n   */\n  setResolution(width, height) {\n    this.width_ = width;\n    this.height_ = height;\n  }\n\n  /**\n   * Record the time it took between the user signalling \"I want to play this\"\n   * to \"I am now seeing this\".\n   *\n   * @param {number} seconds\n   */\n  setLoadLatency(seconds) {\n    this.loadLatencySeconds_ = seconds;\n  }\n\n  /**\n   * Record the time it took to download and parse the manifest.\n   *\n   * @param {number} seconds\n   */\n  setManifestTime(seconds) {\n    this.manifestTimeSeconds_ = seconds;\n  }\n\n  /**\n   * Record the time it took to download the first drm key.\n   *\n   * @param {number} seconds\n   */\n  setDrmTime(seconds) {\n    this.drmTimeSeconds_ = seconds;\n  }\n\n  /**\n   * Record the cumulative time spent on license requests during this session.\n   *\n   * @param {number} seconds\n   */\n  setLicenseTime(seconds) {\n    this.licenseTimeSeconds_ = seconds;\n  }\n\n  /**\n   * Record the latency in live streams.\n   *\n   * @param {number} seconds\n   */\n  setLiveLatency(seconds) {\n    this.liveLatencySeconds_ = seconds;\n  }\n\n  /**\n   * Record the presentation's max segment duration.\n   *\n   * @param {number} seconds\n   */\n  setMaxSegmentDuration(seconds) {\n    this.maxSegmentDurationSeconds_ = seconds;\n  }\n\n  /**\n   * @param {number} bandwidth\n   */\n  setCurrentStreamBandwidth(bandwidth) {\n    this.currentStreamBandwidth_ = bandwidth;\n  }\n\n  /**\n   * @param {number} bandwidth\n   */\n  setBandwidthEstimate(bandwidth) {\n    this.bandwidthEstimate_ = bandwidth;\n  }\n\n  /**\n   * @return {!shaka.util.StateHistory}\n   */\n  getStateHistory() {\n    return this.stateHistory_;\n  }\n\n  /**\n   * @return {!shaka.util.SwitchHistory}\n   */\n  getSwitchHistory() {\n    return this.switchHistory_;\n  }\n\n  /**\n   * Create a stats blob that we can pass up to the app. This blob will not\n   * reference any internal data.\n   *\n   * @return {shaka.extern.Stats}\n   */\n  getBlob() {\n    return {\n      width: this.width_,\n      height: this.height_,\n      streamBandwidth: this.currentStreamBandwidth_,\n      decodedFrames: this.totalDecodedFrames_,\n      droppedFrames: this.totalDroppedFrames_,\n      corruptedFrames: this.totalCorruptedFrames_,\n      estimatedBandwidth: this.bandwidthEstimate_,\n      loadLatency: this.loadLatencySeconds_,\n      manifestTimeSeconds: this.manifestTimeSeconds_,\n      drmTimeSeconds: this.drmTimeSeconds_,\n      playTime: this.stateHistory_.getTimeSpentIn('playing'),\n      pauseTime: this.stateHistory_.getTimeSpentIn('paused'),\n      bufferingTime: this.stateHistory_.getTimeSpentIn('buffering'),\n      licenseTime: this.licenseTimeSeconds_,\n      liveLatency: this.liveLatencySeconds_,\n      maxSegmentDuration: this.maxSegmentDurationSeconds_,\n      stateHistory: this.stateHistory_.getCopy(),\n      switchHistory: this.switchHistory_.getCopy(),\n    };\n  }\n\n  /**\n   * Create an empty stats blob. This resembles the stats when we are not\n   * playing any content.\n   *\n   * @return {shaka.extern.Stats}\n   */\n  static getEmptyBlob() {\n    return {\n      width: NaN,\n      height: NaN,\n      streamBandwidth: NaN,\n      decodedFrames: NaN,\n      droppedFrames: NaN,\n      corruptedFrames: NaN,\n      estimatedBandwidth: NaN,\n      loadLatency: NaN,\n      manifestTimeSeconds: NaN,\n      drmTimeSeconds: NaN,\n      playTime: NaN,\n      pauseTime: NaN,\n      bufferingTime: NaN,\n      licenseTime: NaN,\n      liveLatency: NaN,\n      maxSegmentDuration: NaN,\n      switchHistory: [],\n      stateHistory: [],\n    };\n  }\n};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.ads.AdsStats');\n\n\n/**\n * This class tracks all the various components (some optional) that are used to\n * populate |shaka.extern.AdsStats| which is passed to the app.\n *\n * @final\n */\nshaka.ads.AdsStats = class {\n  constructor() {\n    /** @private {!Array.<number>} */\n    this.loadTimes_ = [];\n    /** @private {number} */\n    this.started_ = 0;\n    /** @private {number} */\n    this.playedCompletely_ = 0;\n    /** @private {number} */\n    this.skipped_ = 0;\n  }\n\n  /**\n   * Record the time it took to get the final manifest.\n   *\n   * @param {number} seconds\n   */\n  addLoadTime(seconds) {\n    this.loadTimes_.push(seconds);\n  }\n\n  /**\n   * Increase the number of ads started by one.\n   */\n  incrementStarted() {\n    this.started_++;\n  }\n\n  /**\n   * Increase the number of ads played completely by one.\n   */\n  incrementPlayedCompletely() {\n    this.playedCompletely_++;\n  }\n\n  /**\n   * Increase the number of ads skipped by one.\n   */\n  incrementSkipped() {\n    this.skipped_++;\n  }\n\n  /**\n   * Create a stats blob that we can pass up to the app. This blob will not\n   * reference any internal data.\n   *\n   * @return {shaka.extern.AdsStats}\n   */\n  getBlob() {\n    return {\n      loadTimes: this.loadTimes_,\n      started: this.started_,\n      playedCompletely: this.playedCompletely_,\n      skipped: this.skipped_,\n    };\n  }\n};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n\ngoog.provide('shaka.ads.ClientSideAd');\n\ngoog.require('shaka.util.EventManager');\n\n\n/**\n * @implements {shaka.extern.IAd}\n * @export\n */\nshaka.ads.ClientSideAd = class {\n  /**\n   * @param {!google.ima.Ad} imaAd\n   * @param {!google.ima.AdsManager} imaAdManager\n   */\n  constructor(imaAd, imaAdManager) {\n    /** @private {google.ima.Ad} */\n    this.ad_ = imaAd;\n\n    /** @private {google.ima.AdsManager} */\n    this.manager_ = imaAdManager;\n\n    /** @private {boolean} */\n    this.isPaused_ = false;\n\n    /** @private {number} */\n    this.volume_ = this.manager_.getVolume();\n\n    /** @private {shaka.util.EventManager} */\n    this.eventManager_ = new shaka.util.EventManager();\n\n    this.eventManager_.listen(this.manager_,\n        google.ima.AdEvent.Type.PAUSED, () => {\n          this.isPaused_ = true;\n        });\n\n    this.eventManager_.listen(this.manager_,\n        google.ima.AdEvent.Type.RESUMED, () => {\n          this.isPaused_ = false;\n        });\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  getDuration() {\n    return this.ad_.getDuration();\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  getRemainingTime() {\n    return this.manager_.getRemainingTime();\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  isPaused() {\n    return this.isPaused_;\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  isSkippable() {\n    // IMA returns -1 for non-skippable ads. Any positive number is a genuine\n    // skip offset, meaning the ad is skippable.\n    return this.ad_.getSkipTimeOffset() >= 0;\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  getTimeUntilSkippable() {\n    const skipOffset = this.ad_.getSkipTimeOffset();\n    const canSkipIn = this.getRemainingTime() - skipOffset;\n    return Math.max(canSkipIn, 0);\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  canSkipNow() {\n    return this.manager_.getAdSkippableState();\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  skip() {\n    return this.manager_.skip();\n  }\n\n  /**\n   * @param {boolean} paused\n   */\n  setPaused(paused) {\n    this.isPaused_ = paused;\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  pause() {\n    return this.manager_.pause();\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  play() {\n    return this.manager_.resume();\n  }\n\n\n  /**\n   * @override\n   * @export\n   */\n  getVolume() {\n    return this.manager_.getVolume();\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  setVolume(volume) {\n    return this.manager_.setVolume(volume);\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  isMuted() {\n    return this.manager_.getVolume() == 0;\n  }\n\n\n  /**\n   * @override\n   * @export\n   */\n  resize(width, height) {\n    const viewMode = document.fullscreenElement ?\n        google.ima.ViewMode.FULLSCREEN : google.ima.ViewMode.NORMAL;\n    this.manager_.resize(width, height, viewMode);\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  setMuted(muted) {\n    // Emulate the \"mute\" functionality, where current, pre-mute\n    // volume is saved and can be restored on unmute.\n    if (muted) {\n      this.volume_ = this.getVolume();\n      this.setVolume(0);\n    } else {\n      this.setVolume(this.volume_);\n    }\n  }\n\n\n  /**\n   * @override\n   * @export\n   */\n  getSequenceLength() {\n    const podInfo = this.ad_.getAdPodInfo();\n    if (podInfo == null) {\n      // No pod, just one ad.\n      return 1;\n    }\n\n    return podInfo.getTotalAds();\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  getPositionInSequence() {\n    const podInfo = this.ad_.getAdPodInfo();\n    if (podInfo == null) {\n      // No pod, just one ad.\n      return 1;\n    }\n\n    return podInfo.getAdPosition();\n  }\n\n\n  /**\n   * @override\n   * @export\n   */\n  release() {\n    this.ad_ = null;\n    this.manager_ = null;\n  }\n};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview\n * @suppress {missingRequire} TODO(b/152540451): this shouldn't be needed\n */\n\ngoog.provide('shaka.ads.ClientSideAdManager');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.ads.ClientSideAd');\n\n\n/**\n * A class responsible for client-side ad interactions.\n */\nshaka.ads.ClientSideAdManager = class {\n  /**\n   * @param {HTMLElement} adContainer\n   * @param {HTMLMediaElement} video\n   * @param {string} locale\n   * @param {function(!shaka.util.FakeEvent)} onEvent\n   */\n  constructor(adContainer, video, locale, onEvent) {\n    /** @private {HTMLElement} */\n    this.adContainer_ = adContainer;\n\n    /** @private {HTMLMediaElement} */\n    this.video_ = video;\n\n    /** @private {number} */\n    this.requestAdsStartTime_ = NaN;\n\n    /** @private {function(!shaka.util.FakeEvent)} */\n    this.onEvent_ = onEvent;\n\n    /** @private {shaka.ads.ClientSideAd} */\n    this.ad_ = null;\n\n    /** @private {shaka.util.EventManager} */\n    this.eventManager_ = new shaka.util.EventManager();\n\n    google.ima.settings.setLocale(locale);\n\n    const adDisplayContainer = new google.ima.AdDisplayContainer(\n        this.adContainer_,\n        this.video_);\n\n    // TODO: IMA: Must be done as the result of a user action on mobile\n    adDisplayContainer.initialize();\n\n    // IMA: This instance should be re-used for the entire lifecycle of\n    // the page.\n    this.adsLoader_ = new google.ima.AdsLoader(adDisplayContainer);\n\n    this.adsLoader_.getSettings().setPlayerType('shaka-player');\n    this.adsLoader_.getSettings().setPlayerVersion(shaka.Player.version);\n\n    /** @private {google.ima.AdsManager} */\n    this.imaAdsManager_ = null;\n\n    this.eventManager_.listenOnce(this.adsLoader_,\n        google.ima.AdsManagerLoadedEvent.Type.ADS_MANAGER_LOADED, (e) => {\n          this.onAdsManagerLoaded_(\n              /** @type {!google.ima.AdsManagerLoadedEvent} */ (e));\n        });\n\n    this.eventManager_.listen(this.adsLoader_,\n        google.ima.AdEvent.Type.AD_ERROR, (e) => {\n          this.onAdError_( /** @type {!google.ima.AdErrorEvent} */ (e));\n        });\n\n    // Notify the SDK when the video has ended, so it can play post-roll ads.\n    this.video_.onended = () => {\n      this.adsLoader_.contentComplete();\n    };\n  }\n\n  /**\n   * @param {!google.ima.AdsRequest} imaRequest\n   */\n  requestAds(imaRequest) {\n    goog.asserts.assert(\n        imaRequest.adTagUrl || imaRequest.adsResponse,\n        'The ad tag needs to be set up before requesting ads, ' +\n          'or adsResponse must be filled.');\n    this.requestAdsStartTime_ = Date.now() / 1000;\n    this.adsLoader_.requestAds(imaRequest);\n  }\n\n  /**\n   * Stop all currently playing ads.\n   */\n  stop() {\n    // this.imaAdsManager_ might not be set yet... if, for example, an ad\n    // blocker prevented the ads from ever loading.\n    if (this.imaAdsManager_) {\n      this.imaAdsManager_.stop();\n    }\n    if (this.adContainer_) {\n      shaka.util.Dom.removeAllChildren(this.adContainer_);\n    }\n  }\n\n  /**\n   * @param {!google.ima.AdErrorEvent} e\n   * @private\n   */\n  onAdError_(e) {\n    shaka.log.warning(\n        'There was an ad error from the IMA SDK: ' + e.getError());\n    shaka.log.warning('Resuming playback.');\n    this.onAdComplete_(/* adEvent= */ null);\n    // Remove ad breaks from the timeline\n    this.onEvent_(\n        new shaka.util.FakeEvent(shaka.ads.AdManager.CUEPOINTS_CHANGED,\n            {'cuepoints': []}));\n  }\n\n\n  /**\n   * @param {!google.ima.AdsManagerLoadedEvent} e\n   * @private\n   */\n  onAdsManagerLoaded_(e) {\n    goog.asserts.assert(this.video_ != null, 'Video should not be null!');\n\n    const now = Date.now() / 1000;\n    const loadTime = now - this.requestAdsStartTime_;\n    this.onEvent_(\n        new shaka.util.FakeEvent(shaka.ads.AdManager.ADS_LOADED,\n            {'loadTime': loadTime}));\n\n    this.imaAdsManager_ = e.getAdsManager(this.video_);\n\n    this.onEvent_(new shaka.util.FakeEvent(\n        shaka.ads.AdManager.IMA_AD_MANAGER_LOADED,\n        {\n          'imaAdsManager': this.imaAdsManager_,\n        }));\n\n    const cuePointStarts = this.imaAdsManager_.getCuePoints();\n    if (cuePointStarts.length) {\n      /** @type {!Array.<!shaka.ads.CuePoint>} */\n      const cuePoints = [];\n      for (const start of cuePointStarts) {\n        const shakaCuePoint = new shaka.ads.CuePoint(start);\n        cuePoints.push(shakaCuePoint);\n      }\n\n      this.onEvent_(\n          new shaka.util.FakeEvent(shaka.ads.AdManager.CUEPOINTS_CHANGED,\n              {'cuepoints': cuePoints}));\n    }\n\n    this.addImaEventListeners_();\n\n    try {\n      const viewMode = document.fullscreenElement ?\n          google.ima.ViewMode.FULLSCREEN : google.ima.ViewMode.NORMAL;\n\n      this.imaAdsManager_.init(this.video_.offsetWidth,\n          this.video_.offsetHeight, viewMode);\n\n      // Wait on the 'loadeddata' event rather than the 'loadedmetadata' event\n      // because 'loadedmetadata' is sometimes called before the video resizes\n      // on some platforms (e.g. Safari).\n      this.eventManager_.listen(this.video_, 'loadeddata', () => {\n        const viewMode = document.fullscreenElement ?\n            google.ima.ViewMode.FULLSCREEN : google.ima.ViewMode.NORMAL;\n        this.imaAdsManager_.resize(this.video_.offsetWidth,\n            this.video_.offsetHeight, viewMode);\n      });\n\n      // Single video and overlay ads will start at this time\n      // TODO (ismena): Need a better inderstanding of what this does.\n      // The docs say it's called to 'start playing the ads,' but I haven't\n      // seen the ads actually play until requestAds() is called.\n      this.imaAdsManager_.start();\n    } catch (adError) {\n      // If there was a problem with the VAST response,\n      // we we won't be getting an ad. Hide ad UI if we showed it already\n      // and get back to the presentation.\n      this.onAdComplete_(/* adEvent= */ null);\n    }\n  }\n\n\n  /**\n   * @private\n   */\n  addImaEventListeners_() {\n    this.eventManager_.listen(this.imaAdsManager_,\n        google.ima.AdErrorEvent.Type.AD_ERROR, (error) => {\n          this.onAdError_(/** @type {!google.ima.AdErrorEvent} */ (error));\n        });\n\n    this.eventManager_.listen(this.imaAdsManager_,\n        google.ima.AdEvent.Type.CONTENT_PAUSE_REQUESTED, (e) => {\n          this.onAdStart_(/** @type {!google.ima.AdEvent} */ (e));\n        });\n\n    this.eventManager_.listen(this.imaAdsManager_,\n        google.ima.AdEvent.Type.STARTED, (e) => {\n          this.onAdStart_(/** @type {!google.ima.AdEvent} */ (e));\n        });\n\n    this.eventManager_.listen(this.imaAdsManager_,\n        google.ima.AdEvent.Type.FIRST_QUARTILE, (e) => {\n          this.onEvent_(\n              new shaka.util.FakeEvent(shaka.ads.AdManager.AD_FIRST_QUARTILE,\n                  {'originalEvent': e}));\n        });\n\n    this.eventManager_.listen(this.imaAdsManager_,\n        google.ima.AdEvent.Type.MIDPOINT, (e) => {\n          this.onEvent_(\n              new shaka.util.FakeEvent(shaka.ads.AdManager.AD_MIDPOINT,\n                  {'originalEvent': e}));\n        });\n\n    this.eventManager_.listen(this.imaAdsManager_,\n        google.ima.AdEvent.Type.THIRD_QUARTILE, (e) => {\n          this.onEvent_(\n              new shaka.util.FakeEvent(shaka.ads.AdManager.AD_THIRD_QUARTILE,\n                  {'originalEvent': e}));\n        });\n\n    this.eventManager_.listen(this.imaAdsManager_,\n        google.ima.AdEvent.Type.COMPLETE, (e) => {\n          this.onEvent_(\n              new shaka.util.FakeEvent(shaka.ads.AdManager.AD_COMPLETE,\n                  {'originalEvent': e}));\n        });\n\n    this.eventManager_.listen(this.imaAdsManager_,\n        google.ima.AdEvent.Type.CONTENT_RESUME_REQUESTED, (e) => {\n          this.onAdComplete_(/** @type {!google.ima.AdEvent} */ (e));\n        });\n\n    this.eventManager_.listen(this.imaAdsManager_,\n        google.ima.AdEvent.Type.ALL_ADS_COMPLETED, (e) => {\n          this.onAdComplete_(/** @type {!google.ima.AdEvent} */ (e));\n        });\n\n    this.eventManager_.listen(this.imaAdsManager_,\n        google.ima.AdEvent.Type.SKIPPED, (e) => {\n          this.onEvent_(\n              new shaka.util.FakeEvent(shaka.ads.AdManager.AD_SKIPPED,\n                  {'originalEvent': e}));\n        });\n\n    this.eventManager_.listen(this.imaAdsManager_,\n        google.ima.AdEvent.Type.VOLUME_CHANGED, (e) => {\n          this.onEvent_(\n              new shaka.util.FakeEvent(shaka.ads.AdManager.AD_VOLUME_CHANGED,\n                  {'originalEvent': e}));\n        });\n\n    this.eventManager_.listen(this.imaAdsManager_,\n        google.ima.AdEvent.Type.VOLUME_MUTED, (e) => {\n          this.onEvent_(\n              new shaka.util.FakeEvent(shaka.ads.AdManager.AD_MUTED,\n                  {'originalEvent': e}));\n        });\n\n    this.eventManager_.listen(this.imaAdsManager_,\n        google.ima.AdEvent.Type.PAUSED, (e) => {\n          goog.asserts.assert(this.ad_ != null, 'Ad should not be null!');\n          this.ad_.setPaused(true);\n          this.onEvent_(\n              new shaka.util.FakeEvent(shaka.ads.AdManager.AD_PAUSED,\n                  {'originalEvent': e}));\n        });\n\n    this.eventManager_.listen(this.imaAdsManager_,\n        google.ima.AdEvent.Type.RESUMED, (e) => {\n          goog.asserts.assert(this.ad_ != null, 'Ad should not be null!');\n          this.ad_.setPaused(false);\n          this.onEvent_(\n              new shaka.util.FakeEvent(shaka.ads.AdManager.AD_RESUMED,\n                  {'originalEvent': e}));\n        });\n\n    this.eventManager_.listen(this.imaAdsManager_,\n        google.ima.AdEvent.Type.SKIPPABLE_STATE_CHANGED, (e) => {\n          goog.asserts.assert(this.ad_ != null, 'Ad should not be null!');\n          this.onEvent_(new shaka.util.FakeEvent(\n              shaka.ads.AdManager.AD_SKIP_STATE_CHANGED,\n              {'originalEvent': e}));\n        });\n\n    this.eventManager_.listen(this.imaAdsManager_,\n        google.ima.AdEvent.Type.CLICK, (e) => {\n          this.onEvent_(new shaka.util.FakeEvent(\n              shaka.ads.AdManager.AD_CLICKED));\n        });\n\n    this.eventManager_.listen(this.imaAdsManager_,\n        google.ima.AdEvent.Type.AD_PROGRESS, (e) => {\n          this.onEvent_(new shaka.util.FakeEvent(\n              shaka.ads.AdManager.AD_PROGRESS,\n              {'originalEvent': e}));\n        });\n\n    this.eventManager_.listen(this.imaAdsManager_,\n        google.ima.AdEvent.Type.AD_BUFFERING, (e) => {\n          this.onEvent_(new shaka.util.FakeEvent(\n              shaka.ads.AdManager.AD_BUFFERING,\n              {'originalEvent': e}));\n        });\n\n    this.eventManager_.listen(this.imaAdsManager_,\n        google.ima.AdEvent.Type.IMPRESSION, (e) => {\n          this.onEvent_(new shaka.util.FakeEvent(\n              shaka.ads.AdManager.AD_IMPRESSION,\n              {'originalEvent': e}));\n        });\n\n    this.eventManager_.listen(this.imaAdsManager_,\n        google.ima.AdEvent.Type.DURATION_CHANGE, (e) => {\n          this.onEvent_(new shaka.util.FakeEvent(\n              shaka.ads.AdManager.AD_DURATION_CHANGED,\n              {'originalEvent': e}));\n        });\n\n    this.eventManager_.listen(this.imaAdsManager_,\n        google.ima.AdEvent.Type.USER_CLOSE, (e) => {\n          this.onEvent_(new shaka.util.FakeEvent(\n              shaka.ads.AdManager.AD_CLOSED,\n              {'originalEvent': e}));\n        });\n\n    this.eventManager_.listen(this.imaAdsManager_,\n        google.ima.AdEvent.Type.LOADED, (e) => {\n          this.onEvent_(new shaka.util.FakeEvent(\n              shaka.ads.AdManager.AD_LOADED,\n              {'originalEvent': e}));\n        });\n\n    this.eventManager_.listen(this.imaAdsManager_,\n        google.ima.AdEvent.Type.ALL_ADS_COMPLETED, (e) => {\n          this.onEvent_(new shaka.util.FakeEvent(\n              shaka.ads.AdManager.ALL_ADS_COMPLETED,\n              {'originalEvent': e}));\n        });\n\n    this.eventManager_.listen(this.imaAdsManager_,\n        google.ima.AdEvent.Type.LINEAR_CHANGED, (e) => {\n          this.onEvent_(new shaka.util.FakeEvent(\n              shaka.ads.AdManager.AD_LINEAR_CHANGED,\n              {'originalEvent': e}));\n        });\n\n    this.eventManager_.listen(this.imaAdsManager_,\n        google.ima.AdEvent.Type.AD_METADATA, (e) => {\n          this.onEvent_(new shaka.util.FakeEvent(\n              shaka.ads.AdManager.AD_METADATA,\n              {'originalEvent': e}));\n        });\n\n    this.eventManager_.listen(this.imaAdsManager_,\n        google.ima.AdEvent.Type.LOG, (e) => {\n          this.onEvent_(new shaka.util.FakeEvent(\n              shaka.ads.AdManager.AD_RECOVERABLE_ERROR,\n              {'originalEvent': e}));\n        });\n\n    this.eventManager_.listen(this.imaAdsManager_,\n        google.ima.AdEvent.Type.AD_BREAK_READY, (e) => {\n          this.onEvent_(new shaka.util.FakeEvent(\n              shaka.ads.AdManager.AD_BREAK_READY,\n              {'originalEvent': e}));\n        });\n\n    this.eventManager_.listen(this.imaAdsManager_,\n        google.ima.AdEvent.Type.INTERACTION, (e) => {\n          this.onEvent_(new shaka.util.FakeEvent(\n              shaka.ads.AdManager.AD_INTERACTION,\n              {'originalEvent': e}));\n        });\n  }\n\n  /**\n   * @param {!google.ima.AdEvent} e\n   * @private\n   */\n  onAdStart_(e) {\n    goog.asserts.assert(this.imaAdsManager_,\n        'Should have an ads manager at this point!');\n\n    const imaAd = e.getAd();\n    this.ad_ = new shaka.ads.ClientSideAd(imaAd, this.imaAdsManager_);\n    this.onEvent_(new shaka.util.FakeEvent(shaka.ads.AdManager.AD_STARTED,\n        {\n          'ad': this.ad_,\n          'sdkAdObject': imaAd,\n          'originalEvent': e,\n        }));\n    this.adContainer_.setAttribute('ad-active', 'true');\n    this.video_.pause();\n  }\n\n  /**\n   * @param {?google.ima.AdEvent} e\n   * @private\n   */\n  onAdComplete_(e) {\n    this.onEvent_(new shaka.util.FakeEvent(shaka.ads.AdManager.AD_STOPPED,\n        {'originalEvent': e}));\n    this.adContainer_.removeAttribute('ad-active');\n    this.video_.play();\n  }\n};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n\ngoog.provide('shaka.ads.AdManager');\ngoog.provide('shaka.ads.CuePoint');\n\ngoog.require('shaka.Player');\ngoog.require('shaka.ads.AdsStats');\ngoog.require('shaka.ads.ClientSideAdManager');\ngoog.require('shaka.ads.ServerSideAdManager');\ngoog.require('shaka.log');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.FakeEvent');\ngoog.require('shaka.util.FakeEventTarget');\n\n\n/**\n * @event shaka.ads.AdManager.ADS_LOADED\n * @description Fired when an ad has started playing.\n * @property {string} type\n *   'ads-loaded'\n * @property {number} loadTime\n *    The time it takes to load ads.\n * @exportDoc\n */\n\n/**\n * @event shaka.ads.AdManager.AdStartedEvent\n * @description Fired when an ad has started playing.\n * @property {string} type\n *   'ad-started'\n * @property {!shaka.extern.IAd} ad\n *    The ad that has started playing.\n * @property {Object} sdkAdObject\n *    The ad object in the SDK format, if there is one.\n * @property {Object} originalEvent\n *    The native SDK event, if available.\n * @exportDoc\n */\n\n\n/**\n * @event shaka.ads.AdManager.AdCompleteEvent\n * @description Fired when an ad has played through.\n * @property {string} type\n *   'ad-complete'\n * @property {Object} originalEvent\n *    The native SDK event, if available.\n * @exportDoc\n */\n\n\n/**\n * @event shaka.ads.AdManager.AdSkippedEvent\n * @description Fired when an ad has been skipped.\n * @property {string} type\n *   'ad-skipped'\n * @property {Object} originalEvent\n *    The native SDK event, if available.\n * @exportDoc\n */\n\n\n/**\n * @event shaka.ads.AdManager.AdFirstQuartileEvent\n * @description Fired when an ad has played through the first 1/4.\n * @property {string} type\n *   'ad-first-quartile'\n * @property {Object} originalEvent\n *    The native SDK event, if available.\n * @exportDoc\n */\n\n\n/**\n * @event shaka.ads.AdManager.AdMidpointEvent\n * @description Fired when an ad has played through its midpoint.\n * @property {string} type\n *   'ad-midpoint'\n * @property {Object} originalEvent\n *    The native SDK event, if available.\n * @exportDoc\n */\n\n\n/**\n * @event shaka.ads.AdManager.AdThirdQuartileEvent\n * @description Fired when an ad has played through the third quartile.\n * @property {string} type\n *   'ad-third-quartile'\n * @property {Object} originalEvent\n *    The native SDK event, if available.\n * @exportDoc\n */\n\n\n/**\n * @event shaka.ads.AdManager.AdStoppedEvent\n * @description Fired when an ad has stopped playing, was skipped,\n *   or was unable to proceed due to an error.\n * @property {string} type\n *   'ad-stopped'\n * @property {Object} originalEvent\n *    The native SDK event, if available.\n * @exportDoc\n */\n\n\n/**\n * @event shaka.ads.AdManager.AdVolumeChangedEvent\n * @description Fired when an ad's volume changed.\n * @property {string} type\n *   'ad-volume-changed'\n * @property {Object} originalEvent\n *    The native SDK event, if available.\n * @exportDoc\n */\n\n\n/**\n * @event shaka.ads.AdManager.AdMutedEvent\n * @description Fired when an ad was muted.\n * @property {string} type\n *   'ad-muted'\n * @property {Object} originalEvent\n *    The native SDK event, if available.\n * @exportDoc\n */\n\n\n/**\n * @event shaka.ads.AdManager.AdPausedEvent\n * @description Fired when an ad was paused.\n * @property {string} type\n *   'ad-paused'\n * @property {Object} originalEvent\n *    The native SDK event, if available.\n * @exportDoc\n */\n\n\n/**\n * @event shaka.ads.AdManager.AdResumedEvent\n * @description Fired when an ad was resumed after a pause.\n * @property {string} type\n *   'ad-resumed'\n * @property {Object} originalEvent\n *    The native SDK event, if available.\n * @exportDoc\n */\n\n\n/**\n * @event shaka.ads.AdManager.AdSkipStateChangedEvent\n * @description Fired when an ad's skip state changes (for example, when\n *  it becomes possible to skip the ad).\n * @property {string} type\n *   'ad-skip-state-changed'\n * @property {Object} originalEvent\n *    The native SDK event, if available.\n * @exportDoc\n */\n\n\n/**\n * @event shaka.ads.AdManager.AdResumedEvent\n * @description Fired when the ad cue points change, signalling ad breaks\n *  change.\n * @property {string} type\n *   'ad-cue-points-changed'\n * @property {Object} originalEvent\n *    The native SDK event, if available.\n * @exportDoc\n */\n\n\n/**\n * @event shaka.ads.AdManager.AdProgressEvent\n * @description Fired when there is an update to the current ad's progress.\n * @property {string} type\n *   'ad-progress'\n * @property {Object} originalEvent\n *    The native SDK event, if available.\n * @exportDoc\n */\n\n\n/**\n * @event shaka.ads.AdManager.AdBufferingEvent\n * @description Fired when the ad has stalled playback to buffer.\n * @property {string} type\n *   'ad-buffering'\n * @property {Object} originalEvent\n *    The native SDK event, if available.\n * @exportDoc\n */\n\n\n/**\n * @event shaka.ads.AdManager.AdImpressionEvent\n * @description Fired when the impression URL has been pinged.\n * @property {string} type\n *   'ad-impression'\n * @property {Object} originalEvent\n *    The native SDK event, if available.\n * @exportDoc\n */\n\n\n/**\n * @event shaka.ads.AdManager.AdClickEvent\n * @description Fired when the ad was clicked.\n * @property {string} type\n *   'ad-clicked'\n * @property {Object} originalEvent\n *    The native SDK event, if available.\n * @exportDoc\n */\n\n\n/**\n * @event shaka.ads.AdManager.AdDurationChangedEvent\n * @description Fired when the ad's duration changes.\n * @property {string} type\n *   'ad-duration-changed'\n * @property {Object} originalEvent\n *    The native SDK event, if available.\n * @exportDoc\n */\n\n\n/**\n * @event shaka.ads.AdManager.AdClosedEvent\n * @description Fired when the ad was closed by the user.\n * @property {string} type\n *   'ad-closed'\n * @property {Object} originalEvent\n *    The native SDK event, if available.\n * @exportDoc\n */\n\n\n/**\n * @event shaka.ads.AdManager.AdLoadedEvent\n * @description Fired when the ad data becomes available.\n * @property {string} type\n *   'ad-loaded'\n * @property {Object} originalEvent\n *    The native SDK event, if available.\n * @exportDoc\n */\n\n\n/**\n * @event shaka.ads.AdManager.AllAdsCompletedEvent\n * @description Fired when the ads manager is done playing all the ads.\n * @property {string} type\n *   'all-ads-completed'\n * @property {Object} originalEvent\n *    The native SDK event, if available.\n * @exportDoc\n */\n\n\n/**\n * @event shaka.ads.AdManager.AdLinearChangedEvent\n * @description Fired when the displayed ad changes from\n *   linear to nonlinear, or vice versa.\n * @property {string} type\n *   'ad-linear-changed'\n * @property {Object} originalEvent\n *    The native SDK event, if available.\n * @exportDoc\n */\n\n\n/**\n * @event shaka.ads.AdManager.AdMetadataEvent\n * @description Fired when the ad's metadata becomes available.\n * @property {string} type\n *   'ad-metadata'\n * @property {Object} originalEvent\n *    The native SDK event, if available.\n * @exportDoc\n */\n\n\n/**\n * @event shaka.ads.AdManager.AdBreakReadyEvent\n * @description Fired when the client-side SDK is ready to play a\n *   VPAID ad or an ad rule.\n * @property {string} type\n *   'ad-break-ready'\n * @property {Object} originalEvent\n *    The native SDK event, if available.\n * @exportDoc\n */\n\n\n/**\n * @event shaka.ads.AdManager.AdRecoverableErrorEvent\n * @description Fired when the a non-fatal error was encountered.\n *   The presentation will continue with the same or next ad playback\n *   depending on the error situation.\n * @property {string} type\n *   'ad-recoverable-error'\n * @property {Object} originalEvent\n *    The native SDK event, if available.\n * @exportDoc\n */\n\n\n/**\n * @event shaka.ads.AdManager.AdInteractionEvent\n * @description Fired when an ad triggers the interaction callback.\n * @property {string} type\n *   'ad-interaction'\n * @property {Object} originalEvent\n *    The native SDK event, if available.\n * @exportDoc\n */\n\n\n/**\n * @event shaka.ads.AdManager.ImaAdManagerLoadedEvent\n * @description Fired when the native IMA ad manager becomes available.\n * @property {string} type\n *   'ima-ad-manager-loaded'\n * @exportDoc\n */\n\n\n/**\n * @event shaka.ads.AdManager.AdClickedEvent\n * @description Fired when the ad was clicked.\n * @property {string} type\n *   'ad-clicked'\n * @exportDoc\n */\n\n\n/**\n * A class responsible for ad-related interactions.\n * @implements {shaka.extern.IAdManager}\n * @export\n */\nshaka.ads.AdManager = class extends shaka.util.FakeEventTarget {\n  constructor() {\n    super();\n    /** @private {shaka.ads.ClientSideAdManager} */\n    this.csAdManager_ = null;\n    /** @private {shaka.ads.ServerSideAdManager} */\n    this.ssAdManager_ = null;\n    /** @private {shaka.ads.AdsStats} */\n    this.stats_ = new shaka.ads.AdsStats();\n    /** @private {string} locale */\n    this.locale_ = navigator.language;\n  }\n\n\n  /**\n   * @override\n   * @export\n   */\n  setLocale(locale) {\n    this.locale_ = locale;\n  }\n\n\n  /**\n   * @override\n   * @export\n   */\n  initClientSide(adContainer, video) {\n    // Check that Client Side IMA SDK has been included\n    // NOTE: (window['google'] && google.ima) check for any\n    // IMA SDK, including SDK for Server Side ads.\n    // The 3rd check insures we have the right SDK:\n    // {google.ima.AdsLoader} is an object that's part of CS IMA SDK\n    // but not SS SDK.\n    if (!window['google'] || !google.ima || !google.ima.AdsLoader) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.ADS,\n          shaka.util.Error.Code.CS_IMA_SDK_MISSING);\n    }\n\n    this.csAdManager_ = new shaka.ads.ClientSideAdManager(\n        adContainer, video, this.locale_,\n        (e) => {\n          const event = /** @type {!shaka.util.FakeEvent} */ (e);\n          if (event && event.type) {\n            switch (event.type) {\n              case shaka.ads.AdManager.ADS_LOADED: {\n                const loadTime = (/** @type {!Object} */ (e))['loadTime'];\n                this.stats_.addLoadTime(loadTime);\n                break;\n              }\n              case shaka.ads.AdManager.AD_STARTED:\n                this.stats_.incrementStarted();\n                break;\n              case shaka.ads.AdManager.AD_COMPLETE:\n                this.stats_.incrementPlayedCompletely();\n                break;\n              case shaka.ads.AdManager.AD_SKIPPED:\n                this.stats_.incrementSkipped();\n                break;\n            }\n          }\n          this.dispatchEvent(event);\n        });\n  }\n\n\n  /**\n  * @override\n  * @export\n  */\n  onAssetUnload() {\n    if (this.csAdManager_) {\n      this.csAdManager_.stop();\n    }\n\n    this.dispatchEvent(\n        new shaka.util.FakeEvent(shaka.ads.AdManager.AD_STOPPED));\n\n    // TODO:\n    // For SS DAI streams, if a different asset gets unloaded as\n    // part of the process\n    // of loading a DAI asset, stream manager state gets reset and we\n    // don't get any ad events.\n    // We need to figure out if it makes sense to stop the SS\n    // manager on unload, and, if it does, find\n    // a way to do it safely.\n    // if (this.ssAdManager_) {\n    //   this.ssAdManager_.stop();\n    // }\n    this.stats_ = new shaka.ads.AdsStats();\n  }\n\n\n  /**\n   * @override\n   * @export\n   */\n  requestClientSideAds(imaRequest) {\n    if (!this.csAdManager_) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.RECOVERABLE,\n          shaka.util.Error.Category.ADS,\n          shaka.util.Error.Code.CS_AD_MANAGER_NOT_INITIALIZED);\n    }\n\n    this.csAdManager_.requestAds(imaRequest);\n  }\n\n\n  /**\n   * @override\n   * @export\n   */\n  initServerSide(adContainer, video) {\n    // Check that Client Side IMA SDK has been included\n    // NOTE: (window['google'] && google.ima) check for any\n    // IMA SDK, including SDK for Server Side ads.\n    // The 3rd check insures we have the right SDK:\n    // {google.ima.dai} is an object that's part of DAI IMA SDK\n    // but not SS SDK.\n    if (!window['google'] || !google.ima || !google.ima.dai) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.ADS,\n          shaka.util.Error.Code.SS_IMA_SDK_MISSING);\n    }\n\n    this.ssAdManager_ = new shaka.ads.ServerSideAdManager(\n        adContainer, video, this.locale_,\n        (e) => {\n          const event = /** @type {!shaka.util.FakeEvent} */ (e);\n          if (event && event.type) {\n            switch (event.type) {\n              case shaka.ads.AdManager.ADS_LOADED: {\n                const loadTime = (/** @type {!Object} */ (e))['loadTime'];\n                this.stats_.addLoadTime(loadTime);\n                break;\n              }\n              case shaka.ads.AdManager.AD_STARTED:\n                this.stats_.incrementStarted();\n                break;\n              case shaka.ads.AdManager.AD_COMPLETE:\n                this.stats_.incrementPlayedCompletely();\n                break;\n              case shaka.ads.AdManager.AD_SKIPPED:\n                this.stats_.incrementSkipped();\n                break;\n            }\n          }\n          this.dispatchEvent(event);\n        });\n  }\n\n\n  /**\n   * @param {!google.ima.dai.api.StreamRequest} imaRequest\n   * @param {string=} backupUrl\n   * @return {!Promise.<string>}\n   * @override\n   * @export\n   */\n  requestServerSideStream(imaRequest, backupUrl = '') {\n    if (!this.ssAdManager_) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.RECOVERABLE,\n          shaka.util.Error.Category.ADS,\n          shaka.util.Error.Code.SS_AD_MANAGER_NOT_INITIALIZED);\n    }\n\n    if (!imaRequest.adTagParameters) {\n      imaRequest.adTagParameters = {};\n    }\n    const adTagParams = imaRequest.adTagParameters;\n\n    if (adTagParams['mpt'] || adTagParams['mpv']) {\n      shaka.log.alwaysWarn('You have attempted to set \"mpt\" and/or \"mpv\" ' +\n        'parameters of the ad tag. Please note that those parameters are ' +\n        'used for Shaka adoption tracking and will be overriden.');\n    }\n\n    // Set player and version parameters for tracking\n    imaRequest.adTagParameters['mpt'] = 'Shaka Player';\n    imaRequest.adTagParameters['mpv'] = shaka.Player.version;\n    return this.ssAdManager_.streamRequest(imaRequest, backupUrl);\n  }\n\n\n  /**\n   * @override\n   * @export\n   */\n  replaceServerSideAdTagParameters(adTagParameters) {\n    if (!this.ssAdManager_) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.RECOVERABLE,\n          shaka.util.Error.Category.ADS,\n          shaka.util.Error.Code.SS_AD_MANAGER_NOT_INITIALIZED);\n    }\n\n    if (adTagParameters['mpt'] || adTagParameters['mpv']) {\n      shaka.log.alwaysWarn('You have attempted to set \"mpt\" and/or \"mpv\" ' +\n        'parameters of the ad tag. Please note that those parameters are ' +\n        'used for Shaka adoption tracking and will be overriden.');\n    }\n\n    adTagParameters['mpt'] = 'Shaka Player';\n    adTagParameters['mpv'] = shaka.Player.version;\n\n    this.ssAdManager_.replaceAdTagParameters(adTagParameters);\n  }\n\n\n  /**\n   * @return {shaka.extern.AdsStats}\n   * @override\n   * @export\n   */\n  getStats() {\n    return this.stats_.getBlob();\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  onDashTimedMetadata(region) {\n    if (this.ssAdManager_ && region.schemeIdUri == 'urn:google:dai:2018') {\n      const type = region.schemeIdUri;\n      const data = region.eventElement ?\n          region.eventElement.getAttribute('messageData') : null;\n      const timestamp = region.startTime;\n      this.ssAdManager_.onTimedMetadata(type, data, timestamp);\n    }\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  onHlsTimedMetadata(metadata, timestamp) {\n    if (this.ssAdManager_) {\n      this.ssAdManager_.onTimedMetadata('ID3', metadata['data'], timestamp);\n    } else {\n      shaka.log.warning('ID3 metadata processing was called without ' +\n        'initializing server side ad logic. Ad-related metadata will ' +\n        'not take effect');\n    }\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  onCueMetadataChange(value) {\n    if (this.ssAdManager_) {\n      this.ssAdManager_.onCueMetadataChange(value);\n    } else {\n      shaka.log.warning('ID3 metadata processing was called without ' +\n        'initializing server side ad logic. Ad-related metadata will ' +\n        'not take effect');\n    }\n  }\n};\n\n\nshaka.ads.CuePoint = class {\n  /**\n   * @param {number} start\n   * @param {?number=} end\n   */\n  constructor(start, end = null) {\n    /** @public {number} */\n    this.start = start;\n    /** @public {?number} */\n    this.end = end;\n  }\n};\n\n/**\n * The event name for when a sequence of ads has been loaded.\n *\n * @const {string}\n * @export\n */\nshaka.ads.AdManager.ADS_LOADED = 'ads-loaded';\n\n/**\n * The event name for when an ad has started playing.\n *\n * @const {string}\n * @export\n */\nshaka.ads.AdManager.AD_STARTED = 'ad-started';\n\n\n/**\n * The event name for when an ad playhead crosses first quartile.\n *\n * @const {string}\n * @export\n */\nshaka.ads.AdManager.AD_FIRST_QUARTILE = 'ad-first-quartile';\n\n\n/**\n * The event name for when an ad playhead crosses midpoint.\n *\n * @const {string}\n * @export\n */\nshaka.ads.AdManager.AD_MIDPOINT = 'ad-midpoint';\n\n\n/**\n * The event name for when an ad playhead crosses third quartile.\n *\n * @const {string}\n * @export\n */\nshaka.ads.AdManager.AD_THIRD_QUARTILE = 'ad-third-quartile';\n\n\n/**\n * The event name for when an ad has completed playing.\n *\n * @const {string}\n * @export\n */\nshaka.ads.AdManager.AD_COMPLETE = 'ad-complete';\n\n\n/**\n * The event name for when an ad has finished playing\n * (played all the way through, was skipped, or was unable to proceed\n * due to an error).\n *\n * @const {string}\n * @export\n */\nshaka.ads.AdManager.AD_STOPPED = 'ad-stopped';\n\n\n/**\n * The event name for when an ad is skipped by the user..\n *\n * @const {string}\n * @export\n */\nshaka.ads.AdManager.AD_SKIPPED = 'ad-skipped';\n\n\n/**\n * The event name for when the ad volume has changed.\n *\n * @const {string}\n * @export\n */\nshaka.ads.AdManager.AD_VOLUME_CHANGED = 'ad-volume-changed';\n\n\n/**\n * The event name for when the ad was muted.\n *\n * @const {string}\n * @export\n */\nshaka.ads.AdManager.AD_MUTED = 'ad-muted';\n\n\n/**\n * The event name for when the ad was paused.\n *\n * @const {string}\n * @export\n */\nshaka.ads.AdManager.AD_PAUSED = 'ad-paused';\n\n\n/**\n * The event name for when the ad was resumed after a pause.\n *\n * @const {string}\n * @export\n */\nshaka.ads.AdManager.AD_RESUMED = 'ad-resumed';\n\n\n/**\n * The event name for when the ad's skip status changes\n * (usually it becomes skippable when it wasn't before).\n *\n * @const {string}\n * @export\n */\nshaka.ads.AdManager.AD_SKIP_STATE_CHANGED = 'ad-skip-state-changed';\n\n\n/**\n * The event name for when the ad's cue points (start/end markers)\n * have changed.\n *\n * @const {string}\n * @export\n */\nshaka.ads.AdManager.CUEPOINTS_CHANGED = 'ad-cue-points-changed';\n\n\n/**\n * The event name for when the native IMA ad manager object has\n * loaded and become available.\n *\n * @const {string}\n * @export\n */\nshaka.ads.AdManager.IMA_AD_MANAGER_LOADED = 'ima-ad-manager-loaded';\n\n\n/**\n * The event name for when the ad was clicked.\n *\n * @const {string}\n * @export\n */\nshaka.ads.AdManager.AD_CLICKED = 'ad-clicked';\n\n\n/**\n * The event name for when there is an update to the current ad's progress.\n *\n * @const {string}\n * @export\n */\nshaka.ads.AdManager.AD_PROGRESS = 'ad-progress';\n\n\n/**\n * The event name for when the ad is buffering.\n *\n * @const {string}\n * @export\n */\nshaka.ads.AdManager.AD_BUFFERING = 'ad-buffering';\n\n\n/**\n * The event name for when the ad's URL was hit.\n *\n * @const {string}\n * @export\n */\nshaka.ads.AdManager.AD_IMPRESSION = 'ad-impression';\n\n\n/**\n * The event name for when the ad's duration changed.\n *\n * @const {string}\n * @export\n */\nshaka.ads.AdManager.AD_DURATION_CHANGED = 'ad-duration-changed';\n\n\n/**\n * The event name for when the ad was closed by the user.\n *\n * @const {string}\n * @export\n */\nshaka.ads.AdManager.AD_CLOSED = 'ad-closed';\n\n\n/**\n * The event name for when the ad data becomes available.\n *\n * @const {string}\n * @export\n */\nshaka.ads.AdManager.AD_LOADED = 'ad-loaded';\n\n\n/**\n * The event name for when all the ads were completed.\n *\n * @const {string}\n * @export\n */\nshaka.ads.AdManager.ALL_ADS_COMPLETED = 'all-ads-completed';\n\n\n/**\n * The event name for when the ad changes from or to linear.\n *\n * @const {string}\n * @export\n */\nshaka.ads.AdManager.AD_LINEAR_CHANGED = 'ad-linear-changed';\n\n\n/**\n * The event name for when the ad's metadata becomes available.\n *\n * @const {string}\n * @export\n */\nshaka.ads.AdManager.AD_METADATA = 'ad-metadata';\n\n\n/**\n * The event name for when the ad display encountered a recoverable\n * error.\n *\n * @const {string}\n * @export\n */\nshaka.ads.AdManager.AD_RECOVERABLE_ERROR = 'ad-recoverable-error';\n\n\n/**\n * The event name for when the client side SDK signalled its readiness\n * to play a VPAID ad or an ad rule.\n *\n * @const {string}\n * @export\n */\nshaka.ads.AdManager.AD_BREAK_READY = 'ad-break-ready';\n\n\n/**\n * The event name for when the interaction callback for the ad was\n * triggered.\n *\n * @const {string}\n * @export\n */\nshaka.ads.AdManager.AD_INTERACTION = 'ad-interaction';\n\n\n/**\n * Set this is a default ad manager for the player.\n * Apps can also set their own ad manager, if they'd like.\n */\nshaka.Player.setAdManagerFactory(() => new shaka.ads.AdManager());\n\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n\ngoog.provide('shaka.ads.ServerSideAd');\n\n/**\n * @implements {shaka.extern.IAd}\n * @export\n */\nshaka.ads.ServerSideAd = class {\n  /**\n   * @param {google.ima.dai.api.Ad} imaAd\n   * @param {HTMLMediaElement} video\n   */\n  constructor(imaAd, video) {\n    /** @private {google.ima.dai.api.Ad} */\n    this.ad_ = imaAd;\n\n    /** @private {?google.ima.dai.api.AdProgressData} */\n    this.adProgressData_ = null;\n\n    /** @private {HTMLMediaElement} */\n    this.video_ = video;\n  }\n\n\n  /**\n   * @param {google.ima.dai.api.AdProgressData} data\n   */\n  setProgressData(data) {\n    this.adProgressData_ = data;\n  }\n\n\n  /**\n   * @override\n   * @export\n   */\n  getDuration() {\n    if (!this.adProgressData_) {\n      // Unknown yet\n      return -1;\n    }\n    return this.adProgressData_.duration;\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  getRemainingTime() {\n    if (!this.adProgressData_) {\n      // Unknown yet\n      return -1;\n    }\n\n    return this.adProgressData_.duration - this.adProgressData_.currentTime;\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  isPaused() {\n    return this.video_.paused;\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  isSkippable() {\n    return this.ad_.isSkippable();\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  getTimeUntilSkippable() {\n    const skipOffset = this.ad_.getSkipTimeOffset();\n    const canSkipIn = this.getRemainingTime() - skipOffset;\n    return Math.max(canSkipIn, 0);\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  canSkipNow() {\n    return this.getTimeUntilSkippable() == 0;\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  skip() {\n    this.video_.currentTime += this.getRemainingTime();\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  pause() {\n    return this.video_.pause();\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  play() {\n    return this.video_.play();\n  }\n\n\n  /**\n   * @override\n   * @export\n   */\n  getVolume() {\n    return this.video_.volume;\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  setVolume(volume) {\n    this.video_.volume = volume;\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  isMuted() {\n    return this.video_.muted;\n  }\n\n\n  /**\n   * @override\n   * @export\n   */\n  resize(width, height) {\n    // Nothing\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  setMuted(muted) {\n    this.video_.muted = muted;\n  }\n\n\n  /**\n   * @override\n   * @export\n   */\n  getSequenceLength() {\n    const podInfo = this.ad_.getAdPodInfo();\n    if (podInfo == null) {\n      // No pod, just one ad.\n      return 1;\n    }\n\n    return podInfo.getTotalAds();\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  getPositionInSequence() {\n    const podInfo = this.ad_.getAdPodInfo();\n    if (podInfo == null) {\n      // No pod, just one ad.\n      return 1;\n    }\n\n    return podInfo.getAdPosition();\n  }\n\n\n  /**\n   * @override\n   * @export\n   */\n  release() {\n    this.ad_ = null;\n    this.adProgressData_ = null;\n    this.video_ = null;\n  }\n};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview\n * @suppress {missingRequire} TODO(b/152540451): this shouldn't be needed\n */\n\ngoog.provide('shaka.ads.ServerSideAdManager');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.ads.ServerSideAd');\ngoog.require('shaka.log');\n\n\n/**\n * A class responsible for server-side ad interactions.\n */\nshaka.ads.ServerSideAdManager = class {\n  /**\n   * @param {HTMLElement} adContainer\n   * @param {HTMLMediaElement} video\n   * @param {string} locale\n   * @param {function(!shaka.util.FakeEvent)} onEvent\n   */\n  constructor(adContainer, video, locale, onEvent) {\n    /** @private {HTMLElement} */\n    this.adContainer_ = adContainer;\n\n    /** @private {HTMLMediaElement} */\n    this.video_ = video;\n\n    /** @private\n        {?shaka.util.PublicPromise.<string>} */\n    this.streamPromise_ = null;\n\n    /** @private {number} */\n    this.streamRequestStartTime_ = NaN;\n\n    /** @private {function(!shaka.util.FakeEvent)} */\n    this.onEvent_ = onEvent;\n\n    /** @private {boolean} */\n    this.isLiveContent_ = false;\n\n    /**\n     * Time to seek to after an ad if that ad was played as the result of\n     * snapback.\n     * @private {?number}\n     */\n    this.snapForwardTime_ = null;\n\n    /** @private {shaka.ads.ServerSideAd} */\n    this.ad_ = null;\n\n    /** @private {?google.ima.dai.api.AdProgressData} */\n    this.adProgressData_ = null;\n\n    /** @private {string} */\n    this.backupUrl_ = '';\n\n    /** @private {shaka.util.EventManager} */\n    this.eventManager_ = new shaka.util.EventManager();\n\n    /** @private {google.ima.dai.api.UiSettings} */\n    const uiSettings = new google.ima.dai.api.UiSettings();\n    uiSettings.setLocale(locale);\n\n    /** @private {google.ima.dai.api.StreamManager} */\n    this.streamManager_ = new google.ima.dai.api.StreamManager(\n        this.video_, this.adContainer_, uiSettings);\n\n    // Events\n    this.eventManager_.listen(this.streamManager_,\n        google.ima.dai.api.StreamEvent.Type.LOADED, (e) => {\n          shaka.log.info('Ad SS Loaded');\n          this.onLoaded_(\n              /** @type {!google.ima.dai.api.StreamEvent} */ (e));\n        });\n\n    this.eventManager_.listen(this.streamManager_,\n        google.ima.dai.api.StreamEvent.Type.ERROR, () => {\n          shaka.log.info('Ad SS Error');\n          this.onError_();\n        });\n\n    this.eventManager_.listen(this.streamManager_,\n        google.ima.dai.api.StreamEvent.Type.AD_BREAK_STARTED, () => {\n          shaka.log.info('Ad Break Started');\n        });\n\n    this.eventManager_.listen(this.streamManager_,\n        google.ima.dai.api.StreamEvent.Type.STARTED, (e) => {\n          shaka.log.info('Ad Started');\n          this.onAdStart_(/** @type {!google.ima.dai.api.StreamEvent} */ (e));\n        });\n\n    this.eventManager_.listen(this.streamManager_,\n        google.ima.dai.api.StreamEvent.Type.AD_BREAK_ENDED, () => {\n          shaka.log.info('Ad Break Ended');\n          this.onAdBreakEnded_();\n        });\n\n    this.eventManager_.listen(this.streamManager_,\n        google.ima.dai.api.StreamEvent.Type.AD_PROGRESS, (e) => {\n          this.onAdProgress_(\n              /** @type {!google.ima.dai.api.StreamEvent} */ (e));\n        });\n\n    this.eventManager_.listen(this.streamManager_,\n        google.ima.dai.api.StreamEvent.Type.FIRST_QUARTILE, () => {\n          shaka.log.info('Ad event: First Quartile');\n          this.onEvent_(\n              new shaka.util.FakeEvent(shaka.ads.AdManager.AD_FIRST_QUARTILE));\n        });\n\n    this.eventManager_.listen(this.streamManager_,\n        google.ima.dai.api.StreamEvent.Type.MIDPOINT, () => {\n          shaka.log.info('Ad event: Midpoint');\n          this.onEvent_(\n              new shaka.util.FakeEvent(shaka.ads.AdManager.AD_MIDPOINT));\n        });\n\n    this.eventManager_.listen(this.streamManager_,\n        google.ima.dai.api.StreamEvent.Type.THIRD_QUARTILE, () => {\n          shaka.log.info('Ad event: Third Quartile');\n          this.onEvent_(\n              new shaka.util.FakeEvent(shaka.ads.AdManager.AD_THIRD_QUARTILE));\n        });\n\n    this.eventManager_.listen(this.streamManager_,\n        google.ima.dai.api.StreamEvent.Type.COMPLETE, () => {\n          shaka.log.info('Ad event: Complete');\n          this.onEvent_(\n              new shaka.util.FakeEvent(shaka.ads.AdManager.AD_COMPLETE));\n          this.onEvent_(\n              new shaka.util.FakeEvent(shaka.ads.AdManager.AD_STOPPED));\n          this.adContainer_.removeAttribute('ad-active');\n          this.ad_ = null;\n        });\n\n    this.eventManager_.listen(this.streamManager_,\n        google.ima.dai.api.StreamEvent.Type.SKIPPED, () => {\n          shaka.log.info('Ad event: Skipped');\n          this.onEvent_(\n              new shaka.util.FakeEvent(shaka.ads.AdManager.AD_SKIPPED));\n          this.onEvent_(\n              new shaka.util.FakeEvent(shaka.ads.AdManager.AD_STOPPED));\n        });\n\n    this.eventManager_.listen(this.streamManager_,\n        google.ima.dai.api.StreamEvent.Type.CUEPOINTS_CHANGED, (e) => {\n          shaka.log.info('Ad event: Cue points changed');\n          this.onCuePointsChanged_(\n              /** @type {!google.ima.dai.api.StreamEvent} */ (e));\n        });\n  }\n\n  /**\n   * @param {!google.ima.dai.api.StreamRequest} streamRequest\n   * @param {string=} backupUrl\n   * @return {!Promise.<string>}\n   */\n  streamRequest(streamRequest, backupUrl) {\n    if (this.streamPromise_) {\n      return Promise.reject(new shaka.util.Error(\n          shaka.util.Error.Severity.RECOVERABLE,\n          shaka.util.Error.Category.ADS,\n          shaka.util.Error.Code.CURRENT_DAI_REQUEST_NOT_FINISHED));\n    }\n    if (streamRequest instanceof google.ima.dai.api.LiveStreamRequest) {\n      this.isLiveContent_ = true;\n    }\n\n    this.streamPromise_ = new shaka.util.PublicPromise();\n    this.streamManager_.requestStream(streamRequest);\n    this.backupUrl_ = backupUrl || '';\n\n    this.streamRequestStartTime_ = Date.now() / 1000;\n\n    return this.streamPromise_;\n  }\n\n  /**\n   * @param {Object} adTagParameters\n   */\n  replaceAdTagParameters(adTagParameters) {\n    this.streamManager_.replaceAdTagParameters(adTagParameters);\n  }\n\n  /**\n   * Resets the stream manager and removes any continuous polling.\n   */\n  stop() {\n    this.streamManager_.reset();\n    this.backupUrl_ = '';\n    this.snapForwardTime_ = null;\n  }\n\n  /**\n   * @param {string} type\n   * @param {Uint8Array|string} data\n   *   Comes as string in DASH and as Uint8Array in HLS.\n   * @param {number} timestamp (in seconds)\n   */\n  onTimedMetadata(type, data, timestamp) {\n    this.streamManager_.processMetadata(type, data, timestamp);\n  }\n\n  /**\n   * @param {shaka.extern.ID3Metadata} value\n   */\n  onCueMetadataChange(value) {\n    // Native HLS over Safari/iOS/iPadOS\n    // For live event streams, the stream needs some way of informing the SDK\n    // that an ad break is coming up or ending. In the IMA DAI SDK, this is\n    // done through timed metadata. Timed metadata is carried as part of the\n    // DAI stream content and carries ad break timing information used by the\n    // SDK to track ad breaks.\n    if (value['key'] && value['data']) {\n      const metadata = {};\n      metadata[value['key']] = value['data'];\n      this.streamManager_.onTimedMetadata(metadata);\n    }\n  }\n\n  /**\n   * If a seek jumped over the ad break, return to the start of the\n   * ad break, then complete the seek after the ad played through.\n   * @private\n   */\n  checkForSnapback_() {\n    const currentTime = this.video_.currentTime;\n    if (currentTime == 0) {\n      return;\n    }\n\n    this.streamManager_.streamTimeForContentTime(currentTime);\n    const previousCuePoint =\n        this.streamManager_.previousCuePointForStreamTime(currentTime);\n    // The cue point gets marked as 'played' as soon as the playhead hits it\n    // (at the start of an ad), so when we come back to this method as a result\n    // of seeking back to the user-selected time, the 'played' flag will be set.\n    if (previousCuePoint && !previousCuePoint.played) {\n      shaka.log.info('Seeking back to the start of the ad break at ' +\n          previousCuePoint.start + ' and will return to ' + currentTime);\n      this.snapForwardTime_ = currentTime;\n      this.video_.currentTime = previousCuePoint.start;\n    }\n  }\n\n  /**\n   * @param {!google.ima.dai.api.StreamEvent} e\n   * @private\n   */\n  onAdStart_(e) {\n    goog.asserts.assert(this.streamManager_,\n        'Should have a stream manager at this point!');\n\n    const imaAd = e.getAd();\n    this.ad_ = new shaka.ads.ServerSideAd(imaAd, this.video_);\n\n    // Ad object and ad progress data come from two different IMA events.\n    // It's a race, and we don't know, which one will fire first - the\n    // event that contains an ad object (AD_STARTED) or the one that\n    // contains ad progress info (AD_PROGRESS).\n    // If the progress event fired first, we must've saved the progress\n    // info and can now add it to the ad object.\n    if (this.adProgressData_) {\n      this.ad_.setProgressData(this.adProgressData_);\n    }\n\n    this.onEvent_(new shaka.util.FakeEvent(shaka.ads.AdManager.AD_STARTED,\n        {'ad': this.ad_}));\n    this.adContainer_.setAttribute('ad-active', 'true');\n  }\n\n  /**\n   * @private\n   */\n  onAdBreakEnded_() {\n    this.adContainer_.removeAttribute('ad-active');\n    const currentTime = this.video_.currentTime;\n    // If the ad break was a result of snapping back (a user seeked over\n    // an ad break and was returned to it), seek forward to the point,\n    // originally chosen by the user.\n    if (this.snapForwardTime_ && this.snapForwardTime_ > currentTime) {\n      this.video_.currentTime = this.snapForwardTime_;\n      this.snapForwardTime_ = null;\n    }\n  }\n\n  /**\n   * @param {!google.ima.dai.api.StreamEvent} e\n   * @private\n   */\n  onLoaded_(e) {\n    const now = Date.now() / 1000;\n    const loadTime = now - this.streamRequestStartTime_;\n    this.onEvent_(\n        new shaka.util.FakeEvent(shaka.ads.AdManager.ADS_LOADED,\n            {'loadTime': loadTime}));\n\n    const streamData = e.getStreamData();\n    const url = streamData.url;\n    this.streamPromise_.resolve(url);\n    this.streamPromise_ = null;\n\n    if (!this.isLiveContent_) {\n      this.eventManager_.listen(this.video_, 'seeked', () => {\n        this.checkForSnapback_();\n      });\n    }\n  }\n\n  /**\n   * @private\n   */\n  onError_() {\n    if (!this.backupUrl_.length) {\n      this.streamPromise_.reject('IMA Stream request returned an error ' +\n          'and there was no backup asset uri provided.');\n      this.streamPromise_ = null;\n      return;\n    }\n\n    shaka.log.warning('IMA stream request returned an error. ' +\n        'Falling back to the backup asset uri.');\n    this.streamPromise_.resolve(this.backupUrl_);\n    this.streamPromise_ = null;\n  }\n\n\n  /**\n   * @param {!google.ima.dai.api.StreamEvent} e\n   * @private\n   */\n  onAdProgress_(e) {\n    const streamData = e.getStreamData();\n    const adProgressData = streamData.adProgressData;\n    this.adProgressData_ = adProgressData;\n    if (this.ad_) {\n      this.ad_.setProgressData(this.adProgressData_);\n    }\n  }\n\n\n  /**\n   * @param {!google.ima.dai.api.StreamEvent} e\n   * @private\n   */\n  onCuePointsChanged_(e) {\n    const streamData = e.getStreamData();\n\n    /** @type {!Array.<!shaka.ads.CuePoint>} */\n    const cuePoints = [];\n    for (const point of streamData.cuepoints) {\n      const shakaCuePoint = new shaka.ads.CuePoint(point.start, point.end);\n      cuePoints.push(shakaCuePoint);\n    }\n\n    this.onEvent_(\n        new shaka.util.FakeEvent(shaka.ads.AdManager.CUEPOINTS_CHANGED,\n            {'cuepoints': cuePoints}));\n  }\n};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.cast.CastUtils');\n\ngoog.require('shaka.media.TimeRangesUtils');\ngoog.require('shaka.util.FakeEvent');\n\n\n/**\n * @summary A set of cast utility functions and variables shared between sender\n *   and receiver.\n */\nshaka.cast.CastUtils = class {\n  /**\n   * Serialize as JSON, but specially encode things JSON will not otherwise\n   * represent.\n   * @param {?} thing\n   * @return {string}\n   */\n  static serialize(thing) {\n    return JSON.stringify(thing, (key, value) => {\n      if (typeof value == 'function') {\n        // Functions can't be (safely) serialized.\n        return undefined;\n      }\n\n      if (value instanceof Event || value instanceof shaka.util.FakeEvent) {\n        // Events don't serialize to JSON well because of the DOM objects\n        // and other complex objects they contain, so we strip these out.\n        // Note that using Object.keys or JSON.stringify directly on the event\n        // will not capture its properties.  We must use a for loop.\n        const simpleEvent = {};\n        for (const eventKey in value) {\n          const eventValue = value[eventKey];\n          if (eventValue && typeof eventValue == 'object') {\n            if (eventKey == 'detail') {\n              // Keep the detail value, because it contains important\n              // information for diagnosing errors.\n              simpleEvent[eventKey] = eventValue;\n            }\n            // Strip out non-null object types because they are complex and we\n            // don't need them.\n          } else if (eventKey in Event) {\n            // Strip out keys that are found on Event itself because they are\n            // class-level constants we don't need, like Event.MOUSEMOVE == 16.\n          } else {\n            simpleEvent[eventKey] = eventValue;\n          }\n        }\n        return simpleEvent;\n      }\n\n      if (value instanceof Error) {\n        // Errors don't serialize to JSON well, either.  TypeError, for example,\n        // turns in \"{}\", leading to messages like \"Error UNKNOWN.UNKNOWN\" when\n        // deserialized on the sender and displayed in the demo app.\n        return shaka.cast.CastUtils.unpackError_(value);\n      }\n\n      if (value instanceof TimeRanges) {\n        // TimeRanges must be unpacked into plain data for serialization.\n        return shaka.cast.CastUtils.unpackTimeRanges_(value);\n      }\n\n      if (value instanceof Uint8Array) {\n        // Some of our code cares about Uint8Arrays actually being Uint8Arrays,\n        // so this gives them special treatment.\n        return shaka.cast.CastUtils.unpackUint8Array_(value);\n      }\n\n      if (typeof value == 'number') {\n        // NaN and infinity cannot be represented directly in JSON.\n        if (isNaN(value)) {\n          return 'NaN';\n        }\n        if (isFinite(value)) {\n          return value;\n        }\n        if (value < 0) {\n          return '-Infinity';\n        }\n        return 'Infinity';\n      }\n\n      return value;\n    });\n  }\n\n\n  /**\n   * Deserialize JSON using our special encodings.\n   * @param {string} str\n   * @return {?}\n   */\n  static deserialize(str) {\n    return JSON.parse(str, (key, value) => {\n      if (value == 'NaN') {\n        return NaN;\n      } else if (value == '-Infinity') {\n        return -Infinity;\n      } else if (value == 'Infinity') {\n        return Infinity;\n      } else if (value && typeof value == 'object' &&\n                 value['__type__'] == 'TimeRanges') {\n        // TimeRanges objects have been unpacked and sent as plain data.\n        // Simulate the original TimeRanges object.\n        return shaka.cast.CastUtils.simulateTimeRanges_(value);\n      } else if (value && typeof value == 'object' &&\n                 value['__type__'] == 'Uint8Array') {\n        return shaka.cast.CastUtils.makeUint8Array_(value);\n      } else if (value && typeof value == 'object' &&\n                 value['__type__'] == 'Error') {\n        return shaka.cast.CastUtils.makeError_(value);\n      }\n      return value;\n    });\n  }\n\n\n  /**\n   * @param {!TimeRanges} ranges\n   * @return {!Object}\n   * @private\n   */\n  static unpackTimeRanges_(ranges) {\n    const obj = {\n      '__type__': 'TimeRanges',  // a signal to deserialize\n      'length': ranges.length,\n      'start': [],\n      'end': [],\n    };\n\n    const TimeRangesUtils = shaka.media.TimeRangesUtils;\n    for (const {start, end} of TimeRangesUtils.getBufferedInfo(ranges)) {\n      obj['start'].push(start);\n      obj['end'].push(end);\n    }\n\n    return obj;\n  }\n\n\n  /**\n   * Creates a simulated TimeRanges object from data sent by the cast receiver.\n   * @param {?} obj\n   * @return {{\n   *   length: number,\n   *   start: function(number): number,\n   *   end: function(number): number\n   * }}\n   * @private\n   */\n  static simulateTimeRanges_(obj) {\n    return {\n      length: obj.length,\n      // NOTE: a more complete simulation would throw when |i| was out of range,\n      // but for simplicity we will assume a well-behaved application that uses\n      // length instead of catch to stop iterating.\n      start: (i) => { return obj.start[i]; },\n      end: (i) => { return obj.end[i]; },\n    };\n  }\n\n\n  /**\n   * @param {!Uint8Array} array\n   * @return {!Object}\n   * @private\n   */\n  static unpackUint8Array_(array) {\n    return {\n      '__type__': 'Uint8Array',  // a signal to deserialize\n      'entries': Array.from(array),\n    };\n  }\n\n\n  /**\n   * Creates a Uint8Array object from data sent by the cast receiver.\n   * @param {?} obj\n   * @return {!Uint8Array}\n   * @private\n   */\n  static makeUint8Array_(obj) {\n    return new Uint8Array(/** @type {!Array.<number>} */ (obj['entries']));\n  }\n\n\n  /**\n   * @param {!Error} error\n   * @return {!Object}\n   * @private\n   */\n  static unpackError_(error) {\n    // None of the properties in TypeError are enumerable, but there are some\n    // common Error properties we expect.  We also enumerate any enumerable\n    // properties and \"own\" properties of the type, in case there is an Error\n    // subtype with additional properties we don't know about in advance.\n    const properties = new Set(['name', 'message', 'stack']);\n    for (const key in error) {\n      properties.add(key);\n    }\n    for (const key of Object.getOwnPropertyNames(error)) {\n      properties.add(key);\n    }\n\n    const contents = {};\n    for (const key of properties) {\n      contents[key] = error[key];\n    }\n\n    return {\n      '__type__': 'Error',  // a signal to deserialize\n      'contents': contents,\n    };\n  }\n\n\n  /**\n   * Creates an Error object from data sent by the cast receiver.\n   * @param {?} obj\n   * @return {!Error}\n   * @private\n   */\n  static makeError_(obj) {\n    const contents = obj['contents'];\n    const error = new Error(contents['message']);\n    for (const key in contents) {\n      error[key] = contents[key];\n    }\n    return error;\n  }\n};\n\n/**\n * HTMLMediaElement events that are proxied while casting.\n * @const {!Array.<string>}\n */\nshaka.cast.CastUtils.VideoEvents = [\n  'ended',\n  'play',\n  'playing',\n  'pause',\n  'pausing',\n  'ratechange',\n  'seeked',\n  'seeking',\n  'timeupdate',\n  'volumechange',\n];\n\n\n/**\n * HTMLMediaElement attributes that are proxied while casting.\n * @const {!Array.<string>}\n */\nshaka.cast.CastUtils.VideoAttributes = [\n  'buffered',\n  'currentTime',\n  'duration',\n  'ended',\n  'loop',\n  'muted',\n  'paused',\n  'playbackRate',\n  'seeking',\n  'videoHeight',\n  'videoWidth',\n  'volume',\n];\n\n\n/**\n * HTMLMediaElement attributes that are transferred when casting begins.\n * @const {!Array.<string>}\n */\nshaka.cast.CastUtils.VideoInitStateAttributes = [\n  'loop',\n  'playbackRate',\n];\n\n\n/**\n * HTMLMediaElement methods with no return value that are proxied while casting.\n * @const {!Array.<string>}\n */\nshaka.cast.CastUtils.VideoVoidMethods = [\n  'pause',\n  'play',\n];\n\n\n/**\n * Player getter methods that are proxied while casting.\n * The key is the method, the value is the frequency of updates.\n * Frequency 1 translates to every update; frequency 2 to every 2 updates, etc.\n * @const {!Object.<string, number>}\n */\nshaka.cast.CastUtils.PlayerGetterMethods = {\n  // NOTE: The 'drmInfo' property is not proxied, as it is very large.\n  'getAssetUri': 2,\n  'getAudioLanguages': 2,\n  'getAudioLanguagesAndRoles': 2,\n  'getBufferedInfo': 2,\n  // NOTE: The 'getSharedConfiguration' property is not proxied as it would\n  //       not be possible to share a reference.\n  'getConfiguration': 2,\n  'getExpiration': 2,\n  // NOTE: The 'getManifest' property is not proxied, as it is very large.\n  // NOTE: The 'getManifestParserFactory' property is not proxied, as it would\n  // not serialize.\n  'getPlaybackRate': 2,\n  'getTextLanguages': 2,\n  'getTextLanguagesAndRoles': 2,\n  'getTextTracks': 2,\n  'getStats': 5,\n  'getVariantTracks': 2,\n  'isAudioOnly': 10,\n  'isBuffering': 1,\n  'isInProgress': 1,\n  'isLive': 10,\n  'isTextTrackVisible': 1,\n  'keySystem': 10,\n  'seekRange': 1,\n  'getLoadMode': 10,\n};\n\n\n/**\n * Player getter methods that are proxied while casting, but only when casting\n * a livestream.\n * The key is the method, the value is the frequency of updates.\n * Frequency 1 translates to every update; frequency 2 to every 2 updates, etc.\n * @const {!Object.<string, number>}\n */\nshaka.cast.CastUtils.PlayerGetterMethodsThatRequireLive = {\n  'getPlayheadTimeAsDate': 1,\n  'getPresentationStartTimeAsDate': 20,\n};\n\n\n/**\n * Player getter and setter methods that are used to transfer state when casting\n * begins.\n * @const {!Array.<!Array.<string>>}\n */\nshaka.cast.CastUtils.PlayerInitState = [\n  ['getConfiguration', 'configure'],\n];\n\n\n/**\n * Player getter and setter methods that are used to transfer state after\n * load() is resolved.\n * @const {!Array.<!Array.<string>>}\n */\nshaka.cast.CastUtils.PlayerInitAfterLoadState = [\n  ['isTextTrackVisible', 'setTextTrackVisibility'],\n];\n\n\n/**\n * Player methods with no return value that are proxied while casting.\n * @const {!Array.<string>}\n */\nshaka.cast.CastUtils.PlayerVoidMethods = [\n  'addTextTrack',\n  'cancelTrickPlay',\n  'configure',\n  'resetConfiguration',\n  'retryStreaming',\n  'selectAudioLanguage',\n  'selectTextLanguage',\n  'selectTextTrack',\n  'selectVariantTrack',\n  'selectVariantsByLabel',\n  'setTextTrackVisibility',\n  'trickPlay',\n];\n\n\n/**\n * Player methods returning a Promise that are proxied while casting.\n * @const {!Array.<string>}\n */\nshaka.cast.CastUtils.PlayerPromiseMethods = [\n  'attach',\n  'detach',\n  // The manifestFactory parameter of load is not supported.\n  'load',\n  'unload',\n];\n\n\n/**\n * @typedef {{\n *   video: Object,\n *   player: Object,\n *   manifest: ?string,\n *   startTime: ?number\n * }}\n * @property {Object} video\n *   Dictionary of video properties to be set.\n * @property {Object} player\n *   Dictionary of player setters to be called.\n * @property {?string} manifest\n *   The currently-selected manifest, if present.\n * @property {?number} startTime\n *   The playback start time, if currently playing.\n */\nshaka.cast.CastUtils.InitStateType;\n\n\n/**\n * The namespace for Shaka messages on the cast bus.\n * @const {string}\n */\nshaka.cast.CastUtils.SHAKA_MESSAGE_NAMESPACE = 'urn:x-cast:com.google.shaka.v2';\n\n\n/**\n * The namespace for generic messages on the cast bus.\n * @const {string}\n */\nshaka.cast.CastUtils.GENERIC_MESSAGE_NAMESPACE =\n    'urn:x-cast:com.google.cast.media';\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.cast.CastSender');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.cast.CastUtils');\ngoog.require('shaka.log');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.FakeEvent');\ngoog.require('shaka.util.IDestroyable');\ngoog.require('shaka.util.PublicPromise');\ngoog.require('shaka.util.Timer');\n\n\n/**\n * @implements {shaka.util.IDestroyable}\n */\nshaka.cast.CastSender = class {\n  /**\n   * @param {string} receiverAppId The ID of the cast receiver application.\n   * @param {function()} onStatusChanged A callback invoked when the cast status\n   *   changes.\n   * @param {function()} onFirstCastStateUpdate A callback invoked when an\n   *   \"update\" event has been received for the first time.\n   * @param {function(string, !shaka.util.FakeEvent)} onRemoteEvent A callback\n   *   invoked with target name and event when a remote event is received.\n   * @param {function()} onResumeLocal A callback invoked when the local player\n   *   should resume playback.  Called before the cached remote state is wiped.\n   * @param {function()} onInitStateRequired A callback to get local player's.\n   *   state.  Invoked when casting is initiated from Chrome's cast button.\n   */\n  constructor(receiverAppId, onStatusChanged, onFirstCastStateUpdate,\n      onRemoteEvent, onResumeLocal, onInitStateRequired) {\n    /** @private {string} */\n    this.receiverAppId_ = receiverAppId;\n\n    /** @private {shaka.util.Timer} */\n    this.statusChangeTimer_ = new shaka.util.Timer(onStatusChanged);\n\n    /** @private {?function()} */\n    this.onFirstCastStateUpdate_ = onFirstCastStateUpdate;\n\n    /** @private {boolean} */\n    this.hasJoinedExistingSession_ = false;\n\n    /** @private {?function(string, !shaka.util.FakeEvent)} */\n    this.onRemoteEvent_ = onRemoteEvent;\n\n    /** @private {?function()} */\n    this.onResumeLocal_ = onResumeLocal;\n\n    /** @private {?function()} */\n    this.onInitStateRequired_ = onInitStateRequired;\n\n    /** @private {boolean} */\n    this.apiReady_ = false;\n\n    /** @private {boolean} */\n    this.isCasting_ = false;\n\n    /** @private {string} */\n    this.receiverName_ = '';\n\n    /** @private {Object} */\n    this.appData_ = null;\n\n    /** @private {?function()} */\n    this.onConnectionStatusChangedBound_ =\n        () => this.onConnectionStatusChanged_();\n\n    /** @private {?function(string, string)} */\n    this.onMessageReceivedBound_ = (namespace, serialized) =>\n      this.onMessageReceived_(namespace, serialized);\n\n    /** @private {Object} */\n    this.cachedProperties_ = {\n      'video': {},\n      'player': {},\n    };\n\n    /** @private {number} */\n    this.nextAsyncCallId_ = 0;\n\n    /** @private {Object.<string, !shaka.util.PublicPromise>} */\n    this.asyncCallPromises_ = {};\n\n    /** @private {shaka.util.PublicPromise} */\n    this.castPromise_ = null;\n\n    shaka.cast.CastSender.instances_.add(this);\n  }\n\n\n  /** @override */\n  destroy() {\n    shaka.cast.CastSender.instances_.delete(this);\n\n    this.rejectAllPromises_();\n    if (shaka.cast.CastSender.session_) {\n      this.removeListeners_();\n      // Don't leave the session, so that this session can be re-used later if\n      // necessary.\n    }\n\n    if (this.statusChangeTimer_) {\n      this.statusChangeTimer_.stop();\n      this.statusChangeTimer_ = null;\n    }\n\n    this.onRemoteEvent_ = null;\n    this.onResumeLocal_ = null;\n    this.apiReady_ = false;\n    this.isCasting_ = false;\n    this.appData_ = null;\n    this.cachedProperties_ = null;\n    this.asyncCallPromises_ = null;\n    this.castPromise_ = null;\n    this.onConnectionStatusChangedBound_ = null;\n    this.onMessageReceivedBound_ = null;\n\n    return Promise.resolve();\n  }\n\n\n  /**\n   * @return {boolean} True if the cast API is available.\n   */\n  apiReady() {\n    return this.apiReady_;\n  }\n\n\n  /**\n   * @return {boolean} True if there are receivers.\n   */\n  hasReceivers() {\n    return shaka.cast.CastSender.hasReceivers_;\n  }\n\n\n  /**\n   * @return {boolean} True if we are currently casting.\n   */\n  isCasting() {\n    return this.isCasting_;\n  }\n\n\n  /**\n   * @return {string} The name of the Cast receiver device, if isCasting().\n   */\n  receiverName() {\n    return this.receiverName_;\n  }\n\n\n  /**\n   * @return {boolean} True if we have a cache of remote properties from the\n   *   receiver.\n   */\n  hasRemoteProperties() {\n    return Object.keys(this.cachedProperties_['video']).length != 0;\n  }\n\n\n  /** Initialize the Cast API. */\n  init() {\n    const CastSender = shaka.cast.CastSender;\n\n    // Check for the cast API and the receiver id.\n    if (!window.chrome || !chrome.cast || !chrome.cast.isAvailable ||\n        !this.receiverAppId_.length) {\n      // Return if either:\n      // 1) The API is not available on this platform or is not ready yet.\n      // 2) No cast receiver id has been provided.\n      // If the API becomes available before this instance dies, or the reveiver\n      // id changes, init() will be called again.\n      return;\n    }\n\n    // The API is now available.\n    this.apiReady_ = true;\n    this.statusChangeTimer_.tickNow();\n\n    // Use static versions of the API callbacks, since the ChromeCast API is\n    // static. If we used local versions, we might end up retaining references\n    // to destroyed players here.\n    const sessionRequest = new chrome.cast.SessionRequest(this.receiverAppId_);\n    const apiConfig = new chrome.cast.ApiConfig(sessionRequest,\n        (session) => CastSender.onExistingSessionJoined_(session),\n        (availability) => CastSender.onReceiverStatusChanged_(availability),\n        'origin_scoped');\n\n    // TODO: Have never seen this fail.  When would it and how should we react?\n    chrome.cast.initialize(apiConfig,\n        () => { shaka.log.debug('CastSender: init'); },\n        (error) => { shaka.log.error('CastSender: init error', error); });\n    if (shaka.cast.CastSender.hasReceivers_) {\n      // Fire a fake cast status change, to simulate the update that\n      // would be fired normally.\n      // This is after a brief delay, to give users a chance to add event\n      // listeners.\n      this.statusChangeTimer_.tickAfter(shaka.cast.CastSender.STATUS_DELAY);\n    }\n\n    const oldSession = shaka.cast.CastSender.session_;\n    if (oldSession && oldSession.status != chrome.cast.SessionStatus.STOPPED) {\n      // The old session still exists, so re-use it.\n      shaka.log.debug('CastSender: re-using existing connection');\n      this.onExistingSessionJoined_(oldSession);\n    } else {\n      // The session has been canceled in the meantime, so ignore it.\n      shaka.cast.CastSender.session_ = null;\n    }\n  }\n\n\n  /**\n   * Set application-specific data.\n   *\n   * @param {Object} appData Application-specific data to relay to the receiver.\n   */\n  setAppData(appData) {\n    this.appData_ = appData;\n    if (this.isCasting_) {\n      this.sendMessage_({\n        'type': 'appData',\n        'appData': this.appData_,\n      });\n    }\n  }\n\n\n  /**\n   * @param {shaka.cast.CastUtils.InitStateType} initState Video and player\n   *   state to be sent to the receiver.\n   * @return {!Promise} Resolved when connected to a receiver.  Rejected if the\n   *   connection fails or is canceled by the user.\n   */\n  async cast(initState) {\n    if (!this.apiReady_) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.RECOVERABLE,\n          shaka.util.Error.Category.CAST,\n          shaka.util.Error.Code.CAST_API_UNAVAILABLE);\n    }\n    if (!shaka.cast.CastSender.hasReceivers_) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.RECOVERABLE,\n          shaka.util.Error.Category.CAST,\n          shaka.util.Error.Code.NO_CAST_RECEIVERS);\n    }\n    if (this.isCasting_) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.RECOVERABLE,\n          shaka.util.Error.Category.CAST,\n          shaka.util.Error.Code.ALREADY_CASTING);\n    }\n\n    this.castPromise_ = new shaka.util.PublicPromise();\n    chrome.cast.requestSession(\n        (session) => this.onSessionInitiated_(initState, session),\n        (error) => this.onConnectionError_(error));\n    await this.castPromise_;\n  }\n\n\n  /**\n   * Shows user a cast dialog where they can choose to stop\n   * casting.  Relies on Chrome to perform disconnect if they do.\n   * Doesn't do anything if not connected.\n   */\n  showDisconnectDialog() {\n    if (!this.isCasting_) {\n      return;\n    }\n    const initState = this.onInitStateRequired_();\n\n    chrome.cast.requestSession(\n        (session) => this.onSessionInitiated_(initState, session),\n        (error) => this.onConnectionError_(error));\n  }\n\n\n  /**\n   * Forces the receiver app to shut down by disconnecting.  Does nothing if not\n   * connected.\n   */\n  forceDisconnect() {\n    if (!this.isCasting_) {\n      return;\n    }\n\n    this.rejectAllPromises_();\n\n    if (shaka.cast.CastSender.session_) {\n      this.removeListeners_();\n\n      // This can throw if we've already been disconnected somehow.\n      try {\n        shaka.cast.CastSender.session_.stop(() => {}, () => {});\n      } catch (error) {}\n\n      shaka.cast.CastSender.session_ = null;\n    }\n\n    // Update casting status.\n    this.onConnectionStatusChanged_();\n  }\n\n\n  /**\n   * Getter for properties of remote objects.\n   * @param {string} targetName\n   * @param {string} property\n   * @return {?}\n   */\n  get(targetName, property) {\n    goog.asserts.assert(targetName == 'video' || targetName == 'player',\n        'Unexpected target name');\n    const CastUtils = shaka.cast.CastUtils;\n    if (targetName == 'video') {\n      if (CastUtils.VideoVoidMethods.includes(property)) {\n        return (...args) => this.remoteCall_(targetName, property, ...args);\n      }\n    } else if (targetName == 'player') {\n      if (CastUtils.PlayerGetterMethodsThatRequireLive[property]) {\n        const isLive = this.get('player', 'isLive')();\n        goog.asserts.assert(isLive,\n            property + ' should be called on a live stream!');\n        // If the property shouldn't exist, return a fake function so that the\n        // user doesn't call an undefined function and get a second error.\n        if (!isLive) {\n          return () => undefined;\n        }\n      }\n      if (CastUtils.PlayerVoidMethods.includes(property)) {\n        return (...args) => this.remoteCall_(targetName, property, ...args);\n      }\n      if (CastUtils.PlayerPromiseMethods.includes(property)) {\n        return (...args) =>\n          this.remoteAsyncCall_(targetName, property, ...args);\n      }\n      if (CastUtils.PlayerGetterMethods[property]) {\n        return () => this.propertyGetter_(targetName, property);\n      }\n    }\n\n    return this.propertyGetter_(targetName, property);\n  }\n\n\n  /**\n   * Setter for properties of remote objects.\n   * @param {string} targetName\n   * @param {string} property\n   * @param {?} value\n   */\n  set(targetName, property, value) {\n    goog.asserts.assert(targetName == 'video' || targetName == 'player',\n        'Unexpected target name');\n\n    this.cachedProperties_[targetName][property] = value;\n    this.sendMessage_({\n      'type': 'set',\n      'targetName': targetName,\n      'property': property,\n      'value': value,\n    });\n  }\n\n\n  /**\n   * @param {shaka.cast.CastUtils.InitStateType} initState\n   * @param {chrome.cast.Session} session\n   * @private\n   */\n  onSessionInitiated_(initState, session) {\n    shaka.log.debug('CastSender: onSessionInitiated');\n    this.onSessionCreated_(session);\n\n    this.sendMessage_({\n      'type': 'init',\n      'initState': initState,\n      'appData': this.appData_,\n    });\n\n    this.castPromise_.resolve();\n  }\n\n\n  /**\n   * @param {chrome.cast.Error} error\n   * @private\n   */\n  onConnectionError_(error) {\n    // Default error code:\n    let code = shaka.util.Error.Code.UNEXPECTED_CAST_ERROR;\n\n    switch (error.code) {\n      case 'cancel':\n        code = shaka.util.Error.Code.CAST_CANCELED_BY_USER;\n        break;\n      case 'timeout':\n        code = shaka.util.Error.Code.CAST_CONNECTION_TIMED_OUT;\n        break;\n      case 'receiver_unavailable':\n        code = shaka.util.Error.Code.CAST_RECEIVER_APP_UNAVAILABLE;\n        break;\n    }\n\n    this.castPromise_.reject(new shaka.util.Error(\n        shaka.util.Error.Severity.CRITICAL,\n        shaka.util.Error.Category.CAST,\n        code,\n        error));\n  }\n\n\n  /**\n   * @param {string} targetName\n   * @param {string} property\n   * @return {?}\n   * @private\n   */\n  propertyGetter_(targetName, property) {\n    goog.asserts.assert(targetName == 'video' || targetName == 'player',\n        'Unexpected target name');\n    return this.cachedProperties_[targetName][property];\n  }\n\n\n  /**\n   * @param {string} targetName\n   * @param {string} methodName\n   * @param {...*} varArgs\n   * @private\n   */\n  remoteCall_(targetName, methodName, ...varArgs) {\n    goog.asserts.assert(targetName == 'video' || targetName == 'player',\n        'Unexpected target name');\n    this.sendMessage_({\n      'type': 'call',\n      'targetName': targetName,\n      'methodName': methodName,\n      'args': varArgs,\n    });\n  }\n\n\n  /**\n   * @param {string} targetName\n   * @param {string} methodName\n   * @param {...*} varArgs\n   * @return {!Promise}\n   * @private\n   */\n  remoteAsyncCall_(targetName, methodName, ...varArgs) {\n    goog.asserts.assert(targetName == 'video' || targetName == 'player',\n        'Unexpected target name');\n\n    const p = new shaka.util.PublicPromise();\n    const id = this.nextAsyncCallId_.toString();\n    this.nextAsyncCallId_++;\n    this.asyncCallPromises_[id] = p;\n\n    try {\n      this.sendMessage_({\n        'type': 'asyncCall',\n        'targetName': targetName,\n        'methodName': methodName,\n        'args': varArgs,\n        'id': id,\n      });\n    } catch (error) {\n      p.reject(error);\n    }\n    return p;\n  }\n\n\n  /**\n   * A static version of onExistingSessionJoined_, that calls that method for\n   * each known instance.\n   * @param {chrome.cast.Session} session\n   * @private\n   */\n  static onExistingSessionJoined_(session) {\n    for (const instance of shaka.cast.CastSender.instances_) {\n      instance.onExistingSessionJoined_(session);\n    }\n  }\n\n\n  /**\n   * @param {chrome.cast.Session} session\n   * @private\n   */\n  onExistingSessionJoined_(session) {\n    shaka.log.debug('CastSender: onExistingSessionJoined');\n\n    const initState = this.onInitStateRequired_();\n\n    this.castPromise_ = new shaka.util.PublicPromise();\n    this.hasJoinedExistingSession_ = true;\n\n    this.onSessionInitiated_(initState, session);\n  }\n\n\n  /**\n   * A static version of onReceiverStatusChanged_, that calls that method for\n   * each known instance.\n   * @param {string} availability\n   * @private\n   */\n  static onReceiverStatusChanged_(availability) {\n    for (const instance of shaka.cast.CastSender.instances_) {\n      instance.onReceiverStatusChanged_(availability);\n    }\n  }\n\n\n  /**\n   * @param {string} availability\n   * @private\n   */\n  onReceiverStatusChanged_(availability) {\n    // The cast API is telling us whether there are any cast receiver devices\n    // available.\n    shaka.log.debug('CastSender: receiver status', availability);\n    shaka.cast.CastSender.hasReceivers_ = availability == 'available';\n    this.statusChangeTimer_.tickNow();\n  }\n\n\n  /**\n   * @param {chrome.cast.Session} session\n   * @private\n   */\n  onSessionCreated_(session) {\n    shaka.cast.CastSender.session_ = session;\n    session.addUpdateListener(this.onConnectionStatusChangedBound_);\n    session.addMessageListener(shaka.cast.CastUtils.SHAKA_MESSAGE_NAMESPACE,\n        this.onMessageReceivedBound_);\n    this.onConnectionStatusChanged_();\n  }\n\n\n  /**\n   * @private\n   */\n  removeListeners_() {\n    const session = shaka.cast.CastSender.session_;\n    session.removeUpdateListener(this.onConnectionStatusChangedBound_);\n    session.removeMessageListener(shaka.cast.CastUtils.SHAKA_MESSAGE_NAMESPACE,\n        this.onMessageReceivedBound_);\n  }\n\n\n  /**\n   * @private\n   */\n  onConnectionStatusChanged_() {\n    const connected = shaka.cast.CastSender.session_ ?\n        shaka.cast.CastSender.session_.status == 'connected' :\n        false;\n    shaka.log.debug('CastSender: connection status', connected);\n    if (this.isCasting_ && !connected) {\n      // Tell CastProxy to transfer state back to local player.\n      this.onResumeLocal_();\n\n      // Clear whatever we have cached.\n      for (const targetName in this.cachedProperties_) {\n        this.cachedProperties_[targetName] = {};\n      }\n\n      this.rejectAllPromises_();\n    }\n\n    this.isCasting_ = connected;\n    this.receiverName_ = connected ?\n        shaka.cast.CastSender.session_.receiver.friendlyName :\n        '';\n    this.statusChangeTimer_.tickNow();\n  }\n\n\n  /**\n   * Reject any async call promises that are still pending.\n   * @private\n   */\n  rejectAllPromises_() {\n    for (const id in this.asyncCallPromises_) {\n      const p = this.asyncCallPromises_[id];\n      delete this.asyncCallPromises_[id];\n\n      // Reject pending async operations as if they were interrupted.\n      // At the moment, load() is the only async operation we are worried about.\n      p.reject(new shaka.util.Error(\n          shaka.util.Error.Severity.RECOVERABLE,\n          shaka.util.Error.Category.PLAYER,\n          shaka.util.Error.Code.LOAD_INTERRUPTED));\n    }\n  }\n\n\n  /**\n   * @param {string} namespace\n   * @param {string} serialized\n   * @private\n   */\n  onMessageReceived_(namespace, serialized) {\n    // Since this method is in the compiled library, make sure all messages\n    // passed in here were created with quoted property names.\n\n    const message = shaka.cast.CastUtils.deserialize(serialized);\n    shaka.log.v2('CastSender: message', message);\n\n    switch (message['type']) {\n      case 'event': {\n        const targetName = message['targetName'];\n        const event = message['event'];\n        const fakeEvent = new shaka.util.FakeEvent(event['type'], event);\n        this.onRemoteEvent_(targetName, fakeEvent);\n        break;\n      }\n      case 'update': {\n        const update = message['update'];\n        for (const targetName in update) {\n          const target = this.cachedProperties_[targetName] || {};\n          for (const property in update[targetName]) {\n            target[property] = update[targetName][property];\n          }\n        }\n        if (this.hasJoinedExistingSession_) {\n          this.onFirstCastStateUpdate_();\n          this.hasJoinedExistingSession_ = false;\n        }\n        break;\n      }\n      case 'asyncComplete': {\n        const id = message['id'];\n        const error = message['error'];\n        const p = this.asyncCallPromises_[id];\n        delete this.asyncCallPromises_[id];\n\n        goog.asserts.assert(p, 'Unexpected async id');\n        if (!p) {\n          break;\n        }\n\n        if (error) {\n          // This is a hacky way to reconstruct the serialized error.\n          const reconstructedError = new shaka.util.Error(\n              error.severity, error.category, error.code);\n          for (const k in error) {\n            (/** @type {Object} */(reconstructedError))[k] = error[k];\n          }\n          p.reject(reconstructedError);\n        } else {\n          p.resolve();\n        }\n        break;\n      }\n    }\n  }\n\n\n  /**\n   * @param {!Object} message\n   * @private\n   */\n  sendMessage_(message) {\n    // Since this method is in the compiled library, make sure all messages\n    // passed in here were created with quoted property names.\n\n    const serialized = shaka.cast.CastUtils.serialize(message);\n    const session = shaka.cast.CastSender.session_;\n\n    // NOTE: This takes an error callback that we have not seen fire.  We don't\n    // know if it would fire synchronously or asynchronously.  Until we know how\n    // it works, we just log from that callback.  But we _have_ seen\n    // sendMessage() throw synchronously, so we handle that.\n    try {\n      session.sendMessage(shaka.cast.CastUtils.SHAKA_MESSAGE_NAMESPACE,\n          serialized,\n          () => {},  // success callback\n          shaka.log.error);  // error callback\n    } catch (error) {\n      shaka.log.error('Cast session sendMessage threw', error);\n\n      // Translate the error\n      const shakaError = new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.CAST,\n          shaka.util.Error.Code.CAST_CONNECTION_TIMED_OUT,\n          error);\n\n      // Dispatch it through the Player proxy\n      const fakeEvent = new shaka.util.FakeEvent(\n          'error', {'detail': shakaError});\n      this.onRemoteEvent_('player', fakeEvent);\n\n      // Force this session to disconnect and transfer playback to the local\n      // device\n      this.forceDisconnect();\n\n      // Throw the translated error from this getter/setter/method to the UI/app\n      throw shakaError;\n    }\n  }\n};\n\n/** @type {number} */\nshaka.cast.CastSender.STATUS_DELAY = 0.02;\n\n/** @private {boolean} */\nshaka.cast.CastSender.hasReceivers_ = false;\n\n/** @private {chrome.cast.Session} */\nshaka.cast.CastSender.session_ = null;\n\n/**\n * A set of all living CastSender instances.  The constructor and destroy\n * methods will add and remove instances from this set.\n *\n * This is used to deal with delayed initialization of the Cast SDK.  When the\n * SDK becomes available, instances will be reinitialized.\n *\n * @private {!Set.<shaka.cast.CastSender>}\n */\nshaka.cast.CastSender.instances_ = new Set();\n\n/**\n * If the cast SDK is not available yet, it will invoke this callback once it\n * becomes available.\n *\n * @param {boolean} loaded\n * @private\n */\nshaka.cast.CastSender.onSdkLoaded_ = (loaded) => {\n  if (loaded) {\n    // Any living instances of CastSender should have their init methods called\n    // again now that the API is available.\n    for (const sender of shaka.cast.CastSender.instances_) {\n      sender.init();\n    }\n  }\n};\n\n// The cast SDK will invoke this global callback.  Since in our testing\n// environment, we load both uncompiled and compiled code, this global callback\n// in uncompiled mode can be overwritten by the same in compiled mode.  The two\n// versions will each have their own instances_ map.\n// Therefore we gave the callback a name that the CastSender tests could invoke\n// instead of using a global that could be overwritten.\nwindow.__onGCastApiAvailable = shaka.cast.CastSender.onSdkLoaded_;\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.cast.CastProxy');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.Player');\ngoog.require('shaka.cast.CastSender');\ngoog.require('shaka.cast.CastUtils');\ngoog.require('shaka.log');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.EventManager');\ngoog.require('shaka.util.FakeEvent');\ngoog.require('shaka.util.FakeEventTarget');\ngoog.require('shaka.util.IDestroyable');\n\n\n/**\n * @event shaka.cast.CastProxy.CastStatusChangedEvent\n * @description Fired when cast status changes.  The status change will be\n *   reflected in canCast() and isCasting().\n * @property {string} type\n *   'caststatuschanged'\n * @exportDoc\n */\n\n\n/**\n * @summary A proxy to switch between local and remote playback for Chromecast\n * in a way that is transparent to the app's controls.\n *\n * @implements {shaka.util.IDestroyable}\n * @export\n */\nshaka.cast.CastProxy = class extends shaka.util.FakeEventTarget {\n  /**\n   * @param {!HTMLMediaElement} video The local video element associated with\n   *   the local Player instance.\n   * @param {!shaka.Player} player A local Player instance.\n   * @param {string} receiverAppId The ID of the cast receiver application.\n   *   If blank, casting will not be available, but the proxy will still\n   *   function otherwise.\n   */\n  constructor(video, player, receiverAppId) {\n    super();\n\n    /** @private {HTMLMediaElement} */\n    this.localVideo_ = video;\n\n    /** @private {shaka.Player} */\n    this.localPlayer_ = player;\n\n    /** @private {Object} */\n    this.videoProxy_ = null;\n\n    /** @private {Object} */\n    this.playerProxy_ = null;\n\n    /** @private {shaka.util.FakeEventTarget} */\n    this.videoEventTarget_ = null;\n\n    /** @private {shaka.util.FakeEventTarget} */\n    this.playerEventTarget_ = null;\n\n    /** @private {shaka.util.EventManager} */\n    this.eventManager_ = null;\n\n    /** @private {string} */\n    this.receiverAppId_ = receiverAppId;\n\n    /** @private {!Map} */\n    this.compiledToExternNames_ = new Map();\n\n    /** @private {shaka.cast.CastSender} */\n    this.sender_ = new shaka.cast.CastSender(\n        receiverAppId,\n        () => this.onCastStatusChanged_(),\n        () => this.onFirstCastStateUpdate_(),\n        (targetName, event) => this.onRemoteEvent_(targetName, event),\n        () => this.onResumeLocal_(),\n        () => this.getInitState_());\n\n\n    this.init_();\n  }\n\n  /**\n   * Destroys the proxy and the underlying local Player.\n   *\n   * @param {boolean=} forceDisconnect If true, force the receiver app to shut\n   *   down by disconnecting.  Does nothing if not connected.\n   * @override\n   * @export\n   */\n  destroy(forceDisconnect) {\n    if (forceDisconnect) {\n      this.sender_.forceDisconnect();\n    }\n\n    if (this.eventManager_) {\n      this.eventManager_.release();\n      this.eventManager_ = null;\n    }\n\n    const waitFor = [];\n    if (this.localPlayer_) {\n      waitFor.push(this.localPlayer_.destroy());\n      this.localPlayer_ = null;\n    }\n\n    if (this.sender_) {\n      waitFor.push(this.sender_.destroy());\n      this.sender_ = null;\n    }\n\n    this.localVideo_ = null;\n    this.videoProxy_ = null;\n    this.playerProxy_ = null;\n\n    return Promise.all(waitFor);\n  }\n\n  /**\n   * Get a proxy for the video element that delegates to local and remote video\n   * elements as appropriate.\n   *\n   * @suppress {invalidCasts} to cast proxy Objects to unrelated types\n   * @return {!HTMLMediaElement}\n   * @export\n   */\n  getVideo() {\n    return /** @type {!HTMLMediaElement} */(this.videoProxy_);\n  }\n\n  /**\n   * Get a proxy for the Player that delegates to local and remote Player\n   * objects as appropriate.\n   *\n   * @suppress {invalidCasts} to cast proxy Objects to unrelated types\n   * @return {!shaka.Player}\n   * @export\n   */\n  getPlayer() {\n    return /** @type {!shaka.Player} */(this.playerProxy_);\n  }\n\n  /**\n   * @return {boolean} True if the cast API is available and there are\n   *   receivers.\n   * @export\n   */\n  canCast() {\n    return this.sender_.apiReady() && this.sender_.hasReceivers();\n  }\n\n  /**\n   * @return {boolean} True if we are currently casting.\n   * @export\n   */\n  isCasting() {\n    return this.sender_.isCasting();\n  }\n\n  /**\n   * @return {string} The name of the Cast receiver device, if isCasting().\n   * @export\n   */\n  receiverName() {\n    return this.sender_.receiverName();\n  }\n\n  /**\n   * @return {!Promise} Resolved when connected to a receiver.  Rejected if the\n   *   connection fails or is canceled by the user.\n   * @export\n   */\n  async cast() {\n    const initState = this.getInitState_();\n\n    // TODO: transfer manually-selected tracks?\n    // TODO: transfer side-loaded text tracks?\n\n    await this.sender_.cast(initState);\n    if (!this.localPlayer_) {\n      // We've already been destroyed.\n      return;\n    }\n\n    // Unload the local manifest when casting succeeds.\n    await this.localPlayer_.unload();\n  }\n\n  /**\n   * Set application-specific data.\n   *\n   * @param {Object} appData Application-specific data to relay to the receiver.\n   * @export\n   */\n  setAppData(appData) {\n    this.sender_.setAppData(appData);\n  }\n\n  /**\n   * Show a dialog where user can choose to disconnect from the cast connection.\n   * @export\n   */\n  suggestDisconnect() {\n    this.sender_.showDisconnectDialog();\n  }\n\n  /**\n   * Force the receiver app to shut down by disconnecting.\n   * @export\n   */\n  forceDisconnect() {\n    this.sender_.forceDisconnect();\n  }\n\n\n  /**\n   * @param {string} newAppId\n   * @export\n   */\n  async changeReceiverId(newAppId) {\n    if (newAppId == this.receiverAppId_) {\n      // Nothing to change\n      return;\n    }\n\n    this.receiverAppId_ = newAppId;\n\n    // Destroy the old sender\n    this.sender_.forceDisconnect();\n    await this.sender_.destroy();\n    this.sender_ = null;\n\n\n    // Create the new one\n    this.sender_ = new shaka.cast.CastSender(\n        newAppId,\n        () => this.onCastStatusChanged_(),\n        () => this.onFirstCastStateUpdate_(),\n        (targetName, event) => this.onRemoteEvent_(targetName, event),\n        () => this.onResumeLocal_(),\n        () => this.getInitState_());\n\n    this.sender_.init();\n  }\n\n  /**\n   * Initialize the Proxies and the Cast sender.\n   * @private\n   */\n  init_() {\n    this.sender_.init();\n\n    this.eventManager_ = new shaka.util.EventManager();\n\n    for (const name of shaka.cast.CastUtils.VideoEvents) {\n      this.eventManager_.listen(this.localVideo_, name,\n          (event) => this.videoProxyLocalEvent_(event));\n    }\n\n    for (const key in shaka.Player.EventName) {\n      const name = shaka.Player.EventName[key];\n      this.eventManager_.listen(this.localPlayer_, name,\n          (event) => this.playerProxyLocalEvent_(event));\n    }\n\n    // We would like to use Proxy here, but it is not supported on IE11 or\n    // Safari.\n    this.videoProxy_ = {};\n    for (const k in this.localVideo_) {\n      Object.defineProperty(this.videoProxy_, k, {\n        configurable: false,\n        enumerable: true,\n        get: () => this.videoProxyGet_(k),\n        set: (value) => this.videoProxySet_(k, value),\n      });\n    }\n\n    this.playerProxy_ = {};\n    this.iterateOverPlayerMethods_((name, method) => {\n      goog.asserts.assert(this.playerProxy_, 'Must have player proxy!');\n      Object.defineProperty(this.playerProxy_, name, {\n        configurable: false,\n        enumerable: true,\n        get: () => this.playerProxyGet_(name),\n      });\n    });\n\n    if (COMPILED) {\n      this.mapCompiledToUncompiledPlayerMethodNames_();\n    }\n\n    this.videoEventTarget_ = new shaka.util.FakeEventTarget();\n    this.videoEventTarget_.dispatchTarget =\n      /** @type {EventTarget} */(this.videoProxy_);\n\n    this.playerEventTarget_ = new shaka.util.FakeEventTarget();\n    this.playerEventTarget_.dispatchTarget =\n      /** @type {EventTarget} */(this.playerProxy_);\n  }\n\n\n  /**\n   * Maps compiled to uncompiled player names so we can figure out\n   * which method to call in compiled build, while casting.\n   * @private\n   */\n  mapCompiledToUncompiledPlayerMethodNames_() {\n    // In compiled mode, UI tries to access player methods\n    // by their internal renamed names, but the proxy object doesn't know about\n    // those.\n    // See https://github.com/google/shaka-player/issues/2130 for details.\n    const methodsToNames = new Map();\n    this.iterateOverPlayerMethods_((name, method) => {\n      if (methodsToNames.has(method)) {\n        // If two method names, point to the same method, add them to the\n        // map as aliases of each other.\n        const name2 = methodsToNames.get(method);\n        // Assumes that the compiled name is shorter\n        if (name.length < name2.length) {\n          this.compiledToExternNames_.set(name, name2);\n        } else {\n          this.compiledToExternNames_.set(name2, name);\n        }\n      } else {\n        methodsToNames.set(method, name);\n      }\n    });\n  }\n\n  /**\n   * Iterates over all of the methods of the player, including inherited methods\n   * from FakeEventTarget.\n   * @param {function(string, function())} operation\n   * @private\n   */\n  iterateOverPlayerMethods_(operation) {\n    goog.asserts.assert(this.localPlayer_, 'Must have player!');\n    const player = /** @type {!Object} */ (this.localPlayer_);\n    // Avoid accessing any over-written methods in the prototype chain.\n    const seenNames = new Set();\n\n    /**\n     * @param {string} name\n     * @return {boolean}\n     */\n    function shouldAddToTheMap(name) {\n      if (name == 'constructor') {\n        // Don't proxy the constructor.\n        return false;\n      }\n\n      const method = /** @type {Object} */(player)[name];\n      if (typeof method != 'function') {\n        // Don't proxy non-methods.\n        return false;\n      }\n\n      // Add if the map does not already have it\n      return !seenNames.has(name);\n    }\n\n    // First, look at the methods on the object itself, so this can properly\n    // proxy any methods not on the prototype (for example, in the mock player).\n    for (const key in player) {\n      if (shouldAddToTheMap(key)) {\n        seenNames.add(key);\n        operation(key, player[key]);\n      }\n    }\n\n    // The exact length of the prototype chain might vary; for resiliency, this\n    // will just look at the entire chain, rather than assuming a set length.\n    let proto = /** @type {!Object} */ (Object.getPrototypeOf(player));\n    const objProto = /** @type {!Object} */ (Object.getPrototypeOf({}));\n    while (proto && proto != objProto) { // Don't proxy Object methods.\n      for (const name of Object.getOwnPropertyNames(proto)) {\n        if (shouldAddToTheMap(name)) {\n          seenNames.add(name);\n          operation(name, (player)[name]);\n        }\n      }\n      proto = /** @type {!Object} */ (Object.getPrototypeOf(proto));\n    }\n  }\n\n  /**\n   * @return {shaka.cast.CastUtils.InitStateType} initState Video and player\n   *   state to be sent to the receiver.\n   * @private\n   */\n  getInitState_() {\n    const initState = {\n      'video': {},\n      'player': {},\n      'playerAfterLoad': {},\n      'manifest': this.localPlayer_.getAssetUri(),\n      'startTime': null,\n    };\n\n    // Pause local playback before capturing state.\n    this.localVideo_.pause();\n\n    for (const name of shaka.cast.CastUtils.VideoInitStateAttributes) {\n      initState['video'][name] = this.localVideo_[name];\n    }\n\n    // If the video is still playing, set the startTime.\n    // Has no effect if nothing is loaded.\n    if (!this.localVideo_.ended) {\n      initState['startTime'] = this.localVideo_.currentTime;\n    }\n\n    for (const pair of shaka.cast.CastUtils.PlayerInitState) {\n      const getter = pair[0];\n      const setter = pair[1];\n      const value = /** @type {Object} */(this.localPlayer_)[getter]();\n\n      initState['player'][setter] = value;\n    }\n\n    for (const pair of shaka.cast.CastUtils.PlayerInitAfterLoadState) {\n      const getter = pair[0];\n      const setter = pair[1];\n      const value = /** @type {Object} */(this.localPlayer_)[getter]();\n\n      initState['playerAfterLoad'][setter] = value;\n    }\n\n    return initState;\n  }\n\n  /**\n   * Dispatch an event to notify the app that the status has changed.\n   * @private\n   */\n  onCastStatusChanged_() {\n    const event = new shaka.util.FakeEvent('caststatuschanged');\n    this.dispatchEvent(event);\n  }\n\n  /**\n   * Dispatch a synthetic play or pause event to ensure that the app correctly\n   * knows that the player is playing, if joining an existing receiver.\n   * @private\n   */\n  onFirstCastStateUpdate_() {\n    const type = this.videoProxy_['paused'] ? 'pause' : 'play';\n    const fakeEvent = new shaka.util.FakeEvent(type);\n    this.videoEventTarget_.dispatchEvent(fakeEvent);\n  }\n\n  /**\n   * Transfer remote state back and resume local playback.\n   * @private\n   */\n  onResumeLocal_() {\n    // Transfer back the player state.\n    for (const pair of shaka.cast.CastUtils.PlayerInitState) {\n      const getter = pair[0];\n      const setter = pair[1];\n      const value = this.sender_.get('player', getter)();\n      /** @type {Object} */(this.localPlayer_)[setter](value);\n    }\n\n    // Get the most recent manifest URI and ended state.\n    const assetUri = this.sender_.get('player', 'getAssetUri')();\n    const ended = this.sender_.get('video', 'ended');\n\n    let manifestReady = Promise.resolve();\n    const autoplay = this.localVideo_.autoplay;\n\n    let startTime = null;\n\n    // If the video is still playing, set the startTime.\n    // Has no effect if nothing is loaded.\n    if (!ended) {\n      startTime = this.sender_.get('video', 'currentTime');\n    }\n\n    // Now load the manifest, if present.\n    if (assetUri) {\n      // Don't autoplay the content until we finish setting up initial state.\n      this.localVideo_.autoplay = false;\n      manifestReady = this.localPlayer_.load(assetUri, startTime);\n    }\n\n    // Get the video state into a temp variable since we will apply it async.\n    const videoState = {};\n    for (const name of shaka.cast.CastUtils.VideoInitStateAttributes) {\n      videoState[name] = this.sender_.get('video', name);\n    }\n\n    // Finally, take on video state and player's \"after load\" state.\n    manifestReady.then(() => {\n      if (!this.localVideo_) {\n        // We've already been destroyed.\n        return;\n      }\n\n      for (const name of shaka.cast.CastUtils.VideoInitStateAttributes) {\n        this.localVideo_[name] = videoState[name];\n      }\n\n      for (const pair of shaka.cast.CastUtils.PlayerInitAfterLoadState) {\n        const getter = pair[0];\n        const setter = pair[1];\n        const value = this.sender_.get('player', getter)();\n        /** @type {Object} */(this.localPlayer_)[setter](value);\n      }\n\n      // Restore the original autoplay setting.\n      this.localVideo_.autoplay = autoplay;\n      if (assetUri) {\n        // Resume playback with transferred state.\n        this.localVideo_.play();\n      }\n    }, (error) => {\n      // Pass any errors through to the app.\n      goog.asserts.assert(error instanceof shaka.util.Error,\n          'Wrong error type!');\n      const eventType = shaka.Player.EventName.Error;\n      const event = new shaka.util.FakeEvent(eventType, {'detail': error});\n      this.localPlayer_.dispatchEvent(event);\n    });\n  }\n\n  /**\n   * @param {string} name\n   * @return {?}\n   * @private\n   */\n  videoProxyGet_(name) {\n    if (name == 'addEventListener') {\n      return (type, listener, options) => {\n        return this.videoEventTarget_.addEventListener(type, listener, options);\n      };\n    }\n    if (name == 'removeEventListener') {\n      return (type, listener, options) => {\n        return this.videoEventTarget_.removeEventListener(\n            type, listener, options);\n      };\n    }\n\n    // If we are casting, but the first update has not come in yet, use local\n    // values, but not local methods.\n    if (this.sender_.isCasting() && !this.sender_.hasRemoteProperties()) {\n      const value = this.localVideo_[name];\n      if (typeof value != 'function') {\n        return value;\n      }\n    }\n\n    // Use local values and methods if we are not casting.\n    if (!this.sender_.isCasting()) {\n      let value = this.localVideo_[name];\n      if (typeof value == 'function') {\n        // eslint-disable-next-line no-restricted-syntax\n        value = value.bind(this.localVideo_);\n      }\n      return value;\n    }\n\n    return this.sender_.get('video', name);\n  }\n\n  /**\n   * @param {string} name\n   * @param {?} value\n   * @private\n   */\n  videoProxySet_(name, value) {\n    if (!this.sender_.isCasting()) {\n      this.localVideo_[name] = value;\n      return;\n    }\n\n    this.sender_.set('video', name, value);\n  }\n\n  /**\n   * @param {!Event} event\n   * @private\n   */\n  videoProxyLocalEvent_(event) {\n    if (this.sender_.isCasting()) {\n      // Ignore any unexpected local events while casting.  Events can still be\n      // fired by the local video and Player when we unload() after the Cast\n      // connection is complete.\n      return;\n    }\n\n    // Convert this real Event into a FakeEvent for dispatch from our\n    // FakeEventListener.\n    const fakeEvent = new shaka.util.FakeEvent(event.type, event);\n    this.videoEventTarget_.dispatchEvent(fakeEvent);\n  }\n\n  /**\n   * @param {string} name\n   * @return {?}\n   * @private\n   */\n  playerProxyGet_(name) {\n    // If name is a shortened compiled name, get the original version\n    // from our map.\n    if (this.compiledToExternNames_.has(name)) {\n      name = this.compiledToExternNames_.get(name);\n    }\n\n    if (name == 'addEventListener') {\n      return (type, listener, options) => {\n        return this.playerEventTarget_.addEventListener(\n            type, listener, options);\n      };\n    }\n    if (name == 'removeEventListener') {\n      return (type, listener, options) => {\n        return this.playerEventTarget_.removeEventListener(\n            type, listener, options);\n      };\n    }\n\n    if (name == 'getMediaElement') {\n      return () => this.videoProxy_;\n    }\n\n    if (name == 'getSharedConfiguration') {\n      shaka.log.warning(\n          'Can\\'t share configuration across a network. Returning copy.');\n      return this.sender_.get('player', 'getConfiguration');\n    }\n\n    if (name == 'getNetworkingEngine') {\n      // Always returns a local instance, in case you need to make a request.\n      // Issues a warning, in case you think you are making a remote request\n      // or affecting remote filters.\n      if (this.sender_.isCasting()) {\n        shaka.log.warning('NOTE: getNetworkingEngine() is always local!');\n      }\n      return () => this.localPlayer_.getNetworkingEngine();\n    }\n\n    if (name == 'getAdManager') {\n      // Always returns a local instance.\n      if (this.sender_.isCasting()) {\n        shaka.log.warning('NOTE: getAdManager() is always local!');\n      }\n      return () => this.localPlayer_.getAdManager();\n    }\n\n    if (name == 'setVideoContainer') {\n      // Always returns a local instance.\n      if (this.sender_.isCasting()) {\n        shaka.log.warning('NOTE: setVideoContainer() is always local!');\n      }\n      return (container) => this.localPlayer_.setVideoContainer(container);\n    }\n\n    if (this.sender_.isCasting()) {\n      // These methods are unavailable or otherwise stubbed during casting.\n      if (name == 'getManifest' || name == 'drmInfo') {\n        return () => {\n          shaka.log.alwaysWarn(name + '() does not work while casting!');\n          return null;\n        };\n      }\n\n      if (name == 'attach' || name == 'detach') {\n        return () => {\n          shaka.log.alwaysWarn(name + '() does not work while casting!');\n          return Promise.resolve();\n        };\n      }\n    }  // if (this.sender_.isCasting())\n\n    // If we are casting, but the first update has not come in yet, use local\n    // getters, but not local methods.\n    if (this.sender_.isCasting() && !this.sender_.hasRemoteProperties()) {\n      if (shaka.cast.CastUtils.PlayerGetterMethods[name]) {\n        const value = /** @type {Object} */(this.localPlayer_)[name];\n        goog.asserts.assert(typeof value == 'function',\n            'only methods on Player');\n        // eslint-disable-next-line no-restricted-syntax\n        return value.bind(this.localPlayer_);\n      }\n    }\n\n    // Use local getters and methods if we are not casting.\n    if (!this.sender_.isCasting()) {\n      const value = /** @type {Object} */(this.localPlayer_)[name];\n      goog.asserts.assert(typeof value == 'function',\n          'only methods on Player');\n      // eslint-disable-next-line no-restricted-syntax\n      return value.bind(this.localPlayer_);\n    }\n\n    return this.sender_.get('player', name);\n  }\n\n  /**\n   * @param {!Event} event\n   * @private\n   */\n  playerProxyLocalEvent_(event) {\n    if (this.sender_.isCasting()) {\n      // Ignore any unexpected local events while casting.\n      return;\n    }\n\n    this.playerEventTarget_.dispatchEvent(event);\n  }\n\n  /**\n   * @param {string} targetName\n   * @param {!shaka.util.FakeEvent} event\n   * @private\n   */\n  onRemoteEvent_(targetName, event) {\n    goog.asserts.assert(this.sender_.isCasting(),\n        'Should only receive remote events while casting');\n    if (!this.sender_.isCasting()) {\n      // Ignore any unexpected remote events.\n      return;\n    }\n\n    if (targetName == 'video') {\n      this.videoEventTarget_.dispatchEvent(event);\n    } else if (targetName == 'player') {\n      this.playerEventTarget_.dispatchEvent(event);\n    }\n  }\n};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.cast.CastReceiver');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.Player');\ngoog.require('shaka.cast.CastUtils');\ngoog.require('shaka.log');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.EventManager');\ngoog.require('shaka.util.FakeEvent');\ngoog.require('shaka.util.FakeEventTarget');\ngoog.require('shaka.util.IDestroyable');\ngoog.require('shaka.util.Platform');\ngoog.require('shaka.util.Timer');\n\n\n/**\n * A receiver to communicate between the Chromecast-hosted player and the\n * sender application.\n *\n * @implements {shaka.util.IDestroyable}\n * @export\n */\nshaka.cast.CastReceiver = class extends shaka.util.FakeEventTarget {\n  /**\n   * @param {!HTMLMediaElement} video The local video element associated with\n   *   the local Player instance.\n   * @param {!shaka.Player} player A local Player instance.\n   * @param {function(Object)=} appDataCallback A callback to handle\n   *   application-specific data passed from the sender.  This can come either\n   *   from a Shaka-based sender through CastProxy.setAppData, or from a\n   *   sender using the customData field of the LOAD message of the standard\n   *   Cast message namespace.  It can also be null if no such data is sent.\n   * @param {function(string):string=} contentIdCallback A callback to\n   *   retrieve manifest URI from the provided content id.\n   */\n  constructor(video, player, appDataCallback, contentIdCallback) {\n    super();\n\n    /** @private {HTMLMediaElement} */\n    this.video_ = video;\n\n    /** @private {shaka.Player} */\n    this.player_ = player;\n\n    /** @private {shaka.util.EventManager} */\n    this.eventManager_ = new shaka.util.EventManager();\n\n    /** @private {Object} */\n    this.targets_ = {\n      'video': video,\n      'player': player,\n    };\n\n    /** @private {?function(Object)} */\n    this.appDataCallback_ = appDataCallback || (() => {});\n\n    /** @private {?function(string):string} */\n    this.contentIdCallback_ = contentIdCallback ||\n                          /** @param {string} contentId\n                              @return {string} */\n                          ((contentId) => contentId);\n\n    /**\n     * A Cast metadata object, one of:\n     *  - https://developers.google.com/cast/docs/reference/messages#GenericMediaMetadata\n     *  - https://developers.google.com/cast/docs/reference/messages#MovieMediaMetadata\n     *  - https://developers.google.com/cast/docs/reference/messages#TvShowMediaMetadata\n     *  - https://developers.google.com/cast/docs/reference/messages#MusicTrackMediaMetadata\n     * @private {Object}\n     */\n    this.metadata_ = null;\n\n    /** @private {boolean} */\n    this.isConnected_ = false;\n\n    /** @private {boolean} */\n    this.isIdle_ = true;\n\n    /** @private {number} */\n    this.updateNumber_ = 0;\n\n    /** @private {boolean} */\n    this.startUpdatingUpdateNumber_ = false;\n\n    /** @private {boolean} */\n    this.initialStatusUpdatePending_ = true;\n\n    /** @private {cast.receiver.CastMessageBus} */\n    this.shakaBus_ = null;\n\n    /** @private {cast.receiver.CastMessageBus} */\n    this.genericBus_ = null;\n\n    /** @private {shaka.util.Timer} */\n    this.pollTimer_ = new shaka.util.Timer(() => {\n      this.pollAttributes_();\n    });\n\n    this.init_();\n  }\n\n  /**\n   * @return {boolean} True if the cast API is available and there are\n   *   receivers.\n   * @export\n   */\n  isConnected() {\n    return this.isConnected_;\n  }\n\n  /**\n   * @return {boolean} True if the receiver is not currently doing loading or\n   *   playing anything.\n   * @export\n   */\n  isIdle() {\n    return this.isIdle_;\n  }\n\n  /**\n   * Set all Cast content metadata, as defined by the Cast SDK.\n   * Should be called from an appDataCallback.\n   *\n   * For a simpler way to set basic metadata, see:\n   *  - setContentTitle()\n   *  - setContentImage()\n   *  - setContentArtist()\n   *\n   * @param {Object} metadata\n   *   A Cast metadata object, one of:\n   *    - https://developers.google.com/cast/docs/reference/messages#GenericMediaMetadata\n   *    - https://developers.google.com/cast/docs/reference/messages#MovieMediaMetadata\n   *    - https://developers.google.com/cast/docs/reference/messages#TvShowMediaMetadata\n   *    - https://developers.google.com/cast/docs/reference/messages#MusicTrackMediaMetadata\n   * @export\n   */\n  setContentMetadata(metadata) {\n    this.metadata_ = metadata;\n  }\n\n  /**\n   * Clear all Cast content metadata.\n   * Should be called from an appDataCallback.\n   *\n   * @export\n   */\n  clearContentMetadata() {\n    this.metadata_ = null;\n  }\n\n  /**\n   * Set the Cast content's title.\n   * Should be called from an appDataCallback.\n   *\n   * @param {string} title\n   * @export\n   */\n  setContentTitle(title) {\n    if (!this.metadata_) {\n      this.metadata_ = {\n        'metadataType': cast.receiver.media.MetadataType.GENERIC,\n      };\n    }\n    this.metadata_['title'] = title;\n  }\n\n  /**\n   * Set the Cast content's thumbnail image.\n   * Should be called from an appDataCallback.\n   *\n   * @param {string} imageUrl\n   * @export\n   */\n  setContentImage(imageUrl) {\n    if (!this.metadata_) {\n      this.metadata_ = {\n        'metadataType': cast.receiver.media.MetadataType.GENERIC,\n      };\n    }\n    this.metadata_['images'] = [\n      {\n        'url': imageUrl,\n      },\n    ];\n  }\n\n  /**\n   * Set the Cast content's artist.\n   * Also sets the metadata type to music.\n   * Should be called from an appDataCallback.\n   *\n   * @param {string} artist\n   * @export\n   */\n  setContentArtist(artist) {\n    if (!this.metadata_) {\n      this.metadata_ = {};\n    }\n    this.metadata_['artist'] = artist;\n    this.metadata_['metadataType'] =\n        cast.receiver.media.MetadataType.MUSIC_TRACK;\n  }\n\n  /**\n   * Destroys the underlying Player, then terminates the cast receiver app.\n   *\n   * @override\n   * @export\n   */\n  async destroy() {\n    if (this.eventManager_) {\n      this.eventManager_.release();\n      this.eventManager_ = null;\n    }\n\n    const waitFor = [];\n    if (this.player_) {\n      waitFor.push(this.player_.destroy());\n      this.player_ = null;\n    }\n\n    if (this.pollTimer_) {\n      this.pollTimer_.stop();\n      this.pollTimer_ = null;\n    }\n\n    this.video_ = null;\n    this.targets_ = null;\n    this.appDataCallback_ = null;\n    this.isConnected_ = false;\n    this.isIdle_ = true;\n    this.shakaBus_ = null;\n    this.genericBus_ = null;\n\n    await Promise.all(waitFor);\n\n    const manager = cast.receiver.CastReceiverManager.getInstance();\n    manager.stop();\n  }\n\n  /** @private */\n  init_() {\n    const manager = cast.receiver.CastReceiverManager.getInstance();\n    manager.onSenderConnected = () => this.onSendersChanged_();\n    manager.onSenderDisconnected = () => this.onSendersChanged_();\n    manager.onSystemVolumeChanged = () => this.fakeVolumeChangeEvent_();\n\n    this.genericBus_ = manager.getCastMessageBus(\n        shaka.cast.CastUtils.GENERIC_MESSAGE_NAMESPACE);\n    this.genericBus_.onMessage = (event) => this.onGenericMessage_(event);\n\n    this.shakaBus_ = manager.getCastMessageBus(\n        shaka.cast.CastUtils.SHAKA_MESSAGE_NAMESPACE);\n    this.shakaBus_.onMessage = (event) => this.onShakaMessage_(event);\n\n    if (goog.DEBUG) {\n      // Sometimes it is useful to load the receiver app in Chrome to work on\n      // the UI.  To avoid log spam caused by the SDK trying to connect to web\n      // sockets that don't exist, in uncompiled mode we check if the hosting\n      // browser is a Chromecast before starting the receiver manager.  We\n      // wouldn't do browser detection except for debugging, so only do this in\n      // uncompiled mode.\n      if (shaka.util.Platform.isChromecast()) {\n        manager.start();\n      }\n    } else {\n      manager.start();\n    }\n\n    for (const name of shaka.cast.CastUtils.VideoEvents) {\n      this.eventManager_.listen(\n          this.video_, name, (event) => this.proxyEvent_('video', event));\n    }\n\n    for (const key in shaka.Player.EventName) {\n      const name = shaka.Player.EventName[key];\n      this.eventManager_.listen(\n          this.player_, name, (event) => this.proxyEvent_('player', event));\n    }\n\n    // In our tests, the original Chromecast seems to have trouble decoding\n    // above 1080p.  It would be a waste to select a higher res anyway, given\n    // that the device only outputs 1080p to begin with.\n\n    // Chromecast has an extension to query the device/display's resolution.\n    if (cast.__platform__ && cast.__platform__.canDisplayType(\n        'video/mp4; codecs=\"avc1.640028\"; width=3840; height=2160')) {\n      // The device and display can both do 4k.  Assume a 4k limit.\n      this.player_.setMaxHardwareResolution(3840, 2160);\n    } else {\n      // Chromecast has always been able to do 1080p.  Assume a 1080p limit.\n      this.player_.setMaxHardwareResolution(1920, 1080);\n    }\n\n    // Do not start excluding values from update messages until the video is\n    // fully loaded.\n    this.eventManager_.listen(this.video_, 'loadeddata', () => {\n      this.startUpdatingUpdateNumber_ = true;\n    });\n\n    // Maintain idle state.\n    this.eventManager_.listen(this.player_, 'loading', () => {\n      // No longer idle once loading.  This allows us to show the spinner during\n      // the initial buffering phase.\n      this.isIdle_ = false;\n      this.onCastStatusChanged_();\n    });\n    this.eventManager_.listen(this.video_, 'playing', () => {\n      // No longer idle once playing.  This allows us to replay a video without\n      // reloading.\n      this.isIdle_ = false;\n      this.onCastStatusChanged_();\n    });\n    this.eventManager_.listen(this.video_, 'pause', () => {\n      this.onCastStatusChanged_();\n    });\n    this.eventManager_.listen(this.player_, 'unloading', () => {\n      // Go idle when unloading content.\n      this.isIdle_ = true;\n      this.onCastStatusChanged_();\n    });\n    this.eventManager_.listen(this.video_, 'ended', () => {\n      // Go idle 5 seconds after 'ended', assuming we haven't started again or\n      // been destroyed.\n      const timer = new shaka.util.Timer(() => {\n        if (this.video_ && this.video_.ended) {\n          this.isIdle_ = true;\n          this.onCastStatusChanged_();\n        }\n      });\n\n      timer.tickAfter(shaka.cast.CastReceiver.IDLE_INTERVAL);\n    });\n\n    // Do not start polling until after the sender's 'init' message is handled.\n  }\n\n  /** @private */\n  onSendersChanged_() {\n    // Reset update message frequency values, to make sure whomever joined\n    // will get a full update message.\n    this.updateNumber_ = 0;\n    // Don't reset startUpdatingUpdateNumber_, because this operation does not\n    // result in new data being loaded.\n    this.initialStatusUpdatePending_ = true;\n\n    const manager = cast.receiver.CastReceiverManager.getInstance();\n    this.isConnected_ = manager.getSenders().length != 0;\n    this.onCastStatusChanged_();\n  }\n\n  /**\n   * Dispatch an event to notify the receiver app that the status has changed.\n   * @private\n   */\n  async onCastStatusChanged_() {\n    // Do this asynchronously so that synchronous changes to idle state (such as\n    // Player calling unload() as part of load()) are coalesced before the event\n    // goes out.\n    await Promise.resolve();\n    if (!this.player_) {\n      // We've already been destroyed.\n      return;\n    }\n\n    const event = new shaka.util.FakeEvent('caststatuschanged');\n    this.dispatchEvent(event);\n    // Send a media status message, with a media info message if appropriate.\n    if (!this.maybeSendMediaInfoMessage_()) {\n      this.sendMediaStatus_();\n    }\n  }\n\n  /**\n   * Take on initial state from the sender.\n   * @param {shaka.cast.CastUtils.InitStateType} initState\n   * @param {Object} appData\n   * @private\n   */\n  async initState_(initState, appData) {\n    // Take on player state first.\n    for (const k in initState['player']) {\n      const v = initState['player'][k];\n      // All player state vars are setters to be called.\n      /** @type {Object} */(this.player_)[k](v);\n    }\n\n    // Now process custom app data, which may add additional player configs:\n    this.appDataCallback_(appData);\n\n    const autoplay = this.video_.autoplay;\n\n    // Now load the manifest, if present.\n    if (initState['manifest']) {\n      // Don't autoplay the content until we finish setting up initial state.\n      this.video_.autoplay = false;\n      try {\n        await this.player_.load(initState['manifest'], initState['startTime']);\n      } catch (error) {\n        // Pass any errors through to the app.\n        goog.asserts.assert(error instanceof shaka.util.Error,\n            'Wrong error type!');\n        const eventType = shaka.Player.EventName.Error;\n        const event = new shaka.util.FakeEvent(eventType, {'detail': error});\n        this.player_.dispatchEvent(event);\n        return;\n      }\n    } else {\n      // Ensure the below happens async.\n      await Promise.resolve();\n    }\n\n    if (!this.player_) {\n      // We've already been destroyed.\n      return;\n    }\n\n    // Finally, take on video state and player's \"after load\" state.\n    for (const k in initState['video']) {\n      const v = initState['video'][k];\n      this.video_[k] = v;\n    }\n\n    for (const k in initState['playerAfterLoad']) {\n      const v = initState['playerAfterLoad'][k];\n      // All player state vars are setters to be called.\n      /** @type {Object} */(this.player_)[k](v);\n    }\n\n    // Restore original autoplay setting.\n    this.video_.autoplay = autoplay;\n    if (initState['manifest']) {\n      // Resume playback with transferred state.\n      this.video_.play();\n      // Notify generic controllers of the state change.\n      this.sendMediaStatus_();\n    }\n  }\n\n  /**\n   * @param {string} targetName\n   * @param {!Event} event\n   * @private\n   */\n  proxyEvent_(targetName, event) {\n    if (!this.player_) {\n      // The receiver is destroyed, so it should ignore further events.\n      return;\n    }\n\n    // Poll and send an update right before we send the event.  Some events\n    // indicate an attribute change, so that change should be visible when the\n    // event is handled.\n    this.pollAttributes_();\n\n    this.sendMessage_({\n      'type': 'event',\n      'targetName': targetName,\n      'event': event,\n    }, this.shakaBus_);\n  }\n\n  /** @private */\n  pollAttributes_() {\n    // The poll timer may have been pre-empted by an event (e.g. timeupdate).\n    // Calling |start| will cancel any pending calls and therefore will avoid us\n    // polling too often.\n    this.pollTimer_.tickAfter(shaka.cast.CastReceiver.POLL_INTERVAL);\n\n    const update = {\n      'video': {},\n      'player': {},\n    };\n\n    for (const name of shaka.cast.CastUtils.VideoAttributes) {\n      update['video'][name] = this.video_[name];\n    }\n\n    // TODO: Instead of this variable frequency update system, instead cache the\n    // previous player state and only send over changed values, with complete\n    // updates every ~20 updates to account for dropped messages.\n\n    if (this.player_.isLive()) {\n      const PlayerGetterMethodsThatRequireLive =\n          shaka.cast.CastUtils.PlayerGetterMethodsThatRequireLive;\n      for (const name in PlayerGetterMethodsThatRequireLive) {\n        const frequency = PlayerGetterMethodsThatRequireLive[name];\n        if (this.updateNumber_ % frequency == 0) {\n          update['player'][name] = /** @type {Object} */ (this.player_)[name]();\n        }\n      }\n    }\n    for (const name in shaka.cast.CastUtils.PlayerGetterMethods) {\n      const frequency = shaka.cast.CastUtils.PlayerGetterMethods[name];\n      if (this.updateNumber_ % frequency == 0) {\n        update['player'][name] = /** @type {Object} */ (this.player_)[name]();\n      }\n    }\n\n    // Volume attributes are tied to the system volume.\n    const manager = cast.receiver.CastReceiverManager.getInstance();\n    const systemVolume = manager.getSystemVolume();\n    if (systemVolume) {\n      update['video']['volume'] = systemVolume.level;\n      update['video']['muted'] = systemVolume.muted;\n    }\n\n    // Only start progressing the update number once data is loaded,\n    // just in case any of the \"rarely changing\" properties with less frequent\n    // update messages changes significantly during the loading process.\n    if (this.startUpdatingUpdateNumber_) {\n      this.updateNumber_ += 1;\n    }\n\n    this.sendMessage_({\n      'type': 'update',\n      'update': update,\n    }, this.shakaBus_);\n\n    this.maybeSendMediaInfoMessage_();\n  }\n\n  /**\n   * Composes and sends a mediaStatus message if appropriate.\n   * @return {boolean}\n   * @private\n   */\n  maybeSendMediaInfoMessage_() {\n    if (this.initialStatusUpdatePending_ &&\n        (this.video_.duration || this.player_.isLive())) {\n      // Send over a media status message to set the duration of the cast\n      // dialogue.\n      this.sendMediaInfoMessage_();\n      this.initialStatusUpdatePending_ = false;\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Composes and sends a mediaStatus message with a mediaInfo component.\n   *\n   * @param {number=} requestId\n   * @private\n   */\n  sendMediaInfoMessage_(requestId = 0) {\n    const media = {\n      'contentId': this.player_.getAssetUri(),\n      'streamType': this.player_.isLive() ? 'LIVE' : 'BUFFERED',\n      // Sending an empty string for now since it's a mandatory field.\n      // We don't have this info, and it doesn't seem to be useful, anyway.\n      'contentType': '',\n    };\n    if (!this.player_.isLive()) {\n      // Optional, and only sent when the duration is known.\n      media['duration'] = this.video_.duration;\n    }\n    if (this.metadata_) {\n      media['metadata'] = this.metadata_;\n    }\n    this.sendMediaStatus_(requestId, media);\n  }\n\n  /**\n   * Dispatch a fake 'volumechange' event to mimic the video element, since\n   * volume changes are routed to the system volume on the receiver.\n   * @private\n   */\n  fakeVolumeChangeEvent_() {\n    // Volume attributes are tied to the system volume.\n    const manager = cast.receiver.CastReceiverManager.getInstance();\n    const systemVolume = manager.getSystemVolume();\n    goog.asserts.assert(systemVolume, 'System volume should not be null!');\n\n    if (systemVolume) {\n      // Send an update message with just the latest volume level and muted\n      // state.\n      this.sendMessage_({\n        'type': 'update',\n        'update': {\n          'video': {\n            'volume': systemVolume.level,\n            'muted': systemVolume.muted,\n          },\n        },\n      }, this.shakaBus_);\n    }\n\n    // Send another message with a 'volumechange' event to update the sender's\n    // UI.\n    this.sendMessage_({\n      'type': 'event',\n      'targetName': 'video',\n      'event': {'type': 'volumechange'},\n    }, this.shakaBus_);\n  }\n\n  /**\n   * Since this method is in the compiled library, make sure all messages are\n   * read with quoted properties.\n   * @param {!cast.receiver.CastMessageBus.Event} event\n   * @private\n   */\n  onShakaMessage_(event) {\n    const message = shaka.cast.CastUtils.deserialize(event.data);\n    shaka.log.debug('CastReceiver: message', message);\n\n    switch (message['type']) {\n      case 'init':\n        // Reset update message frequency values after initialization.\n        this.updateNumber_ = 0;\n        this.startUpdatingUpdateNumber_ = false;\n        this.initialStatusUpdatePending_ = true;\n\n        this.initState_(message['initState'], message['appData']);\n        // The sender is supposed to reflect the cast system volume after\n        // connecting.  Using fakeVolumeChangeEvent_() would create a race on\n        // the sender side, since it would have volume properties, but no\n        // others.\n        // This would lead to hasRemoteProperties() being true, even though a\n        // complete set had never been sent.\n        // Now that we have init state, this is a good time for the first update\n        // message anyway.\n        this.pollAttributes_();\n        break;\n      case 'appData':\n        this.appDataCallback_(message['appData']);\n        break;\n      case 'set': {\n        const targetName = message['targetName'];\n        const property = message['property'];\n        const value = message['value'];\n\n        if (targetName == 'video') {\n          // Volume attributes must be rerouted to the system.\n          const manager = cast.receiver.CastReceiverManager.getInstance();\n          if (property == 'volume') {\n            manager.setSystemVolumeLevel(value);\n            break;\n          } else if (property == 'muted') {\n            manager.setSystemVolumeMuted(value);\n            break;\n          }\n        }\n\n        this.targets_[targetName][property] = value;\n        break;\n      }\n      case 'call': {\n        const targetName = message['targetName'];\n        const methodName = message['methodName'];\n        const args = message['args'];\n        const target = this.targets_[targetName];\n        // eslint-disable-next-line prefer-spread\n        target[methodName].apply(target, args);\n        break;\n      }\n      case 'asyncCall': {\n        const targetName = message['targetName'];\n        const methodName = message['methodName'];\n        if (targetName == 'player' && methodName == 'load') {\n          // Reset update message frequency values after a load.\n          this.updateNumber_ = 0;\n          this.startUpdatingUpdateNumber_ = false;\n        }\n        const args = message['args'];\n        const id = message['id'];\n        const senderId = event.senderId;\n        const target = this.targets_[targetName];\n        // eslint-disable-next-line prefer-spread\n        let p = target[methodName].apply(target, args);\n        if (targetName == 'player' && methodName == 'load') {\n          // Wait until the manifest has actually loaded to send another media\n          // info message, so on a new load it doesn't send the old info over.\n          p = p.then(() => {\n            this.initialStatusUpdatePending_ = true;\n          });\n        }\n        // Replies must go back to the specific sender who initiated, so that we\n        // don't have to deal with conflicting IDs between senders.\n        p.then(\n            () => this.sendAsyncComplete_(senderId, id, /* error= */ null),\n            (error) => this.sendAsyncComplete_(senderId, id, error));\n        break;\n      }\n    }\n  }\n\n  /**\n   * @param {!cast.receiver.CastMessageBus.Event} event\n   * @private\n   */\n  onGenericMessage_(event) {\n    const message = shaka.cast.CastUtils.deserialize(event.data);\n    shaka.log.debug('CastReceiver: message', message);\n    // TODO(ismena): error message on duplicate request id from the same sender\n    switch (message['type']) {\n      case 'PLAY':\n        this.video_.play();\n        // Notify generic controllers that the player state changed.\n        // requestId=0 (the parameter) means that the message was not\n        // triggered by a GET_STATUS request.\n        this.sendMediaStatus_();\n        break;\n      case 'PAUSE':\n        this.video_.pause();\n        this.sendMediaStatus_();\n        break;\n      case 'SEEK': {\n        const currentTime = message['currentTime'];\n        const resumeState = message['resumeState'];\n        if (currentTime != null) {\n          this.video_.currentTime = Number(currentTime);\n        }\n        if (resumeState && resumeState == 'PLAYBACK_START') {\n          this.video_.play();\n          this.sendMediaStatus_();\n        } else if (resumeState && resumeState == 'PLAYBACK_PAUSE') {\n          this.video_.pause();\n          this.sendMediaStatus_();\n        }\n        break;\n      }\n      case 'STOP':\n        this.player_.unload().then(() => {\n          if (!this.player_) {\n            // We've already been destroyed.\n            return;\n          }\n\n          this.sendMediaStatus_();\n        });\n        break;\n      case 'GET_STATUS':\n        // TODO(ismena): According to the SDK this is supposed to be a\n        // unicast message to the sender that requested the status,\n        // but it doesn't appear to be working.\n        // Look into what's going on there and change this to be a\n        // unicast.\n        this.sendMediaInfoMessage_(Number(message['requestId']));\n        break;\n      case 'VOLUME': {\n        const volumeObject = message['volume'];\n        const level = volumeObject['level'];\n        const muted = volumeObject['muted'];\n        const oldVolumeLevel = this.video_.volume;\n        const oldVolumeMuted = this.video_.muted;\n        if (level != null) {\n          this.video_.volume = Number(level);\n        }\n        if (muted != null) {\n          this.video_.muted = muted;\n        }\n        // Notify generic controllers if the volume changed.\n        if (oldVolumeLevel != this.video_.volume ||\n            oldVolumeMuted != this.video_.muted) {\n          this.sendMediaStatus_();\n        }\n        break;\n      }\n      case 'LOAD': {\n        // Reset update message frequency values after a load.\n        this.updateNumber_ = 0;\n        this.startUpdatingUpdateNumber_ = false;\n        // This already sends an update.\n        this.initialStatusUpdatePending_ = false;\n\n        const mediaInfo = message['media'];\n        const contentId = mediaInfo['contentId'];\n        const currentTime = message['currentTime'];\n        const assetUri = this.contentIdCallback_(contentId);\n        const autoplay = message['autoplay'] || true;\n        const customData = mediaInfo['customData'];\n\n        this.appDataCallback_(customData);\n\n        if (autoplay) {\n          this.video_.autoplay = true;\n        }\n        this.player_.load(assetUri, currentTime).then(() => {\n          if (!this.player_) {\n            // We've already been destroyed.\n            return;\n          }\n\n          // Notify generic controllers that the media has changed.\n          this.sendMediaInfoMessage_();\n        }).catch((error) => {\n          goog.asserts.assert(error instanceof shaka.util.Error,\n              'Wrong error type!');\n\n          // Load failed.  Dispatch the error message to the sender.\n          let type = 'LOAD_FAILED';\n          if (error.category == shaka.util.Error.Category.PLAYER &&\n              error.code == shaka.util.Error.Code.LOAD_INTERRUPTED) {\n            type = 'LOAD_CANCELLED';\n          }\n\n          this.sendMessage_({\n            'requestId': Number(message['requestId']),\n            'type': type,\n          }, this.genericBus_);\n        });\n        break;\n      }\n      default:\n        shaka.log.warning(\n            'Unrecognized message type from the generic Chromecast controller!',\n            message['type']);\n        // Dispatch an error to the sender.\n        this.sendMessage_({\n          'requestId': Number(message['requestId']),\n          'type': 'INVALID_REQUEST',\n          'reason': 'INVALID_COMMAND',\n        }, this.genericBus_);\n        break;\n    }\n  }\n\n  /**\n   * Tell the sender that the async operation is complete.\n   * @param {string} senderId\n   * @param {string} id\n   * @param {shaka.util.Error} error\n   * @private\n   */\n  sendAsyncComplete_(senderId, id, error) {\n    if (!this.player_) {\n      // We've already been destroyed.\n      return;\n    }\n\n    this.sendMessage_({\n      'type': 'asyncComplete',\n      'id': id,\n      'error': error,\n    }, this.shakaBus_, senderId);\n  }\n\n  /**\n   * Since this method is in the compiled library, make sure all messages passed\n   * in here were created with quoted property names.\n   * @param {!Object} message\n   * @param {cast.receiver.CastMessageBus} bus\n   * @param {string=} senderId\n   * @private\n   */\n  sendMessage_(message, bus, senderId) {\n    // Cuts log spam when debugging the receiver UI in Chrome.\n    if (!this.isConnected_) {\n      return;\n    }\n\n    const serialized = shaka.cast.CastUtils.serialize(message);\n    if (senderId) {\n      bus.getCastChannel(senderId).send(serialized);\n    } else {\n      bus.broadcast(serialized);\n    }\n  }\n\n  /**\n   * @return {string}\n   * @private\n   */\n  getPlayState_() {\n    const playState = shaka.cast.CastReceiver.PLAY_STATE;\n    if (this.isIdle_) {\n      return playState.IDLE;\n    } else if (this.player_.isBuffering()) {\n      return playState.BUFFERING;\n    } else if (this.video_.paused) {\n      return playState.PAUSED;\n    } else {\n      return playState.PLAYING;\n    }\n  }\n\n  /**\n   * @param {number=} requestId\n   * @param {Object=} media\n   * @private\n   */\n  sendMediaStatus_(requestId = 0, media = null) {\n    const mediaStatus = {\n      // mediaSessionId is a unique ID for the playback of this specific\n      // session.\n      // It's used to identify a specific instance of a playback.\n      // We don't support multiple playbacks, so just return 0.\n      'mediaSessionId': 0,\n      'playbackRate': this.video_.playbackRate,\n      'playerState': this.getPlayState_(),\n      'currentTime': this.video_.currentTime,\n      // supportedMediaCommands is a sum of all the flags of commands that the\n      // player supports.\n      // The list of comands with respective flags is:\n      // 1 - Pause\n      // 2 - Seek\n      // 4 - Stream volume\n      // 8 - Stream mute\n      // 16 - Skip forward\n      // 32 - Skip backward\n      // We support all of them, and their sum is 63.\n      'supportedMediaCommands': 63,\n      'volume': {\n        'level': this.video_.volume,\n        'muted': this.video_.muted,\n      },\n    };\n\n    if (media) {\n      mediaStatus['media'] = media;\n    }\n\n    const ret = {\n      'requestId': requestId,\n      'type': 'MEDIA_STATUS',\n      'status': [mediaStatus],\n    };\n\n    this.sendMessage_(ret, this.genericBus_);\n  }\n};\n\n/** @type {number} The interval, in seconds, to poll for changes. */\nshaka.cast.CastReceiver.POLL_INTERVAL = 0.5;\n\n/** @type {number} The interval, in seconds, to go \"idle\". */\nshaka.cast.CastReceiver.IDLE_INTERVAL = 5;\n\n/**\n * @enum {string}\n */\nshaka.cast.CastReceiver.PLAY_STATE = {\n  IDLE: 'IDLE',\n  PLAYING: 'PLAYING',\n  BUFFERING: 'BUFFERING',\n  PAUSED: 'PAUSED',\n};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.util.Pssh');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.util.BufferUtils');\ngoog.require('shaka.util.Functional');\ngoog.require('shaka.util.Iterables');\ngoog.require('shaka.util.Mp4Parser');\ngoog.require('shaka.util.Uint8ArrayUtils');\n\n\n/**\n * @summary\n * Parse a PSSH box and extract the system IDs.\n */\nshaka.util.Pssh = class {\n  /**\n   * @param {!Uint8Array} psshBox\n   */\n  constructor(psshBox) {\n    /**\n     * In hex.\n     * @type {!Array.<string>}\n     */\n    this.systemIds = [];\n\n    /**\n     * In hex.\n     * @type {!Array.<string>}\n     */\n    this.cencKeyIds = [];\n\n    /**\n     * Array with the pssh boxes found.\n     * @type {!Array.<!Uint8Array>}\n     */\n    this.data = [];\n\n    new shaka.util.Mp4Parser()\n        .box('moov', shaka.util.Mp4Parser.children)\n        .fullBox('pssh', (box) => this.parsePsshBox_(box))\n        .parse(psshBox);\n\n    if (this.data.length == 0) {\n      shaka.log.warning('No pssh box found!');\n    }\n  }\n\n\n  /**\n   * @param {!shaka.extern.ParsedBox} box\n   * @private\n   */\n  parsePsshBox_(box) {\n    goog.asserts.assert(\n        box.version != null,\n        'PSSH boxes are full boxes and must have a valid version');\n\n    goog.asserts.assert(\n        box.flags != null,\n        'PSSH boxes are full boxes and must have a valid flag');\n\n    if (box.version > 1) {\n      shaka.log.warning('Unrecognized PSSH version found!');\n      return;\n    }\n\n    // The \"reader\" gives us a view on the payload of the box.  Create a new\n    // view that contains the whole box.\n    const dataView = box.reader.getDataView();\n    goog.asserts.assert(\n        dataView.byteOffset >= 12, 'DataView at incorrect position');\n    const pssh = shaka.util.BufferUtils.toUint8(dataView, -12, box.size);\n    this.data.push(pssh);\n\n    this.systemIds.push(\n        shaka.util.Uint8ArrayUtils.toHex(box.reader.readBytes(16)));\n    if (box.version > 0) {\n      const numKeyIds = box.reader.readUint32();\n      for (const _ of shaka.util.Iterables.range(numKeyIds)) {\n        shaka.util.Functional.ignored(_);\n        const keyId =\n            shaka.util.Uint8ArrayUtils.toHex(box.reader.readBytes(16));\n        this.cencKeyIds.push(keyId);\n      }\n    }\n  }\n\n  /**\n   * Creates a pssh blob from the given system ID and data.\n   *\n   * @param {!Uint8Array} data\n   * @param {!Uint8Array} systemId\n   * @return {!Uint8Array}\n   */\n  static createPssh(data, systemId) {\n    goog.asserts.assert(systemId.byteLength == 16, 'Invalid system ID length');\n    const dataLength = data.length;\n    const psshSize = 0x4 + 0x4 + 0x4 + systemId.length + 0x4 + dataLength;\n\n    /** @type {!Uint8Array} */\n    const psshBox = new Uint8Array(psshSize);\n    /** @type {!DataView} */\n    const psshData = shaka.util.BufferUtils.toDataView(psshBox);\n\n    let byteCursor = 0;\n    psshData.setUint32(byteCursor, psshSize);\n    byteCursor += 0x4;\n    psshData.setUint32(byteCursor, 0x70737368);  // 'pssh'\n    byteCursor += 0x4;\n    psshData.setUint32(byteCursor, 0);  // flags\n    byteCursor += 0x4;\n    psshBox.set(systemId, byteCursor);\n    byteCursor += systemId.length;\n    psshData.setUint32(byteCursor, dataLength);\n    byteCursor += 0x4;\n    psshBox.set(data, byteCursor);\n    byteCursor += dataLength;\n\n    goog.asserts.assert(byteCursor === psshSize, 'PSSH invalid length.');\n    return psshBox;\n  }\n\n\n  /**\n   * Normalise the initData array. This is to apply browser specific\n   * work-arounds, e.g. removing duplicates which appears to occur\n   * intermittently when the native msneedkey event fires (i.e. event.initData\n   * contains dupes).\n   *\n   * @param {!Uint8Array} initData\n   * @return {!Uint8Array}\n   */\n  static normaliseInitData(initData) {\n    if (!initData) {\n      return initData;\n    }\n\n    const pssh = new shaka.util.Pssh(initData);\n\n    // If there is only a single pssh, return the original array.\n    if (pssh.data.length <= 1) {\n      return initData;\n    }\n\n    // Dedupe psshData.\n    /** @type {!Array.<!Uint8Array>} */\n    const dedupedInitDatas = [];\n    for (const initData of pssh.data) {\n      const found = dedupedInitDatas.some((x) => {\n        return shaka.util.BufferUtils.equal(x, initData);\n      });\n\n      if (!found) {\n        dedupedInitDatas.push(initData);\n      }\n    }\n\n    return shaka.util.Uint8ArrayUtils.concat(...dedupedInitDatas);\n  }\n};\n\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.util.XmlUtils');\n\ngoog.require('shaka.log');\ngoog.require('shaka.util.StringUtils');\n\n\n/**\n * @summary A set of XML utility functions.\n */\nshaka.util.XmlUtils = class {\n  /**\n   * Finds a child XML element.\n   * @param {!Node} elem The parent XML element.\n   * @param {string} name The child XML element's tag name.\n   * @return {Element} The child XML element, or null if a child XML element\n   *   does not exist with the given tag name OR if there exists more than one\n   *   child XML element with the given tag name.\n   */\n  static findChild(elem, name) {\n    const children = shaka.util.XmlUtils.findChildren(elem, name);\n    if (children.length != 1) {\n      return null;\n    }\n    return children[0];\n  }\n\n\n  /**\n   * Finds a namespace-qualified child XML element.\n   * @param {!Node} elem The parent XML element.\n   * @param {string} ns The child XML element's namespace URI.\n   * @param {string} name The child XML element's local name.\n   * @return {Element} The child XML element, or null if a child XML element\n   *   does not exist with the given tag name OR if there exists more than one\n   *   child XML element with the given tag name.\n   */\n  static findChildNS(elem, ns, name) {\n    const children = shaka.util.XmlUtils.findChildrenNS(elem, ns, name);\n    if (children.length != 1) {\n      return null;\n    }\n    return children[0];\n  }\n\n\n  /**\n   * Finds child XML elements.\n   * @param {!Node} elem The parent XML element.\n   * @param {string} name The child XML element's tag name.\n   * @return {!Array.<!Element>} The child XML elements.\n   */\n  static findChildren(elem, name) {\n    return Array.from(elem.childNodes).filter((child) => {\n      return child instanceof Element && child.tagName == name;\n    });\n  }\n\n\n  /**\n   * Finds namespace-qualified child XML elements.\n   * @param {!Node} elem The parent XML element.\n   * @param {string} ns The child XML element's namespace URI.\n   * @param {string} name The child XML element's local name.\n   * @return {!Array.<!Element>} The child XML elements.\n   */\n  static findChildrenNS(elem, ns, name) {\n    return Array.from(elem.childNodes).filter((child) => {\n      return child instanceof Element && child.localName == name &&\n          child.namespaceURI == ns;\n    });\n  }\n\n\n  /**\n   * Gets a namespace-qualified attribute.\n   * @param {!Element} elem The element to get from.\n   * @param {string} ns The namespace URI.\n   * @param {string} name The local name of the attribute.\n   * @return {?string} The attribute's value, or null if not present.\n   */\n  static getAttributeNS(elem, ns, name) {\n    // Some browsers return the empty string when the attribute is missing,\n    // so check if it exists first.  See: https://mzl.la/2L7F0UK\n    return elem.hasAttributeNS(ns, name) ? elem.getAttributeNS(ns, name) : null;\n  }\n\n\n  /**\n   * Gets the text contents of a node.\n   * @param {!Node} elem The XML element.\n   * @return {?string} The text contents, or null if there are none.\n   */\n  static getContents(elem) {\n    const isText = (child) => {\n      return child.nodeType == Node.TEXT_NODE ||\n          child.nodeType == Node.CDATA_SECTION_NODE;\n    };\n    if (!Array.from(elem.childNodes).every(isText)) {\n      return null;\n    }\n\n    // Read merged text content from all text nodes.\n    return elem.textContent.trim();\n  }\n\n\n  /**\n   * Parses an attribute by its name.\n   * @param {!Element} elem The XML element.\n   * @param {string} name The attribute name.\n   * @param {function(string): (T|null)} parseFunction A function that parses\n   *   the attribute.\n   * @param {(T|null)=} defaultValue The attribute's default value, if not\n   *   specified, the attibute's default value is null.\n   * @return {(T|null)} The parsed attribute on success, or the attribute's\n   *   default value if the attribute does not exist or could not be parsed.\n   * @template T\n   */\n  static parseAttr(\n      elem, name, parseFunction, defaultValue = null) {\n    let parsedValue = null;\n\n    const value = elem.getAttribute(name);\n    if (value != null) {\n      parsedValue = parseFunction(value);\n    }\n    return parsedValue == null ? defaultValue : parsedValue;\n  }\n\n\n  /**\n   * Parses an XML date string.\n   * @param {string} dateString\n   * @return {?number} The parsed date in seconds on success; otherwise, return\n   *   null.\n   */\n  static parseDate(dateString) {\n    if (!dateString) {\n      return null;\n    }\n\n    // Times in the manifest should be in UTC. If they don't specify a timezone,\n    // Date.parse() will use the local timezone instead of UTC.  So manually add\n    // the timezone if missing ('Z' indicates the UTC timezone).\n    // Format: YYYY-MM-DDThh:mm:ss.ssssss\n    if (/^\\d+-\\d+-\\d+T\\d+:\\d+:\\d+(\\.\\d+)?$/.test(dateString)) {\n      dateString += 'Z';\n    }\n\n    const result = Date.parse(dateString);\n    return (!isNaN(result) ? Math.floor(result / 1000.0) : null);\n  }\n\n\n  /**\n   * Parses an XML duration string.\n   * Negative values are not supported. Years and months are treated as exactly\n   * 365 and 30 days respectively.\n   * @param {string} durationString The duration string, e.g., \"PT1H3M43.2S\",\n   *   which means 1 hour, 3 minutes, and 43.2 seconds.\n   * @return {?number} The parsed duration in seconds on success; otherwise,\n   *   return null.\n   * @see {@link http://www.datypic.com/sc/xsd/t-xsd_duration.html}\n   */\n  static parseDuration(durationString) {\n    if (!durationString) {\n      return null;\n    }\n\n    const re = '^P(?:([0-9]*)Y)?(?:([0-9]*)M)?(?:([0-9]*)D)?' +\n             '(?:T(?:([0-9]*)H)?(?:([0-9]*)M)?(?:([0-9.]*)S)?)?$';\n    const matches = new RegExp(re).exec(durationString);\n\n    if (!matches) {\n      shaka.log.warning('Invalid duration string:', durationString);\n      return null;\n    }\n\n    // Note: Number(null) == 0 but Number(undefined) == NaN.\n    const years = Number(matches[1] || null);\n    const months = Number(matches[2] || null);\n    const days = Number(matches[3] || null);\n    const hours = Number(matches[4] || null);\n    const minutes = Number(matches[5] || null);\n    const seconds = Number(matches[6] || null);\n\n    // Assume a year always has 365 days and a month always has 30 days.\n    const d = (60 * 60 * 24 * 365) * years +\n            (60 * 60 * 24 * 30) * months +\n            (60 * 60 * 24) * days +\n            (60 * 60) * hours +\n            60 * minutes +\n            seconds;\n    return isFinite(d) ? d : null;\n  }\n\n\n  /**\n   * Parses a range string.\n   * @param {string} rangeString The range string, e.g., \"101-9213\".\n   * @return {?{start: number, end: number}} The parsed range on success;\n   *   otherwise, return null.\n   */\n  static parseRange(rangeString) {\n    const matches = /([0-9]+)-([0-9]+)/.exec(rangeString);\n\n    if (!matches) {\n      return null;\n    }\n\n    const start = Number(matches[1]);\n    if (!isFinite(start)) {\n      return null;\n    }\n\n    const end = Number(matches[2]);\n    if (!isFinite(end)) {\n      return null;\n    }\n\n    return {start: start, end: end};\n  }\n\n\n  /**\n   * Parses an integer.\n   * @param {string} intString The integer string.\n   * @return {?number} The parsed integer on success; otherwise, return null.\n   */\n  static parseInt(intString) {\n    const n = Number(intString);\n    return (n % 1 === 0) ? n : null;\n  }\n\n\n  /**\n   * Parses a positive integer.\n   * @param {string} intString The integer string.\n   * @return {?number} The parsed positive integer on success; otherwise,\n   *   return null.\n   */\n  static parsePositiveInt(intString) {\n    const n = Number(intString);\n    return (n % 1 === 0) && (n > 0) ? n : null;\n  }\n\n\n  /**\n   * Parses a non-negative integer.\n   * @param {string} intString The integer string.\n   * @return {?number} The parsed non-negative integer on success; otherwise,\n   *   return null.\n   */\n  static parseNonNegativeInt(intString) {\n    const n = Number(intString);\n    return (n % 1 === 0) && (n >= 0) ? n : null;\n  }\n\n\n  /**\n   * Parses a floating point number.\n   * @param {string} floatString The floating point number string.\n   * @return {?number} The parsed floating point number on success; otherwise,\n   *   return null. May return -Infinity or Infinity.\n   */\n  static parseFloat(floatString) {\n    const n = Number(floatString);\n    return !isNaN(n) ? n : null;\n  }\n\n\n  /**\n   * Evaluate a division expressed as a string.\n   * @param {string} exprString\n   *   The expression to evaluate, e.g. \"200/2\". Can also be a single number.\n   * @return {?number} The evaluated expression as floating point number on\n   *   success; otherwise return null.\n   */\n  static evalDivision(exprString) {\n    let res;\n    let n;\n    if ((res = exprString.match(/^(\\d+)\\/(\\d+)$/))) {\n      n = Number(res[1]) / Number(res[2]);\n    } else {\n      n = Number(exprString);\n    }\n    return !isNaN(n) ? n : null;\n  }\n\n\n  /**\n   * Parse a string and return the resulting root element if\n   * it was valid XML.\n   * @param {string} xmlString\n   * @param {string} expectedRootElemName\n   * @return {Element}\n   */\n  static parseXmlString(xmlString, expectedRootElemName) {\n    const parser = new DOMParser();\n    let rootElem = null;\n    let xml = null;\n    try {\n      xml = parser.parseFromString(xmlString, 'text/xml');\n    } catch (exception) {}\n    if (xml) {\n      // The top-level element in the loaded xml should have the\n      // same type as the element linking.\n      if (xml.documentElement.tagName == expectedRootElemName) {\n        rootElem = xml.documentElement;\n      }\n    }\n    if (rootElem && rootElem.getElementsByTagName('parsererror').length > 0) {\n      return null;\n    }  // It had a parser error in it.\n\n    return rootElem;\n  }\n\n\n  /**\n   * Parse some UTF8 data and return the resulting root element if\n   * it was valid XML.\n   * @param {BufferSource} data\n   * @param {string} expectedRootElemName\n   * @return {Element}\n   */\n  static parseXml(data, expectedRootElemName) {\n    try {\n      const string = shaka.util.StringUtils.fromUTF8(data);\n      return shaka.util.XmlUtils.parseXmlString(string, expectedRootElemName);\n    } catch (exception) {\n      return null;\n    }\n  }\n};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.dash.ContentProtection');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.util.BufferUtils');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.ManifestParserUtils');\ngoog.require('shaka.util.Pssh');\ngoog.require('shaka.util.StringUtils');\ngoog.require('shaka.util.Uint8ArrayUtils');\ngoog.require('shaka.util.XmlUtils');\n\n\n/**\n * @summary A set of functions for parsing and interpreting ContentProtection\n *   elements.\n */\nshaka.dash.ContentProtection = class {\n  /**\n   * Parses info from the ContentProtection elements at the AdaptationSet level.\n   *\n   * @param {!Array.<!Element>} elems\n   * @param {boolean} ignoreDrmInfo\n   * @return {shaka.dash.ContentProtection.Context}\n   */\n  static parseFromAdaptationSet(elems, ignoreDrmInfo) {\n    const ContentProtection = shaka.dash.ContentProtection;\n    const ManifestParserUtils = shaka.util.ManifestParserUtils;\n    const parsed = ContentProtection.parseElements_(elems);\n    /** @type {Array.<shaka.extern.InitDataOverride>} */\n    let defaultInit = null;\n    /** @type {!Array.<shaka.extern.DrmInfo>} */\n    let drmInfos = [];\n    let parsedNonCenc = [];\n\n    // Get the default key ID; if there are multiple, they must all match.\n    const keyIds = new Set(parsed.map((element) => element.keyId));\n    // Remove any possible null value (elements may have no key ids).\n    keyIds.delete(null);\n\n    if (keyIds.size > 1) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.MANIFEST,\n          shaka.util.Error.Code.DASH_CONFLICTING_KEY_IDS);\n    }\n\n    if (!ignoreDrmInfo) {\n      // Find the default key ID and init data.  Create a new array of all the\n      // non-CENC elements.\n      parsedNonCenc = parsed.filter((elem) => {\n        if (elem.schemeUri == ContentProtection.MP4Protection_) {\n          goog.asserts.assert(!elem.init || elem.init.length,\n              'Init data must be null or non-empty.');\n          defaultInit = elem.init || defaultInit;\n          return false;\n        } else {\n          return true;\n        }\n      });\n\n      if (parsedNonCenc.length) {\n        drmInfos = ContentProtection.convertElements_(\n            defaultInit, parsedNonCenc);\n\n        // If there are no drmInfos after parsing, then add a dummy entry.\n        // This may be removed in parseKeyIds.\n        if (drmInfos.length == 0) {\n          drmInfos = [ManifestParserUtils.createDrmInfo('', defaultInit)];\n        }\n      }\n    }\n\n    // If there are only CENC element(s) or ignoreDrmInfo flag is set, assume\n    // all key-systems are supported.\n    if (parsed.length && (ignoreDrmInfo || !parsedNonCenc.length)) {\n      drmInfos = [];\n\n      const keySystems = ContentProtection.defaultKeySystems_;\n      for (const keySystem of keySystems.values()) {\n        // If the manifest doesn't specify any key systems, we shouldn't\n        // put clearkey in this list.  Otherwise, it may be triggered when\n        // a real key system should be used instead.\n        if (keySystem != 'org.w3.clearkey') {\n          const info =\n              ManifestParserUtils.createDrmInfo(keySystem, defaultInit);\n          drmInfos.push(info);\n        }\n      }\n    }\n\n    // If we have a default key id, apply it to every initData.\n    const defaultKeyId = Array.from(keyIds)[0] || null;\n\n    if (defaultKeyId) {\n      for (const info of drmInfos) {\n        for (const initData of info.initData) {\n          initData.keyId = defaultKeyId;\n        }\n      }\n    }\n\n    return {\n      defaultKeyId: defaultKeyId,\n      defaultInit: defaultInit,\n      drmInfos: drmInfos,\n      firstRepresentation: true,\n    };\n  }\n\n  /**\n   * Parses the given ContentProtection elements found at the Representation\n   * level.  This may update the |context|.\n   *\n   * @param {!Array.<!Element>} elems\n   * @param {shaka.dash.ContentProtection.Context} context\n   * @param {boolean} ignoreDrmInfo\n   * @return {?string} The parsed key ID\n   */\n  static parseFromRepresentation(elems, context, ignoreDrmInfo) {\n    const ContentProtection = shaka.dash.ContentProtection;\n    const repContext = ContentProtection.parseFromAdaptationSet(\n        elems, ignoreDrmInfo);\n\n    if (context.firstRepresentation) {\n      const asUnknown = context.drmInfos.length == 1 &&\n          !context.drmInfos[0].keySystem;\n      const asUnencrypted = context.drmInfos.length == 0;\n      const repUnencrypted = repContext.drmInfos.length == 0;\n\n      // There are two cases where we need to replace the |drmInfos| in the\n      // context with those in the Representation:\n      //   1. The AdaptationSet does not list any ContentProtection.\n      //   2. The AdaptationSet only lists unknown key-systems.\n      if (asUnencrypted || (asUnknown && !repUnencrypted)) {\n        context.drmInfos = repContext.drmInfos;\n      }\n      context.firstRepresentation = false;\n    } else if (repContext.drmInfos.length > 0) {\n      // If this is not the first Representation, then we need to remove entries\n      // from the context that do not appear in this Representation.\n      context.drmInfos = context.drmInfos.filter((asInfo) => {\n        return repContext.drmInfos.some((repInfo) => {\n          return repInfo.keySystem == asInfo.keySystem;\n        });\n      });\n      // If we have filtered out all key-systems, throw an error.\n      if (context.drmInfos.length == 0) {\n        throw new shaka.util.Error(\n            shaka.util.Error.Severity.CRITICAL,\n            shaka.util.Error.Category.MANIFEST,\n            shaka.util.Error.Code.DASH_NO_COMMON_KEY_SYSTEM);\n      }\n    }\n\n    return repContext.defaultKeyId || context.defaultKeyId;\n  }\n\n  /**\n   * Gets a Widevine license URL from a content protection element\n   * containing a custom `ms:laurl` element\n   *\n   * @param {shaka.dash.ContentProtection.Element} element\n   * @return {string}\n   */\n  static getWidevineLicenseUrl(element) {\n    const mslaurlNode = shaka.util.XmlUtils.findChildNS(\n        element.node, 'urn:microsoft', 'laurl');\n    if (mslaurlNode) {\n      return mslaurlNode.getAttribute('licenseUrl') || '';\n    }\n    return '';\n  }\n\n  /**\n   * Parses an Array buffer starting at byteOffset for PlayReady Object Records.\n   * Each PRO Record is preceded by its PlayReady Record type and length in\n   * bytes.\n   *\n   * PlayReady Object Record format: https://goo.gl/FTcu46\n   *\n   * @param {!DataView} view\n   * @param {number} byteOffset\n   * @return {!Array.<shaka.dash.ContentProtection.PlayReadyRecord>}\n   * @private\n   */\n  static parseMsProRecords_(view, byteOffset) {\n    const records = [];\n\n    while (byteOffset < view.byteLength - 1) {\n      const type = view.getUint16(byteOffset, true);\n      byteOffset += 2;\n\n      const byteLength = view.getUint16(byteOffset, true);\n      byteOffset += 2;\n\n      if ((byteLength & 1) != 0 || byteLength + byteOffset > view.byteLength) {\n        shaka.log.warning('Malformed MS PRO object');\n        return [];\n      }\n\n      const recordValue = shaka.util.BufferUtils.toUint8(\n          view, byteOffset, byteLength);\n      records.push({\n        type: type,\n        value: recordValue,\n      });\n\n      byteOffset += byteLength;\n    }\n\n    return records;\n  }\n\n  /**\n   * Parses a buffer for PlayReady Objects.  The data\n   * should contain a 32-bit integer indicating the length of\n   * the PRO in bytes.  Following that, a 16-bit integer for\n   * the number of PlayReady Object Records in the PRO.  Lastly,\n   * a byte array of the PRO Records themselves.\n   *\n   * PlayReady Object format: https://goo.gl/W8yAN4\n   *\n   * @param {BufferSource} data\n   * @return {!Array.<shaka.dash.ContentProtection.PlayReadyRecord>}\n   * @private\n   */\n  static parseMsPro_(data) {\n    let byteOffset = 0;\n    const view = shaka.util.BufferUtils.toDataView(data);\n\n    // First 4 bytes is the PRO length (DWORD)\n    const byteLength = view.getUint32(byteOffset, /* littleEndian= */ true);\n    byteOffset += 4;\n\n    if (byteLength != data.byteLength) {\n      // Malformed PRO\n      shaka.log.warning('PlayReady Object with invalid length encountered.');\n      return [];\n    }\n\n    // Skip PRO Record count (WORD)\n    byteOffset += 2;\n\n    // Rest of the data contains the PRO Records\n    const ContentProtection = shaka.dash.ContentProtection;\n    return ContentProtection.parseMsProRecords_(view, byteOffset);\n  }\n\n  /**\n   * PlayReady Header format: https://goo.gl/dBzxNA\n   *\n   * @param {!Element} xml\n   * @return {string}\n   * @private\n   */\n  static getLaurl_(xml) {\n    // LA_URL element is optional and no more than one is\n    // allowed inside the DATA element. Only absolute URLs are allowed.\n    // If the LA_URL element exists, it must not be empty.\n    for (const elem of xml.getElementsByTagName('DATA')) {\n      for (const child of elem.childNodes) {\n        if (child instanceof Element && child.tagName == 'LA_URL') {\n          return child.textContent;\n        }\n      }\n    }\n\n    // Not found\n    return '';\n  }\n\n  /**\n   * Gets a PlayReady license URL from a content protection element\n   * containing a PlayReady Header Object\n   *\n   * @param {shaka.dash.ContentProtection.Element} element\n   * @return {string}\n   */\n  static getPlayReadyLicenseUrl(element) {\n    const proNode = shaka.util.XmlUtils.findChildNS(\n        element.node, 'urn:microsoft:playready', 'pro');\n\n    if (!proNode) {\n      return '';\n    }\n\n    const ContentProtection = shaka.dash.ContentProtection;\n    const PLAYREADY_RECORD_TYPES = ContentProtection.PLAYREADY_RECORD_TYPES;\n\n    const bytes = shaka.util.Uint8ArrayUtils.fromBase64(proNode.textContent);\n    const records = ContentProtection.parseMsPro_(bytes);\n    const record = records.filter((record) => {\n      return record.type === PLAYREADY_RECORD_TYPES.RIGHTS_MANAGEMENT;\n    })[0];\n\n    if (!record) {\n      return '';\n    }\n\n    const xml = shaka.util.StringUtils.fromUTF16(record.value, true);\n    const rootElement = shaka.util.XmlUtils.parseXmlString(xml, 'WRMHEADER');\n    if (!rootElement) {\n      return '';\n    }\n\n    return ContentProtection.getLaurl_(rootElement);\n  }\n\n  /**\n   * Gets a PlayReady initData from a content protection element\n   * containing a PlayReady Pro Object\n   *\n   * @param {shaka.dash.ContentProtection.Element} element\n   * @return {?Array.<shaka.extern.InitDataOverride>}\n   * @private\n   */\n  static getInitDataFromPro_(element) {\n    const proNode = shaka.util.XmlUtils.findChildNS(\n        element.node, 'urn:microsoft:playready', 'pro');\n    if (!proNode) {\n      return null;\n    }\n    const Uint8ArrayUtils = shaka.util.Uint8ArrayUtils;\n    const data = Uint8ArrayUtils.fromBase64(proNode.textContent);\n    const systemId = new Uint8Array([\n      0x9a, 0x04, 0xf0, 0x79, 0x98, 0x40, 0x42, 0x86,\n      0xab, 0x92, 0xe6, 0x5b, 0xe0, 0x88, 0x5f, 0x95,\n    ]);\n    const pssh = shaka.util.Pssh.createPssh(data, systemId);\n    return [\n      {\n        initData: pssh,\n        initDataType: 'cenc',\n        keyId: element.keyId,\n      },\n    ];\n  }\n\n  /**\n   * Creates DrmInfo objects from the given element.\n   *\n   * @param {Array.<shaka.extern.InitDataOverride>} defaultInit\n   * @param {!Array.<shaka.dash.ContentProtection.Element>} elements\n   * @return {!Array.<shaka.extern.DrmInfo>}\n   * @private\n   */\n  static convertElements_(defaultInit, elements) {\n    const ContentProtection = shaka.dash.ContentProtection;\n    const ManifestParserUtils = shaka.util.ManifestParserUtils;\n    const defaultKeySystems = ContentProtection.defaultKeySystems_;\n    const licenseUrlParsers = ContentProtection.licenseUrlParsers_;\n\n    /** @type {!Array.<shaka.extern.DrmInfo>} */\n    const out = [];\n\n    for (const element of elements) {\n      const keySystem = defaultKeySystems.get(element.schemeUri);\n      if (keySystem) {\n        goog.asserts.assert(\n            !element.init || element.init.length,\n            'Init data must be null or non-empty.');\n\n        const proInitData = ContentProtection.getInitDataFromPro_(element);\n        const initData = element.init || defaultInit || proInitData;\n        const info = ManifestParserUtils.createDrmInfo(keySystem, initData);\n        const licenseParser = licenseUrlParsers.get(keySystem);\n        if (licenseParser) {\n          info.licenseServerUri = licenseParser(element);\n        }\n\n        out.push(info);\n      }\n    }\n\n    return out;\n  }\n\n  /**\n   * Parses the given ContentProtection elements.  If there is an error, it\n   * removes those elements.\n   *\n   * @param {!Array.<!Element>} elems\n   * @return {!Array.<shaka.dash.ContentProtection.Element>}\n   * @private\n   */\n  static parseElements_(elems) {\n    /** @type {!Array.<shaka.dash.ContentProtection.Element>} */\n    const out = [];\n\n    for (const elem of elems) {\n      const parsed = shaka.dash.ContentProtection.parseElement_(elem);\n      if (parsed) {\n        out.push(parsed);\n      }\n    }\n\n    return out;\n  }\n\n  /**\n   * Parses the given ContentProtection element.\n   *\n   * @param {!Element} elem\n   * @return {?shaka.dash.ContentProtection.Element}\n   * @private\n   */\n  static parseElement_(elem) {\n    const NS = shaka.dash.ContentProtection.CencNamespaceUri_;\n\n    /** @type {?string} */\n    let schemeUri = elem.getAttribute('schemeIdUri');\n    /** @type {?string} */\n    let keyId = shaka.util.XmlUtils.getAttributeNS(elem, NS, 'default_KID');\n    /** @type {!Array.<string>} */\n    const psshs = shaka.util.XmlUtils.findChildrenNS(elem, NS, 'pssh')\n        .map(shaka.util.XmlUtils.getContents);\n\n    if (!schemeUri) {\n      shaka.log.error('Missing required schemeIdUri attribute on',\n          'ContentProtection element', elem);\n      return null;\n    }\n\n    schemeUri = schemeUri.toLowerCase();\n    if (keyId) {\n      keyId = keyId.replace(/-/g, '').toLowerCase();\n      if (keyId.includes(' ')) {\n        throw new shaka.util.Error(\n            shaka.util.Error.Severity.CRITICAL,\n            shaka.util.Error.Category.MANIFEST,\n            shaka.util.Error.Code.DASH_MULTIPLE_KEY_IDS_NOT_SUPPORTED);\n      }\n    }\n\n    /** @type {!Array.<shaka.extern.InitDataOverride>} */\n    let init = [];\n    try {\n      // Try parsing PSSH data.\n      init = psshs.map((pssh) => {\n        return {\n          initDataType: 'cenc',\n          initData: shaka.util.Uint8ArrayUtils.fromBase64(pssh),\n          keyId: null,\n        };\n      });\n    } catch (e) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.MANIFEST,\n          shaka.util.Error.Code.DASH_PSSH_BAD_ENCODING);\n    }\n\n    return {\n      node: elem,\n      schemeUri: schemeUri,\n      keyId: keyId,\n      init: (init.length > 0 ? init : null),\n    };\n  }\n};\n\n/**\n * @typedef {{\n *   type: number,\n *   value: !Uint8Array\n * }}\n *\n * @description\n * The parsed result of a PlayReady object record.\n *\n * @property {number} type\n *   Type of data stored in the record.\n * @property {!Uint8Array} value\n *   Record content.\n */\nshaka.dash.ContentProtection.PlayReadyRecord;\n\n/**\n * Enum for PlayReady record types.\n * @enum {number}\n */\nshaka.dash.ContentProtection.PLAYREADY_RECORD_TYPES = {\n  RIGHTS_MANAGEMENT: 0x001,\n  RESERVED: 0x002,\n  EMBEDDED_LICENSE: 0x003,\n};\n\n/**\n * @typedef {{\n *   defaultKeyId: ?string,\n *   defaultInit: Array.<shaka.extern.InitDataOverride>,\n *   drmInfos: !Array.<shaka.extern.DrmInfo>,\n *   firstRepresentation: boolean\n * }}\n *\n * @description\n * Contains information about the ContentProtection elements found at the\n * AdaptationSet level.\n *\n * @property {?string} defaultKeyId\n *   The default key ID to use.  This is used by parseKeyIds as a default.  This\n *   can be null to indicate that there is no default.\n * @property {Array.<shaka.extern.InitDataOverride>} defaultInit\n *   The default init data override.  This can be null to indicate that there\n *   is no default.\n * @property {!Array.<shaka.extern.DrmInfo>} drmInfos\n *   The DrmInfo objects.\n * @property {boolean} firstRepresentation\n *   True when first parsed; changed to false after the first call to\n *   parseKeyIds.  This is used to determine if a dummy key-system should be\n *   overwritten; namely that the first representation can replace the dummy\n *   from the AdaptationSet.\n */\nshaka.dash.ContentProtection.Context;\n\n\n/**\n * @typedef {{\n *   node: !Element,\n *   schemeUri: string,\n *   keyId: ?string,\n *   init: Array.<shaka.extern.InitDataOverride>\n * }}\n *\n * @description\n * The parsed result of a single ContentProtection element.\n *\n * @property {!Element} node\n *   The ContentProtection XML element.\n * @property {string} schemeUri\n *   The scheme URI.\n * @property {?string} keyId\n *   The default key ID, if present.\n * @property {Array.<shaka.extern.InitDataOverride>} init\n *   The init data, if present.  If there is no init data, it will be null.  If\n *   this is non-null, there is at least one element.\n */\nshaka.dash.ContentProtection.Element;\n\n\n/**\n * A map of scheme URI to key system name.\n *\n * @const {!Map.<string, string>}\n * @private\n */\nshaka.dash.ContentProtection.defaultKeySystems_ = new Map()\n    .set('urn:uuid:1077efec-c0b2-4d02-ace3-3c1e52e2fb4b',\n        'org.w3.clearkey')\n    .set('urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed',\n        'com.widevine.alpha')\n    .set('urn:uuid:9a04f079-9840-4286-ab92-e65be0885f95',\n        'com.microsoft.playready')\n    .set('urn:uuid:79f0049a-4098-8642-ab92-e65be0885f95',\n        'com.microsoft.playready')\n    .set('urn:uuid:f239e769-efa3-4850-9c16-a903c6932efb',\n        'com.adobe.primetime');\n\n/**\n * A map of key system name to license server url parser.\n *\n * @const {!Map.<string, function(shaka.dash.ContentProtection.Element)>}\n * @private\n */\nshaka.dash.ContentProtection.licenseUrlParsers_ = new Map()\n    .set('com.widevine.alpha',\n        shaka.dash.ContentProtection.getWidevineLicenseUrl)\n    .set('com.microsoft.playready',\n        shaka.dash.ContentProtection.getPlayReadyLicenseUrl);\n\n/**\n * @const {string}\n * @private\n */\nshaka.dash.ContentProtection.MP4Protection_ =\n    'urn:mpeg:dash:mp4protection:2011';\n\n\n/**\n * @const {string}\n * @private\n */\nshaka.dash.ContentProtection.CencNamespaceUri_ = 'urn:mpeg:cenc:2013';\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.dash.MpdUtils');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.net.NetworkingEngine');\ngoog.require('shaka.util.AbortableOperation');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.Functional');\ngoog.require('shaka.util.Iterables');\ngoog.require('shaka.util.ManifestParserUtils');\ngoog.require('shaka.util.XmlUtils');\ngoog.requireType('shaka.dash.DashParser');\n\n\n/**\n * @summary MPD processing utility functions.\n */\nshaka.dash.MpdUtils = class {\n  /**\n   * Fills a SegmentTemplate URI template.  This function does not validate the\n   * resulting URI.\n   *\n   * @param {string} uriTemplate\n   * @param {?string} representationId\n   * @param {?number} number\n   * @param {?number} bandwidth\n   * @param {?number} time\n   * @return {string} A URI string.\n   * @see ISO/IEC 23009-1:2014 section 5.3.9.4.4\n   */\n  static fillUriTemplate(\n      uriTemplate, representationId, number, bandwidth, time) {\n    /** @type {!Object.<string, ?number|?string>} */\n    const valueTable = {\n      'RepresentationID': representationId,\n      'Number': number,\n      'Bandwidth': bandwidth,\n      'Time': time,\n    };\n\n    const re = /\\$(RepresentationID|Number|Bandwidth|Time)?(?:%0([0-9]+)([diouxX]))?\\$/g;  // eslint-disable-line max-len\n    const uri = uriTemplate.replace(re, (match, name, widthStr, format) => {\n      if (match == '$$') {\n        return '$';\n      }\n\n      let value = valueTable[name];\n      goog.asserts.assert(value !== undefined, 'Unrecognized identifier');\n\n      // Note that |value| may be 0 or ''.\n      if (value == null) {\n        shaka.log.warning(\n            'URL template does not have an available substitution for ',\n            'identifier \"' + name + '\":',\n            uriTemplate);\n        return match;\n      }\n\n      if (name == 'RepresentationID' && widthStr) {\n        shaka.log.warning(\n            'URL template should not contain a width specifier for identifier',\n            '\"RepresentationID\":',\n            uriTemplate);\n        widthStr = undefined;\n      }\n\n      if (name == 'Time') {\n        goog.asserts.assert(typeof value == 'number',\n            'Time value should be a number!');\n        goog.asserts.assert(Math.abs(value - Math.round(value)) < 0.2,\n            'Calculated $Time$ values must be close to integers');\n        value = Math.round(value);\n      }\n\n      /** @type {string} */\n      let valueString;\n      switch (format) {\n        case undefined:  // Happens if there is no format specifier.\n        case 'd':\n        case 'i':\n        case 'u':\n          valueString = value.toString();\n          break;\n        case 'o':\n          valueString = value.toString(8);\n          break;\n        case 'x':\n          valueString = value.toString(16);\n          break;\n        case 'X':\n          valueString = value.toString(16).toUpperCase();\n          break;\n        default:\n          goog.asserts.assert(false, 'Unhandled format specifier');\n          valueString = value.toString();\n          break;\n      }\n\n      // Create a padding string.\n      const width = window.parseInt(widthStr, 10) || 1;\n      const paddingSize = Math.max(0, width - valueString.length);\n      const padding = (new Array(paddingSize + 1)).join('0');\n\n      return padding + valueString;\n    });\n\n    return uri;\n  }\n\n  /**\n   * Expands a SegmentTimeline into an array-based timeline.  The results are in\n   * seconds.\n   *\n   * @param {!Element} segmentTimeline\n   * @param {number} timescale\n   * @param {number} unscaledPresentationTimeOffset\n   * @param {number} periodDuration The Period's duration in seconds.\n   *   Infinity indicates that the Period continues indefinitely.\n   * @return {!Array.<shaka.dash.MpdUtils.TimeRange>}\n   */\n  static createTimeline(\n      segmentTimeline, timescale, unscaledPresentationTimeOffset,\n      periodDuration) {\n    goog.asserts.assert(\n        timescale > 0 && timescale < Infinity,\n        'timescale must be a positive, finite integer');\n    goog.asserts.assert(\n        periodDuration > 0, 'period duration must be a positive integer');\n\n    // Alias.\n    const XmlUtils = shaka.util.XmlUtils;\n\n    const timePoints = XmlUtils.findChildren(segmentTimeline, 'S');\n\n    /** @type {!Array.<shaka.dash.MpdUtils.TimeRange>} */\n    const timeline = [];\n    let lastEndTime = -unscaledPresentationTimeOffset;\n\n    const enumerate = (it) => shaka.util.Iterables.enumerate(it);\n    for (const {item: timePoint, next} of enumerate(timePoints)) {\n      let t = XmlUtils.parseAttr(timePoint, 't', XmlUtils.parseNonNegativeInt);\n      const d =\n          XmlUtils.parseAttr(timePoint, 'd', XmlUtils.parseNonNegativeInt);\n      const r = XmlUtils.parseAttr(timePoint, 'r', XmlUtils.parseInt);\n\n      // Adjust the start time to account for the presentation time offset.\n      if (t != null) {\n        t -= unscaledPresentationTimeOffset;\n      }\n\n      if (!d) {\n        shaka.log.warning(\n            '\"S\" element must have a duration:',\n            'ignoring the remaining \"S\" elements.', timePoint);\n        return timeline;\n      }\n\n      let startTime = t != null ? t : lastEndTime;\n\n      let repeat = r || 0;\n      if (repeat < 0) {\n        if (next) {\n          const nextStartTime =\n              XmlUtils.parseAttr(next, 't', XmlUtils.parseNonNegativeInt);\n          if (nextStartTime == null) {\n            shaka.log.warning(\n                'An \"S\" element cannot have a negative repeat',\n                'if the next \"S\" element does not have a valid start time:',\n                'ignoring the remaining \"S\" elements.', timePoint);\n            return timeline;\n          } else if (startTime >= nextStartTime) {\n            shaka.log.warning(\n                'An \"S\" element cannot have a negative repeatif its start ',\n                'time exceeds the next \"S\" element\\'s start time:',\n                'ignoring the remaining \"S\" elements.', timePoint);\n            return timeline;\n          }\n          repeat = Math.ceil((nextStartTime - startTime) / d) - 1;\n        } else {\n          if (periodDuration == Infinity) {\n            // The DASH spec. actually allows the last \"S\" element to have a\n            // negative repeat value even when the Period has an infinite\n            // duration.  No one uses this feature and no one ever should,\n            // ever.\n            shaka.log.warning(\n                'The last \"S\" element cannot have a negative repeat',\n                'if the Period has an infinite duration:',\n                'ignoring the last \"S\" element.', timePoint);\n            return timeline;\n          } else if (startTime / timescale >= periodDuration) {\n            shaka.log.warning(\n                'The last \"S\" element cannot have a negative repeat',\n                'if its start time exceeds the Period\\'s duration:',\n                'igoring the last \"S\" element.', timePoint);\n            return timeline;\n          }\n          repeat = Math.ceil((periodDuration * timescale - startTime) / d) - 1;\n        }\n      }\n\n      // The end of the last segment may be before the start of the current\n      // segment (a gap) or after the start of the current segment (an\n      // overlap). If there is a gap/overlap then stretch/compress the end of\n      // the last segment to the start of the current segment.\n      //\n      // Note: it is possible to move the start of the current segment to the\n      // end of the last segment, but this would complicate the computation of\n      // the $Time$ placeholder later on.\n      if ((timeline.length > 0) && (startTime != lastEndTime)) {\n        const delta = startTime - lastEndTime;\n\n        if (Math.abs(delta / timescale) >=\n            shaka.util.ManifestParserUtils.GAP_OVERLAP_TOLERANCE_SECONDS) {\n          shaka.log.warning(\n              'SegmentTimeline contains a large gap/overlap:',\n              'the content may have errors in it.', timePoint);\n        }\n\n        timeline[timeline.length - 1].end = startTime / timescale;\n      }\n\n      for (const _ of shaka.util.Iterables.range(repeat + 1)) {\n        shaka.util.Functional.ignored(_);\n        const endTime = startTime + d;\n        const item = {\n          start: startTime / timescale,\n          end: endTime / timescale,\n          unscaledStart: startTime,\n        };\n        timeline.push(item);\n\n        startTime = endTime;\n        lastEndTime = endTime;\n      }\n    }\n\n    return timeline;\n  }\n\n  /**\n   * Parses common segment info for SegmentList and SegmentTemplate.\n   *\n   * @param {shaka.dash.DashParser.Context} context\n   * @param {function(?shaka.dash.DashParser.InheritanceFrame):Element} callback\n   *   Gets the element that contains the segment info.\n   * @return {shaka.dash.MpdUtils.SegmentInfo}\n   */\n  static parseSegmentInfo(context, callback) {\n    goog.asserts.assert(\n        callback(context.representation),\n        'There must be at least one element of the given type.');\n    const MpdUtils = shaka.dash.MpdUtils;\n    const XmlUtils = shaka.util.XmlUtils;\n\n    const timescaleStr =\n        MpdUtils.inheritAttribute(context, callback, 'timescale');\n    let timescale = 1;\n    if (timescaleStr) {\n      timescale = XmlUtils.parsePositiveInt(timescaleStr) || 1;\n    }\n\n    const durationStr =\n        MpdUtils.inheritAttribute(context, callback, 'duration');\n    let segmentDuration = XmlUtils.parsePositiveInt(durationStr || '');\n    if (segmentDuration) {\n      segmentDuration /= timescale;\n    }\n\n    const startNumberStr =\n        MpdUtils.inheritAttribute(context, callback, 'startNumber');\n    const unscaledPresentationTimeOffset =\n        Number(MpdUtils.inheritAttribute(context, callback,\n            'presentationTimeOffset')) || 0;\n    let startNumber = XmlUtils.parseNonNegativeInt(startNumberStr || '');\n    if (startNumberStr == null || startNumber == null) {\n      startNumber = 1;\n    }\n\n    const timelineNode =\n        MpdUtils.inheritChild(context, callback, 'SegmentTimeline');\n    /** @type {Array.<shaka.dash.MpdUtils.TimeRange>} */\n    let timeline = null;\n    if (timelineNode) {\n      timeline = MpdUtils.createTimeline(\n          timelineNode, timescale, unscaledPresentationTimeOffset,\n          context.periodInfo.duration || Infinity);\n    }\n\n    const scaledPresentationTimeOffset =\n        (unscaledPresentationTimeOffset / timescale) || 0;\n    return {\n      timescale: timescale,\n      segmentDuration: segmentDuration,\n      startNumber: startNumber,\n      scaledPresentationTimeOffset: scaledPresentationTimeOffset,\n      unscaledPresentationTimeOffset: unscaledPresentationTimeOffset,\n      timeline: timeline,\n    };\n  }\n\n  /**\n   * Searches the inheritance for a Segment* with the given attribute.\n   *\n   * @param {shaka.dash.DashParser.Context} context\n   * @param {function(?shaka.dash.DashParser.InheritanceFrame):Element} callback\n   *   Gets the Element that contains the attribute to inherit.\n   * @param {string} attribute\n   * @return {?string}\n   */\n  static inheritAttribute(context, callback, attribute) {\n    const Functional = shaka.util.Functional;\n    goog.asserts.assert(\n        callback(context.representation),\n        'There must be at least one element of the given type');\n\n    /** @type {!Array.<!Element>} */\n    const nodes = [\n      callback(context.representation),\n      callback(context.adaptationSet),\n      callback(context.period),\n    ].filter(Functional.isNotNull);\n\n    return nodes\n        .map((s) => { return s.getAttribute(attribute); })\n        .reduce((all, part) => { return all || part; });\n  }\n\n  /**\n   * Searches the inheritance for a Segment* with the given child.\n   *\n   * @param {shaka.dash.DashParser.Context} context\n   * @param {function(?shaka.dash.DashParser.InheritanceFrame):Element} callback\n   *   Gets the Element that contains the child to inherit.\n   * @param {string} child\n   * @return {Element}\n   */\n  static inheritChild(context, callback, child) {\n    const Functional = shaka.util.Functional;\n    goog.asserts.assert(\n        callback(context.representation),\n        'There must be at least one element of the given type');\n\n    /** @type {!Array.<!Element>} */\n    const nodes = [\n      callback(context.representation),\n      callback(context.adaptationSet),\n      callback(context.period),\n    ].filter(Functional.isNotNull);\n\n    const XmlUtils = shaka.util.XmlUtils;\n    return nodes\n        .map((s) => { return XmlUtils.findChild(s, child); })\n        .reduce((all, part) => { return all || part; });\n  }\n\n  /**\n   * Follow the xlink link contained in the given element.\n   * It also strips the xlink properties off of the element,\n   * even if the process fails.\n   *\n   * @param {!Element} element\n   * @param {!shaka.extern.RetryParameters} retryParameters\n   * @param {boolean} failGracefully\n   * @param {string} baseUri\n   * @param {!shaka.net.NetworkingEngine} networkingEngine\n   * @param {number} linkDepth\n   * @return {!shaka.util.AbortableOperation.<!Element>}\n   * @private\n   */\n  static handleXlinkInElement_(\n      element, retryParameters, failGracefully, baseUri, networkingEngine,\n      linkDepth) {\n    const MpdUtils = shaka.dash.MpdUtils;\n    const XmlUtils = shaka.util.XmlUtils;\n    const Error = shaka.util.Error;\n    const ManifestParserUtils = shaka.util.ManifestParserUtils;\n    const NS = MpdUtils.XlinkNamespaceUri_;\n\n    const xlinkHref = XmlUtils.getAttributeNS(element, NS, 'href');\n    const xlinkActuate =\n        XmlUtils.getAttributeNS(element, NS, 'actuate') || 'onRequest';\n\n    // Remove the xlink properties, so it won't download again\n    // when re-processed.\n    for (const attribute of Array.from(element.attributes)) {\n      if (attribute.namespaceURI == NS) {\n        element.removeAttributeNS(attribute.namespaceURI, attribute.localName);\n      }\n    }\n\n    if (linkDepth >= 5) {\n      return shaka.util.AbortableOperation.failed(new Error(\n          Error.Severity.CRITICAL, Error.Category.MANIFEST,\n          Error.Code.DASH_XLINK_DEPTH_LIMIT));\n    }\n\n    if (xlinkActuate != 'onLoad') {\n      // Only xlink:actuate=\"onLoad\" is supported.\n      // When no value is specified, the assumed value is \"onRequest\".\n      return shaka.util.AbortableOperation.failed(new Error(\n          Error.Severity.CRITICAL, Error.Category.MANIFEST,\n          Error.Code.DASH_UNSUPPORTED_XLINK_ACTUATE));\n    }\n\n    // Resolve the xlink href, in case it's a relative URL.\n    const uris = ManifestParserUtils.resolveUris([baseUri], [xlinkHref]);\n\n    // Load in the linked elements.\n    const requestType = shaka.net.NetworkingEngine.RequestType.MANIFEST;\n    const request =\n        shaka.net.NetworkingEngine.makeRequest(uris, retryParameters);\n\n    const requestOperation = networkingEngine.request(requestType, request);\n    // The interface is abstract, but we know it was implemented with the\n    // more capable internal class.\n    goog.asserts.assert(\n        requestOperation instanceof shaka.util.AbortableOperation,\n        'Unexpected implementation of IAbortableOperation!');\n    // Satisfy the compiler with a cast.\n    const networkOperation =\n    /** @type {!shaka.util.AbortableOperation.<shaka.extern.Response>} */ (\n        requestOperation);\n\n    // Chain onto that operation.\n    return networkOperation.chain(\n        (response) => {\n          // This only supports the case where the loaded xml has a single\n          // top-level element.  If there are multiple roots, it will be\n          // rejected.\n          const rootElem =\n          shaka.util.XmlUtils.parseXml(response.data, element.tagName);\n          if (!rootElem) {\n            // It was not valid XML.\n            return shaka.util.AbortableOperation.failed(new Error(\n                Error.Severity.CRITICAL, Error.Category.MANIFEST,\n                Error.Code.DASH_INVALID_XML, xlinkHref));\n          }\n\n          // Now that there is no other possibility of the process erroring,\n          // the element can be changed further.\n\n          // Remove the current contents of the node.\n          while (element.childNodes.length) {\n            element.removeChild(element.childNodes[0]);\n          }\n\n          // Move the children of the loaded xml into the current element.\n          while (rootElem.childNodes.length) {\n            const child = rootElem.childNodes[0];\n            rootElem.removeChild(child);\n            element.appendChild(child);\n          }\n\n          // Move the attributes of the loaded xml into the current element.\n          for (const attribute of Array.from(rootElem.attributes)) {\n            element.setAttributeNode(attribute.cloneNode(/* deep= */ false));\n          }\n\n          return shaka.dash.MpdUtils.processXlinks(\n              element, retryParameters, failGracefully, uris[0],\n              networkingEngine, linkDepth + 1);\n        });\n  }\n\n  /**\n   * Filter the contents of a node recursively, replacing xlink links\n   * with their associated online data.\n   *\n   * @param {!Element} element\n   * @param {!shaka.extern.RetryParameters} retryParameters\n   * @param {boolean} failGracefully\n   * @param {string} baseUri\n   * @param {!shaka.net.NetworkingEngine} networkingEngine\n   * @param {number=} linkDepth, default set to 0\n   * @return {!shaka.util.AbortableOperation.<!Element>}\n   */\n  static processXlinks(\n      element, retryParameters, failGracefully, baseUri, networkingEngine,\n      linkDepth = 0) {\n    const MpdUtils = shaka.dash.MpdUtils;\n    const XmlUtils = shaka.util.XmlUtils;\n    const NS = MpdUtils.XlinkNamespaceUri_;\n\n    if (XmlUtils.getAttributeNS(element, NS, 'href')) {\n      let handled = MpdUtils.handleXlinkInElement_(\n          element, retryParameters, failGracefully, baseUri, networkingEngine,\n          linkDepth);\n      if (failGracefully) {\n        // Catch any error and go on.\n        handled = handled.chain(undefined, (error) => {\n          // handleXlinkInElement_ strips the xlink properties off of the\n          // element even if it fails, so calling processXlinks again will\n          // handle whatever contents the element natively has.\n          return MpdUtils.processXlinks(\n              element, retryParameters, failGracefully, baseUri,\n              networkingEngine, linkDepth);\n        });\n      }\n      return handled;\n    }\n\n    const childOperations = [];\n    for (const child of Array.from(element.childNodes)) {\n      if (child instanceof Element) {\n        const resolveToZeroString = 'urn:mpeg:dash:resolve-to-zero:2013';\n        if (XmlUtils.getAttributeNS(child, NS, 'href') == resolveToZeroString) {\n          // This is a 'resolve to zero' code; it means the element should\n          // be removed, as specified by the mpeg-dash rules for xlink.\n          element.removeChild(child);\n        } else if (child.tagName != 'SegmentTimeline') {\n          // Don't recurse into a SegmentTimeline since xlink attributes\n          // aren't valid in there and looking at each segment can take a long\n          // time with larger manifests.\n\n          // Replace the child with its processed form.\n          childOperations.push(shaka.dash.MpdUtils.processXlinks(\n              /** @type {!Element} */ (child), retryParameters, failGracefully,\n              baseUri, networkingEngine, linkDepth));\n        }\n      }\n    }\n\n    return shaka.util.AbortableOperation.all(childOperations).chain(() => {\n      return element;\n    });\n  }\n};\n\n\n/**\n * @typedef {{\n *   start: number,\n *   unscaledStart: number,\n *   end: number\n * }}\n *\n * @description\n * Defines a time range of a media segment.  Times are in seconds.\n *\n * @property {number} start\n *   The start time of the range.\n * @property {number} unscaledStart\n *   The start time of the range in representation timescale units.\n * @property {number} end\n *   The end time (exclusive) of the range.\n */\nshaka.dash.MpdUtils.TimeRange;\n\n\n/**\n * @typedef {{\n *   timescale: number,\n *   segmentDuration: ?number,\n *   startNumber: number,\n *   scaledPresentationTimeOffset: number,\n *   unscaledPresentationTimeOffset: number,\n *   timeline: Array.<shaka.dash.MpdUtils.TimeRange>\n * }}\n *\n * @description\n * Contains common information between SegmentList and SegmentTemplate items.\n *\n * @property {number} timescale\n *   The time-scale of the representation.\n * @property {?number} segmentDuration\n *   The duration of the segments in seconds, if given.\n * @property {number} startNumber\n *   The start number of the segments; 1 or greater.\n * @property {number} scaledPresentationTimeOffset\n *   The presentation time offset of the representation, in seconds.\n * @property {number} unscaledPresentationTimeOffset\n *   The presentation time offset of the representation, in timescale units.\n * @property {Array.<shaka.dash.MpdUtils.TimeRange>} timeline\n *   The timeline of the representation, if given.  Times in seconds.\n */\nshaka.dash.MpdUtils.SegmentInfo;\n\n\n/**\n * @const {string}\n * @private\n */\nshaka.dash.MpdUtils.XlinkNamespaceUri_ = 'http://www.w3.org/1999/xlink';\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.media.Mp4SegmentIndexParser');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.media.InitSegmentReference');\ngoog.require('shaka.media.SegmentReference');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.Functional');\ngoog.require('shaka.util.Iterables');\ngoog.require('shaka.util.Mp4Parser');\n\n\nshaka.media.Mp4SegmentIndexParser = class {\n  /**\n   * Parses SegmentReferences from an ISO BMFF SIDX structure.\n   * @param {BufferSource} sidxData The MP4's container's SIDX.\n   * @param {number} sidxOffset The SIDX's offset, in bytes, from the start of\n   *   the MP4 container.\n   * @param {!Array.<string>} uris The possible locations of the MP4 file that\n   *   contains the segments.\n   * @param {shaka.media.InitSegmentReference} initSegmentReference\n   * @param {number} timestampOffset\n   * @param {number} appendWindowStart\n   * @param {number} appendWindowEnd\n   * @return {!Array.<!shaka.media.SegmentReference>}\n   */\n  static parse(\n      sidxData, sidxOffset, uris, initSegmentReference, timestampOffset,\n      appendWindowStart, appendWindowEnd) {\n    const Mp4SegmentIndexParser = shaka.media.Mp4SegmentIndexParser;\n\n    let references;\n\n    const parser = new shaka.util.Mp4Parser()\n        .fullBox('sidx', (box) => {\n          references = Mp4SegmentIndexParser.parseSIDX_(\n              sidxOffset,\n              initSegmentReference,\n              timestampOffset,\n              appendWindowStart,\n              appendWindowEnd,\n              uris,\n              box);\n        });\n\n    if (sidxData) {\n      parser.parse(sidxData);\n    }\n\n    if (references) {\n      return references;\n    } else {\n      shaka.log.error('Invalid box type, expected \"sidx\".');\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.MEDIA,\n          shaka.util.Error.Code.MP4_SIDX_WRONG_BOX_TYPE);\n    }\n  }\n\n\n  /**\n   * Parse a SIDX box from the given reader.\n   *\n   * @param {number} sidxOffset\n   * @param {shaka.media.InitSegmentReference} initSegmentReference\n   * @param {number} timestampOffset\n   * @param {number} appendWindowStart\n   * @param {number} appendWindowEnd\n   * @param {!Array.<string>} uris The possible locations of the MP4 file that\n   *   contains the segments.\n   * @param {!shaka.extern.ParsedBox} box\n   * @return {!Array.<!shaka.media.SegmentReference>}\n   * @private\n   */\n  static parseSIDX_(\n      sidxOffset, initSegmentReference, timestampOffset, appendWindowStart,\n      appendWindowEnd, uris, box) {\n    goog.asserts.assert(\n        box.version != null,\n        'SIDX is a full box and should have a valid version.');\n\n    const references = [];\n\n    // Parse the SIDX structure.\n    // Skip reference_ID (32 bits).\n    box.reader.skip(4);\n\n    const timescale = box.reader.readUint32();\n\n    if (timescale == 0) {\n      shaka.log.error('Invalid timescale.');\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.MEDIA,\n          shaka.util.Error.Code.MP4_SIDX_INVALID_TIMESCALE);\n    }\n\n    let earliestPresentationTime;\n    let firstOffset;\n\n    if (box.version == 0) {\n      earliestPresentationTime = box.reader.readUint32();\n      firstOffset = box.reader.readUint32();\n    } else {\n      earliestPresentationTime = box.reader.readUint64();\n      firstOffset = box.reader.readUint64();\n    }\n\n    // Skip reserved (16 bits).\n    box.reader.skip(2);\n\n    // Add references.\n    const referenceCount = box.reader.readUint16();\n\n    // Subtract the presentation time offset\n    let unscaledStartTime = earliestPresentationTime;\n    let startByte = sidxOffset + box.size + firstOffset;\n\n    for (const _ of shaka.util.Iterables.range(referenceCount)) {\n      shaka.util.Functional.ignored(_);\n      // |chunk| is 1 bit for |referenceType|, and 31 bits for |referenceSize|.\n      const chunk = box.reader.readUint32();\n      const referenceType = (chunk & 0x80000000) >>> 31;\n      const referenceSize = chunk & 0x7FFFFFFF;\n\n      const subsegmentDuration = box.reader.readUint32();\n\n      // Skipping 1 bit for |startsWithSap|, 3 bits for |sapType|, and 28 bits\n      // for |sapDelta|.\n      box.reader.skip(4);\n\n      // If |referenceType| is 1 then the reference is to another SIDX.\n      // We do not support this.\n      if (referenceType == 1) {\n        shaka.log.error('Heirarchical SIDXs are not supported.');\n        throw new shaka.util.Error(\n            shaka.util.Error.Severity.CRITICAL,\n            shaka.util.Error.Category.MEDIA,\n            shaka.util.Error.Code.MP4_SIDX_TYPE_NOT_SUPPORTED);\n      }\n\n      // The media timestamps inside the container.\n      const nativeStartTime = unscaledStartTime / timescale;\n      const nativeEndTime =\n          (unscaledStartTime + subsegmentDuration) / timescale;\n\n      references.push(\n          new shaka.media.SegmentReference(\n              nativeStartTime + timestampOffset,\n              nativeEndTime + timestampOffset,\n              (() => { return uris; }),\n              startByte,\n              startByte + referenceSize - 1,\n              initSegmentReference,\n              timestampOffset,\n              appendWindowStart,\n              appendWindowEnd));\n\n      unscaledStartTime += subsegmentDuration;\n      startByte += referenceSize;\n    }\n\n    box.parser.stop();\n    return references;\n  }\n};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.util.EbmlElement');\ngoog.provide('shaka.util.EbmlParser');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.util.BufferUtils');\ngoog.require('shaka.util.DataViewReader');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.Iterables');\n\n\n/**\n * @summary\n * Extensible Binary Markup Language (EBML) parser.\n */\nshaka.util.EbmlParser = class {\n  /**\n   * @param {BufferSource} data\n   */\n  constructor(data) {\n    /** @private {!DataView} */\n    this.dataView_ = shaka.util.BufferUtils.toDataView(data);\n\n    /** @private {!shaka.util.DataViewReader} */\n    this.reader_ = new shaka.util.DataViewReader(\n        this.dataView_, shaka.util.DataViewReader.Endianness.BIG_ENDIAN);\n  }\n\n\n  /**\n   * @return {boolean} True if the parser has more data, false otherwise.\n   */\n  hasMoreData() {\n    return this.reader_.hasMoreData();\n  }\n\n\n  /**\n   * Parses an EBML element from the parser's current position, and advances\n   * the parser.\n   * @return {!shaka.util.EbmlElement} The EBML element.\n   * @see http://matroska.org/technical/specs/rfc/index.html\n   */\n  parseElement() {\n    const id = this.parseId_();\n\n    // Parse the element's size.\n    const vint = this.parseVint_();\n    let size;\n    if (shaka.util.EbmlParser.isDynamicSizeValue_(vint)) {\n      // If this has an unknown size, assume that it takes up the rest of the\n      // data.\n      size = this.dataView_.byteLength - this.reader_.getPosition();\n    } else {\n      size = shaka.util.EbmlParser.getVintValue_(vint);\n    }\n\n    // Note that if the element's size is larger than the buffer then we are\n    // parsing a \"partial element\". This may occur if for example we are\n    // parsing the beginning of some WebM container data, but our buffer does\n    // not contain the entire WebM container data.\n    const elementSize =\n        this.reader_.getPosition() + size <= this.dataView_.byteLength ?\n        size :\n        this.dataView_.byteLength - this.reader_.getPosition();\n\n    const dataView = shaka.util.BufferUtils.toDataView(\n        this.dataView_, this.reader_.getPosition(), elementSize);\n\n    this.reader_.skip(elementSize);\n\n    return new shaka.util.EbmlElement(id, dataView);\n  }\n\n\n  /**\n   * Parses an EBML ID from the parser's current position, and advances the\n   * parser.\n   * @return {number} The EBML ID.\n   * @private\n   */\n  parseId_() {\n    const vint = this.parseVint_();\n\n    if (vint.length > 7) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.MEDIA,\n          shaka.util.Error.Code.EBML_OVERFLOW);\n    }\n\n    let id = 0;\n    for (const /* byte */ b of vint) {\n      // Note that we cannot use << since |value| may exceed 32 bits.\n      id = (256 * id) + b;\n    }\n\n    return id;\n  }\n\n\n  /**\n   * Parses a variable sized integer from the parser's current position, and\n   * advances the parser.\n   * For example:\n   *   1 byte  wide: 1xxx xxxx\n   *   2 bytes wide: 01xx xxxx xxxx xxxx\n   *   3 bytes wide: 001x xxxx xxxx xxxx xxxx xxxx\n   * @return {!Uint8Array} The variable sized integer.\n   * @private\n   */\n  parseVint_() {\n    const position = this.reader_.getPosition();\n    const firstByte = this.reader_.readUint8();\n    if (firstByte == 0) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.MEDIA,\n          shaka.util.Error.Code.EBML_OVERFLOW);\n    }\n\n    // Determine the index of the highest bit set.\n    const index = Math.floor(Math.log2(firstByte));\n    const numBytes = 8 - index;\n    goog.asserts.assert(numBytes <= 8 && numBytes >= 1, 'Incorrect log2 value');\n    this.reader_.skip(numBytes - 1);\n    return shaka.util.BufferUtils.toUint8(this.dataView_, position, numBytes);\n  }\n\n\n  /**\n   * Gets the value of a variable sized integer.\n   * For example, the x's below are part of the vint's value.\n   *    7-bit value: 1xxx xxxx\n   *   14-bit value: 01xx xxxx xxxx xxxx\n   *   21-bit value: 001x xxxx xxxx xxxx xxxx xxxx\n   * @param {!Uint8Array} vint The variable sized integer.\n   * @return {number} The value of the variable sized integer.\n   * @private\n   */\n  static getVintValue_(vint) {\n    // If |vint| is 8 bytes wide then we must ensure that it does not have more\n    // than 53 meaningful bits. For example, assume |vint| is 8 bytes wide,\n    // so it has the following structure,\n    // 0000 0001 | xxxx xxxx ...\n    // Thus, the first 3 bits following the first byte of |vint| must be 0.\n    if ((vint.length == 8) && (vint[1] & 0xe0)) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.MEDIA,\n          shaka.util.Error.Code.JS_INTEGER_OVERFLOW);\n    }\n\n    let value = 0;\n    for (const {item, i} of shaka.util.Iterables.enumerate(vint)) {\n      if (i == 0) {\n        // Mask out the first few bits of |vint|'s first byte to get the most\n        // significant bits of |vint|'s value. If |vint| is 8 bytes wide then\n        // |value| will be set to 0.\n        const mask = 0x1 << (8 - vint.length);\n        value = item & (mask - 1);\n      } else {\n        // Note that we cannot use << since |value| may exceed 32 bits.\n        value = (256 * value) + item;\n      }\n    }\n\n    return value;\n  }\n\n\n  /**\n   * Checks if the given variable sized integer represents a dynamic size value.\n   * @param {!Uint8Array} vint The variable sized integer.\n   * @return {boolean} true if |vint| represents a dynamic size value,\n   *   false otherwise.\n   * @private\n   */\n  static isDynamicSizeValue_(vint) {\n    const EbmlParser = shaka.util.EbmlParser;\n    const BufferUtils = shaka.util.BufferUtils;\n\n    for (const dynamicSizeConst of EbmlParser.DYNAMIC_SIZES) {\n      if (BufferUtils.equal(vint, new Uint8Array(dynamicSizeConst))) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n};\n\n\n/**\n * A list of EBML dynamic size constants.\n * @const {!Array.<!Array.<number>>}\n */\nshaka.util.EbmlParser.DYNAMIC_SIZES = [\n  [0xff],\n  [0x7f, 0xff],\n  [0x3f, 0xff, 0xff],\n  [0x1f, 0xff, 0xff, 0xff],\n  [0x0f, 0xff, 0xff, 0xff, 0xff],\n  [0x07, 0xff, 0xff, 0xff, 0xff, 0xff],\n  [0x03, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff],\n  [0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff],\n];\n\n\nshaka.util.EbmlElement = class {\n  /**\n   * @param {number} id The ID.\n   * @param {!DataView} dataView The DataView.\n   */\n  constructor(id, dataView) {\n    /** @type {number} */\n    this.id = id;\n\n    /** @private {!DataView} */\n    this.dataView_ = dataView;\n  }\n\n\n  /**\n   * Gets the element's offset from the beginning of the buffer.\n   * @return {number}\n   */\n  getOffset() {\n    return this.dataView_.byteOffset;\n  }\n\n\n  /**\n   * Interpret the element's data as a list of sub-elements.\n   * @return {!shaka.util.EbmlParser} A parser over the sub-elements.\n   */\n  createParser() {\n    return new shaka.util.EbmlParser(this.dataView_);\n  }\n\n\n  /**\n   * Interpret the element's data as an unsigned integer.\n   * @return {number}\n   */\n  getUint() {\n    if (this.dataView_.byteLength > 8) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.MEDIA,\n          shaka.util.Error.Code.EBML_OVERFLOW);\n    }\n\n    // Ensure we have at most 53 meaningful bits.\n    if ((this.dataView_.byteLength == 8) &&\n        (this.dataView_.getUint8(0) & 0xe0)) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.MEDIA,\n          shaka.util.Error.Code.JS_INTEGER_OVERFLOW);\n    }\n\n    let value = 0;\n\n    for (const i of shaka.util.Iterables.range(this.dataView_.byteLength)) {\n      const chunk = this.dataView_.getUint8(i);\n      value = (256 * value) + chunk;\n    }\n\n    return value;\n  }\n\n\n  /**\n   * Interpret the element's data as a floating point number\n   * (32 bits or 64 bits). 80-bit floating point numbers are not supported.\n   * @return {number}\n   */\n  getFloat() {\n    if (this.dataView_.byteLength == 4) {\n      return this.dataView_.getFloat32(0);\n    } else if (this.dataView_.byteLength == 8) {\n      return this.dataView_.getFloat64(0);\n    } else {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.MEDIA,\n          shaka.util.Error.Code.EBML_BAD_FLOATING_POINT_SIZE);\n    }\n  }\n};\n\n\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.media.WebmSegmentIndexParser');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.media.InitSegmentReference');\ngoog.require('shaka.media.SegmentReference');\ngoog.require('shaka.util.EbmlElement');\ngoog.require('shaka.util.EbmlParser');\ngoog.require('shaka.util.Error');\n\n\nshaka.media.WebmSegmentIndexParser = class {\n  /**\n   * Parses SegmentReferences from a WebM container.\n   * @param {BufferSource} cuesData The WebM container's \"Cueing Data\" section.\n   * @param {BufferSource} initData The WebM container's headers.\n   * @param {!Array.<string>} uris The possible locations of the WebM file that\n   *   contains the segments.\n   * @param {shaka.media.InitSegmentReference} initSegmentReference\n   * @param {number} timestampOffset\n   * @param {number} appendWindowStart\n   * @param {number} appendWindowEnd\n   * @return {!Array.<!shaka.media.SegmentReference>}\n   * @see http://www.matroska.org/technical/specs/index.html\n   * @see http://www.webmproject.org/docs/container/\n   */\n  static parse(\n      cuesData, initData, uris, initSegmentReference, timestampOffset,\n      appendWindowStart, appendWindowEnd) {\n    const tuple =\n        shaka.media.WebmSegmentIndexParser.parseWebmContainer_(initData);\n    const parser = new shaka.util.EbmlParser(cuesData);\n    const cuesElement = parser.parseElement();\n    if (cuesElement.id != shaka.media.WebmSegmentIndexParser.CUES_ID) {\n      shaka.log.error('Not a Cues element.');\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.MEDIA,\n          shaka.util.Error.Code.WEBM_CUES_ELEMENT_MISSING);\n    }\n\n    return shaka.media.WebmSegmentIndexParser.parseCues_(\n        cuesElement, tuple.segmentOffset, tuple.timecodeScale, tuple.duration,\n        uris, initSegmentReference, timestampOffset, appendWindowStart,\n        appendWindowEnd);\n  }\n\n\n  /**\n   * Parses a WebM container to get the segment's offset, timecode scale, and\n   * duration.\n   *\n   * @param {BufferSource} initData\n   * @return {{segmentOffset: number, timecodeScale: number, duration: number}}\n   *   The segment's offset in bytes, the segment's timecode scale in seconds,\n   *   and the duration in seconds.\n   * @private\n   */\n  static parseWebmContainer_(initData) {\n    const parser = new shaka.util.EbmlParser(initData);\n\n    // Check that the WebM container data starts with the EBML header, but\n    // skip its contents.\n    const ebmlElement = parser.parseElement();\n    if (ebmlElement.id != shaka.media.WebmSegmentIndexParser.EBML_ID) {\n      shaka.log.error('Not an EBML element.');\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.MEDIA,\n          shaka.util.Error.Code.WEBM_EBML_HEADER_ELEMENT_MISSING);\n    }\n\n    const segmentElement = parser.parseElement();\n    if (segmentElement.id != shaka.media.WebmSegmentIndexParser.SEGMENT_ID) {\n      shaka.log.error('Not a Segment element.');\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.MEDIA,\n          shaka.util.Error.Code.WEBM_SEGMENT_ELEMENT_MISSING);\n    }\n\n    // This value is used as the initial offset to the first referenced segment.\n    const segmentOffset = segmentElement.getOffset();\n\n    // Parse the Segment element to get the segment info.\n    const segmentInfo = shaka.media.WebmSegmentIndexParser.parseSegment_(\n        segmentElement);\n    return {\n      segmentOffset: segmentOffset,\n      timecodeScale: segmentInfo.timecodeScale,\n      duration: segmentInfo.duration,\n    };\n  }\n\n\n  /**\n   * Parses a WebM Info element to get the segment's timecode scale and\n   * duration.\n   * @param {!shaka.util.EbmlElement} segmentElement\n   * @return {{timecodeScale: number, duration: number}} The segment's timecode\n   *   scale in seconds and duration in seconds.\n   * @private\n   */\n  static parseSegment_(segmentElement) {\n    const parser = segmentElement.createParser();\n\n    // Find the Info element.\n    let infoElement = null;\n    while (parser.hasMoreData()) {\n      const elem = parser.parseElement();\n      if (elem.id != shaka.media.WebmSegmentIndexParser.INFO_ID) {\n        continue;\n      }\n\n      infoElement = elem;\n\n      break;\n    }\n\n    if (!infoElement) {\n      shaka.log.error('Not an Info element.');\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.MEDIA,\n          shaka.util.Error.Code.WEBM_INFO_ELEMENT_MISSING);\n    }\n\n    return shaka.media.WebmSegmentIndexParser.parseInfo_(infoElement);\n  }\n\n\n  /**\n   * Parses a WebM Info element to get the segment's timecode scale and\n   * duration.\n   * @param {!shaka.util.EbmlElement} infoElement\n   * @return {{timecodeScale: number, duration: number}} The segment's timecode\n   *   scale in seconds and duration in seconds.\n   * @private\n   */\n  static parseInfo_(infoElement) {\n    const parser = infoElement.createParser();\n\n    // The timecode scale factor in units of [nanoseconds / T], where [T] are\n    // the units used to express all other time values in the WebM container.\n    // By default it's assumed that [T] == [milliseconds].\n    let timecodeScaleNanoseconds = 1000000;\n    /** @type {?number} */\n    let durationScale = null;\n\n    while (parser.hasMoreData()) {\n      const elem = parser.parseElement();\n      if (elem.id == shaka.media.WebmSegmentIndexParser.TIMECODE_SCALE_ID) {\n        timecodeScaleNanoseconds = elem.getUint();\n      } else if (elem.id == shaka.media.WebmSegmentIndexParser.DURATION_ID) {\n        durationScale = elem.getFloat();\n      }\n    }\n    if (durationScale == null) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.MEDIA,\n          shaka.util.Error.Code.WEBM_DURATION_ELEMENT_MISSING);\n    }\n\n    // The timecode scale factor in units of [seconds / T].\n    const timecodeScale = timecodeScaleNanoseconds / 1000000000;\n    // The duration is stored in units of [T]\n    const durationSeconds = durationScale * timecodeScale;\n\n    return {timecodeScale: timecodeScale, duration: durationSeconds};\n  }\n\n\n  /**\n   * Parses a WebM CuesElement.\n   * @param {!shaka.util.EbmlElement} cuesElement\n   * @param {number} segmentOffset\n   * @param {number} timecodeScale\n   * @param {number} duration\n   * @param {!Array.<string>} uris\n   * @param {shaka.media.InitSegmentReference} initSegmentReference\n   * @param {number} timestampOffset\n   * @param {number} appendWindowStart\n   * @param {number} appendWindowEnd\n   * @return {!Array.<!shaka.media.SegmentReference>}\n   * @private\n   */\n  static parseCues_(cuesElement, segmentOffset, timecodeScale, duration,\n      uris, initSegmentReference, timestampOffset, appendWindowStart,\n      appendWindowEnd) {\n    const references = [];\n    const getUris = () => uris;\n\n    const parser = cuesElement.createParser();\n\n    let lastTime = null;\n    let lastOffset = null;\n\n    while (parser.hasMoreData()) {\n      const elem = parser.parseElement();\n      if (elem.id != shaka.media.WebmSegmentIndexParser.CUE_POINT_ID) {\n        continue;\n      }\n\n      const tuple = shaka.media.WebmSegmentIndexParser.parseCuePoint_(elem);\n      if (!tuple) {\n        continue;\n      }\n\n      // Subtract the presentation time offset from the unscaled time\n      const currentTime = timecodeScale * tuple.unscaledTime;\n      const currentOffset = segmentOffset + tuple.relativeOffset;\n\n      if (lastTime != null) {\n        goog.asserts.assert(lastOffset != null, 'last offset cannot be null');\n\n        references.push(\n            new shaka.media.SegmentReference(\n                lastTime + timestampOffset,\n                currentTime + timestampOffset,\n                getUris,\n                /* startByte= */ lastOffset, /* endByte= */ currentOffset - 1,\n                initSegmentReference,\n                timestampOffset,\n                appendWindowStart,\n                appendWindowEnd));\n      }\n\n      lastTime = currentTime;\n      lastOffset = currentOffset;\n    }\n\n    if (lastTime != null) {\n      goog.asserts.assert(lastOffset != null, 'last offset cannot be null');\n\n      references.push(\n          new shaka.media.SegmentReference(\n              lastTime + timestampOffset,\n              duration + timestampOffset,\n              getUris,\n              /* startByte= */ lastOffset, /* endByte= */ null,\n              initSegmentReference,\n              timestampOffset,\n              appendWindowStart,\n              appendWindowEnd));\n    }\n\n    return references;\n  }\n\n\n  /**\n   * Parses a WebM CuePointElement to get an \"unadjusted\" segment reference.\n   * @param {shaka.util.EbmlElement} cuePointElement\n   * @return {{unscaledTime: number, relativeOffset: number}} The referenced\n   *   segment's start time in units of [T] (see parseInfo_()), and the\n   *   referenced segment's offset in bytes, relative to a WebM Segment\n   *   element.\n   * @private\n   */\n  static parseCuePoint_(cuePointElement) {\n    const parser = cuePointElement.createParser();\n\n    // Parse CueTime element.\n    const cueTimeElement = parser.parseElement();\n    if (cueTimeElement.id != shaka.media.WebmSegmentIndexParser.CUE_TIME_ID) {\n      shaka.log.warning('Not a CueTime element.');\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.MEDIA,\n          shaka.util.Error.Code.WEBM_CUE_TIME_ELEMENT_MISSING);\n    }\n    const unscaledTime = cueTimeElement.getUint();\n\n    // Parse CueTrackPositions element.\n    const cueTrackPositionsElement = parser.parseElement();\n    if (cueTrackPositionsElement.id !=\n        shaka.media.WebmSegmentIndexParser.CUE_TRACK_POSITIONS_ID) {\n      shaka.log.warning('Not a CueTrackPositions element.');\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.MEDIA,\n          shaka.util.Error.Code.WEBM_CUE_TRACK_POSITIONS_ELEMENT_MISSING);\n    }\n\n    const cueTrackParser = cueTrackPositionsElement.createParser();\n    let relativeOffset = 0;\n\n    while (cueTrackParser.hasMoreData()) {\n      const elem = cueTrackParser.parseElement();\n      if (elem.id != shaka.media.WebmSegmentIndexParser.CUE_CLUSTER_POSITION) {\n        continue;\n      }\n\n      relativeOffset = elem.getUint();\n      break;\n    }\n\n    return {unscaledTime: unscaledTime, relativeOffset: relativeOffset};\n  }\n};\n\n\n/** @const {number} */\nshaka.media.WebmSegmentIndexParser.EBML_ID = 0x1a45dfa3;\n\n\n/** @const {number} */\nshaka.media.WebmSegmentIndexParser.SEGMENT_ID = 0x18538067;\n\n\n/** @const {number} */\nshaka.media.WebmSegmentIndexParser.INFO_ID = 0x1549a966;\n\n\n/** @const {number} */\nshaka.media.WebmSegmentIndexParser.TIMECODE_SCALE_ID = 0x2ad7b1;\n\n\n/** @const {number} */\nshaka.media.WebmSegmentIndexParser.DURATION_ID = 0x4489;\n\n\n/** @const {number} */\nshaka.media.WebmSegmentIndexParser.CUES_ID = 0x1c53bb6b;\n\n\n/** @const {number} */\nshaka.media.WebmSegmentIndexParser.CUE_POINT_ID = 0xbb;\n\n\n/** @const {number} */\nshaka.media.WebmSegmentIndexParser.CUE_TIME_ID = 0xb3;\n\n\n/** @const {number} */\nshaka.media.WebmSegmentIndexParser.CUE_TRACK_POSITIONS_ID = 0xb7;\n\n\n/** @const {number} */\nshaka.media.WebmSegmentIndexParser.CUE_CLUSTER_POSITION = 0xf1;\n\n\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.dash.SegmentBase');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.dash.MpdUtils');\ngoog.require('shaka.log');\ngoog.require('shaka.media.InitSegmentReference');\ngoog.require('shaka.media.Mp4SegmentIndexParser');\ngoog.require('shaka.media.SegmentIndex');\ngoog.require('shaka.media.WebmSegmentIndexParser');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.ManifestParserUtils');\ngoog.require('shaka.util.ObjectUtils');\ngoog.require('shaka.util.XmlUtils');\ngoog.requireType('shaka.dash.DashParser');\ngoog.requireType('shaka.media.PresentationTimeline');\ngoog.requireType('shaka.media.SegmentReference');\n\n\n/**\n * @summary A set of functions for parsing SegmentBase elements.\n */\nshaka.dash.SegmentBase = class {\n  /**\n   * Creates an init segment reference from a Context object.\n   *\n   * @param {shaka.dash.DashParser.Context} context\n   * @param {function(?shaka.dash.DashParser.InheritanceFrame):Element} callback\n   * @return {shaka.media.InitSegmentReference}\n   */\n  static createInitSegment(context, callback) {\n    const MpdUtils = shaka.dash.MpdUtils;\n    const XmlUtils = shaka.util.XmlUtils;\n    const ManifestParserUtils = shaka.util.ManifestParserUtils;\n\n    const initialization =\n        MpdUtils.inheritChild(context, callback, 'Initialization');\n    if (!initialization) {\n      return null;\n    }\n\n    let resolvedUris = context.representation.baseUris;\n    const uri = initialization.getAttribute('sourceURL');\n    if (uri) {\n      resolvedUris = ManifestParserUtils.resolveUris(\n          context.representation.baseUris, [uri]);\n    }\n\n    let startByte = 0;\n    let endByte = null;\n    const range =\n        XmlUtils.parseAttr(initialization, 'range', XmlUtils.parseRange);\n    if (range) {\n      startByte = range.start;\n      endByte = range.end;\n    }\n\n    const getUris = () => resolvedUris;\n    return new shaka.media.InitSegmentReference(getUris, startByte, endByte);\n  }\n\n  /**\n   * Creates a new StreamInfo object.\n   *\n   * @param {shaka.dash.DashParser.Context} context\n   * @param {shaka.dash.DashParser.RequestInitSegmentCallback}\n   *     requestInitSegment\n   * @return {shaka.dash.DashParser.StreamInfo}\n   */\n  static createStreamInfo(context, requestInitSegment) {\n    goog.asserts.assert(context.representation.segmentBase,\n        'Should only be called with SegmentBase');\n    // Since SegmentBase does not need updates, simply treat any call as\n    // the initial parse.\n    const MpdUtils = shaka.dash.MpdUtils;\n    const SegmentBase = shaka.dash.SegmentBase;\n    const XmlUtils = shaka.util.XmlUtils;\n\n    const unscaledPresentationTimeOffset = Number(MpdUtils.inheritAttribute(\n        context, SegmentBase.fromInheritance_, 'presentationTimeOffset')) || 0;\n\n    const timescaleStr = MpdUtils.inheritAttribute(\n        context, SegmentBase.fromInheritance_, 'timescale');\n    let timescale = 1;\n    if (timescaleStr) {\n      timescale = XmlUtils.parsePositiveInt(timescaleStr) || 1;\n    }\n\n    const scaledPresentationTimeOffset =\n        (unscaledPresentationTimeOffset / timescale) || 0;\n\n    const initSegmentReference =\n        SegmentBase.createInitSegment(context, SegmentBase.fromInheritance_);\n\n    // Throws an immediate error if the format is unsupported.\n    SegmentBase.checkSegmentIndexRangeSupport_(context, initSegmentReference);\n\n    // Direct fields of context will be reassigned by the parser before\n    // generateSegmentIndex is called.  So we must make a shallow copy first,\n    // and use that in the generateSegmentIndex callbacks.\n    const shallowCopyOfContext =\n        shaka.util.ObjectUtils.shallowCloneObject(context);\n\n    return {\n      generateSegmentIndex: () => {\n        return SegmentBase.generateSegmentIndex_(\n            shallowCopyOfContext, requestInitSegment, initSegmentReference,\n            scaledPresentationTimeOffset);\n      },\n    };\n  }\n\n  /**\n   * Creates a SegmentIndex for the given URIs and context.\n   *\n   * @param {shaka.dash.DashParser.Context} context\n   * @param {shaka.dash.DashParser.RequestInitSegmentCallback}\n   *     requestInitSegment\n   * @param {shaka.media.InitSegmentReference} initSegmentReference\n   * @param {!Array.<string>} uris\n   * @param {number} startByte\n   * @param {?number} endByte\n   * @param {number} scaledPresentationTimeOffset\n   * @return {!Promise.<shaka.media.SegmentIndex>}\n   */\n  static async generateSegmentIndexFromUris(\n      context, requestInitSegment, initSegmentReference, uris, startByte,\n      endByte, scaledPresentationTimeOffset) {\n    // Unpack context right away, before we start an async process.\n    // This immunizes us against changes to the context object later.\n    /** @type {shaka.media.PresentationTimeline} */\n    const presentationTimeline = context.presentationTimeline;\n    const fitLast = !context.dynamic || !context.periodInfo.isLastPeriod;\n    const periodStart = context.periodInfo.start;\n    const periodDuration = context.periodInfo.duration;\n    const containerType = context.representation.mimeType.split('/')[1];\n\n    // Create a local variable to bind to so we can set to null to help the GC.\n    let localRequest = requestInitSegment;\n    let segmentIndex = null;\n\n    const responses = [\n      localRequest(uris, startByte, endByte),\n      containerType == 'webm' ?\n          localRequest(\n              initSegmentReference.getUris(),\n              initSegmentReference.startByte,\n              initSegmentReference.endByte) :\n          null,\n    ];\n\n    localRequest = null;\n    const results = await Promise.all(responses);\n    const indexData = results[0];\n    const initData = results[1] || null;\n    /** @type {Array.<!shaka.media.SegmentReference>} */\n    let references = null;\n\n    const timestampOffset = periodStart - scaledPresentationTimeOffset;\n    const appendWindowStart = periodStart;\n    const appendWindowEnd = periodDuration ?\n        periodStart + periodDuration : Infinity;\n\n    if (containerType == 'mp4') {\n      references = shaka.media.Mp4SegmentIndexParser.parse(\n          indexData, startByte, uris, initSegmentReference, timestampOffset,\n          appendWindowStart, appendWindowEnd);\n    } else {\n      goog.asserts.assert(initData, 'WebM requires init data');\n      references = shaka.media.WebmSegmentIndexParser.parse(\n          indexData, initData, uris, initSegmentReference, timestampOffset,\n          appendWindowStart, appendWindowEnd);\n    }\n\n    presentationTimeline.notifySegments(references);\n\n    // Since containers are never updated, we don't need to store the\n    // segmentIndex in the map.\n    goog.asserts.assert(!segmentIndex,\n        'Should not call generateSegmentIndex twice');\n\n    segmentIndex = new shaka.media.SegmentIndex(references);\n    if (fitLast) {\n      segmentIndex.fit(appendWindowStart, appendWindowEnd);\n    }\n    return segmentIndex;\n  }\n\n  /**\n   * @param {?shaka.dash.DashParser.InheritanceFrame} frame\n   * @return {Element}\n   * @private\n   */\n  static fromInheritance_(frame) {\n    return frame.segmentBase;\n  }\n\n  /**\n   * Compute the byte range of the segment index from the container.\n   *\n   * @param {shaka.dash.DashParser.Context} context\n   * @return {?{start: number, end: number}}\n   * @private\n   */\n  static computeIndexRange_(context) {\n    const MpdUtils = shaka.dash.MpdUtils;\n    const SegmentBase = shaka.dash.SegmentBase;\n    const XmlUtils = shaka.util.XmlUtils;\n\n    const representationIndex = MpdUtils.inheritChild(\n        context, SegmentBase.fromInheritance_, 'RepresentationIndex');\n    const indexRangeElem = MpdUtils.inheritAttribute(\n        context, SegmentBase.fromInheritance_, 'indexRange');\n\n    let indexRange = XmlUtils.parseRange(indexRangeElem || '');\n    if (representationIndex) {\n      indexRange = XmlUtils.parseAttr(\n          representationIndex, 'range', XmlUtils.parseRange, indexRange);\n    }\n    return indexRange;\n  }\n\n  /**\n   * Compute the URIs of the segment index from the container.\n   *\n   * @param {shaka.dash.DashParser.Context} context\n   * @return {!Array.<string>}\n   * @private\n   */\n  static computeIndexUris_(context) {\n    const ManifestParserUtils = shaka.util.ManifestParserUtils;\n    const MpdUtils = shaka.dash.MpdUtils;\n    const SegmentBase = shaka.dash.SegmentBase;\n\n    const representationIndex = MpdUtils.inheritChild(\n        context, SegmentBase.fromInheritance_, 'RepresentationIndex');\n\n    let indexUris = context.representation.baseUris;\n    if (representationIndex) {\n      const representationUri = representationIndex.getAttribute('sourceURL');\n      if (representationUri) {\n        indexUris = ManifestParserUtils.resolveUris(\n            context.representation.baseUris, [representationUri]);\n      }\n    }\n\n    return indexUris;\n  }\n\n  /**\n   * Check if this type of segment index is supported.  This allows for\n   * immediate errors during parsing, as opposed to an async error from\n   * createSegmentIndex().\n   *\n   * Also checks for a valid byte range, which is not required for callers from\n   * SegmentTemplate.\n   *\n   * @param {shaka.dash.DashParser.Context} context\n   * @param {shaka.media.InitSegmentReference} initSegmentReference\n   * @private\n   */\n  static checkSegmentIndexRangeSupport_(context, initSegmentReference) {\n    const SegmentBase = shaka.dash.SegmentBase;\n\n    SegmentBase.checkSegmentIndexSupport(context, initSegmentReference);\n\n    const indexRange = SegmentBase.computeIndexRange_(context);\n    if (!indexRange) {\n      shaka.log.error(\n          'SegmentBase does not contain sufficient segment information:',\n          'the SegmentBase does not contain @indexRange',\n          'or a RepresentationIndex element.',\n          context.representation);\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.MANIFEST,\n          shaka.util.Error.Code.DASH_NO_SEGMENT_INFO);\n    }\n  }\n\n  /**\n   * Check if this type of segment index is supported.  This allows for\n   * immediate errors during parsing, as opposed to an async error from\n   * createSegmentIndex().\n   *\n   * @param {shaka.dash.DashParser.Context} context\n   * @param {shaka.media.InitSegmentReference} initSegmentReference\n   */\n  static checkSegmentIndexSupport(context, initSegmentReference) {\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n\n    const contentType = context.representation.contentType;\n    const containerType = context.representation.mimeType.split('/')[1];\n\n    if (contentType != ContentType.TEXT && containerType != 'mp4' &&\n        containerType != 'webm') {\n      shaka.log.error(\n          'SegmentBase specifies an unsupported container type.',\n          context.representation);\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.MANIFEST,\n          shaka.util.Error.Code.DASH_UNSUPPORTED_CONTAINER);\n    }\n\n    if ((containerType == 'webm') && !initSegmentReference) {\n      shaka.log.error(\n          'SegmentBase does not contain sufficient segment information:',\n          'the SegmentBase uses a WebM container,',\n          'but does not contain an Initialization element.',\n          context.representation);\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.MANIFEST,\n          shaka.util.Error.Code.DASH_WEBM_MISSING_INIT);\n    }\n  }\n\n  /**\n   * Generate a SegmentIndex from a Context object.\n   *\n   * @param {shaka.dash.DashParser.Context} context\n   * @param {shaka.dash.DashParser.RequestInitSegmentCallback}\n   *     requestInitSegment\n   * @param {shaka.media.InitSegmentReference} initSegmentReference\n   * @param {number} scaledPresentationTimeOffset\n   * @return {!Promise.<shaka.media.SegmentIndex>}\n   * @private\n   */\n  static generateSegmentIndex_(\n      context, requestInitSegment, initSegmentReference,\n      scaledPresentationTimeOffset) {\n    const SegmentBase = shaka.dash.SegmentBase;\n\n    const indexUris = SegmentBase.computeIndexUris_(context);\n    const indexRange = SegmentBase.computeIndexRange_(context);\n    goog.asserts.assert(indexRange, 'Index range should not be null!');\n\n    return shaka.dash.SegmentBase.generateSegmentIndexFromUris(\n        context, requestInitSegment, initSegmentReference, indexUris,\n        indexRange.start, indexRange.end,\n        scaledPresentationTimeOffset);\n  }\n};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.dash.SegmentList');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.dash.MpdUtils');\ngoog.require('shaka.dash.SegmentBase');\ngoog.require('shaka.log');\ngoog.require('shaka.media.InitSegmentReference');\ngoog.require('shaka.media.SegmentIndex');\ngoog.require('shaka.media.SegmentReference');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.Functional');\ngoog.require('shaka.util.Iterables');\ngoog.require('shaka.util.ManifestParserUtils');\ngoog.require('shaka.util.XmlUtils');\ngoog.requireType('shaka.dash.DashParser');\n\n\n/**\n * @summary A set of functions for parsing SegmentList elements.\n */\nshaka.dash.SegmentList = class {\n  /**\n   * Creates a new StreamInfo object.\n   * Updates the existing SegmentIndex, if any.\n   *\n   * @param {shaka.dash.DashParser.Context} context\n   * @param {!Object.<string, !shaka.media.SegmentIndex>} segmentIndexMap\n   * @return {shaka.dash.DashParser.StreamInfo}\n   */\n  static createStreamInfo(context, segmentIndexMap) {\n    goog.asserts.assert(context.representation.segmentList,\n        'Should only be called with SegmentList');\n    const SegmentList = shaka.dash.SegmentList;\n\n    const initSegmentReference = shaka.dash.SegmentBase.createInitSegment(\n        context, SegmentList.fromInheritance_);\n    const info = SegmentList.parseSegmentListInfo_(context);\n\n    SegmentList.checkSegmentListInfo_(context, info);\n\n    /** @type {shaka.media.SegmentIndex} */\n    let segmentIndex = null;\n    let id = null;\n    if (context.period.id && context.representation.id) {\n      // Only check/store the index if period and representation IDs are set.\n      id = context.period.id + ',' + context.representation.id;\n      segmentIndex = segmentIndexMap[id];\n    }\n\n    const references = SegmentList.createSegmentReferences_(\n        context.periodInfo.start, context.periodInfo.duration,\n        info.startNumber, context.representation.baseUris, info,\n        initSegmentReference);\n\n    if (segmentIndex) {\n      segmentIndex.merge(references);\n      const start = context.presentationTimeline.getSegmentAvailabilityStart();\n      segmentIndex.evict(start);\n    } else {\n      context.presentationTimeline.notifySegments(references);\n      segmentIndex = new shaka.media.SegmentIndex(references);\n      if (id && context.dynamic) {\n        segmentIndexMap[id] = segmentIndex;\n      }\n    }\n\n    if (!context.dynamic || !context.periodInfo.isLastPeriod) {\n      const periodStart = context.periodInfo.start;\n      const periodEnd = context.periodInfo.duration ?\n          context.periodInfo.start + context.periodInfo.duration : Infinity;\n      segmentIndex.fit(periodStart, periodEnd);\n    }\n\n    return {\n      generateSegmentIndex: () => Promise.resolve(segmentIndex),\n    };\n  }\n\n  /**\n   * @param {?shaka.dash.DashParser.InheritanceFrame} frame\n   * @return {Element}\n   * @private\n   */\n  static fromInheritance_(frame) {\n    return frame.segmentList;\n  }\n\n  /**\n   * Parses the SegmentList items to create an info object.\n   *\n   * @param {shaka.dash.DashParser.Context} context\n   * @return {shaka.dash.SegmentList.SegmentListInfo}\n   * @private\n   */\n  static parseSegmentListInfo_(context) {\n    const SegmentList = shaka.dash.SegmentList;\n    const MpdUtils = shaka.dash.MpdUtils;\n\n    const mediaSegments = SegmentList.parseMediaSegments_(context);\n    const segmentInfo =\n        MpdUtils.parseSegmentInfo(context, SegmentList.fromInheritance_);\n\n    let startNumber = segmentInfo.startNumber;\n    if (startNumber == 0) {\n      shaka.log.warning('SegmentList@startNumber must be > 0');\n      startNumber = 1;\n    }\n\n    let startTime = 0;\n    if (segmentInfo.segmentDuration) {\n      // See DASH sec. 5.3.9.5.3\n      // Don't use presentationTimeOffset for @duration.\n      startTime = segmentInfo.segmentDuration * (startNumber - 1);\n    } else if (segmentInfo.timeline && segmentInfo.timeline.length > 0) {\n      // The presentationTimeOffset was considered in timeline creation.\n      startTime = segmentInfo.timeline[0].start;\n    }\n\n    return {\n      segmentDuration: segmentInfo.segmentDuration,\n      startTime: startTime,\n      startNumber: startNumber,\n      scaledPresentationTimeOffset: segmentInfo.scaledPresentationTimeOffset,\n      timeline: segmentInfo.timeline,\n      mediaSegments: mediaSegments,\n    };\n  }\n\n  /**\n   * Checks whether a SegmentListInfo object is valid.\n   *\n   * @param {shaka.dash.DashParser.Context} context\n   * @param {shaka.dash.SegmentList.SegmentListInfo} info\n   * @private\n   */\n  static checkSegmentListInfo_(context, info) {\n    if (!info.segmentDuration && !info.timeline &&\n        info.mediaSegments.length > 1) {\n      shaka.log.warning(\n          'SegmentList does not contain sufficient segment information:',\n          'the SegmentList specifies multiple segments,',\n          'but does not specify a segment duration or timeline.',\n          context.representation);\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.MANIFEST,\n          shaka.util.Error.Code.DASH_NO_SEGMENT_INFO);\n    }\n\n    if (!info.segmentDuration && !context.periodInfo.duration &&\n        !info.timeline && info.mediaSegments.length == 1) {\n      shaka.log.warning(\n          'SegmentList does not contain sufficient segment information:',\n          'the SegmentList specifies one segment,',\n          'but does not specify a segment duration, period duration,',\n          'or timeline.',\n          context.representation);\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.MANIFEST,\n          shaka.util.Error.Code.DASH_NO_SEGMENT_INFO);\n    }\n\n    if (info.timeline && info.timeline.length == 0) {\n      shaka.log.warning(\n          'SegmentList does not contain sufficient segment information:',\n          'the SegmentList has an empty timeline.',\n          context.representation);\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.MANIFEST,\n          shaka.util.Error.Code.DASH_NO_SEGMENT_INFO);\n    }\n  }\n\n  /**\n   * Creates an array of segment references for the given data.\n   *\n   * @param {number} periodStart in seconds.\n   * @param {?number} periodDuration in seconds.\n   * @param {number} startNumber\n   * @param {!Array.<string>} baseUris\n   * @param {shaka.dash.SegmentList.SegmentListInfo} info\n   * @param {shaka.media.InitSegmentReference} initSegmentReference\n   * @return {!Array.<!shaka.media.SegmentReference>}\n   * @private\n   */\n  static createSegmentReferences_(\n      periodStart, periodDuration, startNumber, baseUris, info,\n      initSegmentReference) {\n    const ManifestParserUtils = shaka.util.ManifestParserUtils;\n\n    let max = info.mediaSegments.length;\n    if (info.timeline && info.timeline.length != info.mediaSegments.length) {\n      max = Math.min(info.timeline.length, info.mediaSegments.length);\n      shaka.log.warning(\n          'The number of items in the segment timeline and the number of ',\n          'segment URLs do not match, truncating', info.mediaSegments.length,\n          'to', max);\n    }\n\n    const timestampOffset = periodStart - info.scaledPresentationTimeOffset;\n    const appendWindowStart = periodStart;\n    const appendWindowEnd = periodDuration ?\n        periodStart + periodDuration : Infinity;\n\n    /** @type {!Array.<!shaka.media.SegmentReference>} */\n    const references = [];\n    let prevEndTime = info.startTime;\n    for (const i of shaka.util.Iterables.range(max)) {\n      const segment = info.mediaSegments[i];\n      const mediaUri = ManifestParserUtils.resolveUris(\n          baseUris, [segment.mediaUri]);\n\n      const startTime = prevEndTime;\n      let endTime;\n\n      if (info.segmentDuration != null) {\n        endTime = startTime + info.segmentDuration;\n      } else if (info.timeline) {\n        // Ignore the timepoint start since they are continuous.\n        endTime = info.timeline[i].end;\n      } else {\n        // If segmentDuration and timeline are null then there must\n        // be exactly one segment.\n        goog.asserts.assert(\n            info.mediaSegments.length == 1 && periodDuration,\n            'There should be exactly one segment with a Period duration.');\n        endTime = startTime + periodDuration;\n      }\n\n      const getUris = () => mediaUri;\n      references.push(\n          new shaka.media.SegmentReference(\n              periodStart + startTime,\n              periodStart + endTime,\n              getUris,\n              segment.start,\n              segment.end,\n              initSegmentReference,\n              timestampOffset,\n              appendWindowStart, appendWindowEnd));\n      prevEndTime = endTime;\n    }\n\n    return references;\n  }\n\n  /**\n   * Parses the media URIs from the context.\n   *\n   * @param {shaka.dash.DashParser.Context} context\n   * @return {!Array.<shaka.dash.SegmentList.MediaSegment>}\n   * @private\n   */\n  static parseMediaSegments_(context) {\n    const Functional = shaka.util.Functional;\n    /** @type {!Array.<!Element>} */\n    const segmentLists = [\n      context.representation.segmentList,\n      context.adaptationSet.segmentList,\n      context.period.segmentList,\n    ].filter(Functional.isNotNull);\n\n    const XmlUtils = shaka.util.XmlUtils;\n    // Search each SegmentList for one with at least one SegmentURL element,\n    // select the first one, and convert each SegmentURL element to a tuple.\n    return segmentLists\n        .map((node) => { return XmlUtils.findChildren(node, 'SegmentURL'); })\n        .reduce((all, part) => { return all.length > 0 ? all : part; })\n        .map((urlNode) => {\n          if (urlNode.getAttribute('indexRange') &&\n              !context.indexRangeWarningGiven) {\n            context.indexRangeWarningGiven = true;\n            shaka.log.warning(\n                'We do not support the SegmentURL@indexRange attribute on ' +\n                'SegmentList.  We only use the SegmentList@duration ' +\n                'attribute or SegmentTimeline, which must be accurate.');\n          }\n\n          const uri = urlNode.getAttribute('media');\n          const range = XmlUtils.parseAttr(\n              urlNode, 'mediaRange', XmlUtils.parseRange,\n              {start: 0, end: null});\n          return {mediaUri: uri, start: range.start, end: range.end};\n        });\n  }\n};\n\n/**\n * @typedef {{\n *   mediaUri: string,\n *   start: number,\n *   end: ?number\n * }}\n *\n * @property {string} mediaUri\n *   The URI of the segment.\n * @property {number} start\n *   The start byte of the segment.\n * @property {?number} end\n *   The end byte of the segment, or null.\n */\nshaka.dash.SegmentList.MediaSegment;\n\n/**\n * @typedef {{\n *   segmentDuration: ?number,\n *   startTime: number,\n *   startNumber: number,\n *   scaledPresentationTimeOffset: number,\n *   timeline: Array.<shaka.dash.MpdUtils.TimeRange>,\n *   mediaSegments: !Array.<shaka.dash.SegmentList.MediaSegment>\n * }}\n * @private\n *\n * @description\n * Contains information about a SegmentList.\n *\n * @property {?number} segmentDuration\n *   The duration of the segments, if given.\n * @property {number} startTime\n *   The start time of the first segment, in seconds.\n * @property {number} startNumber\n *   The start number of the segments; 1 or greater.\n * @property {number} scaledPresentationTimeOffset\n *   The scaledPresentationTimeOffset of the representation, in seconds.\n * @property {Array.<shaka.dash.MpdUtils.TimeRange>} timeline\n *   The timeline of the representation, if given.  Times in seconds.\n * @property {!Array.<shaka.dash.SegmentList.MediaSegment>} mediaSegments\n *   The URI and byte-ranges of the media segments.\n */\nshaka.dash.SegmentList.SegmentListInfo;\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.dash.SegmentTemplate');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.dash.MpdUtils');\ngoog.require('shaka.dash.SegmentBase');\ngoog.require('shaka.log');\ngoog.require('shaka.media.InitSegmentReference');\ngoog.require('shaka.media.SegmentIndex');\ngoog.require('shaka.media.SegmentReference');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.Iterables');\ngoog.require('shaka.util.ManifestParserUtils');\ngoog.require('shaka.util.ObjectUtils');\ngoog.requireType('shaka.dash.DashParser');\n\n\n/**\n * @summary A set of functions for parsing SegmentTemplate elements.\n */\nshaka.dash.SegmentTemplate = class {\n  /**\n   * Creates a new StreamInfo object.\n   * Updates the existing SegmentIndex, if any.\n   *\n   * @param {shaka.dash.DashParser.Context} context\n   * @param {shaka.dash.DashParser.RequestInitSegmentCallback}\n   *   requestInitSegment\n   * @param {!Object.<string, !shaka.media.SegmentIndex>} segmentIndexMap\n   * @param {boolean} isUpdate True if the manifest is being updated.\n   * @param {number} segmentLimit The maximum number of segments to generate for\n   *   a SegmentTemplate with fixed duration.\n   * @return {shaka.dash.DashParser.StreamInfo}\n   */\n  static createStreamInfo(\n      context, requestInitSegment, segmentIndexMap, isUpdate,\n      segmentLimit) {\n    goog.asserts.assert(context.representation.segmentTemplate,\n        'Should only be called with SegmentTemplate');\n    const SegmentTemplate = shaka.dash.SegmentTemplate;\n\n    const initSegmentReference = SegmentTemplate.createInitSegment_(context);\n    const info = SegmentTemplate.parseSegmentTemplateInfo_(context);\n\n    SegmentTemplate.checkSegmentTemplateInfo_(context, info);\n\n    // Direct fields of context will be reassigned by the parser before\n    // generateSegmentIndex is called.  So we must make a shallow copy first,\n    // and use that in the generateSegmentIndex callbacks.\n    const shallowCopyOfContext =\n        shaka.util.ObjectUtils.shallowCloneObject(context);\n\n    if (info.indexTemplate) {\n      shaka.dash.SegmentBase.checkSegmentIndexSupport(\n          context, initSegmentReference);\n\n      return {\n        generateSegmentIndex: () => {\n          return SegmentTemplate.generateSegmentIndexFromIndexTemplate_(\n              shallowCopyOfContext, requestInitSegment, initSegmentReference,\n              info);\n        },\n      };\n    } else if (info.segmentDuration) {\n      if (!isUpdate) {\n        context.presentationTimeline.notifyMaxSegmentDuration(\n            info.segmentDuration);\n        context.presentationTimeline.notifyMinSegmentStartTime(\n            context.periodInfo.start);\n      }\n\n      return {\n        generateSegmentIndex: () => {\n          return SegmentTemplate.generateSegmentIndexFromDuration_(\n              shallowCopyOfContext, info, segmentLimit, initSegmentReference);\n        },\n      };\n    } else {\n      /** @type {shaka.media.SegmentIndex} */\n      let segmentIndex = null;\n      let id = null;\n      if (context.period.id && context.representation.id) {\n        // Only check/store the index if period and representation IDs are set.\n        id = context.period.id + ',' + context.representation.id;\n        segmentIndex = segmentIndexMap[id];\n      }\n\n      const references = SegmentTemplate.createFromTimeline_(\n          shallowCopyOfContext, info, initSegmentReference);\n\n      const periodStart = context.periodInfo.start;\n      const periodEnd = context.periodInfo.duration ?\n          context.periodInfo.start + context.periodInfo.duration : Infinity;\n\n      // Don't fit live content, since it might receive more segments.\n      // Unless that live content is multi-period; it's safe to fit every period\n      // but the last one, since only the last period might receive new\n      // segments.\n      const shouldFit = periodEnd != Infinity;\n\n      if (segmentIndex) {\n        if (shouldFit) {\n          // Fit the new references before merging them, so that the merge\n          // algorithm has a more accurate view of their start and end times.\n          const wrapper = new shaka.media.SegmentIndex(references);\n          wrapper.fit(periodStart, periodEnd);\n        }\n\n        segmentIndex.merge(references);\n        segmentIndex.evict(\n            context.presentationTimeline.getSegmentAvailabilityStart());\n      } else {\n        context.presentationTimeline.notifySegments(references);\n        segmentIndex = new shaka.media.SegmentIndex(references);\n        if (id && context.dynamic) {\n          segmentIndexMap[id] = segmentIndex;\n        }\n      }\n\n      if (shouldFit) {\n        segmentIndex.fit(periodStart, periodEnd);\n      }\n\n      return {\n        generateSegmentIndex: () => Promise.resolve(segmentIndex),\n      };\n    }\n  }\n\n  /**\n   * @param {?shaka.dash.DashParser.InheritanceFrame} frame\n   * @return {Element}\n   * @private\n   */\n  static fromInheritance_(frame) {\n    return frame.segmentTemplate;\n  }\n\n  /**\n   * Parses a SegmentTemplate element into an info object.\n   *\n   * @param {shaka.dash.DashParser.Context} context\n   * @return {shaka.dash.SegmentTemplate.SegmentTemplateInfo}\n   * @private\n   */\n  static parseSegmentTemplateInfo_(context) {\n    const SegmentTemplate = shaka.dash.SegmentTemplate;\n    const MpdUtils = shaka.dash.MpdUtils;\n    const segmentInfo =\n        MpdUtils.parseSegmentInfo(context, SegmentTemplate.fromInheritance_);\n\n    const media = MpdUtils.inheritAttribute(\n        context, SegmentTemplate.fromInheritance_, 'media');\n    const index = MpdUtils.inheritAttribute(\n        context, SegmentTemplate.fromInheritance_, 'index');\n\n    return {\n      segmentDuration: segmentInfo.segmentDuration,\n      timescale: segmentInfo.timescale,\n      startNumber: segmentInfo.startNumber,\n      scaledPresentationTimeOffset: segmentInfo.scaledPresentationTimeOffset,\n      unscaledPresentationTimeOffset:\n          segmentInfo.unscaledPresentationTimeOffset,\n      timeline: segmentInfo.timeline,\n      mediaTemplate: media,\n      indexTemplate: index,\n    };\n  }\n\n  /**\n   * Verifies a SegmentTemplate info object.\n   *\n   * @param {shaka.dash.DashParser.Context} context\n   * @param {shaka.dash.SegmentTemplate.SegmentTemplateInfo} info\n   * @private\n   */\n  static checkSegmentTemplateInfo_(context, info) {\n    let n = 0;\n    n += info.indexTemplate ? 1 : 0;\n    n += info.timeline ? 1 : 0;\n    n += info.segmentDuration ? 1 : 0;\n\n    if (n == 0) {\n      shaka.log.error(\n          'SegmentTemplate does not contain any segment information:',\n          'the SegmentTemplate must contain either an index URL template',\n          'a SegmentTimeline, or a segment duration.',\n          context.representation);\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.MANIFEST,\n          shaka.util.Error.Code.DASH_NO_SEGMENT_INFO);\n    } else if (n != 1) {\n      shaka.log.warning(\n          'SegmentTemplate containes multiple segment information sources:',\n          'the SegmentTemplate should only contain an index URL template,',\n          'a SegmentTimeline or a segment duration.',\n          context.representation);\n      if (info.indexTemplate) {\n        shaka.log.info('Using the index URL template by default.');\n        info.timeline = null;\n        info.segmentDuration = null;\n      } else {\n        goog.asserts.assert(info.timeline, 'There should be a timeline');\n        shaka.log.info('Using the SegmentTimeline by default.');\n        info.segmentDuration = null;\n      }\n    }\n\n    if (!info.indexTemplate && !info.mediaTemplate) {\n      shaka.log.error(\n          'SegmentTemplate does not contain sufficient segment information:',\n          'the SegmentTemplate\\'s media URL template is missing.',\n          context.representation);\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.MANIFEST,\n          shaka.util.Error.Code.DASH_NO_SEGMENT_INFO);\n    }\n  }\n\n  /**\n   * Generates a SegmentIndex from an index URL template.\n   *\n   * @param {shaka.dash.DashParser.Context} context\n   * @param {shaka.dash.DashParser.RequestInitSegmentCallback}\n   *     requestInitSegment\n   * @param {shaka.media.InitSegmentReference} init\n   * @param {shaka.dash.SegmentTemplate.SegmentTemplateInfo} info\n   * @return {!Promise.<shaka.media.SegmentIndex>}\n   * @private\n   */\n  static generateSegmentIndexFromIndexTemplate_(\n      context, requestInitSegment, init, info) {\n    const MpdUtils = shaka.dash.MpdUtils;\n    const ManifestParserUtils = shaka.util.ManifestParserUtils;\n\n    goog.asserts.assert(info.indexTemplate, 'must be using index template');\n    const filledTemplate = MpdUtils.fillUriTemplate(\n        info.indexTemplate, context.representation.id,\n        null, context.bandwidth || null, null);\n\n    const resolvedUris = ManifestParserUtils.resolveUris(\n        context.representation.baseUris, [filledTemplate]);\n\n    return shaka.dash.SegmentBase.generateSegmentIndexFromUris(\n        context, requestInitSegment, init, resolvedUris, 0, null,\n        info.scaledPresentationTimeOffset);\n  }\n\n  /**\n   * Generates a SegmentIndex from fixed-duration segments.\n   *\n   * @param {shaka.dash.DashParser.Context} context\n   * @param {shaka.dash.SegmentTemplate.SegmentTemplateInfo} info\n   * @param {number} segmentLimit The maximum number of segments to generate.\n   * @param {shaka.media.InitSegmentReference} initSegmentReference\n   * @return {!Promise.<shaka.media.SegmentIndex>}\n   * @private\n   */\n  static generateSegmentIndexFromDuration_(\n      context, info, segmentLimit, initSegmentReference) {\n    goog.asserts.assert(info.mediaTemplate,\n        'There should be a media template with duration');\n\n    const MpdUtils = shaka.dash.MpdUtils;\n    const ManifestParserUtils = shaka.util.ManifestParserUtils;\n\n    const presentationTimeline = context.presentationTimeline;\n\n    // Capture values that could change as the parsing context moves on to\n    // other parts of the manifest.\n    const periodStart = context.periodInfo.start;\n    const periodDuration = context.periodInfo.duration;\n    const periodEnd = periodDuration ?\n        periodStart + periodDuration : Infinity;\n\n    const segmentDuration = info.segmentDuration;\n    goog.asserts.assert(\n        segmentDuration != null, 'Segment duration must not be null!');\n\n    const startNumber = info.startNumber;\n    const timescale = info.timescale;\n\n    const template = info.mediaTemplate;\n    const bandwidth = context.bandwidth || null;\n    const id = context.representation.id;\n    const baseUris = context.representation.baseUris;\n\n    const timestampOffset = periodStart - info.scaledPresentationTimeOffset;\n\n    // Computes the range of presentation timestamps both within the period and\n    // available.  This is an intersection of the period range and the\n    // availability window.\n    const computeAvailablePeriodRange = () => {\n      return [\n        Math.max(\n            presentationTimeline.getSegmentAvailabilityStart(),\n            periodStart),\n\n        Math.min(\n            presentationTimeline.getSegmentAvailabilityEnd(),\n            periodEnd),\n      ];\n    };\n\n    // Computes the range of absolute positions both within the period and\n    // available.  The range is inclusive.  These are the positions for which we\n    // will generate segment references.\n    const computeAvailablePositionRange = () => {\n      // In presentation timestamps.\n      const availablePresentationTimes = computeAvailablePeriodRange();\n      goog.asserts.assert(availablePresentationTimes.every(isFinite),\n          'Available presentation times must be finite!');\n      goog.asserts.assert(availablePresentationTimes.every((x) => x >= 0),\n          'Available presentation times must be positive!');\n      goog.asserts.assert(segmentDuration != null,\n          'Segment duration must not be null!');\n\n      // In period-relative timestamps.\n      const availablePeriodTimes =\n          availablePresentationTimes.map((x) => x - periodStart);\n      // These may sometimes be reversed ([1] <= [0]) if the period is\n      // completely unavailable.  The logic will still work if this happens,\n      // because we will simply generate no references.\n\n      // In period-relative positions (0-based).\n      const availablePeriodPositions = [\n        Math.ceil(availablePeriodTimes[0] / segmentDuration),\n        Math.ceil(availablePeriodTimes[1] / segmentDuration) - 1,\n      ];\n\n      // In absolute positions.\n      const availablePresentationPositions =\n          availablePeriodPositions.map((x) => x + startNumber);\n      return availablePresentationPositions;\n    };\n\n    // For Live, we must limit the initial SegmentIndex in size, to avoid\n    // consuming too much CPU or memory for content with gigantic\n    // timeShiftBufferDepth (which can have values up to and including\n    // Infinity).\n    const range = computeAvailablePositionRange();\n    const minPosition = context.dynamic ?\n        Math.max(range[0], range[1] - segmentLimit + 1) :\n        range[0];\n    const maxPosition = range[1];\n\n    const references = [];\n    const createReference = (position) => {\n      // These inner variables are all scoped to the inner loop, and can be used\n      // safely in the callback below.\n\n      goog.asserts.assert(segmentDuration != null,\n          'Segment duration must not be null!');\n\n      // Relative to the period start.\n      const positionWithinPeriod = position - startNumber;\n      const segmentPeriodTime = positionWithinPeriod * segmentDuration;\n\n      // What will appear in the actual segment files.  The media timestamp is\n      // what is expected in the $Time$ template.\n      const segmentMediaTime = segmentPeriodTime +\n          info.scaledPresentationTimeOffset;\n\n      const getUris = () => {\n        const mediaUri = MpdUtils.fillUriTemplate(\n            template, id, position, bandwidth,\n            segmentMediaTime * timescale);\n        return ManifestParserUtils.resolveUris(baseUris, [mediaUri]);\n      };\n\n      // Relative to the presentation.\n      const segmentStart = segmentPeriodTime + periodStart;\n      // Cap the segment end at the period end so that references from the\n      // next period will fit neatly after it.\n      const segmentEnd = Math.min(segmentStart + segmentDuration, periodEnd);\n\n      // This condition will be true unless the segmentStart was >= periodEnd.\n      // If we've done the position calculations correctly, this won't happen.\n      goog.asserts.assert(segmentStart < segmentEnd,\n          'Generated a segment outside of the period!');\n\n      return new shaka.media.SegmentReference(\n          segmentStart,\n          segmentEnd,\n          getUris,\n          /* startByte= */ 0,\n          /* endByte= */ null,\n          initSegmentReference,\n          timestampOffset,\n          /* appendWindowStart= */ periodStart,\n          /* appendWindowEnd= */ periodEnd);\n    };\n\n    for (let position = minPosition; position <= maxPosition; ++position) {\n      const reference = createReference(position);\n      references.push(reference);\n    }\n\n    /** @type {shaka.media.SegmentIndex} */\n    const segmentIndex = new shaka.media.SegmentIndex(references);\n\n    // If the availability timeline currently ends before the period, we will\n    // need to add references over time.\n    if (presentationTimeline.getSegmentAvailabilityEnd() < periodEnd) {\n      // The period continues to get longer over time, so check for new\n      // references once every |segmentDuration| seconds.\n      let nextPosition = maxPosition + 1;\n      segmentIndex.updateEvery(segmentDuration, () => {\n        // Evict any references outside the window.\n        segmentIndex.evict(presentationTimeline.getSegmentAvailabilityStart());\n\n        // Compute any new references that need to be added.\n        const [_, maxPosition] = computeAvailablePositionRange();\n        const references = [];\n        while (nextPosition <= maxPosition) {\n          const reference = createReference(nextPosition);\n          references.push(reference);\n          nextPosition++;\n        }\n        return references;\n      });\n    }\n\n    return Promise.resolve(segmentIndex);\n  }\n\n  /**\n   * Creates segment references from a timeline.\n   *\n   * @param {shaka.dash.DashParser.Context} context\n   * @param {shaka.dash.SegmentTemplate.SegmentTemplateInfo} info\n   * @param {shaka.media.InitSegmentReference} initSegmentReference\n   * @return {!Array.<!shaka.media.SegmentReference>}\n   * @private\n   */\n  static createFromTimeline_(context, info, initSegmentReference) {\n    const MpdUtils = shaka.dash.MpdUtils;\n    const ManifestParserUtils = shaka.util.ManifestParserUtils;\n\n    const periodStart = context.periodInfo.start;\n    const periodDuration = context.periodInfo.duration;\n\n    const timestampOffset = periodStart - info.scaledPresentationTimeOffset;\n    const appendWindowStart = periodStart;\n    const appendWindowEnd = periodDuration ?\n        periodStart + periodDuration : Infinity;\n\n    /** @type {!Array.<!shaka.media.SegmentReference>} */\n    const references = [];\n    const enum_ = (it) => shaka.util.Iterables.enumerate(it);\n    for (const {i, item: {start, unscaledStart, end}} of enum_(info.timeline)) {\n      // Note: i = k - 1, where k indicates the k'th segment listed in the MPD.\n      // (See section 5.3.9.5.3 of the DASH spec.)\n      const segmentReplacement = i + info.startNumber;\n\n      // Consider the presentation time offset in segment uri computation\n      const timeReplacement = unscaledStart +\n          info.unscaledPresentationTimeOffset;\n      const repId = context.representation.id;\n      const bandwidth = context.bandwidth || null;\n      const mediaTemplate = info.mediaTemplate;\n      const baseUris = context.representation.baseUris;\n\n      // This callback must not capture any non-local\n      // variables, such as info, context, etc.  Make\n      // sure any values you reference here have\n      // been assigned to local variables within the\n      // loop, or else we will end up with a leak.\n      const createUris =\n          () => {\n            goog.asserts.assert(\n                mediaTemplate,\n                'There should be a media template with a timeline');\n            const mediaUri = MpdUtils.fillUriTemplate(\n                mediaTemplate, repId,\n                segmentReplacement, bandwidth || null, timeReplacement);\n            return ManifestParserUtils\n                .resolveUris(baseUris, [mediaUri])\n                .map((g) => {\n                  return g.toString();\n                });\n          };\n\n      references.push(new shaka.media.SegmentReference(\n          periodStart + start,\n          periodStart + end,\n          createUris,\n          /* startByte= */ 0,\n          /* endByte= */ null,\n          initSegmentReference,\n          timestampOffset,\n          appendWindowStart,\n          appendWindowEnd));\n    }\n\n    return references;\n  }\n\n  /**\n   * Creates an init segment reference from a context object.\n   *\n   * @param {shaka.dash.DashParser.Context} context\n   * @return {shaka.media.InitSegmentReference}\n   * @private\n   */\n  static createInitSegment_(context) {\n    const MpdUtils = shaka.dash.MpdUtils;\n    const ManifestParserUtils = shaka.util.ManifestParserUtils;\n    const SegmentTemplate = shaka.dash.SegmentTemplate;\n\n    const initialization = MpdUtils.inheritAttribute(\n        context, SegmentTemplate.fromInheritance_, 'initialization');\n    if (!initialization) {\n      return null;\n    }\n\n    const repId = context.representation.id;\n    const bandwidth = context.bandwidth || null;\n    const baseUris = context.representation.baseUris;\n    const getUris = () => {\n      goog.asserts.assert(initialization, 'Should have returned earler');\n      const filledTemplate = MpdUtils.fillUriTemplate(\n          initialization, repId, null, bandwidth, null);\n      const resolvedUris = ManifestParserUtils.resolveUris(\n          baseUris, [filledTemplate]);\n      return resolvedUris;\n    };\n\n    return new shaka.media.InitSegmentReference(getUris, 0, null);\n  }\n};\n\n/**\n * @typedef {{\n *   timescale: number,\n *   segmentDuration: ?number,\n *   startNumber: number,\n *   scaledPresentationTimeOffset: number,\n *   unscaledPresentationTimeOffset: number,\n *   timeline: Array.<shaka.dash.MpdUtils.TimeRange>,\n *   mediaTemplate: ?string,\n *   indexTemplate: ?string\n * }}\n * @private\n *\n * @description\n * Contains information about a SegmentTemplate.\n *\n * @property {number} timescale\n *   The time-scale of the representation.\n * @property {?number} segmentDuration\n *   The duration of the segments in seconds, if given.\n * @property {number} startNumber\n *   The start number of the segments; 1 or greater.\n * @property {number} scaledPresentationTimeOffset\n *   The presentation time offset of the representation, in seconds.\n * @property {number} unscaledPresentationTimeOffset\n *   The presentation time offset of the representation, in timescale units.\n * @property {Array.<shaka.dash.MpdUtils.TimeRange>} timeline\n *   The timeline of the representation, if given.  Times in seconds.\n * @property {?string} mediaTemplate\n *   The media URI template, if given.\n * @property {?string} indexTemplate\n *   The index URI template, if given.\n */\nshaka.dash.SegmentTemplate.SegmentTemplateInfo;\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.util.PeriodCombiner');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.media.DrmEngine');\ngoog.require('shaka.media.MetaSegmentIndex');\ngoog.require('shaka.media.SegmentIndex');\ngoog.require('shaka.util.ArrayUtils');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.IReleasable');\ngoog.require('shaka.util.Iterables');\ngoog.require('shaka.util.LanguageUtils');\ngoog.require('shaka.util.ManifestParserUtils');\ngoog.require('shaka.util.MapUtils');\ngoog.require('shaka.util.MimeUtils');\n\n/**\n * A utility to combine streams across periods.\n *\n * @implements {shaka.util.IReleasable}\n * @final\n */\nshaka.util.PeriodCombiner = class {\n  constructor() {\n    /** @private {!Array.<shaka.extern.Variant>} */\n    this.variants_ = [];\n\n    /** @private {!Array.<shaka.extern.Stream>} */\n    this.audioStreams_ = [];\n\n    /** @private {!Array.<shaka.extern.Stream>} */\n    this.videoStreams_ = [];\n\n    /** @private {!Array.<shaka.extern.Stream>} */\n    this.textStreams_ = [];\n\n    /**\n     * The IDs of the periods we have already used to generate streams.\n     * This helps us identify the periods which have been added when a live\n     * stream is updated.\n     *\n     * @private {!Set.<string>}\n     */\n    this.usedPeriodIds_ = new Set();\n  }\n\n  /** @override */\n  release() {\n    const allStreams =\n        this.audioStreams_.concat(this.videoStreams_, this.textStreams_);\n\n    for (const stream of allStreams) {\n      if (stream.segmentIndex) {\n        stream.segmentIndex.release();\n      }\n    }\n\n    this.audioStreams_ = [];\n    this.videoStreams_ = [];\n    this.textStreams_ = [];\n    this.variants_ = [];\n  }\n\n  /** @return {!Array.<shaka.extern.Variant>} */\n  getVariants() {\n    return this.variants_;\n  }\n\n  /** @return {!Array.<shaka.extern.Stream>} */\n  getTextStreams() {\n    return this.textStreams_;\n  }\n\n  /**\n   * @param {!Array.<shaka.util.PeriodCombiner.Period>} periods\n   * @param {boolean} isDynamic\n   * @return {!Promise}\n   */\n  async combinePeriods(periods, isDynamic) {\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n    const Iterables = shaka.util.Iterables;\n\n    shaka.util.PeriodCombiner.filterOutAudioStreamDuplicates_(periods);\n    shaka.util.PeriodCombiner.filterOutVideoStreamDuplicates_(periods);\n    shaka.util.PeriodCombiner.filterOutTextStreamDuplicates_(periods);\n\n    // Optimization: for single-period VOD, do nothing.  This makes sure\n    // single-period DASH content will be 100% accurately represented in the\n    // output.\n    if (!isDynamic && periods.length == 1) {\n      const firstPeriod = periods[0];\n      this.audioStreams_ = firstPeriod.audioStreams;\n      this.videoStreams_ = firstPeriod.videoStreams;\n      this.textStreams_ = firstPeriod.textStreams;\n    } else {\n      // Find the first period we haven't seen before.  Tag all the periods we\n      // see now as \"used\".\n      let firstNewPeriodIndex = -1;\n      for (const {i, item: period} of Iterables.enumerate(periods)) {\n        if (this.usedPeriodIds_.has(period.id)) {\n          // This isn't new.\n        } else {\n          // This one _is_ new.\n          this.usedPeriodIds_.add(period.id);\n\n          if (firstNewPeriodIndex == -1) {\n            // And it's the _first_ new one.\n            firstNewPeriodIndex = i;\n          }\n        }\n      }\n\n      if (firstNewPeriodIndex == -1) {\n        // Nothing new? Nothing to do.\n        return;\n      }\n\n      const audioStreamsPerPeriod = periods.map(\n          (period) => period.audioStreams);\n      const videoStreamsPerPeriod = periods.map(\n          (period) => period.videoStreams);\n      const textStreamsPerPeriod = periods.map(\n          (period) => period.textStreams);\n\n      // It's okay to have a period with no text, but our algorithm fails on any\n      // period without matching streams.  So we add dummy text streams to each\n      // period.  Since we combine text streams by language, we might need a\n      // dummy even in periods with text streams already.\n      for (const textStreams of textStreamsPerPeriod) {\n        textStreams.push(shaka.util.PeriodCombiner.dummyTextStream_());\n      }\n\n      await shaka.util.PeriodCombiner.combine_(\n          this.audioStreams_,\n          audioStreamsPerPeriod,\n          firstNewPeriodIndex,\n          shaka.util.PeriodCombiner.cloneStream_,\n          shaka.util.PeriodCombiner.concatenateStreams_);\n\n      await shaka.util.PeriodCombiner.combine_(\n          this.videoStreams_,\n          videoStreamsPerPeriod,\n          firstNewPeriodIndex,\n          shaka.util.PeriodCombiner.cloneStream_,\n          shaka.util.PeriodCombiner.concatenateStreams_);\n\n      await shaka.util.PeriodCombiner.combine_(\n          this.textStreams_,\n          textStreamsPerPeriod,\n          firstNewPeriodIndex,\n          shaka.util.PeriodCombiner.cloneStream_,\n          shaka.util.PeriodCombiner.concatenateStreams_);\n    }\n\n    // Create variants for all audio/video combinations.\n    let nextVariantId = 0;\n    const variants = [];\n    if (!this.videoStreams_.length || !this.audioStreams_.length) {\n      // For audio-only or video-only content, just give each stream its own\n      // variant.\n      const streams = this.videoStreams_.concat(this.audioStreams_);\n      for (const stream of streams) {\n        const id = nextVariantId++;\n        variants.push({\n          id,\n          language: stream.language,\n          primary: stream.primary,\n          audio: stream.type == ContentType.AUDIO ? stream : null,\n          video: stream.type == ContentType.VIDEO ? stream : null,\n          bandwidth: stream.bandwidth || 0,\n          drmInfos: stream.drmInfos,\n          allowedByApplication: true,\n          allowedByKeySystem: true,\n        });\n      }\n    } else {\n      for (const audio of this.audioStreams_) {\n        for (const video of this.videoStreams_) {\n          const commonDrmInfos = shaka.media.DrmEngine.getCommonDrmInfos(\n              audio.drmInfos, video.drmInfos);\n\n          if (audio.drmInfos.length && video.drmInfos.length &&\n              !commonDrmInfos.length) {\n            shaka.log.warning(\n                'Incompatible DRM in audio & video, skipping variant creation.',\n                audio, video);\n            continue;\n          }\n\n          const id = nextVariantId++;\n          variants.push({\n            id,\n            language: audio.language,\n            primary: audio.primary,\n            audio,\n            video,\n            bandwidth: (audio.bandwidth || 0) + (video.bandwidth || 0),\n            drmInfos: commonDrmInfos,\n            allowedByApplication: true,\n            allowedByKeySystem: true,\n          });\n        }\n      }\n    }\n\n    this.variants_ = variants;\n  }\n\n  /**\n   * @param {!Array.<shaka.util.PeriodCombiner.Period>} periods\n   * @private\n   */\n  static filterOutAudioStreamDuplicates_(periods) {\n    const ArrayUtils = shaka.util.ArrayUtils;\n    // Two audio streams are considered to be duplicates of\n    // one another if their ids are different, but all the other\n    // information is the same.\n    for (const period of periods) {\n      const filteredAudios = [];\n      for (const a1 of period.audioStreams) {\n        let duplicate = false;\n        for (const a2 of filteredAudios) {\n          if (a1.id != a2.id &&\n              a1.channelsCount == a2.channelsCount &&\n              a1.language == a2.language &&\n              a1.bandwidth == a2.bandwidth &&\n              a1.label == a2.label &&\n              a1.codecs == a2.codecs &&\n              a1.mimeType == a2.mimeType &&\n              ArrayUtils.hasSameElements(a1.roles, a2.roles) &&\n              a1.audioSamplingRate == a2.audioSamplingRate &&\n              a1.primary == a2.primary) {\n            duplicate = true;\n          }\n        }\n\n        if (!duplicate) {\n          filteredAudios.push(a1);\n        }\n      }\n\n      period.audioStreams = filteredAudios;\n    }\n  }\n\n  /**\n   * @param {!Array.<shaka.util.PeriodCombiner.Period>} periods\n   * @private\n   */\n  static filterOutTextStreamDuplicates_(periods) {\n    const ArrayUtils = shaka.util.ArrayUtils;\n    // Two text streams are considered to be duplicates of\n    // one another if their ids are different, but all the other\n    // information is the same.\n    for (const period of periods) {\n      const filteredTexts = [];\n      for (const t1 of period.textStreams) {\n        let duplicate = false;\n        for (const t2 of filteredTexts) {\n          if (t1.id != t2.id &&\n            t1.language == t2.language &&\n            t1.label == t2.label &&\n            t1.codecs == t2.codecs &&\n            t1.mimeType == t2.mimeType &&\n            ArrayUtils.hasSameElements(t1.roles, t2.roles)) {\n            duplicate = true;\n          }\n        }\n\n        if (!duplicate) {\n          filteredTexts.push(t1);\n        }\n      }\n\n      period.textStreams = filteredTexts;\n    }\n  }\n\n  /**\n   * @param {!Array.<shaka.util.PeriodCombiner.Period>} periods\n   * @private\n   */\n  static filterOutVideoStreamDuplicates_(periods) {\n    const ArrayUtils = shaka.util.ArrayUtils;\n    const MapUtils = shaka.util.MapUtils;\n    // Two video streams are considered to be duplicates of\n    // one another if their ids are different, but all the other\n    // information is the same.\n    for (const period of periods) {\n      const filteredVideos = [];\n      for (const v1 of period.videoStreams) {\n        let duplicate = false;\n        for (const v2 of filteredVideos) {\n          if (v1.id != v2.id &&\n              v1.width == v2.width &&\n              v1.frameRate == v2.frameRate &&\n              v1.codecs == v2.codecs &&\n              v1.mimeType == v2.mimeType &&\n              v1.label == v2.label &&\n              ArrayUtils.hasSameElements(v1.roles, v2.roles) &&\n              MapUtils.hasSameElements(v1.closedCaptions, v2.closedCaptions) &&\n              v1.bandwidth == v2.bandwidth) {\n            duplicate = true;\n          }\n        }\n\n        if (!duplicate) {\n          filteredVideos.push(v1);\n        }\n      }\n\n      period.videoStreams = filteredVideos;\n    }\n  }\n\n  /**\n   * Stitch together DB streams across periods, taking a mix of stream types.\n   * The offline database does not separate these by type.\n   *\n   * Unlike the DASH case, this does not need to maintain any state for manifest\n   * updates.\n   *\n   * @param {!Array.<!Array.<shaka.extern.StreamDB>>} streamDbsPerPeriod\n   * @return {!Promise.<!Array.<shaka.extern.StreamDB>>}\n   */\n  static async combineDbStreams(streamDbsPerPeriod) {\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n\n    // Optimization: for single-period content, do nothing.  This makes sure\n    // single-period DASH or any HLS content stored offline will be 100%\n    // accurately represented in the output.\n    if (streamDbsPerPeriod.length == 1) {\n      return streamDbsPerPeriod[0];\n    }\n\n    const audioStreamDbsPerPeriod = streamDbsPerPeriod.map(\n        (streams) => streams.filter((s) => s.type == ContentType.AUDIO));\n    const videoStreamDbsPerPeriod = streamDbsPerPeriod.map(\n        (streams) => streams.filter((s) => s.type == ContentType.VIDEO));\n    const textStreamDbsPerPeriod = streamDbsPerPeriod.map(\n        (streams) => streams.filter((s) => s.type == ContentType.TEXT));\n\n    // It's okay to have a period with no text, but our algorithm fails on any\n    // period without matching streams.  So we add dummy text streams to each\n    // period.  Since we combine text streams by language, we might need a\n    // dummy even in periods with text streams already.\n    for (const textStreams of textStreamDbsPerPeriod) {\n      textStreams.push(shaka.util.PeriodCombiner.dummyTextStreamDB_());\n    }\n\n    const combinedAudioStreamDbs = await shaka.util.PeriodCombiner.combine_(\n        /* outputStreams= */ [],\n        audioStreamDbsPerPeriod,\n        /* firstNewPeriodIndex= */ 0,\n        shaka.util.PeriodCombiner.cloneStreamDB_,\n        shaka.util.PeriodCombiner.concatenateStreamDBs_);\n\n    const combinedVideoStreamDbs = await shaka.util.PeriodCombiner.combine_(\n        /* outputStreams= */ [],\n        videoStreamDbsPerPeriod,\n        /* firstNewPeriodIndex= */ 0,\n        shaka.util.PeriodCombiner.cloneStreamDB_,\n        shaka.util.PeriodCombiner.concatenateStreamDBs_);\n\n    const combinedTextStreamDbs = await shaka.util.PeriodCombiner.combine_(\n        /* outputStreams= */ [],\n        textStreamDbsPerPeriod,\n        /* firstNewPeriodIndex= */ 0,\n        shaka.util.PeriodCombiner.cloneStreamDB_,\n        shaka.util.PeriodCombiner.concatenateStreamDBs_);\n\n    // Recreate variantIds from scratch in the output.\n    // HLS content is always single-period, so the early return at the top of\n    // this method would catch all HLS content.  DASH content stored with v3.0\n    // will already be flattened before storage.  Therefore the only content\n    // that reaches this point is multi-period DASH content stored before v3.0.\n    // Such content always had variants generated from all combinations of audio\n    // and video, so we can simply do that now without loss of correctness.\n    let nextVariantId = 0;\n    if (!combinedVideoStreamDbs.length || !combinedAudioStreamDbs.length) {\n      // For audio-only or video-only content, just give each stream its own\n      // variant ID.\n      const combinedStreamDbs =\n          combinedVideoStreamDbs.concat(combinedAudioStreamDbs);\n      for (const stream of combinedStreamDbs) {\n        stream.variantIds = [nextVariantId++];\n      }\n    } else {\n      for (const audio of combinedAudioStreamDbs) {\n        for (const video of combinedVideoStreamDbs) {\n          const id = nextVariantId++;\n          video.variantIds.push(id);\n          audio.variantIds.push(id);\n        }\n      }\n    }\n\n    return combinedVideoStreamDbs\n        .concat(combinedAudioStreamDbs)\n        .concat(combinedTextStreamDbs);\n  }\n\n  /**\n   * Combine input Streams per period into flat output Streams.\n   * Templatized to handle both DASH Streams and offline StreamDBs.\n   *\n   * @param {!Array.<T>} outputStreams A list of existing output streams, to\n   *   facilitate updates for live DASH content.  Will be modified and returned.\n   * @param {!Array.<!Array.<T>>} streamsPerPeriod A list of lists of Streams\n   *   from each period.\n   * @param {number} firstNewPeriodIndex An index into streamsPerPeriod which\n   *   represents the first new period that hasn't been processed yet.\n   * @param {function(T):T} clone Make a clone of an input stream.\n   * @param {function(T, T)} concat Concatenate the second stream onto the end\n   *   of the first.\n   *\n   * @return {!Promise.<!Array.<T>>} The same array passed to outputStreams,\n   *   modified to include any newly-created streams.\n   *\n   * @template T\n   * Accepts either a StreamDB or Stream type.\n   *\n   * @private\n   */\n  static async combine_(\n      outputStreams, streamsPerPeriod, firstNewPeriodIndex, clone, concat) {\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n    const Iterables = shaka.util.Iterables;\n\n    const unusedStreamsPerPeriod = [];\n    for (const {i, item: streams} of Iterables.enumerate(streamsPerPeriod)) {\n      if (i >= firstNewPeriodIndex) {\n        // This periods streams are all new.\n        unusedStreamsPerPeriod.push(new Set(streams));\n      } else {\n        // This period's streams have all been used already.\n        unusedStreamsPerPeriod.push(new Set());\n      }\n    }\n\n    // First, extend all existing output Streams into the new periods.\n    for (const outputStream of outputStreams) {\n      // eslint-disable-next-line no-await-in-loop\n      const ok = await shaka.util.PeriodCombiner.extendExistingOutputStream_(\n          outputStream, streamsPerPeriod, firstNewPeriodIndex, concat,\n          unusedStreamsPerPeriod);\n      if (!ok) {\n        // This output Stream was not properly extended to include streams from\n        // the new period.  This is likely a bug in our algorithm, so throw an\n        // error.\n        throw new shaka.util.Error(\n            shaka.util.Error.Severity.CRITICAL,\n            shaka.util.Error.Category.MANIFEST,\n            shaka.util.Error.Code.PERIOD_FLATTENING_FAILED);\n      }\n\n      // This output stream is now complete with content from all known\n      // periods.\n    }  // for (const outputStream of outputStreams)\n\n    for (const unusedStreams of unusedStreamsPerPeriod) {\n      for (const stream of unusedStreams) {\n        // Create a new output stream which includes this input stream.\n        const outputStream =\n            // eslint-disable-next-line no-await-in-loop\n            await shaka.util.PeriodCombiner.createNewOutputStream_(\n                stream, streamsPerPeriod, clone, concat,\n                unusedStreamsPerPeriod);\n        if (outputStream) {\n          outputStreams.push(outputStream);\n        } else {\n          // This is not a stream we can build output from, but it may become\n          // part of another output based on another period's stream.\n        }\n      }  // for (const stream of unusedStreams)\n    }  // for (const unusedStreams of unusedStreamsPerPeriod)\n\n    for (const unusedStreams of unusedStreamsPerPeriod) {\n      for (const stream of unusedStreams) {\n        if (stream.type == ContentType.TEXT && !stream.language) {\n          // This is one of our dummy text streams, so ignore it.  We may not\n          // use them all, and that's fine.\n          continue;\n        }\n        // If this stream has a different codec/MIME than any other stream,\n        // then we can't play it.\n        // TODO(#1528): Consider changing this when we support codec switching.\n        const hasCodec = outputStreams.some((s) => {\n          return s.mimeType == stream.mimeType &&\n                shaka.util.MimeUtils.getCodecBase(s.codecs) ==\n                    shaka.util.MimeUtils.getCodecBase(stream.codecs);\n        });\n        if (!hasCodec) {\n          continue;\n        }\n\n        // Any other unused stream is likely a bug in our algorithm, so throw\n        // an error.\n        throw new shaka.util.Error(\n            shaka.util.Error.Severity.CRITICAL,\n            shaka.util.Error.Category.MANIFEST,\n            shaka.util.Error.Code.PERIOD_FLATTENING_FAILED);\n      }\n    }\n\n    return outputStreams;\n  }\n\n  /**\n   * @param {T} outputStream An existing output stream which needs to be\n   *   extended into new periods.\n   * @param {!Array.<!Array.<T>>} streamsPerPeriod A list of lists of Streams\n   *   from each period.\n   * @param {number} firstNewPeriodIndex An index into streamsPerPeriod which\n   *   represents the first new period that hasn't been processed yet.\n   * @param {function(T, T)} concat Concatenate the second stream onto the end\n   *   of the first.\n   * @param {!Array.<!Set.<T>>} unusedStreamsPerPeriod An array of sets of\n   *   unused streams from each period.\n   *\n   * @return {!Promise.<boolean>}\n   *\n   * @template T\n   * Should only be called with a Stream type in practice, but has call sites\n   * from other templated functions that also accept a StreamDB.\n   *\n   * @private\n   */\n  static async extendExistingOutputStream_(\n      outputStream, streamsPerPeriod, firstNewPeriodIndex, concat,\n      unusedStreamsPerPeriod) {\n    const matches = shaka.util.PeriodCombiner.findMatchesInAllPeriods_(\n        streamsPerPeriod, outputStream);\n\n    if (!matches) {\n      // We were unable to extend this output stream.\n      return false;\n    }\n\n    // This only exists where T == Stream, and this should only ever be called\n    // on Stream types.  StreamDB should not have pre-existing output streams.\n    goog.asserts.assert(outputStream.createSegmentIndex,\n        'outputStream should be a Stream type!');\n\n    // We need to create all the per-period segment indexes and append them to\n    // the output's MetaSegmentIndex.\n    await Promise.all(matches.map((match) => match.createSegmentIndex()));\n\n    // Assure the compiler that matches didn't become null during the async\n    // operation above.\n    goog.asserts.assert(matches, 'Matches should be non-null');\n\n    shaka.util.PeriodCombiner.extendOutputStream_(\n        outputStream, matches, firstNewPeriodIndex, concat,\n        unusedStreamsPerPeriod);\n    return true;\n  }\n\n  /**\n   * Create a new output Stream based on a particular input Stream.  Locates\n   * matching Streams in all other periods and combines them into an output\n   * Stream.\n   * Templatized to handle both DASH Streams and offline StreamDBs.\n   *\n   * @param {T} stream An input stream on which to base the output stream.\n   * @param {!Array.<!Array.<T>>} streamsPerPeriod A list of lists of Streams\n   *   from each period.\n   * @param {function(T):T} clone Make a clone of an input stream.\n   * @param {function(T, T)} concat Concatenate the second stream onto the end\n   *   of the first.\n   * @param {!Array.<!Set.<T>>} unusedStreamsPerPeriod An array of sets of\n   *   unused streams from each period.\n   *\n   * @return {!Promise.<?T>} A newly-created output Stream, or null if matches\n   *   could not be found.`\n   *\n   * @template T\n   * Accepts either a StreamDB or Stream type.\n   *\n   * @private\n   */\n  static async createNewOutputStream_(\n      stream, streamsPerPeriod, clone, concat, unusedStreamsPerPeriod) {\n    // Start by cloning the stream without segments, key IDs, etc.\n    const outputStream = clone(stream);\n\n    // Find best-matching streams in all periods.\n    const matches = shaka.util.PeriodCombiner.findMatchesInAllPeriods_(\n        streamsPerPeriod, outputStream);\n\n    if (!matches) {\n      // This is not a stream we can build output from, but it may become part\n      // of another output based on another period's stream.\n      return null;\n    }\n\n    // This only exists where T == Stream.\n    if (outputStream.createSegmentIndex) {\n      // For T == Stream, we need to create all the per-period segment indexes\n      // in advance.  concat() will add them to the output's MetaSegmentIndex.\n      await Promise.all(matches.map((match) => match.createSegmentIndex()));\n    }\n\n    // Assure the compiler that matches didn't become null during the async\n    // operation above.\n    goog.asserts.assert(matches, 'Matches should be non-null');\n\n    shaka.util.PeriodCombiner.extendOutputStream_(\n        outputStream, matches, /* firstNewPeriodIndex= */ 0, concat,\n        unusedStreamsPerPeriod);\n\n    return outputStream;\n  }\n\n  /**\n   * @param {T} outputStream An existing output stream which needs to be\n   *   extended into new periods.\n   * @param {!Array.<T>} matches A list of matching Streams from each period.\n   * @param {number} firstNewPeriodIndex An index into streamsPerPeriod which\n   *   represents the first new period that hasn't been processed yet.\n   * @param {function(T, T)} concat Concatenate the second stream onto the end\n   *   of the first.\n   * @param {!Array.<!Set.<T>>} unusedStreamsPerPeriod An array of sets of\n   *   unused streams from each period.\n   *\n   * @template T\n   * Accepts either a StreamDB or Stream type.\n   *\n   * @private\n   */\n  static extendOutputStream_(\n      outputStream, matches, firstNewPeriodIndex, concat,\n      unusedStreamsPerPeriod) {\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n    const LanguageUtils = shaka.util.LanguageUtils;\n\n    // Concatenate the new matches onto the stream, starting at the first new\n    // period.\n    const Iterables = shaka.util.Iterables;\n    for (const {i, item: match} of Iterables.enumerate(matches)) {\n      if (i >= firstNewPeriodIndex) {\n        concat(outputStream, match);\n\n        // We only consider an audio stream \"used\" if its language is related to\n        // the output language.  There are scenarios where we want to generate\n        // separate tracks for each language, even when we are forced to connect\n        // unrelated languages across periods.\n        let used = true;\n        if (outputStream.type == ContentType.AUDIO) {\n          const relatedness = LanguageUtils.relatedness(\n              outputStream.language, match.language);\n          if (relatedness == 0) {\n            used = false;\n          }\n        }\n\n        if (used) {\n          unusedStreamsPerPeriod[i].delete(match);\n        }\n      }\n    }\n  }\n\n  /**\n   * Clone a Stream to make an output Stream for combining others across\n   * periods.\n   *\n   * @param {shaka.extern.Stream} stream\n   * @return {shaka.extern.Stream}\n   * @private\n   */\n  static cloneStream_(stream) {\n    const clone = /** @type {shaka.extern.Stream} */(Object.assign({}, stream));\n\n    // These are wiped out now and rebuilt later from the various per-period\n    // streams that match this output.\n    clone.originalId = null;\n    clone.createSegmentIndex = () => Promise.resolve();\n    clone.segmentIndex = new shaka.media.MetaSegmentIndex();\n    clone.emsgSchemeIdUris = [];\n    clone.keyIds = new Set();\n    clone.closedCaptions = null;\n    clone.trickModeVideo = null;\n\n    return clone;\n  }\n\n  /**\n   * Clone a StreamDB to make an output stream for combining others across\n   * periods.\n   *\n   * @param {shaka.extern.StreamDB} streamDb\n   * @return {shaka.extern.StreamDB}\n   * @private\n   */\n  static cloneStreamDB_(streamDb) {\n    const clone = /** @type {shaka.extern.StreamDB} */(Object.assign(\n        {}, streamDb));\n\n    // These are wiped out now and rebuilt later from the various per-period\n    // streams that match this output.\n    clone.keyIds = new Set();\n    clone.segments = [];\n    clone.variantIds = [];\n    clone.closedCaptions = null;\n\n    return clone;\n  }\n\n  /**\n   * Combine the various fields of the input Stream into the output.\n   *\n   * @param {shaka.extern.Stream} output\n   * @param {shaka.extern.Stream} input\n   * @private\n   */\n  static concatenateStreams_(output, input) {\n    // We keep the original stream's bandwidth, resolution, frame rate,\n    // sample rate, and channel count to ensure that it's properly\n    // matched with similar content in other periods further down\n    // the line.\n\n    // Combine arrays, keeping only the unique elements\n    const combineArrays = (a, b) => Array.from(new Set(a.concat(b)));\n    output.roles = combineArrays(output.roles, input.roles);\n\n    if (input.emsgSchemeIdUris) {\n      output.emsgSchemeIdUris = combineArrays(\n          output.emsgSchemeIdUris, input.emsgSchemeIdUris);\n    }\n\n    const combineSets = (a, b) => new Set([...a, ...b]);\n    output.keyIds = combineSets(output.keyIds, input.keyIds);\n\n    if (output.originalId == null) {\n      output.originalId = input.originalId;\n    } else {\n      output.originalId += ',' + (input.originalId || '');\n    }\n\n    const commonDrmInfos = shaka.media.DrmEngine.getCommonDrmInfos(\n        output.drmInfos, input.drmInfos);\n    if (input.drmInfos.length && output.drmInfos.length &&\n        !commonDrmInfos.length) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.MANIFEST,\n          shaka.util.Error.Code.INCONSISTENT_DRM_ACROSS_PERIODS);\n    }\n    output.drmInfos = commonDrmInfos;\n\n    // The output is encrypted if any input was encrypted.\n    output.encrypted = output.encrypted || input.encrypted;\n\n    // Combine the closed captions maps.\n    if (input.closedCaptions) {\n      if (!output.closedCaptions) {\n        output.closedCaptions = new Map();\n      }\n      for (const [key, value] of input.closedCaptions) {\n        output.closedCaptions.set(key, value);\n      }\n    }\n\n    // Satisfy the compiler about the type.\n    goog.asserts.assert(\n        output.segmentIndex instanceof shaka.media.MetaSegmentIndex,\n        'Output streams should have a MetaSegmentIndex!');\n    // Satisfy the compiler that the input index has been created.\n    goog.asserts.assert(\n        input.segmentIndex,\n        'Input segment index should have been created by now!');\n\n    output.segmentIndex.appendSegmentIndex(input.segmentIndex);\n\n    // Combine trick-play video streams, if present.\n    if (input.trickModeVideo) {\n      if (!output.trickModeVideo) {\n        // Create a fresh output stream for trick-mode playback.\n        output.trickModeVideo = shaka.util.PeriodCombiner.cloneStream_(\n            input.trickModeVideo);\n        // Start it with whatever non-trick-mode Streams are in the output so\n        // far.\n        output.trickModeVideo.segmentIndex = output.segmentIndex.clone();\n      }\n\n      // Concatenate the trick mode input onto the trick mode output.\n      shaka.util.PeriodCombiner.concatenateStreams_(\n          output.trickModeVideo, input.trickModeVideo);\n    } else if (output.trickModeVideo) {\n      // We have a trick mode output, but no input from this Period.  Fill it in\n      // from the standard input Stream.\n      shaka.util.PeriodCombiner.concatenateStreams_(\n          output.trickModeVideo, input);\n    }\n  }\n\n  /**\n   * Combine the various fields of the input StreamDB into the output.\n   *\n   * @param {shaka.extern.StreamDB} output\n   * @param {shaka.extern.StreamDB} input\n   * @private\n   */\n  static concatenateStreamDBs_(output, input) {\n    // Combine arrays, keeping only the unique elements\n    const combineArrays = (a, b) => Array.from(new Set(a.concat(b)));\n    output.roles = combineArrays(output.roles, input.roles);\n\n    const combineSets = (a, b) => new Set([...a, ...b]);\n    output.keyIds = combineSets(output.keyIds, input.keyIds);\n\n    // The output is encrypted if any input was encrypted.\n    output.encrypted = output.encrypted && input.encrypted;\n\n    // Concatenate segments without de-duping.\n    output.segments.push(...input.segments);\n\n    // Combine the closed captions maps.\n    if (input.closedCaptions) {\n      if (!output.closedCaptions) {\n        output.closedCaptions = new Map();\n      }\n      for (const [key, value] of input.closedCaptions) {\n        output.closedCaptions.set(key, value);\n      }\n    }\n  }\n\n  /**\n   * Finds streams in all periods which match the output stream.\n   *\n   * @param {!Array.<!Array.<T>>} streamsPerPeriod\n   * @param {T} outputStream\n   * @return {Array.<T>}\n   *\n   * @template T\n   * Accepts either a StreamDB or Stream type.\n   *\n   * @private\n   */\n  static findMatchesInAllPeriods_(streamsPerPeriod, outputStream) {\n    const matches = [];\n    for (const streams of streamsPerPeriod) {\n      const match = shaka.util.PeriodCombiner.findBestMatchInPeriod_(\n          streams, outputStream);\n      if (!match) {\n        return null;\n      }\n      matches.push(match);\n    }\n    return matches;\n  }\n\n  /**\n   * Find the best match for the output stream.\n   *\n   * @param {!Array.<T>} streams\n   * @param {T} outputStream\n   * @return {?T}  Returns null if no match can be found.\n   *\n   * @template T\n   * Accepts either a StreamDB or Stream type.\n   *\n   * @private\n   */\n  static findBestMatchInPeriod_(streams, outputStream) {\n    const areCompatible = {\n      'audio': shaka.util.PeriodCombiner.areAVStreamsCompatible_,\n      'video': shaka.util.PeriodCombiner.areAVStreamsCompatible_,\n      'text': shaka.util.PeriodCombiner.areTextStreamsCompatible_,\n    }[outputStream.type];\n\n    const isBetterMatch = {\n      'audio': shaka.util.PeriodCombiner.isAudioStreamBetterMatch_,\n      'video': shaka.util.PeriodCombiner.isVideoStreamBetterMatch_,\n      'text': shaka.util.PeriodCombiner.isTextStreamBetterMatch_,\n    }[outputStream.type];\n\n    let best = null;\n\n    for (const stream of streams) {\n      if (!areCompatible(outputStream, stream)) {\n        continue;\n      }\n\n      if (!best || isBetterMatch(outputStream, best, stream)) {\n        best = stream;\n      }\n    }\n\n    return best;\n  }\n\n  /**\n   * @param {T} outputStream An audio or video output stream\n   * @param {T} candidate A candidate stream to be combined with the output\n   * @return {boolean} True if the candidate could be combined with the\n   *   output stream\n   *\n   * @template T\n   * Accepts either a StreamDB or Stream type.\n   *\n   * @private\n   */\n  static areAVStreamsCompatible_(outputStream, candidate) {\n    const getCodecBase = (codecs) => shaka.util.MimeUtils.getCodecBase(codecs);\n    // Check MIME type and codecs, which should always be the same.\n    if (candidate.mimeType != outputStream.mimeType ||\n        getCodecBase(candidate.codecs) != getCodecBase(outputStream.codecs)) {\n      return false;\n    }\n\n    // This field is only available on Stream, not StreamDB.\n    if (outputStream.drmInfos) {\n      // Check for compatible DRM systems.  Note that clear streams are\n      // implicitly compatible with any DRM and with each other.\n      if (!shaka.media.DrmEngine.areDrmCompatible(outputStream.drmInfos,\n          candidate.drmInfos)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  /**\n   * @param {T} outputStream A text output stream\n   * @param {T} candidate A candidate stream to be combined with the output\n   * @return {boolean} True if the candidate could be combined with the\n   *   output\n   *\n   * @template T\n   * Accepts either a StreamDB or Stream type.\n   *\n   * @private\n   */\n  static areTextStreamsCompatible_(outputStream, candidate) {\n    const LanguageUtils = shaka.util.LanguageUtils;\n\n    // For text, we don't care about MIME type or codec.  We can always switch\n    // between text types.\n\n    // The output stream should not be a dummy stream inserted to fill a period\n    // gap.  So reject any candidate if the output has no language.  This would\n    // cause findMatchesInAllPeriods_ to return null and this output stream to\n    // be skipped (meaning no output streams based on it).\n    if (!outputStream.language) {\n      return false;\n    }\n\n    // If the candidate is a dummy, then it is compatible, and we could use it\n    // if nothing else matches.\n    if (!candidate.language) {\n      return true;\n    }\n\n    const languageRelatedness = LanguageUtils.relatedness(\n        outputStream.language, candidate.language);\n\n    // We will strictly avoid combining text across languages or \"kinds\"\n    // (caption vs subtitle).\n    if (languageRelatedness == 0 ||\n        candidate.kind != outputStream.kind) {\n      return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * @param {T} outputStream An audio output stream\n   * @param {T} best The best match so far for this period\n   * @param {T} candidate A candidate stream which might be better\n   * @return {boolean} True if the candidate is a better match\n   *\n   * @template T\n   * Accepts either a StreamDB or Stream type.\n   *\n   * @private\n   */\n  static isAudioStreamBetterMatch_(outputStream, best, candidate) {\n    const LanguageUtils = shaka.util.LanguageUtils;\n    const {BETTER, EQUAL, WORSE} = shaka.util.PeriodCombiner.BetterOrWorse;\n\n    // If the output stream was based on the candidate stream, the candidate\n    // stream should be considered a better match. We can check this by\n    // comparing their ids.\n    if (outputStream.id == candidate.id) {\n      return true;\n    }\n\n    // Otherwise, compare the streams' characteristics to detecrmine the best\n    // match.\n\n    // The most important thing is language.  In some cases, we will accept a\n    // different language across periods when we must.\n    const bestRelatedness = LanguageUtils.relatedness(\n        outputStream.language, best.language);\n    const candidateRelatedness = LanguageUtils.relatedness(\n        outputStream.language, candidate.language);\n\n    if (candidateRelatedness > bestRelatedness) {\n      return true;\n    }\n    if (candidateRelatedness < bestRelatedness) {\n      return false;\n    }\n\n    // If the language doesn't match, but the candidate is the \"primary\"\n    // language, then that should be preferred as a fallback.\n    if (!best.primary && candidate.primary) {\n      return true;\n    }\n    if (best.primary && !candidate.primary) {\n      return false;\n    }\n\n    // If language-based differences haven't decided this, look at roles.  If\n    // the candidate has more roles in common with the output, upgrade to the\n    // candidate.\n    if (outputStream.roles.length) {\n      const bestRoleMatches =\n          best.roles.filter((role) => outputStream.roles.includes(role));\n      const candidateRoleMatches =\n          candidate.roles.filter((role) => outputStream.roles.includes(role));\n      if (candidateRoleMatches.length > bestRoleMatches.length) {\n        return true;\n      } else if (candidateRoleMatches.length < bestRoleMatches.length) {\n        return false;\n      } else {\n        // Both streams have the same role overlap with the outputStream\n        // If this is the case, choose the stream with the fewer roles overall.\n        // Streams that match best together tend to be streams with the same\n        // roles, e g stream1 with roles [r1, r2] is likely a better match\n        // for stream2 with roles [r1, r2] vs stream3 with roles\n        // [r1, r2, r3, r4].\n        // If we match stream1 with stream3 due to the same role overlap,\n        // stream2 is likely to be left unmatched and error out later.\n        // See https://github.com/google/shaka-player/issues/2542 for\n        // more details.\n        return candidate.roles.length < best.roles.length;\n      }\n    } else if (!candidate.roles.length && best.roles.length) {\n      // If outputStream has no roles, and only one of the streams has no roles,\n      // choose the one with no roles.\n      return true;\n    } else if (candidate.roles.length && !best.roles.length) {\n      return false;\n    }\n\n    // If language-based and role-based features are equivalent, take the audio\n    // with the closes channel count to the output.\n    const channelsBetterOrWorse =\n        shaka.util.PeriodCombiner.compareClosestPreferLower(\n            outputStream.channelsCount,\n            best.channelsCount,\n            candidate.channelsCount);\n    if (channelsBetterOrWorse == BETTER) {\n      return true;\n    } else if (channelsBetterOrWorse == WORSE) {\n      return false;\n    }\n\n    // If channels are equal, take the closest sample rate to the output.\n    const sampleRateBetterOrWorse =\n        shaka.util.PeriodCombiner.compareClosestPreferLower(\n            outputStream.audioSamplingRate,\n            best.audioSamplingRate,\n            candidate.audioSamplingRate);\n    if (sampleRateBetterOrWorse == BETTER) {\n      return true;\n    } else if (sampleRateBetterOrWorse == WORSE) {\n      return false;\n    }\n\n    if (outputStream.bandwidth) {\n      // Take the audio with the closest bandwidth to the output.\n      const bandwidthBetterOrWorse =\n          shaka.util.PeriodCombiner.compareClosestPreferMinimalAbsDiff_(\n              outputStream.bandwidth,\n              best.bandwidth,\n              candidate.bandwidth);\n      if (bandwidthBetterOrWorse == BETTER) {\n        return true;\n      } else if (bandwidthBetterOrWorse == WORSE) {\n        return false;\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * @param {T} outputStream A video output stream\n   * @param {T} best The best match so far for this period\n   * @param {T} candidate A candidate stream which might be better\n   * @return {boolean} True if the candidate is a better match\n   *\n   * @template T\n   * Accepts either a StreamDB or Stream type.\n   *\n   * @private\n   */\n  static isVideoStreamBetterMatch_(outputStream, best, candidate) {\n    const {BETTER, EQUAL, WORSE} = shaka.util.PeriodCombiner.BetterOrWorse;\n\n    // If the output stream was based on the candidate stream, the candidate\n    // stream should be considered a better match. We can check this by\n    // comparing their ids.\n    if (outputStream.id == candidate.id) {\n      return true;\n    }\n\n    // Otherwise, compare the streams' characteristics to detecrmine the best\n    // match.\n\n    // Take the video with the closest resolution to the output.\n    const resolutionBetterOrWorse =\n        shaka.util.PeriodCombiner.compareClosestPreferLower(\n            outputStream.width * outputStream.height,\n            best.width * best.height,\n            candidate.width * candidate.height);\n    if (resolutionBetterOrWorse == BETTER) {\n      return true;\n    } else if (resolutionBetterOrWorse == WORSE) {\n      return false;\n    }\n\n    // We may not know the frame rate for the content, in which case this gets\n    // skipped.\n    if (outputStream.frameRate) {\n      // Take the video with the closest frame rate to the output.\n      const frameRateBetterOrWorse =\n          shaka.util.PeriodCombiner.compareClosestPreferLower(\n              outputStream.frameRate,\n              best.frameRate,\n              candidate.frameRate);\n      if (frameRateBetterOrWorse == BETTER) {\n        return true;\n      } else if (frameRateBetterOrWorse == WORSE) {\n        return false;\n      }\n    }\n\n\n    if (outputStream.bandwidth) {\n      // Take the video with the closest bandwidth to the output.\n      const bandwidthBetterOrWorse =\n          shaka.util.PeriodCombiner.compareClosestPreferMinimalAbsDiff_(\n              outputStream.bandwidth,\n              best.bandwidth,\n              candidate.bandwidth);\n      if (bandwidthBetterOrWorse == BETTER) {\n        return true;\n      } else if (bandwidthBetterOrWorse == WORSE) {\n        return false;\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * @param {T} outputStream A text output stream\n   * @param {T} best The best match so far for this period\n   * @param {T} candidate A candidate stream which might be better\n   * @return {boolean} True if the candidate is a better match\n   *\n   * @template T\n   * Accepts either a StreamDB or Stream type.\n   *\n   * @private\n   */\n  static isTextStreamBetterMatch_(outputStream, best, candidate) {\n    const LanguageUtils = shaka.util.LanguageUtils;\n\n    // If the output stream was based on the candidate stream, the candidate\n    // stream should be considered a better match. We can check this by\n    // comparing their ids.\n    if (outputStream.id == candidate.id) {\n      return true;\n    }\n\n    // Otherwise, compare the streams' characteristics to detecrmine the best\n    // match.\n\n    // The most important thing is language.  In some cases, we will accept a\n    // different language across periods when we must.\n    const bestRelatedness = LanguageUtils.relatedness(\n        outputStream.language, best.language);\n    const candidateRelatedness = LanguageUtils.relatedness(\n        outputStream.language, candidate.language);\n\n    if (candidateRelatedness > bestRelatedness) {\n      return true;\n    }\n    if (candidateRelatedness < bestRelatedness) {\n      return false;\n    }\n\n    // If the language doesn't match, but the candidate is the \"primary\"\n    // language, then that should be preferred as a fallback.\n    if (!best.primary && candidate.primary) {\n      return true;\n    }\n    if (best.primary && !candidate.primary) {\n      return false;\n    }\n\n    // If the candidate has more roles in common with the output, upgrade to the\n    // candidate.\n    if (outputStream.roles.length) {\n      const bestRoleMatches =\n          best.roles.filter((role) => outputStream.roles.includes(role));\n      const candidateRoleMatches =\n          candidate.roles.filter((role) => outputStream.roles.includes(role));\n      if (candidateRoleMatches.length > bestRoleMatches.length) {\n        return true;\n      }\n      if (candidateRoleMatches.length < bestRoleMatches.length) {\n        return false;\n      }\n    } else if (!candidate.roles.length && best.roles.length) {\n      // If outputStream has no roles, and only one of the streams has no roles,\n      // choose the one with no roles.\n      return true;\n    } else if (candidate.roles.length && !best.roles.length) {\n      return false;\n    }\n\n    // If the candidate has the same MIME type and codec, upgrade to the\n    // candidate.  It's not required that text streams use the same format\n    // across periods, but it's a helpful signal.  Some content in our demo app\n    // contains the same languages repeated with two different text formats in\n    // each period.  This condition ensures that all text streams are used.\n    // Otherwise, we wind up with some one stream of each language left unused,\n    // triggering a failure.\n    if (candidate.mimeType == outputStream.mimeType &&\n        candidate.codecs == outputStream.codecs &&\n        (best.mimeType != outputStream.mimeType ||\n         best.codecs != outputStream.codecs)) {\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Create a dummy text StreamDB to fill in periods with no text, to avoid\n   * failing the general flattening algorithm.\n   *\n   * @return {shaka.extern.StreamDB}\n   * @private\n   */\n  static dummyTextStreamDB_() {\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n\n    return {\n      id: 0,\n      originalId: '',\n      primary: false,\n      type: ContentType.TEXT,\n      mimeType: '',\n      codecs: '',\n      language: '',\n      label: null,\n      width: null,\n      height: null,\n      encrypted: false,\n      keyIds: new Set(),\n      segments: [],\n      variantIds: [],\n      roles: [],\n      channelsCount: null,\n      audioSamplingRate: null,\n      closedCaptions: null,\n    };\n  }\n\n  /**\n   * Create a dummy text Stream to fill in periods with no text, to avoid\n   * failing the general flattening algorithm.\n   *\n   * @return {shaka.extern.Stream}\n   * @private\n   */\n  static dummyTextStream_() {\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n\n    return {\n      id: 0,\n      originalId: '',\n      createSegmentIndex: () => Promise.resolve(),\n      segmentIndex: new shaka.media.SegmentIndex([]),\n      mimeType: '',\n      codecs: '',\n      encrypted: false,\n      drmInfos: [],\n      keyIds: new Set(),\n      language: '',\n      label: null,\n      type: ContentType.TEXT,\n      primary: false,\n      trickModeVideo: null,\n      emsgSchemeIdUris: null,\n      roles: [],\n      channelsCount: null,\n      audioSamplingRate: null,\n      closedCaptions: null,\n    };\n  }\n\n  /**\n   * Compare the best value so far with the candidate value and the output\n   * value.  Decide if the candidate is better, equal, or worse than the best\n   * so far.  Any value less than or equal to the output is preferred over a\n   * larger value, and closer to the output is better than farther.\n   *\n   * This provides us a generic way to choose things that should match as\n   * closely as possible, like resolution, frame rate, audio channels, or\n   * sample rate.  If we have to go higher to make a match, we will.  But if\n   * the user selects 480p, for example, we don't want to surprise them with\n   * 720p and waste bandwidth if there's another choice available to us.\n   *\n   * @param {number} outputValue\n   * @param {number} bestValue\n   * @param {number} candidateValue\n   * @return {shaka.util.PeriodCombiner.BetterOrWorse}\n   */\n  static compareClosestPreferLower(outputValue, bestValue, candidateValue) {\n    const {BETTER, EQUAL, WORSE} = shaka.util.PeriodCombiner.BetterOrWorse;\n\n    // If one is the exact match for the output value, and the other isn't,\n    // prefer the one that is the exact match.\n    if (bestValue == outputValue && outputValue != candidateValue) {\n      return WORSE;\n    } else if (candidateValue == outputValue && outputValue != bestValue) {\n      return BETTER;\n    }\n\n    if (bestValue > outputValue) {\n      if (candidateValue <= outputValue) {\n        // Any smaller-or-equal-to-output value is preferable to a\n        // bigger-than-output value.\n        return BETTER;\n      }\n\n      // Both \"best\" and \"candidate\" are greater than the output.  Take\n      // whichever is closer.\n      if (candidateValue - outputValue < bestValue - outputValue) {\n        return BETTER;\n      } else if (candidateValue - outputValue > bestValue - outputValue) {\n        return WORSE;\n      }\n    } else {\n      // The \"best\" so far is less than or equal to the output.  If the\n      // candidate is bigger than the output, we don't want it.\n      if (candidateValue > outputValue) {\n        return WORSE;\n      }\n\n      // Both \"best\" and \"candidate\" are less than or equal to the output.\n      // Take whichever is closer.\n      if (outputValue - candidateValue < outputValue - bestValue) {\n        return BETTER;\n      } else if (outputValue - candidateValue > outputValue - bestValue) {\n        return WORSE;\n      }\n    }\n\n    return EQUAL;\n  }\n\n  /**\n   * @param {number} outputValue\n   * @param {number} bestValue\n   * @param {number} candidateValue\n   * @return {shaka.util.PeriodCombiner.BetterOrWorse}\n   * @private\n   */\n  static compareClosestPreferMinimalAbsDiff_(\n      outputValue, bestValue, candidateValue) {\n    const {BETTER, EQUAL, WORSE} = shaka.util.PeriodCombiner.BetterOrWorse;\n\n    const absDiffBest = Math.abs(outputValue - bestValue);\n    const absDiffCandidate = Math.abs(outputValue - candidateValue);\n    if (absDiffCandidate < absDiffBest) {\n      return BETTER;\n    } else if (absDiffBest < absDiffCandidate) {\n      return WORSE;\n    }\n\n    return EQUAL;\n  }\n};\n\n/**\n * @typedef {{\n *   id: string,\n *   audioStreams: !Array.<shaka.extern.Stream>,\n *   videoStreams: !Array.<shaka.extern.Stream>,\n *   textStreams: !Array.<shaka.extern.Stream>\n * }}\n *\n * @description Contains the streams from one DASH period.\n *\n * @property {string} id\n *   The Period ID.\n * @property {!Array.<shaka.extern.Stream>} audioStreams\n *   The audio streams from one Period.\n * @property {!Array.<shaka.extern.Stream>} videoStreams\n *   The video streams from one Period.\n * @property {!Array.<shaka.extern.Stream>} textStreams\n *   The text streams from one Period.\n */\nshaka.util.PeriodCombiner.Period;\n\n/**\n * @enum {number}\n */\nshaka.util.PeriodCombiner.BetterOrWorse = {\n  BETTER: 1,\n  EQUAL: 0,\n  WORSE: -1,\n};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.dash.DashParser');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.abr.Ewma');\ngoog.require('shaka.dash.ContentProtection');\ngoog.require('shaka.dash.MpdUtils');\ngoog.require('shaka.dash.SegmentBase');\ngoog.require('shaka.dash.SegmentList');\ngoog.require('shaka.dash.SegmentTemplate');\ngoog.require('shaka.log');\ngoog.require('shaka.media.ManifestParser');\ngoog.require('shaka.media.PresentationTimeline');\ngoog.require('shaka.media.SegmentIndex');\ngoog.require('shaka.net.NetworkingEngine');\ngoog.require('shaka.text.TextEngine');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.Functional');\ngoog.require('shaka.util.Iterables');\ngoog.require('shaka.util.LanguageUtils');\ngoog.require('shaka.util.ManifestParserUtils');\ngoog.require('shaka.util.MimeUtils');\ngoog.require('shaka.util.Networking');\ngoog.require('shaka.util.OperationManager');\ngoog.require('shaka.util.PeriodCombiner');\ngoog.require('shaka.util.StringUtils');\ngoog.require('shaka.util.Timer');\ngoog.require('shaka.util.XmlUtils');\n\n\n/**\n * Creates a new DASH parser.\n *\n * @implements {shaka.extern.ManifestParser}\n * @export\n */\nshaka.dash.DashParser = class {\n  /** Creates a new DASH parser. */\n  constructor() {\n    /** @private {?shaka.extern.ManifestConfiguration} */\n    this.config_ = null;\n\n    /** @private {?shaka.extern.ManifestParser.PlayerInterface} */\n    this.playerInterface_ = null;\n\n    /** @private {!Array.<string>} */\n    this.manifestUris_ = [];\n\n    /** @private {?shaka.extern.Manifest} */\n    this.manifest_ = null;\n\n    /** @private {number} */\n    this.globalId_ = 1;\n\n    /**\n     * A map of IDs to SegmentIndex objects.\n     * ID: Period@id,AdaptationSet@id,@Representation@id\n     * e.g.: '1,5,23'\n     * @private {!Object.<string, !shaka.media.SegmentIndex>}\n     */\n    this.segmentIndexMap_ = {};\n\n    /** @private {shaka.util.PeriodCombiner} */\n    this.periodCombiner_ = new shaka.util.PeriodCombiner();\n\n    /**\n     * The update period in seconds, or 0 for no updates.\n     * @private {number}\n     */\n    this.updatePeriod_ = 0;\n\n    /**\n     * An ewma that tracks how long updates take.\n     * This is to mitigate issues caused by slow parsing on embedded devices.\n     * @private {!shaka.abr.Ewma}\n     */\n    this.averageUpdateDuration_ = new shaka.abr.Ewma(5);\n\n    /** @private {shaka.util.Timer} */\n    this.updateTimer_ = new shaka.util.Timer(() => {\n      this.onUpdate_();\n    });\n\n    /** @private {!shaka.util.OperationManager} */\n    this.operationManager_ = new shaka.util.OperationManager();\n  }\n\n  /**\n   * @override\n   * @exportInterface\n   */\n  configure(config) {\n    goog.asserts.assert(config.dash != null,\n        'DashManifestConfiguration should not be null!');\n\n    this.config_ = config;\n  }\n\n  /**\n   * @override\n   * @exportInterface\n   */\n  async start(uri, playerInterface) {\n    goog.asserts.assert(this.config_, 'Must call configure() before start()!');\n    this.manifestUris_ = [uri];\n    this.playerInterface_ = playerInterface;\n\n    const updateDelay = await this.requestManifest_();\n\n    if (this.playerInterface_) {\n      this.setUpdateTimer_(updateDelay);\n    }\n\n    // Make sure that the parser has not been destroyed.\n    if (!this.playerInterface_) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.PLAYER,\n          shaka.util.Error.Code.OPERATION_ABORTED);\n    }\n\n    goog.asserts.assert(this.manifest_, 'Manifest should be non-null!');\n    return this.manifest_;\n  }\n\n  /**\n   * @override\n   * @exportInterface\n   */\n  stop() {\n    // When the parser stops, release all segment indexes, which stops their\n    // timers, as well.\n    for (const segmentIndex of Object.values(this.segmentIndexMap_)) {\n      segmentIndex.release();\n    }\n\n    if (this.periodCombiner_) {\n      this.periodCombiner_.release();\n    }\n\n    this.playerInterface_ = null;\n    this.config_ = null;\n    this.manifestUris_ = [];\n    this.manifest_ = null;\n    this.segmentIndexMap_ = {};\n    this.periodCombiner_ = null;\n\n    if (this.updateTimer_ != null) {\n      this.updateTimer_.stop();\n      this.updateTimer_ = null;\n    }\n\n    return this.operationManager_.destroy();\n  }\n\n  /**\n   * @override\n   * @exportInterface\n   */\n  async update() {\n    try {\n      await this.requestManifest_();\n    } catch (error) {\n      if (!this.playerInterface_ || !error) {\n        return;\n      }\n      goog.asserts.assert(error instanceof shaka.util.Error, 'Bad error type');\n      this.playerInterface_.onError(error);\n    }\n  }\n\n  /**\n   * @override\n   * @exportInterface\n   */\n  onExpirationUpdated(sessionId, expiration) {\n    // No-op\n  }\n\n  /**\n   * Makes a network request for the manifest and parses the resulting data.\n   *\n   * @return {!Promise.<number>} Resolves with the time it took, in seconds, to\n   *   fulfill the request and parse the data.\n   * @private\n   */\n  async requestManifest_() {\n    const requestType = shaka.net.NetworkingEngine.RequestType.MANIFEST;\n    const request = shaka.net.NetworkingEngine.makeRequest(\n        this.manifestUris_, this.config_.retryParameters);\n    const networkingEngine = this.playerInterface_.networkingEngine;\n\n    const startTime = Date.now();\n    const operation = networkingEngine.request(requestType, request);\n    this.operationManager_.manage(operation);\n\n    const response = await operation.promise;\n\n    // Detect calls to stop().\n    if (!this.playerInterface_) {\n      return 0;\n    }\n\n    // For redirections add the response uri to the first entry in the\n    // Manifest Uris array.\n    if (response.uri && !this.manifestUris_.includes(response.uri)) {\n      this.manifestUris_.unshift(response.uri);\n    }\n\n    // This may throw, but it will result in a failed promise.\n    await this.parseManifest_(response.data, response.uri);\n    // Keep track of how long the longest manifest update took.\n    const endTime = Date.now();\n    const updateDuration = (endTime - startTime) / 1000.0;\n    this.averageUpdateDuration_.sample(1, updateDuration);\n\n    // Let the caller know how long this update took.\n    return updateDuration;\n  }\n\n  /**\n   * Parses the manifest XML.  This also handles updates and will update the\n   * stored manifest.\n   *\n   * @param {BufferSource} data\n   * @param {string} finalManifestUri The final manifest URI, which may\n   *   differ from this.manifestUri_ if there has been a redirect.\n   * @return {!Promise}\n   * @private\n   */\n  async parseManifest_(data, finalManifestUri) {\n    const Error = shaka.util.Error;\n    const MpdUtils = shaka.dash.MpdUtils;\n\n    const mpd = shaka.util.XmlUtils.parseXml(data, 'MPD');\n    if (!mpd) {\n      throw new Error(\n          Error.Severity.CRITICAL, Error.Category.MANIFEST,\n          Error.Code.DASH_INVALID_XML, finalManifestUri);\n    }\n\n    // Process the mpd to account for xlink connections.\n    const failGracefully = this.config_.dash.xlinkFailGracefully;\n    const xlinkOperation = MpdUtils.processXlinks(\n        mpd, this.config_.retryParameters, failGracefully, finalManifestUri,\n        this.playerInterface_.networkingEngine);\n    this.operationManager_.manage(xlinkOperation);\n    const finalMpd = await xlinkOperation.promise;\n    return this.processManifest_(finalMpd, finalManifestUri);\n  }\n\n\n  /**\n   * Takes a formatted MPD and converts it into a manifest.\n   *\n   * @param {!Element} mpd\n   * @param {string} finalManifestUri The final manifest URI, which may\n   *   differ from this.manifestUri_ if there has been a redirect.\n   * @return {!Promise}\n   * @private\n   */\n  async processManifest_(mpd, finalManifestUri) {\n    const Functional = shaka.util.Functional;\n    const XmlUtils = shaka.util.XmlUtils;\n\n    // Get any Location elements.  This will update the manifest location and\n    // the base URI.\n    /** @type {!Array.<string>} */\n    let manifestBaseUris = [finalManifestUri];\n    /** @type {!Array.<string>} */\n    const locations = XmlUtils.findChildren(mpd, 'Location')\n        .map(XmlUtils.getContents)\n        .filter(Functional.isNotNull);\n    if (locations.length > 0) {\n      const absoluteLocations = shaka.util.ManifestParserUtils.resolveUris(\n          manifestBaseUris, locations);\n      this.manifestUris_ = absoluteLocations;\n      manifestBaseUris = absoluteLocations;\n    }\n\n    const uris =\n        XmlUtils.findChildren(mpd, 'BaseURL').map(XmlUtils.getContents);\n    const baseUris = shaka.util.ManifestParserUtils.resolveUris(\n        manifestBaseUris, uris);\n\n    const ignoreMinBufferTime = this.config_.dash.ignoreMinBufferTime;\n    let minBufferTime = 0;\n    if (!ignoreMinBufferTime) {\n      minBufferTime =\n          XmlUtils.parseAttr(mpd, 'minBufferTime', XmlUtils.parseDuration) || 0;\n    }\n\n    this.updatePeriod_ = /** @type {number} */ (XmlUtils.parseAttr(\n        mpd, 'minimumUpdatePeriod', XmlUtils.parseDuration, -1));\n\n    const presentationStartTime = XmlUtils.parseAttr(\n        mpd, 'availabilityStartTime', XmlUtils.parseDate);\n    let segmentAvailabilityDuration = XmlUtils.parseAttr(\n        mpd, 'timeShiftBufferDepth', XmlUtils.parseDuration);\n\n    const ignoreSuggestedPresentationDelay =\n      this.config_.dash.ignoreSuggestedPresentationDelay;\n    let suggestedPresentationDelay = null;\n    if (!ignoreSuggestedPresentationDelay) {\n      suggestedPresentationDelay = XmlUtils.parseAttr(\n          mpd, 'suggestedPresentationDelay', XmlUtils.parseDuration);\n    }\n\n    const maxSegmentDuration = XmlUtils.parseAttr(\n        mpd, 'maxSegmentDuration', XmlUtils.parseDuration);\n    const mpdType = mpd.getAttribute('type') || 'static';\n\n    /** @type {!shaka.media.PresentationTimeline} */\n    let presentationTimeline;\n    if (this.manifest_) {\n      presentationTimeline = this.manifest_.presentationTimeline;\n    } else {\n      // DASH IOP v3.0 suggests using a default delay between minBufferTime\n      // and timeShiftBufferDepth.  This is literally the range of all\n      // feasible choices for the value.  Nothing older than\n      // timeShiftBufferDepth is still available, and anything less than\n      // minBufferTime will cause buffering issues.\n      //\n      // We have decided that our default will be the configured value, or\n      // 1.5 * minBufferTime if not configured. This is fairly conservative.\n      // Content providers should provide a suggestedPresentationDelay whenever\n      // possible to optimize the live streaming experience.\n      const defaultPresentationDelay =\n          this.config_.defaultPresentationDelay || minBufferTime * 1.5;\n      const presentationDelay = suggestedPresentationDelay != null ?\n          suggestedPresentationDelay : defaultPresentationDelay;\n      presentationTimeline = new shaka.media.PresentationTimeline(\n          presentationStartTime, presentationDelay,\n          this.config_.dash.autoCorrectDrift);\n    }\n\n    /** @type {shaka.dash.DashParser.Context} */\n    const context = {\n      // Don't base on updatePeriod_ since emsg boxes can cause manifest\n      // updates.\n      dynamic: mpdType != 'static',\n      presentationTimeline: presentationTimeline,\n      period: null,\n      periodInfo: null,\n      adaptationSet: null,\n      representation: null,\n      bandwidth: 0,\n      indexRangeWarningGiven: false,\n    };\n\n    const periodsAndDuration = this.parsePeriods_(context, baseUris, mpd);\n    const duration = periodsAndDuration.duration;\n    const periods = periodsAndDuration.periods;\n\n    presentationTimeline.setStatic(mpdType == 'static');\n    if (mpdType == 'static' ||\n        !periodsAndDuration.durationDerivedFromPeriods) {\n      // Ignore duration calculated from Period lengths if this is dynamic.\n      presentationTimeline.setDuration(duration || Infinity);\n    }\n\n    const isLive = presentationTimeline.isLive();\n\n    // If it's live, we check for an override.\n    if (isLive && !isNaN(this.config_.availabilityWindowOverride)) {\n      segmentAvailabilityDuration = this.config_.availabilityWindowOverride;\n    }\n\n    // If it's null, that means segments are always available.  This is always\n    // the case for VOD, and sometimes the case for live.\n    if (segmentAvailabilityDuration == null) {\n      segmentAvailabilityDuration = Infinity;\n    }\n\n    presentationTimeline.setSegmentAvailabilityDuration(\n        segmentAvailabilityDuration);\n\n    // Use @maxSegmentDuration to override smaller, derived values.\n    presentationTimeline.notifyMaxSegmentDuration(maxSegmentDuration || 1);\n    if (goog.DEBUG) {\n      presentationTimeline.assertIsValid();\n    }\n\n    await this.periodCombiner_.combinePeriods(periods, context.dynamic);\n\n    // These steps are not done on manifest update.\n    if (!this.manifest_) {\n      this.manifest_ = {\n        presentationTimeline: presentationTimeline,\n        variants: this.periodCombiner_.getVariants(),\n        textStreams: this.periodCombiner_.getTextStreams(),\n        offlineSessionIds: [],\n        minBufferTime: minBufferTime || 0,\n      };\n\n      // We only need to do clock sync when we're using presentation start\n      // time. This condition also excludes VOD streams.\n      if (presentationTimeline.usingPresentationStartTime()) {\n        const XmlUtils = shaka.util.XmlUtils;\n        const timingElements = XmlUtils.findChildren(mpd, 'UTCTiming');\n        const offset = await this.parseUtcTiming_(baseUris, timingElements);\n        // Detect calls to stop().\n        if (!this.playerInterface_) {\n          return;\n        }\n        presentationTimeline.setClockOffset(offset);\n      }\n    } else {\n      // Just update the variants and text streams, which may change as periods\n      // are added or removed.\n      this.manifest_.variants = this.periodCombiner_.getVariants();\n      this.manifest_.textStreams = this.periodCombiner_.getTextStreams();\n    }\n\n    // Add text streams to correspond to closed captions.  This happens right\n    // after period combining, while we still have a direct reference, so that\n    // any new streams will appear in the period combiner.\n    this.playerInterface_.makeTextStreamsForClosedCaptions(this.manifest_);\n\n    goog.asserts.assert(this.manifest_, 'Manifest should exist by now!');\n    await this.playerInterface_.filter(this.manifest_);\n  }\n\n  /**\n   * Reads and parses the periods from the manifest.  This first does some\n   * partial parsing so the start and duration is available when parsing\n   * children.\n   *\n   * @param {shaka.dash.DashParser.Context} context\n   * @param {!Array.<string>} baseUris\n   * @param {!Element} mpd\n   * @return {{\n   *   periods: !Array.<shaka.util.PeriodCombiner.Period>,\n   *   duration: ?number,\n   *   durationDerivedFromPeriods: boolean\n   * }}\n   * @private\n   */\n  parsePeriods_(context, baseUris, mpd) {\n    const XmlUtils = shaka.util.XmlUtils;\n    const presentationDuration = XmlUtils.parseAttr(\n        mpd, 'mediaPresentationDuration', XmlUtils.parseDuration);\n\n    const periods = [];\n    let prevEnd = 0;\n    const periodNodes = XmlUtils.findChildren(mpd, 'Period');\n    // This uses a for-loop rather than a for-of loop because this needs to look\n    // ahead to the next element.\n    const enumerate = (it) => shaka.util.Iterables.enumerate(it);\n    for (const {i, item: elem, next} of enumerate(periodNodes)) {\n      const start = /** @type {number} */ (\n        XmlUtils.parseAttr(elem, 'start', XmlUtils.parseDuration, prevEnd));\n      const givenDuration =\n          XmlUtils.parseAttr(elem, 'duration', XmlUtils.parseDuration);\n\n      let periodDuration = null;\n      if (next) {\n        // \"The difference between the start time of a Period and the start time\n        // of the following Period is the duration of the media content\n        // represented by this Period.\"\n        const nextStart =\n            XmlUtils.parseAttr(next, 'start', XmlUtils.parseDuration);\n        if (nextStart != null) {\n          periodDuration = nextStart - start;\n        }\n      } else if (presentationDuration != null) {\n        // \"The Period extends until the Period.start of the next Period, or\n        // until the end of the Media Presentation in the case of the last\n        // Period.\"\n        periodDuration = presentationDuration - start;\n      }\n\n      const threshold =\n          shaka.util.ManifestParserUtils.GAP_OVERLAP_TOLERANCE_SECONDS;\n      if (periodDuration && givenDuration &&\n          Math.abs(periodDuration - givenDuration) > threshold) {\n        shaka.log.warning('There is a gap/overlap between Periods', elem);\n      }\n      // Only use the @duration in the MPD if we can't calculate it.  We should\n      // favor the @start of the following Period.  This ensures that there\n      // aren't gaps between Periods.\n      if (periodDuration == null) {\n        periodDuration = givenDuration;\n      }\n\n      // Parse child nodes.\n      const info = {\n        start: start,\n        duration: periodDuration,\n        node: elem,\n        isLastPeriod: periodDuration == null || !next,\n      };\n      const period = this.parsePeriod_(context, baseUris, info);\n      periods.push(period);\n\n      if (periodDuration == null) {\n        if (next) {\n          // If the duration is still null and we aren't at the end, then we\n          // will skip any remaining periods.\n          shaka.log.warning(\n              'Skipping Period', i + 1, 'and any subsequent Periods:', 'Period',\n              i + 1, 'does not have a valid start time.', next);\n        }\n\n        // The duration is unknown, so the end is unknown.\n        prevEnd = null;\n        break;\n      }\n\n      prevEnd = start + periodDuration;\n    } // end of period parsing loop\n\n    if (presentationDuration != null) {\n      if (prevEnd != presentationDuration) {\n        shaka.log.warning(\n            '@mediaPresentationDuration does not match the total duration of ',\n            'all Periods.');\n        // Assume @mediaPresentationDuration is correct.\n      }\n      return {\n        periods: periods,\n        duration: presentationDuration,\n        durationDerivedFromPeriods: false,\n      };\n    } else {\n      return {\n        periods: periods,\n        duration: prevEnd,\n        durationDerivedFromPeriods: true,\n      };\n    }\n  }\n\n  /**\n   * Parses a Period XML element.  Unlike the other parse methods, this is not\n   * given the Node; it is given a PeriodInfo structure.  Also, partial parsing\n   * was done before this was called so start and duration are valid.\n   *\n   * @param {shaka.dash.DashParser.Context} context\n   * @param {!Array.<string>} baseUris\n   * @param {shaka.dash.DashParser.PeriodInfo} periodInfo\n   * @return {shaka.util.PeriodCombiner.Period}\n   * @private\n   */\n  parsePeriod_(context, baseUris, periodInfo) {\n    const Functional = shaka.util.Functional;\n    const XmlUtils = shaka.util.XmlUtils;\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n\n    context.period = this.createFrame_(periodInfo.node, null, baseUris);\n    context.periodInfo = periodInfo;\n\n    // If the period doesn't have an ID, give it one based on its start time.\n    if (!context.period.id) {\n      shaka.log.info(\n          'No Period ID given for Period with start time ' + periodInfo.start +\n          ',  Assigning a default');\n      context.period.id = '__shaka_period_' + periodInfo.start;\n    }\n\n    const eventStreamNodes =\n        XmlUtils.findChildren(periodInfo.node, 'EventStream');\n    for (const node of eventStreamNodes) {\n      this.parseEventStream_(periodInfo.start, periodInfo.duration, node);\n    }\n\n    const adaptationSetNodes =\n        XmlUtils.findChildren(periodInfo.node, 'AdaptationSet');\n    const adaptationSets = adaptationSetNodes\n        .map((node) => this.parseAdaptationSet_(context, node))\n        .filter(Functional.isNotNull);\n\n    // For dynamic manifests, we use rep IDs internally, and they must be\n    // unique.\n    if (context.dynamic) {\n      const ids = [];\n      for (const set of adaptationSets) {\n        for (const id of set.representationIds) {\n          ids.push(id);\n        }\n      }\n\n      const uniqueIds = new Set(ids);\n\n      if (ids.length != uniqueIds.size) {\n        throw new shaka.util.Error(\n            shaka.util.Error.Severity.CRITICAL,\n            shaka.util.Error.Category.MANIFEST,\n            shaka.util.Error.Code.DASH_DUPLICATE_REPRESENTATION_ID);\n      }\n    }\n\n    const normalAdaptationSets = adaptationSets\n        .filter((as) => { return !as.trickModeFor; });\n\n    const trickModeAdaptationSets = adaptationSets\n        .filter((as) => { return as.trickModeFor; });\n\n    // Attach trick mode tracks to normal tracks.\n    for (const trickModeSet of trickModeAdaptationSets) {\n      const targetIds = trickModeSet.trickModeFor.split(' ');\n      for (const normalSet of normalAdaptationSets) {\n        if (targetIds.includes(normalSet.id)) {\n          for (const stream of normalSet.streams) {\n            const MimeUtils = shaka.util.MimeUtils;\n            // There may be multiple trick mode streams, but we do not\n            // currently support that.  Just choose one.\n            // TODO: https://github.com/google/shaka-player/issues/1528\n            stream.trickModeVideo = trickModeSet.streams.find((trickStream) =>\n              MimeUtils.getCodecBase(stream.codecs) ==\n              MimeUtils.getCodecBase(trickStream.codecs));\n          }\n        }\n      }\n    }\n\n    const audioSets = this.config_.disableAudio ? [] :\n        this.getSetsOfType_(normalAdaptationSets, ContentType.AUDIO);\n    const videoSets = this.config_.disableVideo ? [] :\n        this.getSetsOfType_(normalAdaptationSets, ContentType.VIDEO);\n    const textSets = this.config_.disableText ? [] :\n        this.getSetsOfType_(normalAdaptationSets, ContentType.TEXT);\n\n    if (!videoSets.length && !audioSets.length) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.MANIFEST,\n          shaka.util.Error.Code.DASH_EMPTY_PERIOD);\n    }\n\n    const audioStreams = [];\n    for (const audioSet of audioSets) {\n      audioStreams.push(...audioSet.streams);\n    }\n\n    const videoStreams = [];\n    for (const videoSet of videoSets) {\n      videoStreams.push(...videoSet.streams);\n    }\n\n    const textStreams = [];\n    for (const textSet of textSets) {\n      textStreams.push(...textSet.streams);\n    }\n\n    return {\n      id: context.period.id,\n      audioStreams,\n      videoStreams,\n      textStreams,\n    };\n  }\n\n  /**\n   * @param {!Array.<!shaka.dash.DashParser.AdaptationInfo>} adaptationSets\n   * @param {string} type\n   * @return {!Array.<!shaka.dash.DashParser.AdaptationInfo>}\n   * @private\n   */\n  getSetsOfType_(adaptationSets, type) {\n    return adaptationSets.filter((as) => {\n      return as.contentType == type;\n    });\n  }\n\n  /**\n   * Parses an AdaptationSet XML element.\n   *\n   * @param {shaka.dash.DashParser.Context} context\n   * @param {!Element} elem The AdaptationSet element.\n   * @return {?shaka.dash.DashParser.AdaptationInfo}\n   * @private\n   */\n  parseAdaptationSet_(context, elem) {\n    const XmlUtils = shaka.util.XmlUtils;\n    const Functional = shaka.util.Functional;\n    const ManifestParserUtils = shaka.util.ManifestParserUtils;\n    const ContentType = ManifestParserUtils.ContentType;\n    const ContentProtection = shaka.dash.ContentProtection;\n\n    context.adaptationSet = this.createFrame_(elem, context.period, null);\n\n    // Filter image adaptation sets, until we add thumbnail track support.\n    // See: https://github.com/google/shaka-player/issues/559\n    const isImage = context.adaptationSet.contentType == ContentType.IMAGE;\n    if (isImage) {\n      shaka.log.warning('Skipping Image AdaptationSet', context.adaptationSet);\n      return null;\n    }\n\n    let main = false;\n    const roleElements = XmlUtils.findChildren(elem, 'Role');\n    const roleValues = roleElements.map((role) => {\n      return role.getAttribute('value');\n    }).filter(Functional.isNotNull);\n\n    // Default kind for text streams is 'subtitle' if unspecified in the\n    // manifest.\n    let kind = undefined;\n    const isText = context.adaptationSet.contentType == ContentType.TEXT;\n    if (isText) {\n      kind = ManifestParserUtils.TextStreamKind.SUBTITLE;\n    }\n\n    for (const roleElement of roleElements) {\n      const scheme = roleElement.getAttribute('schemeIdUri');\n      if (scheme == null || scheme == 'urn:mpeg:dash:role:2011') {\n        // These only apply for the given scheme, but allow them to be specified\n        // if there is no scheme specified.\n        // See: DASH section 5.8.5.5\n        const value = roleElement.getAttribute('value');\n        switch (value) {\n          case 'main':\n            main = true;\n            break;\n          case 'caption':\n          case 'subtitle':\n            kind = value;\n            break;\n        }\n      }\n    }\n\n    const essentialProperties =\n        XmlUtils.findChildren(elem, 'EssentialProperty');\n    // ID of real AdaptationSet if this is a trick mode set:\n    let trickModeFor = null;\n    let unrecognizedEssentialProperty = false;\n    for (const prop of essentialProperties) {\n      const schemeId = prop.getAttribute('schemeIdUri');\n      if (schemeId == 'http://dashif.org/guidelines/trickmode') {\n        trickModeFor = prop.getAttribute('value');\n      } else {\n        unrecognizedEssentialProperty = true;\n      }\n    }\n\n    const accessibilities = XmlUtils.findChildren(elem, 'Accessibility');\n    const LanguageUtils = shaka.util.LanguageUtils;\n    const closedCaptions = new Map();\n    for (const prop of accessibilities) {\n      const schemeId = prop.getAttribute('schemeIdUri');\n      const value = prop.getAttribute('value');\n      if (schemeId == 'urn:scte:dash:cc:cea-608:2015' ||\n          schemeId == 'urn:scte:dash:cc:cea-708:2015') {\n        let channelId = 1;\n        if (value != null) {\n          for (const captionStr of value.split(';')) {\n            let channel;\n            let language;\n            // Some closed caption descriptions have channel number and\n            // language, like \"CC1=eng\" or \"1=lang:eng\", others may only have\n            // the language, like \"eng\".\n            if (!captionStr.includes('=')) {\n              // Since only odd numbers are used as channel numbers, like CC1,\n              // CC3, CC5, etc, when the channel number is not provided, use an\n              // odd number as the key. https://en.wikipedia.org/wiki/EIA-608\n              channel = 'CC' + channelId;\n              channelId += 2;\n              language = captionStr;\n            } else {\n              const channelAndLanguage = captionStr.split('=');\n              // The channel info can be '1' or 'CC1'.\n              // If the channel info only has channel number(like '1'), add 'CC'\n              // as prefix so that it can be a full channel id (like 'CC1').\n              channel = channelAndLanguage[0].startsWith('CC') ?\n                  channelAndLanguage[0] : 'CC' + channelAndLanguage[0];\n              // The language info can be different formats, like 'eng',\n              // 'lang:eng', or 'lang:eng,war:1,er:1'. Extract the language info\n              // and convert it to 2-letter language code format.\n              language = channelAndLanguage[1].split(',')[0].split(':').pop();\n            }\n            closedCaptions.set(channel, LanguageUtils.normalize(language));\n          }\n        } else {\n          // If channel and language information has not been provided, assign\n          // 'CC1' as channel id and 'und' as language info.\n          closedCaptions.set('CC1', 'und');\n        }\n      } else if (schemeId == 'urn:mpeg:dash:role:2011') {\n        // See DASH IOP 3.9.2 Table 4.\n        if (value != null) {\n          roleValues.push(value);\n          if (value == 'captions') {\n            kind = ManifestParserUtils.TextStreamKind.CLOSED_CAPTION;\n          }\n        }\n      }\n    }\n\n    // According to DASH spec (2014) section 5.8.4.8, \"the successful processing\n    // of the descriptor is essential to properly use the information in the\n    // parent element\".  According to DASH IOP v3.3, section 3.3.4, \"if the\n    // scheme or the value\" for EssentialProperty is not recognized, \"the DASH\n    // client shall ignore the parent element.\"\n    if (unrecognizedEssentialProperty) {\n      // Stop parsing this AdaptationSet and let the caller filter out the\n      // nulls.\n      return null;\n    }\n\n    const contentProtectionElems =\n        XmlUtils.findChildren(elem, 'ContentProtection');\n    const contentProtection = ContentProtection.parseFromAdaptationSet(\n        contentProtectionElems, this.config_.dash.ignoreDrmInfo);\n\n    const language =\n        shaka.util.LanguageUtils.normalize(elem.getAttribute('lang') || 'und');\n\n    // This attribute is currently non-standard, but it is supported by Kaltura.\n    let label = elem.getAttribute('label');\n\n    // See DASH IOP 4.3 here https://dashif.org/docs/DASH-IF-IOP-v4.3.pdf (page 35)\n    const labelElements = XmlUtils.findChildren(elem, 'Label');\n    if (labelElements && labelElements.length) {\n      // NOTE: Right now only one label field is supported.\n      const firstLabelElement = labelElements[0];\n      if (firstLabelElement.textContent) {\n        label = firstLabelElement.textContent;\n      }\n    }\n\n    // Parse Representations into Streams.\n    const representations = XmlUtils.findChildren(elem, 'Representation');\n    const streams = representations.map((representation) => {\n      return this.parseRepresentation_(context, contentProtection, kind,\n          language, label, main, roleValues, closedCaptions, representation);\n    }).filter((s) => !!s);\n\n    if (streams.length == 0) {\n      // Ignore empty AdaptationSets if ignoreEmptyAdaptationSet is true\n      // or they are for text content.\n      if (this.config_.dash.ignoreEmptyAdaptationSet || isText) {\n        return null;\n      }\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.MANIFEST,\n          shaka.util.Error.Code.DASH_EMPTY_ADAPTATION_SET);\n    }\n\n    // If AdaptationSet's type is unknown or is ambiguously \"application\",\n    // guess based on the information in the first stream.  If the attributes\n    // mimeType and codecs are split across levels, they will both be inherited\n    // down to the stream level by this point, so the stream will have all the\n    // necessary information.\n    if (!context.adaptationSet.contentType ||\n        context.adaptationSet.contentType == ContentType.APPLICATION) {\n      const mimeType = streams[0].mimeType;\n      const codecs = streams[0].codecs;\n      context.adaptationSet.contentType =\n          shaka.dash.DashParser.guessContentType_(mimeType, codecs);\n\n      for (const stream of streams) {\n        stream.type = context.adaptationSet.contentType;\n      }\n    }\n\n    for (const stream of streams) {\n      // Some DRM license providers require that we have a default\n      // key ID from the manifest in the wrapped license request.\n      // Thus, it should be put in drmInfo to be accessible to request filters.\n      for (const drmInfo of contentProtection.drmInfos) {\n        drmInfo.keyIds = drmInfo.keyIds && stream.keyIds ?\n            new Set([...drmInfo.keyIds, ...stream.keyIds]) :\n            drmInfo.keyIds || stream.keyIds;\n      }\n    }\n\n    const repIds = representations\n        .map((node) => { return node.getAttribute('id'); })\n        .filter(shaka.util.Functional.isNotNull);\n\n    return {\n      id: context.adaptationSet.id || ('__fake__' + this.globalId_++),\n      contentType: context.adaptationSet.contentType,\n      language: language,\n      main: main,\n      streams: streams,\n      drmInfos: contentProtection.drmInfos,\n      trickModeFor: trickModeFor,\n      representationIds: repIds,\n    };\n  }\n\n  /**\n   * Parses a Representation XML element.\n   *\n   * @param {shaka.dash.DashParser.Context} context\n   * @param {shaka.dash.ContentProtection.Context} contentProtection\n   * @param {(string|undefined)} kind\n   * @param {string} language\n   * @param {string} label\n   * @param {boolean} isPrimary\n   * @param {!Array.<string>} roles\n   * @param {Map.<string, string>} closedCaptions\n   * @param {!Element} node\n   * @return {?shaka.extern.Stream} The Stream, or null when there is a\n   *   non-critical parsing error.\n   * @private\n   */\n  parseRepresentation_(context, contentProtection, kind, language, label,\n      isPrimary, roles, closedCaptions, node) {\n    const XmlUtils = shaka.util.XmlUtils;\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n\n    context.representation =\n        this.createFrame_(node, context.adaptationSet, null);\n    if (!this.verifyRepresentation_(context.representation)) {\n      shaka.log.warning('Skipping Representation', context.representation);\n      return null;\n    }\n    const periodStart = context.periodInfo.start;\n\n    // NOTE: bandwidth is a mandatory attribute according to the spec, and zero\n    // does not make sense in the DASH spec's bandwidth formulas.\n    // In some content, however, the attribute is missing or zero.\n    // To avoid NaN at the variant level on broken content, fall back to zero.\n    // https://github.com/google/shaka-player/issues/938#issuecomment-317278180\n    context.bandwidth =\n        XmlUtils.parseAttr(node, 'bandwidth', XmlUtils.parsePositiveInt) || 0;\n\n    /** @type {?shaka.dash.DashParser.StreamInfo} */\n    let streamInfo;\n\n    const contentType = context.representation.contentType;\n    const isText = contentType == ContentType.TEXT ||\n                   contentType == ContentType.APPLICATION;\n\n    try {\n      const requestInitSegment = (uris, startByte, endByte) => {\n        return this.requestInitSegment_(uris, startByte, endByte);\n      };\n      if (context.representation.segmentBase) {\n        streamInfo = shaka.dash.SegmentBase.createStreamInfo(\n            context, requestInitSegment);\n      } else if (context.representation.segmentList) {\n        streamInfo = shaka.dash.SegmentList.createStreamInfo(\n            context, this.segmentIndexMap_);\n      } else if (context.representation.segmentTemplate) {\n        const hasManifest = !!this.manifest_;\n        streamInfo = shaka.dash.SegmentTemplate.createStreamInfo(\n            context, requestInitSegment, this.segmentIndexMap_, hasManifest,\n            this.config_.dash.initialSegmentLimit);\n      } else {\n        goog.asserts.assert(isText,\n            'Must have Segment* with non-text streams.');\n\n        const baseUris = context.representation.baseUris;\n        const duration = context.periodInfo.duration || 0;\n        streamInfo = {\n          generateSegmentIndex: () => {\n            return Promise.resolve(shaka.media.SegmentIndex.forSingleSegment(\n                periodStart, duration, baseUris));\n          },\n        };\n      }\n    } catch (error) {\n      if (isText && error.code == shaka.util.Error.Code.DASH_NO_SEGMENT_INFO) {\n        // We will ignore any DASH_NO_SEGMENT_INFO errors for text streams.\n        return null;\n      }\n\n      // For anything else, re-throw.\n      throw error;\n    }\n\n    const contentProtectionElems =\n        XmlUtils.findChildren(node, 'ContentProtection');\n    const keyId = shaka.dash.ContentProtection.parseFromRepresentation(\n        contentProtectionElems, contentProtection,\n        this.config_.dash.ignoreDrmInfo);\n    const keyIds = new Set(keyId ? [keyId] : []);\n\n    // Detect the presence of E-AC3 JOC audio content, using DD+JOC signaling.\n    // See: ETSI TS 103 420 V1.2.1 (2018-10)\n    const supplementalPropertyElems =\n        XmlUtils.findChildren(node, 'SupplementalProperty');\n    const hasJoc = supplementalPropertyElems.some((element) => {\n      const expectedUri = 'tag:dolby.com,2018:dash:EC3_ExtensionType:2018';\n      const expectedValue = 'JOC';\n      return element.getAttribute('schemeIdUri') == expectedUri &&\n          element.getAttribute('value') == expectedValue;\n    });\n    if (hasJoc) {\n      context.representation.mimeType = 'audio/eac3-joc';\n    }\n\n    /** @type {shaka.extern.Stream} */\n    const stream = {\n      id: this.globalId_++,\n      originalId: context.representation.id,\n      createSegmentIndex: async () => {\n        if (!stream.segmentIndex) {\n          stream.segmentIndex = await streamInfo.generateSegmentIndex();\n        }\n      },\n      segmentIndex: null,\n      mimeType: context.representation.mimeType,\n      codecs: context.representation.codecs,\n      frameRate: context.representation.frameRate,\n      pixelAspectRatio: context.representation.pixelAspectRatio,\n      bandwidth: context.bandwidth,\n      width: context.representation.width,\n      height: context.representation.height,\n      kind,\n      encrypted: contentProtection.drmInfos.length > 0,\n      drmInfos: contentProtection.drmInfos,\n      keyIds,\n      language,\n      label,\n      type: context.adaptationSet.contentType,\n      primary: isPrimary,\n      trickModeVideo: null,\n      emsgSchemeIdUris:\n          context.representation.emsgSchemeIdUris,\n      roles,\n      channelsCount: context.representation.numChannels,\n      audioSamplingRate: context.representation.audioSamplingRate,\n      closedCaptions,\n    };\n    return stream;\n  }\n\n  /**\n   * Called when the update timer ticks.\n   *\n   * @return {!Promise}\n   * @private\n   */\n  async onUpdate_() {\n    goog.asserts.assert(this.updatePeriod_ >= 0,\n        'There should be an update period');\n\n    shaka.log.info('Updating manifest...');\n\n    // Default the update delay to 0 seconds so that if there is an error we can\n    // try again right away.\n    let updateDelay = 0;\n\n    try {\n      updateDelay = await this.requestManifest_();\n    } catch (error) {\n      goog.asserts.assert(error instanceof shaka.util.Error,\n          'Should only receive a Shaka error');\n\n      // Try updating again, but ensure we haven't been destroyed.\n      if (this.playerInterface_) {\n        // We will retry updating, so override the severity of the error.\n        error.severity = shaka.util.Error.Severity.RECOVERABLE;\n        this.playerInterface_.onError(error);\n      }\n    }\n\n    // Detect a call to stop()\n    if (!this.playerInterface_) {\n      return;\n    }\n\n    this.setUpdateTimer_(updateDelay);\n  }\n\n  /**\n   * Sets the update timer.  Does nothing if the manifest does not specify an\n   * update period.\n   *\n   * @param {number} offset An offset, in seconds, to apply to the manifest's\n   *   update period.\n   * @private\n   */\n  setUpdateTimer_(offset) {\n    // NOTE: An updatePeriod_ of -1 means the attribute was missing.\n    // An attribute which is present and set to 0 should still result in\n    // periodic updates.  For more, see:\n    // https://github.com/google/shaka-player/issues/331\n    if (this.updatePeriod_ < 0) {\n      return;\n    }\n\n    const finalDelay = Math.max(\n        shaka.dash.DashParser.MIN_UPDATE_PERIOD_,\n        this.updatePeriod_ - offset,\n        this.averageUpdateDuration_.getEstimate());\n\n    // We do not run the timer as repeating because part of update is async and\n    // we need schedule the update after it finished.\n    this.updateTimer_.tickAfter(/* seconds= */ finalDelay);\n  }\n\n  /**\n   * Creates a new inheritance frame for the given element.\n   *\n   * @param {!Element} elem\n   * @param {?shaka.dash.DashParser.InheritanceFrame} parent\n   * @param {Array.<string>} baseUris\n   * @return {shaka.dash.DashParser.InheritanceFrame}\n   * @private\n   */\n  createFrame_(elem, parent, baseUris) {\n    goog.asserts.assert(parent || baseUris,\n        'Must provide either parent or baseUris');\n    const ManifestParserUtils = shaka.util.ManifestParserUtils;\n    const XmlUtils = shaka.util.XmlUtils;\n    parent = parent || /** @type {shaka.dash.DashParser.InheritanceFrame} */ ({\n      contentType: '',\n      mimeType: '',\n      codecs: '',\n      emsgSchemeIdUris: [],\n      frameRate: undefined,\n      pixelAspectRatio: undefined,\n      numChannels: null,\n      audioSamplingRate: null,\n    });\n    baseUris = baseUris || parent.baseUris;\n\n    const parseNumber = XmlUtils.parseNonNegativeInt;\n    const evalDivision = XmlUtils.evalDivision;\n    const uris =\n        XmlUtils.findChildren(elem, 'BaseURL').map(XmlUtils.getContents);\n\n    let contentType = elem.getAttribute('contentType') || parent.contentType;\n    const mimeType = elem.getAttribute('mimeType') || parent.mimeType;\n    const codecs = elem.getAttribute('codecs') || parent.codecs;\n    const frameRate =\n        XmlUtils.parseAttr(elem, 'frameRate', evalDivision) || parent.frameRate;\n    const pixelAspectRatio =\n        elem.getAttribute('sar') || parent.pixelAspectRatio;\n    const emsgSchemeIdUris = this.emsgSchemeIdUris_(\n        XmlUtils.findChildren(elem, 'InbandEventStream'),\n        parent.emsgSchemeIdUris);\n    const audioChannelConfigs =\n        XmlUtils.findChildren(elem, 'AudioChannelConfiguration');\n    const numChannels =\n        this.parseAudioChannels_(audioChannelConfigs) || parent.numChannels;\n    const audioSamplingRate =\n        XmlUtils.parseAttr(elem, 'audioSamplingRate', parseNumber) ||\n        parent.audioSamplingRate;\n\n    if (!contentType) {\n      contentType = shaka.dash.DashParser.guessContentType_(mimeType, codecs);\n    }\n\n    return {\n      baseUris: ManifestParserUtils.resolveUris(baseUris, uris),\n      segmentBase:\n          XmlUtils.findChild(elem, 'SegmentBase') || parent.segmentBase,\n      segmentList:\n          XmlUtils.findChild(elem, 'SegmentList') || parent.segmentList,\n      segmentTemplate:\n          XmlUtils.findChild(elem, 'SegmentTemplate') || parent.segmentTemplate,\n      width: XmlUtils.parseAttr(elem, 'width', parseNumber) || parent.width,\n      height: XmlUtils.parseAttr(elem, 'height', parseNumber) || parent.height,\n      contentType: contentType,\n      mimeType: mimeType,\n      codecs: codecs,\n      frameRate: frameRate,\n      pixelAspectRatio: pixelAspectRatio,\n      emsgSchemeIdUris: emsgSchemeIdUris,\n      id: elem.getAttribute('id'),\n      numChannels: numChannels,\n      audioSamplingRate: audioSamplingRate,\n    };\n  }\n\n  /**\n   * Returns a new array of InbandEventStream schemeIdUri containing the union\n   * of the ones parsed from inBandEventStreams and the ones provided in\n   * emsgSchemeIdUris.\n   *\n   * @param {!Array.<!Element>} inBandEventStreams Array of InbandEventStream\n   *     elements to parse and add to the returned array.\n   * @param {!Array.<string>} emsgSchemeIdUris Array of parsed\n   *     InbandEventStream schemeIdUri attributes to add to the returned array.\n   * @return {!Array.<string>} schemeIdUris Array of parsed\n   *     InbandEventStream schemeIdUri attributes.\n   * @private\n   */\n  emsgSchemeIdUris_(inBandEventStreams, emsgSchemeIdUris) {\n    const schemeIdUris = emsgSchemeIdUris.slice();\n    for (const event of inBandEventStreams) {\n      const schemeIdUri = event.getAttribute('schemeIdUri');\n      if (!schemeIdUris.includes(schemeIdUri)) {\n        schemeIdUris.push(schemeIdUri);\n      }\n    }\n    return schemeIdUris;\n  }\n\n  /**\n   * @param {!Array.<!Element>} audioChannelConfigs An array of\n   *   AudioChannelConfiguration elements.\n   * @return {?number} The number of audio channels, or null if unknown.\n   * @private\n   */\n  parseAudioChannels_(audioChannelConfigs) {\n    for (const elem of audioChannelConfigs) {\n      const scheme = elem.getAttribute('schemeIdUri');\n      if (!scheme) {\n        continue;\n      }\n\n      const value = elem.getAttribute('value');\n      if (!value) {\n        continue;\n      }\n\n      switch (scheme) {\n        case 'urn:mpeg:dash:outputChannelPositionList:2012':\n          // A space-separated list of speaker positions, so the number of\n          // channels is the length of this list.\n          return value.trim().split(/ +/).length;\n\n        case 'urn:mpeg:dash:23003:3:audio_channel_configuration:2011':\n        case 'urn:dts:dash:audio_channel_configuration:2012': {\n          // As far as we can tell, this is a number of channels.\n          const intValue = parseInt(value, 10);\n          if (!intValue) {  // 0 or NaN\n            shaka.log.warning('Channel parsing failure! ' +\n                          'Ignoring scheme and value', scheme, value);\n            continue;\n          }\n          return intValue;\n        }\n\n        case 'tag:dolby.com,2014:dash:audio_channel_configuration:2011':\n        case 'urn:dolby:dash:audio_channel_configuration:2011': {\n          // A hex-encoded 16-bit integer, in which each bit represents a\n          // channel.\n          let hexValue = parseInt(value, 16);\n          if (!hexValue) {  // 0 or NaN\n            shaka.log.warning('Channel parsing failure! ' +\n                          'Ignoring scheme and value', scheme, value);\n            continue;\n          }\n          // Count the 1-bits in hexValue.\n          let numBits = 0;\n          while (hexValue) {\n            if (hexValue & 1) {\n              ++numBits;\n            }\n            hexValue >>= 1;\n          }\n          return numBits;\n        }\n\n        default:\n          shaka.log.warning(\n              'Unrecognized audio channel scheme:', scheme, value);\n          continue;\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Verifies that a Representation has exactly one Segment* element.  Prints\n   * warnings if there is a problem.\n   *\n   * @param {shaka.dash.DashParser.InheritanceFrame} frame\n   * @return {boolean} True if the Representation is usable; otherwise return\n   *   false.\n   * @private\n   */\n  verifyRepresentation_(frame) {\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n\n    let n = 0;\n    n += frame.segmentBase ? 1 : 0;\n    n += frame.segmentList ? 1 : 0;\n    n += frame.segmentTemplate ? 1 : 0;\n\n    if (n == 0) {\n      // TODO: Extend with the list of MIME types registered to TextEngine.\n      if (frame.contentType == ContentType.TEXT ||\n          frame.contentType == ContentType.APPLICATION) {\n        return true;\n      } else {\n        shaka.log.warning(\n            'Representation does not contain a segment information source:',\n            'the Representation must contain one of SegmentBase, SegmentList,',\n            'SegmentTemplate, or explicitly indicate that it is \"text\".',\n            frame);\n        return false;\n      }\n    }\n\n    if (n != 1) {\n      shaka.log.warning(\n          'Representation contains multiple segment information sources:',\n          'the Representation should only contain one of SegmentBase,',\n          'SegmentList, or SegmentTemplate.',\n          frame);\n      if (frame.segmentBase) {\n        shaka.log.info('Using SegmentBase by default.');\n        frame.segmentList = null;\n        frame.segmentTemplate = null;\n      } else {\n        goog.asserts.assert(frame.segmentList, 'There should be a SegmentList');\n        shaka.log.info('Using SegmentList by default.');\n        frame.segmentTemplate = null;\n      }\n    }\n\n    return true;\n  }\n\n  /**\n   * Makes a request to the given URI and calculates the clock offset.\n   *\n   * @param {!Array.<string>} baseUris\n   * @param {string} uri\n   * @param {string} method\n   * @return {!Promise.<number>}\n   * @private\n   */\n  async requestForTiming_(baseUris, uri, method) {\n    const requestUris =\n        shaka.util.ManifestParserUtils.resolveUris(baseUris, [uri]);\n    const request = shaka.net.NetworkingEngine.makeRequest(\n        requestUris, this.config_.retryParameters);\n    request.method = method;\n    const type = shaka.net.NetworkingEngine.RequestType.TIMING;\n\n    const operation =\n    this.playerInterface_.networkingEngine.request(type, request);\n    this.operationManager_.manage(operation);\n\n    const response = await operation.promise;\n    let text;\n    if (method == 'HEAD') {\n      if (!response.headers || !response.headers['date']) {\n        shaka.log.warning('UTC timing response is missing',\n            'expected date header');\n        return 0;\n      }\n      text = response.headers['date'];\n    } else {\n      text = shaka.util.StringUtils.fromUTF8(response.data);\n    }\n    const date = Date.parse(text);\n    if (isNaN(date)) {\n      shaka.log.warning('Unable to parse date from UTC timing response');\n      return 0;\n    }\n    return (date - Date.now());\n  }\n\n  /**\n   * Parses an array of UTCTiming elements.\n   *\n   * @param {!Array.<string>} baseUris\n   * @param {!Array.<!Element>} elems\n   * @return {!Promise.<number>}\n   * @private\n   */\n  async parseUtcTiming_(baseUris, elems) {\n    const schemesAndValues = elems.map((elem) => {\n      return {\n        scheme: elem.getAttribute('schemeIdUri'),\n        value: elem.getAttribute('value'),\n      };\n    });\n\n    // If there's nothing specified in the manifest, but we have a default from\n    // the config, use that.\n    const clockSyncUri = this.config_.dash.clockSyncUri;\n    if (!schemesAndValues.length && clockSyncUri) {\n      schemesAndValues.push({\n        scheme: 'urn:mpeg:dash:utc:http-head:2014',\n        value: clockSyncUri,\n      });\n    }\n\n    for (const sv of schemesAndValues) {\n      try {\n        const scheme = sv.scheme;\n        const value = sv.value;\n        switch (scheme) {\n          // See DASH IOP Guidelines Section 4.7\n          // https://bit.ly/DashIop3-2\n          // Some old ISO23009-1 drafts used 2012.\n          case 'urn:mpeg:dash:utc:http-head:2014':\n          case 'urn:mpeg:dash:utc:http-head:2012':\n            // eslint-disable-next-line no-await-in-loop\n            return await this.requestForTiming_(baseUris, value, 'HEAD');\n          case 'urn:mpeg:dash:utc:http-xsdate:2014':\n          case 'urn:mpeg:dash:utc:http-iso:2014':\n          case 'urn:mpeg:dash:utc:http-xsdate:2012':\n          case 'urn:mpeg:dash:utc:http-iso:2012':\n            // eslint-disable-next-line no-await-in-loop\n            return await this.requestForTiming_(baseUris, value, 'GET');\n          case 'urn:mpeg:dash:utc:direct:2014':\n          case 'urn:mpeg:dash:utc:direct:2012': {\n            const date = Date.parse(value);\n            return isNaN(date) ? 0 : (date - Date.now());\n          }\n\n          case 'urn:mpeg:dash:utc:http-ntp:2014':\n          case 'urn:mpeg:dash:utc:ntp:2014':\n          case 'urn:mpeg:dash:utc:sntp:2014':\n            shaka.log.alwaysWarn('NTP UTCTiming scheme is not supported');\n            break;\n          default:\n            shaka.log.alwaysWarn(\n                'Unrecognized scheme in UTCTiming element', scheme);\n            break;\n        }\n      } catch (e) {\n        shaka.log.warning('Error fetching time from UTCTiming elem', e.message);\n      }\n    }\n\n    shaka.log.alwaysWarn(\n        'A UTCTiming element should always be given in live manifests! ' +\n        'This content may not play on clients with bad clocks!');\n    return 0;\n  }\n\n  /**\n   * Parses an EventStream element.\n   *\n   * @param {number} periodStart\n   * @param {?number} periodDuration\n   * @param {!Element} elem\n   * @private\n   */\n  parseEventStream_(periodStart, periodDuration, elem) {\n    const XmlUtils = shaka.util.XmlUtils;\n    const parseNumber = XmlUtils.parseNonNegativeInt;\n\n    const schemeIdUri = elem.getAttribute('schemeIdUri') || '';\n    const value = elem.getAttribute('value') || '';\n    const timescale = XmlUtils.parseAttr(elem, 'timescale', parseNumber) || 1;\n\n    for (const eventNode of XmlUtils.findChildren(elem, 'Event')) {\n      const presentationTime =\n          XmlUtils.parseAttr(eventNode, 'presentationTime', parseNumber) || 0;\n      const duration =\n          XmlUtils.parseAttr(eventNode, 'duration', parseNumber) || 0;\n\n      let startTime = presentationTime / timescale + periodStart;\n      let endTime = startTime + (duration / timescale);\n      if (periodDuration != null) {\n        // An event should not go past the Period, even if the manifest says so.\n        // See: Dash sec. 5.10.2.1\n        startTime = Math.min(startTime, periodStart + periodDuration);\n        endTime = Math.min(endTime, periodStart + periodDuration);\n      }\n\n      /** @type {shaka.extern.TimelineRegionInfo} */\n      const region = {\n        schemeIdUri: schemeIdUri,\n        value: value,\n        startTime: startTime,\n        endTime: endTime,\n        id: eventNode.getAttribute('id') || '',\n        eventElement: eventNode,\n      };\n\n      this.playerInterface_.onTimelineRegionAdded(region);\n    }\n  }\n\n  /**\n   * Makes a network request on behalf of SegmentBase.createStreamInfo.\n   *\n   * @param {!Array.<string>} uris\n   * @param {?number} startByte\n   * @param {?number} endByte\n   * @return {!Promise.<BufferSource>}\n   * @private\n   */\n  async requestInitSegment_(uris, startByte, endByte) {\n    const requestType = shaka.net.NetworkingEngine.RequestType.SEGMENT;\n\n    const request = shaka.util.Networking.createSegmentRequest(\n        uris,\n        startByte,\n        endByte,\n        this.config_.retryParameters);\n\n    const networkingEngine = this.playerInterface_.networkingEngine;\n    const operation = networkingEngine.request(requestType, request);\n    this.operationManager_.manage(operation);\n    const response = await operation.promise;\n    return response.data;\n  }\n\n  /**\n   * Guess the content type based on MIME type and codecs.\n   *\n   * @param {string} mimeType\n   * @param {string} codecs\n   * @return {string}\n   * @private\n   */\n  static guessContentType_(mimeType, codecs) {\n    const fullMimeType = shaka.util.MimeUtils.getFullType(mimeType, codecs);\n\n    if (shaka.text.TextEngine.isTypeSupported(fullMimeType)) {\n      // If it's supported by TextEngine, it's definitely text.\n      // We don't check MediaSourceEngine, because that would report support\n      // for platform-supported video and audio types as well.\n      return shaka.util.ManifestParserUtils.ContentType.TEXT;\n    }\n\n    // Otherwise, just split the MIME type.  This handles video and audio\n    // types well.\n    return mimeType.split('/')[0];\n  }\n};\n\n\n/**\n * Contains the minimum amount of time, in seconds, between manifest update\n * requests.\n *\n * @private\n * @const {number}\n */\nshaka.dash.DashParser.MIN_UPDATE_PERIOD_ = 3;\n\n\n/**\n * @typedef {\n *   function(!Array.<string>, ?number, ?number):!Promise.<BufferSource>\n * }\n */\nshaka.dash.DashParser.RequestInitSegmentCallback;\n\n\n/**\n * @typedef {{\n *   segmentBase: Element,\n *   segmentList: Element,\n *   segmentTemplate: Element,\n *   baseUris: !Array.<string>,\n *   width: (number|undefined),\n *   height: (number|undefined),\n *   contentType: string,\n *   mimeType: string,\n *   codecs: string,\n *   frameRate: (number|undefined),\n *   pixelAspectRatio: (string|undefined),\n *   emsgSchemeIdUris: !Array.<string>,\n *   id: ?string,\n *   numChannels: ?number,\n *   audioSamplingRate: ?number\n * }}\n *\n * @description\n * A collection of elements and properties which are inherited across levels\n * of a DASH manifest.\n *\n * @property {Element} segmentBase\n *   The XML node for SegmentBase.\n * @property {Element} segmentList\n *   The XML node for SegmentList.\n * @property {Element} segmentTemplate\n *   The XML node for SegmentTemplate.\n * @property {!Array.<string>} baseUris\n *   An array of absolute base URIs for the frame.\n * @property {(number|undefined)} width\n *   The inherited width value.\n * @property {(number|undefined)} height\n *   The inherited height value.\n * @property {string} contentType\n *   The inherited media type.\n * @property {string} mimeType\n *   The inherited MIME type value.\n * @property {string} codecs\n *   The inherited codecs value.\n * @property {(number|undefined)} frameRate\n *   The inherited framerate value.\n * @property {(string|undefined)} pixelAspectRatio\n *   The inherited pixel aspect ratio value.\n * @property {!Array.<string>} emsgSchemeIdUris\n *   emsg registered schemeIdUris.\n * @property {?string} id\n *   The ID of the element.\n * @property {?number} numChannels\n *   The number of audio channels, or null if unknown.\n * @property {?number} audioSamplingRate\n *   Specifies the maximum sampling rate of the content, or null if unknown.\n */\nshaka.dash.DashParser.InheritanceFrame;\n\n\n/**\n * @typedef {{\n *   dynamic: boolean,\n *   presentationTimeline: !shaka.media.PresentationTimeline,\n *   period: ?shaka.dash.DashParser.InheritanceFrame,\n *   periodInfo: ?shaka.dash.DashParser.PeriodInfo,\n *   adaptationSet: ?shaka.dash.DashParser.InheritanceFrame,\n *   representation: ?shaka.dash.DashParser.InheritanceFrame,\n *   bandwidth: number,\n *   indexRangeWarningGiven: boolean\n * }}\n *\n * @description\n * Contains context data for the streams.  This is designed to be\n * shallow-copyable, so the parser must overwrite (not modify) each key as the\n * parser moves through the manifest and the parsing context changes.\n *\n * @property {boolean} dynamic\n *   True if the MPD is dynamic (not all segments available at once)\n * @property {!shaka.media.PresentationTimeline} presentationTimeline\n *   The PresentationTimeline.\n * @property {?shaka.dash.DashParser.InheritanceFrame} period\n *   The inheritance from the Period element.\n * @property {?shaka.dash.DashParser.PeriodInfo} periodInfo\n *   The Period info for the current Period.\n * @property {?shaka.dash.DashParser.InheritanceFrame} adaptationSet\n *   The inheritance from the AdaptationSet element.\n * @property {?shaka.dash.DashParser.InheritanceFrame} representation\n *   The inheritance from the Representation element.\n * @property {number} bandwidth\n *   The bandwidth of the Representation, or zero if missing.\n * @property {boolean} indexRangeWarningGiven\n *   True if the warning about SegmentURL@indexRange has been printed.\n */\nshaka.dash.DashParser.Context;\n\n\n/**\n * @typedef {{\n *   start: number,\n *   duration: ?number,\n *   node: !Element,\n *   isLastPeriod: boolean\n * }}\n *\n * @description\n * Contains information about a Period element.\n *\n * @property {number} start\n *   The start time of the period.\n * @property {?number} duration\n *   The duration of the period; or null if the duration is not given.  This\n *   will be non-null for all periods except the last.\n * @property {!Element} node\n *   The XML Node for the Period.\n * @property {boolean} isLastPeriod\n *   Whether this Period is the last one in the manifest.\n */\nshaka.dash.DashParser.PeriodInfo;\n\n\n/**\n * @typedef {{\n *   id: string,\n *   contentType: ?string,\n *   language: string,\n *   main: boolean,\n *   streams: !Array.<shaka.extern.Stream>,\n *   drmInfos: !Array.<shaka.extern.DrmInfo>,\n *   trickModeFor: ?string,\n *   representationIds: !Array.<string>\n * }}\n *\n * @description\n * Contains information about an AdaptationSet element.\n *\n * @property {string} id\n *   The unique ID of the adaptation set.\n * @property {?string} contentType\n *   The content type of the AdaptationSet.\n * @property {string} language\n *   The language of the AdaptationSet.\n * @property {boolean} main\n *   Whether the AdaptationSet has the 'main' type.\n * @property {!Array.<shaka.extern.Stream>} streams\n *   The streams this AdaptationSet contains.\n * @property {!Array.<shaka.extern.DrmInfo>} drmInfos\n *   The DRM info for the AdaptationSet.\n * @property {?string} trickModeFor\n *   If non-null, this AdaptationInfo represents trick mode tracks.  This\n *   property is the ID of the normal AdaptationSet these tracks should be\n *   associated with.\n * @property {!Array.<string>} representationIds\n *   An array of the IDs of the Representations this AdaptationSet contains.\n */\nshaka.dash.DashParser.AdaptationInfo;\n\n\n/**\n * @typedef {function():!Promise.<shaka.media.SegmentIndex>}\n * @description\n * An async function which generates and returns a SegmentIndex.\n */\nshaka.dash.DashParser.GenerateSegmentIndexFunction;\n\n\n/**\n * @typedef {{\n *   generateSegmentIndex: shaka.dash.DashParser.GenerateSegmentIndexFunction\n * }}\n *\n * @description\n * Contains information about a Stream. This is passed from the createStreamInfo\n * methods.\n *\n * @property {shaka.dash.DashParser.GenerateSegmentIndexFunction}\n *     generateSegmentIndex\n *   An async function to create the SegmentIndex for the stream.\n */\nshaka.dash.DashParser.StreamInfo;\n\n\nshaka.media.ManifestParser.registerParserByExtension(\n    'mpd', () => new shaka.dash.DashParser());\nshaka.media.ManifestParser.registerParserByMime(\n    'application/dash+xml', () => new shaka.dash.DashParser());\nshaka.media.ManifestParser.registerParserByMime(\n    'video/vnd.mpeg.dash.mpd', () => new shaka.dash.DashParser());\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.hls.Attribute');\ngoog.provide('shaka.hls.Playlist');\ngoog.provide('shaka.hls.PlaylistType');\ngoog.provide('shaka.hls.Segment');\ngoog.provide('shaka.hls.Tag');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.util.Error');\n\n\n/**\n * HLS playlist class.\n */\nshaka.hls.Playlist = class {\n  /**\n   * @param {string} absoluteUri An absolute, final URI after redirects.\n   * @param {!shaka.hls.PlaylistType} type\n   * @param {!Array.<shaka.hls.Tag>} tags\n   * @param {!Array.<shaka.hls.Segment>=} segments\n   */\n  constructor(absoluteUri, type, tags, segments) {\n    /**\n     * An absolute, final URI after redirects.\n     *\n     * @const {string}\n     */\n    this.absoluteUri = absoluteUri;\n\n    /** @const {shaka.hls.PlaylistType} */\n    this.type = type;\n\n    /** @const {!Array.<!shaka.hls.Tag>} */\n    this.tags = tags;\n\n    /** @const {Array.<!shaka.hls.Segment>} */\n    this.segments = segments || null;\n  }\n};\n\n\n/**\n * @enum {number}\n */\nshaka.hls.PlaylistType = {\n  MASTER: 0,\n  MEDIA: 1,\n};\n\n\n/**\n * HLS tag class.\n */\nshaka.hls.Tag = class {\n  /**\n   * @param {number} id\n   * @param {string} name\n   * @param {!Array.<shaka.hls.Attribute>} attributes\n   * @param {?string=} value\n   */\n  constructor(id, name, attributes, value = null) {\n    /** @const {number} */\n    this.id = id;\n\n    /** @const {string} */\n    this.name = name;\n\n    /** @const {Array.<shaka.hls.Attribute>} */\n    this.attributes = attributes;\n\n    /** @const {?string} */\n    this.value = value;\n  }\n\n  /**\n   * Create the string representation of the tag.\n   *\n   * For the DRM system - the full tag needs to be passed down to the CDM.\n   * There are two ways of doing this (1) save the original tag or (2) recreate\n   * the tag.\n   * As in some cases (like in tests) the tag never existed in string form, it\n   * is far easier to recreate the tag from the parsed form.\n   *\n   * @return {string}\n   * @override\n   */\n  toString() {\n    /**\n     * @param {shaka.hls.Attribute} attr\n     * @return {string}\n     */\n    const attrToStr = (attr) => {\n      const isNumericAttr = !isNaN(Number(attr.value));\n      const value = (isNumericAttr ? attr.value : '\"' + attr.value + '\"');\n      return attr.name + '=' + value;\n    };\n    // A valid tag can only follow 1 of 4 patterns.\n    //  1) <NAME>:<VALUE>\n    //  2) <NAME>:<ATTRIBUTE LIST>\n    //  3) <NAME>\n    //  4) <NAME>:<VALUE>,<ATTRIBUTE_LIST>\n\n    let tagStr = '#' + this.name;\n    const appendages = this.attributes ? this.attributes.map(attrToStr) : [];\n\n    if (this.value) {\n      appendages.unshift(this.value);\n    }\n\n    if (appendages.length > 0) {\n      tagStr += ':' + appendages.join(',');\n    }\n\n    return tagStr;\n  }\n\n  /**\n   * Adds an attribute to an HLS Tag.\n   *\n   * @param {!shaka.hls.Attribute} attribute\n   */\n  addAttribute(attribute) {\n    this.attributes.push(attribute);\n  }\n\n\n  /**\n   * Gets the first attribute of the tag with a specified name.\n   *\n   * @param {string} name\n   * @return {?shaka.hls.Attribute} attribute\n   */\n  getAttribute(name) {\n    const attributes = this.attributes.filter((attr) => {\n      return attr.name == name;\n    });\n\n    goog.asserts.assert(attributes.length < 2,\n        'A tag should not have multiple attributes ' +\n                        'with the same name!');\n\n    if (attributes.length) {\n      return attributes[0];\n    } else {\n      return null;\n    }\n  }\n\n  /**\n   * Gets the value of the first attribute of the tag with a specified name.\n   * If not found, returns an optional default value.\n   *\n   * @param {string} name\n   * @param {string=} defaultValue\n   * @return {?string}\n   */\n  getAttributeValue(name, defaultValue) {\n    const attribute = this.getAttribute(name);\n    return attribute ? attribute.value : (defaultValue || null);\n  }\n\n\n  /**\n   * Finds the attribute and returns its value.\n   * Throws an error if attribute was not found.\n   *\n   * @param {string} name\n   * @return {string}\n   */\n  getRequiredAttrValue(name) {\n    const attribute = this.getAttribute(name);\n    if (!attribute) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.MANIFEST,\n          shaka.util.Error.Code.HLS_REQUIRED_ATTRIBUTE_MISSING,\n          name);\n    }\n\n    return attribute.value;\n  }\n};\n\n\n/**\n * HLS segment class.\n */\nshaka.hls.Segment = class {\n  /**\n   * Creates an HLS segment object.\n   *\n   * @param {string} absoluteUri An absolute URI.\n   * @param {!Array.<shaka.hls.Tag>} tags\n   */\n  constructor(absoluteUri, tags) {\n    /** @const {!Array.<shaka.hls.Tag>} */\n    this.tags = tags;\n\n    /**\n     * An absolute URI.\n     *\n     * @const {string}\n     */\n    this.absoluteUri = absoluteUri;\n  }\n};\n\n\n/**\n * HLS Attribute class.\n */\nshaka.hls.Attribute = class {\n  /**\n   * Creates an HLS attribute object.\n   *\n   * @param {string} name\n   * @param {string} value\n   */\n  constructor(name, value) {\n    /** @const {string} */\n    this.name = name;\n\n    /** @const {string} */\n    this.value = value;\n  }\n};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.hls.Utils');\n\ngoog.require('shaka.util.ManifestParserUtils');\ngoog.requireType('shaka.hls.Tag');\n\n\nshaka.hls.Utils = class {\n  /**\n   *\n   * @param {!Array.<!shaka.hls.Tag>} tags\n   * @param {string} name\n   * @return {!Array.<!shaka.hls.Tag>}\n   */\n  static filterTagsByName(tags, name) {\n    return tags.filter((tag) => {\n      return tag.name == name;\n    });\n  }\n\n\n  /**\n   *\n   * @param {!Array.<!shaka.hls.Tag>} tags\n   * @param {string} type\n   * @return {!Array.<!shaka.hls.Tag>}\n   */\n  static filterTagsByType(tags, type) {\n    return tags.filter((tag) => {\n      const tagType = tag.getRequiredAttrValue('TYPE');\n      return tagType == type;\n    });\n  }\n\n\n  /**\n   *\n   * @param {!Array.<!shaka.hls.Tag>} tags\n   * @param {string} name\n   * @return {?shaka.hls.Tag}\n   */\n  static getFirstTagWithName(tags, name) {\n    const tagsWithName = shaka.hls.Utils.filterTagsByName(tags, name);\n    if (!tagsWithName.length) {\n      return null;\n    }\n\n    return tagsWithName[0];\n  }\n\n  /**\n   * Get the numerical value of the first tag with given name if available.\n   * Return the default value if the tag is not present.\n   *\n   * @param {!Array.<!shaka.hls.Tag>} tags\n   * @param {string} name\n   * @param {number=} defaultValue\n   * @return {number}\n   */\n  static getFirstTagWithNameAsNumber(tags, name, defaultValue = 0) {\n    const tag = shaka.hls.Utils.getFirstTagWithName(tags, name);\n    const value = tag ? Number(tag.value) : defaultValue;\n    return value;\n  }\n\n\n  /**\n   * @param {string} parentAbsoluteUri\n   * @param {string} uri\n   * @return {string}\n   */\n  static constructAbsoluteUri(parentAbsoluteUri, uri) {\n    const uris = shaka.util.ManifestParserUtils.resolveUris(\n        [parentAbsoluteUri], [uri]);\n\n    return uris[0];\n  }\n\n\n  /**\n   * Matches a string to an HLS comment format and returns the result.\n   *\n   * @param {string} line\n   * @return {boolean}\n   */\n  static isComment(line) {\n    return /^#(?!EXT)/m.test(line);\n  }\n};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.util.TextParser');\n\ngoog.require('goog.asserts');\n\n\n/**\n * Reads elements from strings.\n */\nshaka.util.TextParser = class {\n  /**\n   * @param {string} data\n   */\n  constructor(data) {\n    /**\n     * @const\n     * @private {string}\n     */\n    this.data_ = data;\n\n    /** @private {number} */\n    this.position_ = 0;\n  }\n\n\n  /** @return {boolean} Whether it is at the end of the string. */\n  atEnd() {\n    return this.position_ == this.data_.length;\n  }\n\n\n  /**\n   * Reads a line from the parser.  This will read but not return the newline.\n   * Returns null at the end.\n   *\n   * @return {?string}\n   */\n  readLine() {\n    return this.readRegexReturnCapture_(/(.*?)(\\n|$)/gm, 1);\n  }\n\n\n  /**\n   * Reads a word from the parser.  This will not read or return any whitespace\n   * before or after the word (including newlines).  Returns null at the end.\n   *\n   * @return {?string}\n   */\n  readWord() {\n    return this.readRegexReturnCapture_(/[^ \\t\\n]*/gm, 0);\n  }\n\n\n  /**\n   * Skips any continuous whitespace from the parser.  Returns null at the end.\n   */\n  skipWhitespace() {\n    this.readRegex(/[ \\t]+/gm);\n  }\n\n\n  /**\n   * Reads the given regular expression from the parser.  This requires the\n   * match to be at the current position; there is no need to include a head\n   * anchor.\n   * This requires that the regex have the global flag to be set so that it can\n   * set lastIndex to start the search at the current position.  Returns null at\n   * the end or if the regex does not match the current position.\n   *\n   * @param {!RegExp} regex\n   * @return {Array.<string>}\n   */\n  readRegex(regex) {\n    const index = this.indexOf_(regex);\n    if (this.atEnd() || index == null || index.position != this.position_) {\n      return null;\n    }\n\n    this.position_ += index.length;\n    return index.results;\n  }\n\n\n  /**\n   * Reads a regex from the parser and returns the given capture.\n   *\n   * @param {!RegExp} regex\n   * @param {number} index\n   * @return {?string}\n   * @private\n   */\n  readRegexReturnCapture_(regex, index) {\n    if (this.atEnd()) {\n      return null;\n    }\n\n    const ret = this.readRegex(regex);\n    if (!ret) {\n      return null;\n    } else {\n      return ret[index];\n    }\n  }\n\n\n  /**\n   * Returns the index info about a regular expression match.\n   *\n   * @param {!RegExp} regex\n   * @return {?{position: number, length: number, results: !Array.<string>}}\n   * @private\n   */\n  indexOf_(regex) {\n    // The global flag is required to use lastIndex.\n    goog.asserts.assert(regex.global, 'global flag should be set');\n\n    regex.lastIndex = this.position_;\n    const results = regex.exec(this.data_);\n    if (results == null) {\n      return null;\n    } else {\n      return {\n        position: results.index,\n        length: results[0].length,\n        results: results,\n      };\n    }\n  }\n};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.hls.ManifestTextParser');\n\ngoog.require('shaka.hls.Attribute');\ngoog.require('shaka.hls.Playlist');\ngoog.require('shaka.hls.PlaylistType');\ngoog.require('shaka.hls.Segment');\ngoog.require('shaka.hls.Tag');\ngoog.require('shaka.hls.Utils');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.Iterables');\ngoog.require('shaka.util.StringUtils');\ngoog.require('shaka.util.TextParser');\n\n\n/**\n * HlS manifest text parser.\n */\nshaka.hls.ManifestTextParser = class {\n  constructor() {\n    /** @private {number} */\n    this.globalId_ = 0;\n  }\n\n  /**\n   * @param {BufferSource} data\n   * @param {string} absolutePlaylistUri An absolute, final URI after redirects.\n   * @return {!shaka.hls.Playlist}\n   */\n  parsePlaylist(data, absolutePlaylistUri) {\n    const MEDIA_PLAYLIST_TAGS =\n        shaka.hls.ManifestTextParser.MEDIA_PLAYLIST_TAGS;\n    const SEGMENT_TAGS = shaka.hls.ManifestTextParser.SEGMENT_TAGS;\n\n    // Get the input as a string.  Normalize newlines to \\n.\n    let str = shaka.util.StringUtils.fromUTF8(data);\n    str = str.replace(/\\r\\n|\\r(?=[^\\n]|$)/gm, '\\n').trim();\n\n    const lines = str.split(/\\n+/m);\n\n    if (!/^#EXTM3U($|[ \\t\\n])/m.test(lines[0])) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.MANIFEST,\n          shaka.util.Error.Code.HLS_PLAYLIST_HEADER_MISSING);\n    }\n\n    /** shaka.hls.PlaylistType */\n    let playlistType = shaka.hls.PlaylistType.MASTER;\n\n    // First, look for media playlist tags, so that we know what the playlist\n    // type really is before we start parsing.\n    // TODO: refactor the for loop for better readability.\n    // Whether to skip the next element; initialize to true to skip first elem.\n    let skip = true;\n    for (const line of lines) {\n      // Ignore comments.\n      if (shaka.hls.Utils.isComment(line) || skip) {\n        skip = false;\n        continue;\n      }\n      const tag = this.parseTag_(line);\n      // These tags won't actually be used, so don't increment the global\n      // id.\n      this.globalId_ -= 1;\n\n      if (MEDIA_PLAYLIST_TAGS.includes(tag.name)) {\n        playlistType = shaka.hls.PlaylistType.MEDIA;\n        break;\n      } else if (tag.name == 'EXT-X-STREAM-INF') {\n        skip = true;\n      }\n    }\n\n    /** {Array.<shaka.hls.Tag>} */\n    const tags = [];\n    // Initialize to \"true\" to skip the first element.\n    skip = true;\n    const enumerate = (it) => shaka.util.Iterables.enumerate(it);\n    for (const {i, item: line, next} of enumerate(lines)) {\n      // Skip comments\n      if (shaka.hls.Utils.isComment(line) || skip) {\n        skip = false;\n        continue;\n      }\n\n      const tag = this.parseTag_(line);\n      if (SEGMENT_TAGS.includes(tag.name)) {\n        if (playlistType != shaka.hls.PlaylistType.MEDIA) {\n          // Only media playlists should contain segment tags\n          throw new shaka.util.Error(\n              shaka.util.Error.Severity.CRITICAL,\n              shaka.util.Error.Category.MANIFEST,\n              shaka.util.Error.Code.HLS_INVALID_PLAYLIST_HIERARCHY);\n        }\n\n        const segmentsData = lines.splice(i, lines.length - i);\n        const segments = this.parseSegments_(\n            absolutePlaylistUri, segmentsData, tags);\n        return new shaka.hls.Playlist(\n            absolutePlaylistUri, playlistType, tags, segments);\n      }\n\n      tags.push(tag);\n\n      // An EXT-X-STREAM-INF tag is followed by a URI of a media playlist.\n      // Add the URI to the tag object.\n      if (tag.name == 'EXT-X-STREAM-INF') {\n        const tagUri = new shaka.hls.Attribute('URI', next);\n        tag.addAttribute(tagUri);\n        skip = true;\n      }\n    }\n\n    return new shaka.hls.Playlist(absolutePlaylistUri, playlistType, tags);\n  }\n\n  /**\n   * Parses an array of strings into an array of HLS Segment objects.\n   *\n   * @param {string} absoluteMediaPlaylistUri\n   * @param {!Array.<string>} lines\n   * @param {!Array.<!shaka.hls.Tag>} playlistTags\n   * @return {!Array.<shaka.hls.Segment>}\n   * @private\n   */\n  parseSegments_(absoluteMediaPlaylistUri, lines, playlistTags) {\n    /** @type {!Array.<shaka.hls.Segment>} */\n    const segments = [];\n    /** @type {!Array.<shaka.hls.Tag>} */\n    let segmentTags = [];\n\n    // The last parsed EXT-X-MAP tag.\n    /** @type {?shaka.hls.Tag} */\n    let currentMapTag = null;\n\n    for (const line of lines) {\n      if (/^(#EXT)/.test(line)) {\n        const tag = this.parseTag_(line);\n        if (shaka.hls.ManifestTextParser.MEDIA_PLAYLIST_TAGS.includes(\n            tag.name)) {\n          playlistTags.push(tag);\n        } else {\n          // Mark the the EXT-X-MAP tag, and add it to the segment tags\n          // following it later.\n          if (tag.name == 'EXT-X-MAP') {\n            currentMapTag = tag;\n          } else {\n            segmentTags.push(tag);\n          }\n        }\n      } else if (shaka.hls.Utils.isComment(line)) {\n        // Skip comments.\n      } else {\n        const verbatimSegmentUri = line.trim();\n        const absoluteSegmentUri = shaka.hls.Utils.constructAbsoluteUri(\n            absoluteMediaPlaylistUri, verbatimSegmentUri);\n\n        // Attach the last parsed EXT-X-MAP tag to the segment.\n        if (currentMapTag) {\n          segmentTags.push(currentMapTag);\n        }\n        // The URI appears after all of the tags describing the segment.\n        const segment =\n            new shaka.hls.Segment(absoluteSegmentUri, segmentTags);\n        segments.push(segment);\n        segmentTags = [];\n      }\n    }\n    return segments;\n  }\n\n  /**\n   * Parses a string into an HLS Tag object while tracking what id to use next.\n   *\n   * @param {string} word\n   * @return {!shaka.hls.Tag}\n   * @private\n   */\n  parseTag_(word) {\n    return shaka.hls.ManifestTextParser.parseTag(this.globalId_++, word);\n  }\n\n  /**\n   * Parses a string into an HLS Tag object.\n   *\n   * @param {number} id\n   * @param {string} word\n   * @return {!shaka.hls.Tag}\n   */\n  static parseTag(id, word) {\n    /* HLS tags start with '#EXT'. A tag can have a set of attributes\n      (#EXT-<tagname>:<attribute list>) and/or a value (#EXT-<tagname>:<value>).\n      An attribute's format is 'AttributeName=AttributeValue'.\n      The parsing logic goes like this:\n       1. Everything before ':' is a name (we ignore '#').\n       2. Everything after ':' is a list of comma-seprated items,\n            2a. The first item might be a value, if it does not contain '='.\n            2b. Otherwise, items are attributes.\n       3. If there is no \":\", it's a simple tag with no attributes and no value.\n    */\n    const blocks = word.match(/^#(EXT[^:]*)(?::(.*))?$/);\n    if (!blocks) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.MANIFEST,\n          shaka.util.Error.Code.INVALID_HLS_TAG,\n          word);\n    }\n    const name = blocks[1];\n    const data = blocks[2];\n    const attributes = [];\n    let value;\n\n    if (data) {\n      const parser = new shaka.util.TextParser(data);\n      let blockAttrs;\n\n      // Regex: any number of non-equals-sign characters at the beginning\n      // terminated by comma or end of line\n      const valueRegex = /^([^,=]+)(?:,|$)/g;\n\n      const blockValue = parser.readRegex(valueRegex);\n\n      if (blockValue) {\n        value = blockValue[1];\n      }\n\n      // Regex:\n      // 1. Key name ([1])\n      // 2. Equals sign\n      // 3. Either:\n      //   a. A quoted string (everything up to the next quote, [2])\n      //   b. An unquoted string\n      //    (everything up to the next comma or end of line, [3])\n      // 4. Either:\n      //   a. A comma\n      //   b. End of line\n      const attributeRegex = /([^=]+)=(?:\"([^\"]*)\"|([^\",]*))(?:,|$)/g;\n\n      while ((blockAttrs = parser.readRegex(attributeRegex))) {\n        const attrName = blockAttrs[1];\n        const attrValue = blockAttrs[2] || blockAttrs[3];\n        const attribute = new shaka.hls.Attribute(attrName, attrValue);\n        attributes.push(attribute);\n      }\n    }\n\n    return new shaka.hls.Tag(id, name, attributes, value);\n  }\n};\n\n\n/**\n * HLS tags that only appear on Media Playlists.\n * Used to determine a playlist type.\n *\n * @const {!Array.<string>}\n */\nshaka.hls.ManifestTextParser.MEDIA_PLAYLIST_TAGS = [\n  'EXT-X-TARGETDURATION',\n  'EXT-X-MEDIA-SEQUENCE',\n  'EXT-X-DISCONTINUITY-SEQUENCE',\n  'EXT-X-PLAYLIST-TYPE',\n  'EXT-X-I-FRAMES-ONLY',\n  'EXT-X-ENDLIST',\n];\n\n\n/**\n * HLS tags that only appear on Segments in a Media Playlists.\n * Used to determine the start of the segments info.\n *\n * @const {!Array.<string>}\n */\nshaka.hls.ManifestTextParser.SEGMENT_TAGS = [\n  'EXTINF',\n  'EXT-X-BYTERANGE',\n  'EXT-X-DISCONTINUITY',\n  'EXT-X-PROGRAM-DATE-TIME',\n  'EXT-X-KEY',\n  'EXT-X-DATERANGE',\n  'EXT-X-MAP',\n];\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.net.DataUriPlugin');\n\ngoog.require('shaka.log');\ngoog.require('shaka.net.NetworkingEngine');\ngoog.require('shaka.util.AbortableOperation');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.StringUtils');\ngoog.require('shaka.util.Uint8ArrayUtils');\n\n\n/**\n * @summary A networking plugin to handle data URIs.\n * @see https://developer.mozilla.org/en-US/docs/Web/HTTP/data_URIs\n * @export\n */\nshaka.net.DataUriPlugin = class {\n  /**\n   * @param {string} uri\n   * @param {shaka.extern.Request} request\n   * @param {shaka.net.NetworkingEngine.RequestType} requestType\n   * @param {shaka.extern.ProgressUpdated} progressUpdated Called when a\n   *   progress event happened.\n   * @return {!shaka.extern.IAbortableOperation.<shaka.extern.Response>}\n   * @export\n   */\n  static parse(uri, request, requestType, progressUpdated) {\n    try {\n      const parsed = shaka.net.DataUriPlugin.parseRaw(uri);\n\n      /** @type {shaka.extern.Response} */\n      const response = {\n        uri: uri,\n        originalUri: uri,\n        data: parsed.data,\n        headers: {\n          'content-type': parsed.contentType,\n        },\n      };\n\n      return shaka.util.AbortableOperation.completed(response);\n    } catch (error) {\n      return shaka.util.AbortableOperation.failed(error);\n    }\n  }\n\n  /**\n   * @param {string} uri\n   * @return {{data: BufferSource, contentType: string}}\n   */\n  static parseRaw(uri) {\n    // Extract the scheme.\n    const parts = uri.split(':');\n    if (parts.length < 2 || parts[0] != 'data') {\n      shaka.log.error('Bad data URI, failed to parse scheme');\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.NETWORK,\n          shaka.util.Error.Code.MALFORMED_DATA_URI,\n          uri);\n    }\n    const path = parts.slice(1).join(':');\n\n    // Extract the encoding and MIME type (required but can be empty).\n    const infoAndData = path.split(',');\n    if (infoAndData.length < 2) {\n      shaka.log.error('Bad data URI, failed to extract encoding and MIME type');\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.NETWORK,\n          shaka.util.Error.Code.MALFORMED_DATA_URI,\n          uri);\n    }\n    const info = infoAndData[0];\n    const dataStr = window.decodeURIComponent(infoAndData.slice(1).join(','));\n\n    // The MIME type is always the first thing in the semicolon-separated list\n    // of type parameters.  It may be blank.\n    const typeInfoList = info.split(';');\n    const contentType = typeInfoList[0];\n\n    // Check for base64 encoding, which is always the last in the\n    // semicolon-separated list if present.\n    let base64Encoded = false;\n    if (typeInfoList.length > 1 &&\n        typeInfoList[typeInfoList.length - 1] == 'base64') {\n      base64Encoded = true;\n      typeInfoList.pop();\n    }\n\n    // Convert the data.\n    /** @type {BufferSource} */\n    let data;\n    if (base64Encoded) {\n      data = shaka.util.Uint8ArrayUtils.fromBase64(dataStr);\n    } else {\n      data = shaka.util.StringUtils.toUTF8(dataStr);\n    }\n\n    return {data: data, contentType};\n  }\n};\n\n\nshaka.net.NetworkingEngine.registerScheme(\n    'data', shaka.net.DataUriPlugin.parse);\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n\ngoog.provide('shaka.hls.HlsParser');\n\ngoog.require('goog.Uri');\ngoog.require('goog.asserts');\ngoog.require('shaka.hls.ManifestTextParser');\ngoog.require('shaka.hls.Playlist');\ngoog.require('shaka.hls.PlaylistType');\ngoog.require('shaka.hls.Tag');\ngoog.require('shaka.hls.Utils');\ngoog.require('shaka.log');\ngoog.require('shaka.media.DrmEngine');\ngoog.require('shaka.media.InitSegmentReference');\ngoog.require('shaka.media.ManifestParser');\ngoog.require('shaka.media.PresentationTimeline');\ngoog.require('shaka.media.SegmentIndex');\ngoog.require('shaka.media.SegmentReference');\ngoog.require('shaka.net.DataUriPlugin');\ngoog.require('shaka.net.NetworkingEngine');\ngoog.require('shaka.util.ArrayUtils');\ngoog.require('shaka.util.BufferUtils');\ngoog.require('shaka.util.DataViewReader');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.Functional');\ngoog.require('shaka.util.Iterables');\ngoog.require('shaka.util.LanguageUtils');\ngoog.require('shaka.util.ManifestParserUtils');\ngoog.require('shaka.util.MimeUtils');\ngoog.require('shaka.util.Mp4Parser');\ngoog.require('shaka.util.Networking');\ngoog.require('shaka.util.OperationManager');\ngoog.require('shaka.util.Timer');\ngoog.requireType('shaka.hls.Segment');\n\n\n/**\n * HLS parser.\n *\n * @implements {shaka.extern.ManifestParser}\n * @export\n */\nshaka.hls.HlsParser = class {\n  /**\n   * Creates an Hls Parser object.\n   */\n  constructor() {\n    /** @private {?shaka.extern.ManifestParser.PlayerInterface} */\n    this.playerInterface_ = null;\n\n    /** @private {?shaka.extern.ManifestConfiguration} */\n    this.config_ = null;\n\n    /** @private {number} */\n    this.globalId_ = 1;\n\n    /** @private {!Map.<string, string>} */\n    this.globalVariables_ = new Map();\n\n    /**\n     * A map from group id to stream infos created from the media tags.\n     * @private {!Map.<string, !Array.<?shaka.hls.HlsParser.StreamInfo>>}\n     */\n    this.groupIdToStreamInfosMap_ = new Map();\n\n    /**\n     * The values are strings of the form \"<VIDEO URI> - <AUDIO URI>\",\n     * where the URIs are the verbatim media playlist URIs as they appeared in\n     * the master playlist.\n     *\n     * Used to avoid duplicates that vary only in their text stream.\n     *\n     * @private {!Set.<string>}\n     */\n    this.variantUriSet_ = new Set();\n\n    /**\n     * A map from (verbatim) media playlist URI to stream infos representing the\n     * playlists.\n     *\n     * On update, used to iterate through and update from media playlists.\n     *\n     * On initial parse, used to iterate through and determine minimum\n     * timestamps, offsets, and to handle TS rollover.\n     *\n     * During parsing, used to avoid duplicates in the async methods\n     * createStreamInfoFromMediaTag_ and createStreamInfoFromVariantTag_.\n     *\n     * During parsing of updates, used by getStartTime_ to determine the start\n     * time of the first segment from existing segment references.\n     *\n     * @private {!Map.<string, shaka.hls.HlsParser.StreamInfo>}\n     */\n    this.uriToStreamInfosMap_ = new Map();\n\n    /** @private {?shaka.media.PresentationTimeline} */\n    this.presentationTimeline_ = null;\n\n    /**\n     * The master playlist URI, after redirects.\n     *\n     * @private {string}\n     */\n    this.masterPlaylistUri_ = '';\n\n    /** @private {shaka.hls.ManifestTextParser} */\n    this.manifestTextParser_ = new shaka.hls.ManifestTextParser();\n\n    /**\n     * This is the number of seconds we want to wait between finishing a\n     * manifest update and starting the next one. This will be set when we parse\n     * the manifest.\n     *\n     * @private {number}\n     */\n    this.updatePlaylistDelay_ = 0;\n\n    /**\n     * This timer is used to trigger the start of a manifest update. A manifest\n     * update is async. Once the update is finished, the timer will be restarted\n     * to trigger the next update. The timer will only be started if the content\n     * is live content.\n     *\n     * @private {shaka.util.Timer}\n     */\n    this.updatePlaylistTimer_ = new shaka.util.Timer(() => {\n      this.onUpdate_();\n    });\n\n    /** @private {shaka.hls.HlsParser.PresentationType_} */\n    this.presentationType_ = shaka.hls.HlsParser.PresentationType_.VOD;\n\n    /** @private {?shaka.extern.Manifest} */\n    this.manifest_ = null;\n\n    /** @private {number} */\n    this.maxTargetDuration_ = 0;\n\n    /** @private {number} */\n    this.minTargetDuration_ = Infinity;\n\n    /** @private {shaka.util.OperationManager} */\n    this.operationManager_ = new shaka.util.OperationManager();\n\n    /** @private {!Array.<!Array.<!shaka.media.SegmentReference>>} */\n    this.segmentsToNotifyByStream_ = [];\n\n    /** A map from closed captions' group id, to a map of closed captions info.\n     * {group id -> {closed captions channel id -> language}}\n     * @private {Map.<string, Map.<string, string>>}\n     */\n    this.groupIdToClosedCaptionsMap_ = new Map();\n\n    /** True if some of the variants in  the playlist is encrypted with AES-128.\n     * @private {boolean} */\n    this.aesEncrypted_ = false;\n\n    /** @private {Map.<string, string>} */\n    this.groupIdToCodecsMap_ = new Map();\n\n    /** @private {?number} */\n    this.playlistStartTime_ = null;\n\n    /** A cache mapping EXT-X-MAP tag info to the InitSegmentReference created\n     * from the tag.\n     * The key is a string combining the EXT-X-MAP tag's absolute uri, and\n     * its BYTERANGE if available.\n     * {!Map.<string, !shaka.media.InitSegmentReference>} */\n    this.mapTagToInitSegmentRefMap_ = new Map();\n\n    /**\n     * A cache mapping a discontinuity sequence number of a segment with\n     * EXT-X-DISCONTINUITY tag into its timestamp offset.\n     * Key: the discontinuity sequence number of a segment\n     * Value: the segment reference's timestamp offset.\n     * {!Map.<number, number>}\n     */\n    this.discontinuityToTso_ = new Map();\n  }\n\n\n  /**\n   * @override\n   * @exportInterface\n   */\n  configure(config) {\n    this.config_ = config;\n  }\n\n  /**\n   * @override\n   * @exportInterface\n   */\n  async start(uri, playerInterface) {\n    goog.asserts.assert(this.config_, 'Must call configure() before start()!');\n    this.playerInterface_ = playerInterface;\n\n    const response = await this.requestManifest_(uri);\n\n    // Record the master playlist URI after redirects.\n    this.masterPlaylistUri_ = response.uri;\n\n    goog.asserts.assert(response.data, 'Response data should be non-null!');\n    await this.parseManifest_(response.data);\n\n    // Start the update timer if we want updates.\n    const delay = this.updatePlaylistDelay_;\n    if (delay > 0) {\n      this.updatePlaylistTimer_.tickAfter(/* seconds= */ delay);\n    }\n\n    goog.asserts.assert(this.manifest_, 'Manifest should be non-null');\n    return this.manifest_;\n  }\n\n  /**\n   * @override\n   * @exportInterface\n   */\n  stop() {\n    // Make sure we don't update the manifest again. Even if the timer is not\n    // running, this is safe to call.\n    if (this.updatePlaylistTimer_) {\n      this.updatePlaylistTimer_.stop();\n      this.updatePlaylistTimer_ = null;\n    }\n\n    /** @type {!Array.<!Promise>} */\n    const pending = [];\n\n    if (this.operationManager_) {\n      pending.push(this.operationManager_.destroy());\n      this.operationManager_ = null;\n    }\n\n    this.playerInterface_ = null;\n    this.config_ = null;\n    this.variantUriSet_.clear();\n    this.manifest_ = null;\n    this.uriToStreamInfosMap_.clear();\n    this.groupIdToStreamInfosMap_.clear();\n    this.groupIdToCodecsMap_.clear();\n    this.globalVariables_.clear();\n\n    return Promise.all(pending);\n  }\n\n  /**\n   * @override\n   * @exportInterface\n   */\n  async update() {\n    if (!this.isLive_()) {\n      return;\n    }\n\n    /** @type {!Array.<!Promise>} */\n    const updates = [];\n    // Reset the start time for the new media playlist.\n    this.playlistStartTime_ = null;\n    const streamInfos = Array.from(this.uriToStreamInfosMap_.values());\n    // Wait for the first stream info created, so that the start time is fetched\n    // and can be reused.\n    if (streamInfos.length) {\n      await this.updateStream_(streamInfos[0]);\n    }\n    for (let i = 1; i < streamInfos.length; i++) {\n      updates.push(this.updateStream_(streamInfos[i]));\n    }\n\n    await Promise.all(updates);\n  }\n\n  /**\n   * Updates a stream.\n   *\n   * @param {!shaka.hls.HlsParser.StreamInfo} streamInfo\n   * @return {!Promise}\n   * @private\n   */\n  async updateStream_(streamInfo) {\n    const PresentationType = shaka.hls.HlsParser.PresentationType_;\n\n    const manifestUri = streamInfo.absoluteMediaPlaylistUri;\n    const response = await this.requestManifest_(manifestUri);\n\n    /** @type {shaka.hls.Playlist} */\n    const playlist = this.manifestTextParser_.parsePlaylist(\n        response.data, response.uri);\n\n    if (playlist.type != shaka.hls.PlaylistType.MEDIA) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.MANIFEST,\n          shaka.util.Error.Code.HLS_INVALID_PLAYLIST_HIERARCHY);\n    }\n\n    /** @type {!Array.<!shaka.hls.Tag>} */\n    const variablesTags = shaka.hls.Utils.filterTagsByName(playlist.tags,\n        'EXT-X-DEFINE');\n\n    const mediaVariables = this.parseMediaVariables_(variablesTags);\n\n    const stream = streamInfo.stream;\n\n    const segments = await this.createSegments_(\n        streamInfo.verbatimMediaPlaylistUri, playlist, stream.type,\n        stream.mimeType, streamInfo.mediaSequenceToStartTime, mediaVariables);\n\n    stream.segmentIndex.merge(segments);\n    if (segments.length) {\n      stream.segmentIndex.evict(segments[0].startTime);\n    }\n    const newestSegment = segments[segments.length - 1];\n    goog.asserts.assert(newestSegment, 'Should have segments!');\n\n    // Once the last segment has been added to the playlist,\n    // #EXT-X-ENDLIST tag will be appended.\n    // If that happened, treat the rest of the EVENT presentation as VOD.\n    const endListTag =\n        shaka.hls.Utils.getFirstTagWithName(playlist.tags, 'EXT-X-ENDLIST');\n\n    if (endListTag) {\n      // Convert the presentation to VOD and set the duration to the last\n      // segment's end time.\n      this.setPresentationType_(PresentationType.VOD);\n      this.presentationTimeline_.setDuration(newestSegment.endTime);\n    }\n  }\n\n\n  /**\n   * @override\n   * @exportInterface\n   */\n  onExpirationUpdated(sessionId, expiration) {\n    // No-op\n  }\n\n  /**\n   * Parses the manifest.\n   *\n   * @param {BufferSource} data\n   * @return {!Promise}\n   * @private\n   */\n  async parseManifest_(data) {\n    const Utils = shaka.hls.Utils;\n\n    goog.asserts.assert(this.masterPlaylistUri_,\n        'Master playlist URI must be set before calling parseManifest_!');\n\n    const playlist = this.manifestTextParser_.parsePlaylist(\n        data, this.masterPlaylistUri_);\n\n    // We don't support directly providing a Media Playlist.\n    // See the error code for details.\n    if (playlist.type != shaka.hls.PlaylistType.MASTER) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.MANIFEST,\n          shaka.util.Error.Code.HLS_MASTER_PLAYLIST_NOT_PROVIDED);\n    }\n\n    /** @type {!Array.<!shaka.hls.Tag>} */\n    const variablesTags = Utils.filterTagsByName(playlist.tags, 'EXT-X-DEFINE');\n\n    this.parseMasterVariables_(variablesTags);\n\n    /** @type {!Array.<!shaka.hls.Tag>} */\n    const mediaTags = Utils.filterTagsByName(playlist.tags, 'EXT-X-MEDIA');\n    /** @type {!Array.<!shaka.hls.Tag>} */\n    const variantTags = Utils.filterTagsByName(\n        playlist.tags, 'EXT-X-STREAM-INF');\n\n    this.parseCodecs_(variantTags);\n\n    // Parse audio and video media tags first, so that we can extract segment\n    // start time from audio/video streams and reuse for text streams.\n    await this.createStreamInfosFromMediaTags_(mediaTags);\n    this.parseClosedCaptions_(mediaTags);\n    const variants = await this.createVariantsForTags_(variantTags);\n    const textStreams = await this.parseTexts_(mediaTags);\n\n    // Make sure that the parser has not been destroyed.\n    if (!this.playerInterface_) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.PLAYER,\n          shaka.util.Error.Code.OPERATION_ABORTED);\n    }\n\n    if (this.aesEncrypted_ && variants.length == 0) {\n      // We do not support AES-128 encryption with HLS yet. Variants is null\n      // when the playlist is encrypted with AES-128.\n      shaka.log.info('No stream is created, because we don\\'t support AES-128',\n          'encryption yet');\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.MANIFEST,\n          shaka.util.Error.Code.HLS_AES_128_ENCRYPTION_NOT_SUPPORTED);\n    }\n\n    // Find the min and max timestamp of the earliest segment in all streams.\n    // Find the minimum duration of all streams as well.\n    let minFirstTimestamp = Infinity;\n    let minDuration = Infinity;\n\n    for (const streamInfo of this.uriToStreamInfosMap_.values()) {\n      minFirstTimestamp =\n          Math.min(minFirstTimestamp, streamInfo.minTimestamp);\n      if (streamInfo.stream.type != 'text') {\n        minDuration = Math.min(minDuration,\n            streamInfo.maxTimestamp - streamInfo.minTimestamp);\n      }\n    }\n\n    // This assert is our own sanity check.\n    goog.asserts.assert(this.presentationTimeline_ == null,\n        'Presentation timeline created early!');\n    this.createPresentationTimeline_();\n\n    // This assert satisfies the compiler that it is not null for the rest of\n    // the method.\n    goog.asserts.assert(this.presentationTimeline_,\n        'Presentation timeline not created!');\n\n    if (this.isLive_()) {\n      // The HLS spec (RFC 8216) states in 6.3.4:\n      // \"the client MUST wait for at least the target duration before\n      // attempting to reload the Playlist file again\"\n      this.updatePlaylistDelay_ = this.minTargetDuration_;\n\n      // The spec says nothing much about seeking in live content, but Safari's\n      // built-in HLS implementation does not allow it.  Therefore we will set\n      // the availability window equal to the presentation delay.  The player\n      // will be able to buffer ahead three segments, but the seek window will\n      // be zero-sized.\n      const PresentationType = shaka.hls.HlsParser.PresentationType_;\n\n      if (this.presentationType_ == PresentationType.LIVE) {\n        // This defaults to the presentation delay, which has the effect of\n        // making the live stream unseekable.  This is consistent with Apple's\n        // HLS implementation.\n        let segmentAvailabilityDuration = this.presentationTimeline_.getDelay();\n\n        // The app can override that with a longer duration, to allow seeking.\n        if (!isNaN(this.config_.availabilityWindowOverride)) {\n          segmentAvailabilityDuration = this.config_.availabilityWindowOverride;\n        }\n\n        this.presentationTimeline_.setSegmentAvailabilityDuration(\n            segmentAvailabilityDuration);\n      }\n    } else {\n      // For VOD/EVENT content, offset everything back to 0.\n      // Use the minimum timestamp as the offset for all streams.\n      // Use the minimum duration as the presentation duration.\n      this.presentationTimeline_.setDuration(minDuration);\n      // Use a negative offset to adjust towards 0.\n      this.presentationTimeline_.offset(-minFirstTimestamp);\n\n      for (const streamInfo of this.uriToStreamInfosMap_.values()) {\n        // The segments were created with actual media times, rather than\n        // presentation-aligned times, so offset them all now.\n        streamInfo.stream.segmentIndex.offset(-minFirstTimestamp);\n        // Finally, fit the segments to the playlist duration.\n        streamInfo.stream.segmentIndex.fit(/* periodStart= */ 0, minDuration);\n      }\n    }\n\n    this.manifest_ = {\n      presentationTimeline: this.presentationTimeline_,\n      variants,\n      textStreams,\n      offlineSessionIds: [],\n      minBufferTime: 0,\n    };\n    this.playerInterface_.makeTextStreamsForClosedCaptions(this.manifest_);\n    await this.playerInterface_.filter(this.manifest_);\n  }\n\n  /**\n   * Get the variables of each variant tag, and store in a map.\n   * @param {!Array.<!shaka.hls.Tag>} tags Variant tags from the playlist.\n   * @private\n   */\n  parseMasterVariables_(tags) {\n    for (const variableTag of tags) {\n      const name = variableTag.getAttributeValue('NAME');\n      const value = variableTag.getAttributeValue('VALUE');\n      if (name && value) {\n        if (!this.globalVariables_.has(name)) {\n          this.globalVariables_.set(name, value);\n        }\n      }\n    }\n  }\n\n  /**\n   * Get the variables of each variant tag, and store in a map.\n   * @param {!Array.<!shaka.hls.Tag>} tags Variant tags from the playlist.\n   * @return {!Map.<string, string>}\n   * @private\n   */\n  parseMediaVariables_(tags) {\n    const mediaVariables = new Map();\n    for (const variableTag of tags) {\n      const name = variableTag.getAttributeValue('NAME');\n      const value = variableTag.getAttributeValue('VALUE');\n      const mediaImport = variableTag.getAttributeValue('IMPORT');\n      if (name && value) {\n        mediaVariables.set(name, value);\n      }\n      if (mediaImport) {\n        const globalValue = this.globalVariables_.get(mediaImport);\n        if (globalValue) {\n          mediaVariables.set(mediaImport, globalValue);\n        }\n      }\n    }\n    return mediaVariables;\n  }\n\n  /**\n   * Get the codecs of each variant tag, and store in a map from\n   * audio/video/subtitle group id to the codecs arraylist.\n   * @param {!Array.<!shaka.hls.Tag>} tags Variant tags from the playlist.\n   * @private\n   */\n  parseCodecs_(tags) {\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n\n    for (const variantTag of tags) {\n      const audioGroupId = variantTag.getAttributeValue('AUDIO');\n      const videoGroupId = variantTag.getAttributeValue('VIDEO');\n      const subGroupId = variantTag.getAttributeValue('SUBTITLES');\n      const allCodecs = this.getCodecsForVariantTag_(variantTag);\n\n      if (subGroupId) {\n        const textCodecs = this.guessCodecsSafe_(ContentType.TEXT, allCodecs);\n        goog.asserts.assert(textCodecs != null, 'Text codecs should be valid.');\n        this.groupIdToCodecsMap_.set(subGroupId, textCodecs);\n        shaka.util.ArrayUtils.remove(allCodecs, textCodecs);\n      }\n      if (audioGroupId) {\n        const codecs = this.guessCodecs_(ContentType.AUDIO, allCodecs);\n        this.groupIdToCodecsMap_.set(audioGroupId, codecs);\n      }\n      if (videoGroupId) {\n        const codecs = this.guessCodecs_(ContentType.VIDEO, allCodecs);\n        this.groupIdToCodecsMap_.set(videoGroupId, codecs);\n      }\n    }\n  }\n\n  /**\n   * Parse Subtitles and Closed Captions from 'EXT-X-MEDIA' tags.\n   * Create text streams for Subtitles, but not Closed Captions.\n   *\n   * @param {!Array.<!shaka.hls.Tag>} mediaTags Media tags from the playlist.\n   * @return {!Promise.<!Array.<!shaka.extern.Stream>>}\n   * @private\n   */\n  async parseTexts_(mediaTags) {\n    // Create text stream for each Subtitle media tag.\n    const subtitleTags =\n        shaka.hls.Utils.filterTagsByType(mediaTags, 'SUBTITLES');\n    const textStreamPromises = subtitleTags.map(async (tag) => {\n      const disableText = this.config_.disableText;\n      if (disableText) {\n        return null;\n      }\n      try {\n        const streamInfo = await this.createStreamInfoFromMediaTag_(tag);\n        goog.asserts.assert(\n            streamInfo, 'Should always have a streamInfo for text');\n        return streamInfo.stream;\n      } catch (e) {\n        if (this.config_.hls.ignoreTextStreamFailures) {\n          return null;\n        }\n        throw e;\n      }\n    });\n    const textStreams = await Promise.all(textStreamPromises);\n\n    // Set the codecs for text streams.\n    for (const tag of subtitleTags) {\n      const groupId = tag.getRequiredAttrValue('GROUP-ID');\n      const codecs = this.groupIdToCodecsMap_.get(groupId);\n      if (codecs) {\n        const textStreamInfos = this.groupIdToStreamInfosMap_.get(groupId);\n        if (textStreamInfos) {\n          for (const textStreamInfo of textStreamInfos) {\n            textStreamInfo.stream.codecs = codecs;\n          }\n        }\n      }\n    }\n\n    // Do not create text streams for Closed captions.\n    return textStreams.filter((s) => s);\n  }\n\n  /**\n   * @param {!Array.<!shaka.hls.Tag>} mediaTags Media tags from the playlist.\n   * @private\n   */\n  async createStreamInfosFromMediaTags_(mediaTags) {\n    // Filter out subtitles and  media tags without uri.\n    mediaTags = mediaTags.filter((tag) => {\n      const uri = tag.getAttributeValue('URI') || '';\n      const type = tag.getAttributeValue('TYPE');\n      return type != 'SUBTITLES' && uri != '';\n    });\n\n    // Create stream info for each audio / video media tag.\n    // Wait for the first stream info created, so that the start time is fetched\n    // and can be reused.\n    if (mediaTags.length) {\n      await this.createStreamInfoFromMediaTag_(mediaTags[0]);\n    }\n    const promises = mediaTags.slice(1).map((tag) => {\n      return this.createStreamInfoFromMediaTag_(tag);\n    });\n    await Promise.all(promises);\n  }\n\n  /**\n   * @param {!Array.<!shaka.hls.Tag>} tags Variant tags from the playlist.\n   * @return {!Promise.<!Array.<!shaka.extern.Variant>>}\n   * @private\n   */\n  async createVariantsForTags_(tags) {\n    // Create variants for each variant tag.\n    const variantsPromises = tags.map(async (tag) => {\n      const frameRate = tag.getAttributeValue('FRAME-RATE');\n      const bandwidth = Number(tag.getRequiredAttrValue('BANDWIDTH'));\n\n      const resolution = tag.getAttributeValue('RESOLUTION');\n      const [width, height] = resolution ? resolution.split('x') : [null, null];\n\n      const streamInfos = await this.createStreamInfosForVariantTag_(tag,\n          resolution, frameRate);\n\n      if (streamInfos) {\n        goog.asserts.assert(streamInfos.audio.length ||\n            streamInfos.video.length, 'We should have created a stream!');\n\n        return this.createVariants_(\n            streamInfos.audio,\n            streamInfos.video,\n            bandwidth,\n            width,\n            height,\n            frameRate);\n      }\n      // We do not support AES-128 encryption with HLS yet. If the streamInfos\n      // is null because of AES-128 encryption, do not create variants for that.\n      return [];\n    });\n\n    const allVariants = await Promise.all(variantsPromises);\n    let variants = allVariants.reduce(shaka.util.Functional.collapseArrays, []);\n    // Filter out null variants.\n    variants = variants.filter((variant) => variant != null);\n    return variants;\n  }\n\n  /**\n   * Create audio and video streamInfos from an 'EXT-X-STREAM-INF' tag and its\n   * related media tags.\n   *\n   * @param {!shaka.hls.Tag} tag\n   * @param {?string} resolution\n   * @param {?string} frameRate\n   * @return {!Promise.<?shaka.hls.HlsParser.StreamInfos>}\n   * @private\n   */\n  async createStreamInfosForVariantTag_(tag, resolution, frameRate) {\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n    /** @type {!Array.<string>} */\n    let allCodecs = this.getCodecsForVariantTag_(tag);\n    const audioGroupId = tag.getAttributeValue('AUDIO');\n    const videoGroupId = tag.getAttributeValue('VIDEO');\n    goog.asserts.assert(audioGroupId == null || videoGroupId == null,\n        'Unexpected: both video and audio described by media tags!');\n\n    const groupId = audioGroupId || videoGroupId;\n    const streamInfos =\n        (groupId && this.groupIdToStreamInfosMap_.has(groupId)) ?\n        this.groupIdToStreamInfosMap_.get(groupId) : [];\n\n    /** @type {shaka.hls.HlsParser.StreamInfos} */\n    const res = {\n      audio: audioGroupId ? streamInfos : [],\n      video: videoGroupId ? streamInfos : [],\n    };\n\n    // Make an educated guess about the stream type.\n    shaka.log.debug('Guessing stream type for', tag.toString());\n    let type;\n    let ignoreStream = false;\n\n    // The Microsoft HLS manifest generators will make audio-only variants\n    // that link to their URI both directly and through an audio tag.\n    // In that case, ignore the local URI and use the version in the\n    // AUDIO tag, so you inherit its language.\n    // As an example, see the manifest linked in issue #860.\n    const streamURI = tag.getRequiredAttrValue('URI');\n    const hasSameUri = res.audio.find((audio) => {\n      return audio && audio.verbatimMediaPlaylistUri == streamURI;\n    });\n\n    const videoCodecs = this.guessCodecsSafe_(ContentType.VIDEO, allCodecs);\n    const hasVideoRelatedInfo = resolution || frameRate || videoCodecs;\n\n    if (allCodecs.length == 1 && !hasVideoRelatedInfo) {\n      // There are no associated media tags, and there's only one codec, and no\n      // video related information, so it should be audio.\n      type = ContentType.AUDIO;\n      shaka.log.debug('Guessing audio-only.');\n    } else if (!streamInfos.length && allCodecs.length > 1) {\n      // There are multiple codecs, so assume multiplexed content.\n      // Note that the default used when CODECS is missing assumes multiple\n      // (and therefore multiplexed).\n      // Recombine the codec strings into one so that MediaSource isn't\n      // lied to later. (That would trigger an error in Chrome.)\n      shaka.log.debug('Guessing multiplexed audio+video.');\n      type = ContentType.VIDEO;\n      allCodecs = [allCodecs.join(',')];\n    } else if (res.audio.length && hasSameUri) {\n      shaka.log.debug('Guessing audio-only.');\n      type = ContentType.AUDIO;\n      ignoreStream = true;\n    } else if (res.video.length) {\n      // There are associated video streams.  Assume this is audio.\n      shaka.log.debug('Guessing audio-only.');\n      type = ContentType.AUDIO;\n    } else {\n      shaka.log.debug('Guessing video-only.');\n      type = ContentType.VIDEO;\n    }\n\n    let streamInfo;\n    if (!ignoreStream) {\n      streamInfo =\n          await this.createStreamInfoFromVariantTag_(tag, allCodecs, type);\n    }\n    if (streamInfo) {\n      res[streamInfo.stream.type] = [streamInfo];\n    } else if (streamInfo === null) {\n      // Triple-equals for undefined.\n      shaka.log.debug('streamInfo is null');\n      return null;\n    }\n    this.filterLegacyCodecs_(res);\n    return res;\n  }\n\n\n  /**\n   * Get the codecs from the 'EXT-X-STREAM-INF' tag.\n   *\n   * @param {!shaka.hls.Tag} tag\n   * @return {!Array.<string>} codecs\n   * @private\n   */\n  getCodecsForVariantTag_(tag) {\n    // These are the default codecs to assume if none are specified.\n    // The video codec is H.264, with baseline profile and level 3.0.\n    // http://blog.pearce.org.nz/2013/11/what-does-h264avc1-codecs-parameters.html\n    // The audio codec is \"low-complexity\" AAC.\n    const defaultCodecsArray = [];\n    if (!this.config_.disableVideo) {\n      defaultCodecsArray.push('avc1.42E01E');\n    }\n    if (!this.config_.disableAudio) {\n      defaultCodecsArray.push('mp4a.40.2');\n    }\n    const defaultCodecs = defaultCodecsArray.join(',');\n\n    const codecsString = tag.getAttributeValue('CODECS', defaultCodecs);\n    // Strip out internal whitespace while splitting on commas:\n    /** @type {!Array.<string>} */\n    const codecs = codecsString.split(/\\s*,\\s*/);\n\n    // Filter out duplicate codecs.\n    const seen = new Set();\n    const ret = [];\n    for (const codec of codecs) {\n      // HLS says the CODECS field needs to include all codecs that appear in\n      // the content. This means that if the content changes profiles, it should\n      // include both. Since all known browsers support changing profiles\n      // without any other work, just ignore them.  See also:\n      // https://github.com/google/shaka-player/issues/1817\n      const shortCodec = shaka.util.MimeUtils.getCodecBase(codec);\n      if (!seen.has(shortCodec)) {\n        ret.push(codec);\n        seen.add(shortCodec);\n      } else {\n        shaka.log.debug('Ignoring duplicate codec');\n      }\n    }\n    return ret;\n  }\n\n  /**\n   * Get the channel count information for an HLS audio track.\n   * CHANNELS specifies an ordered, \"/\" separated list of parameters.\n   * If the type is audio, the first parameter will be a decimal integer\n   * specifying the number of independent, simultaneous audio channels.\n   * No other channels parameters are currently defined.\n   *\n   * @param {!shaka.hls.Tag} tag\n   * @return {?number}\n   * @private\n   */\n  getChannelsCount_(tag) {\n    const channels = tag.getAttributeValue('CHANNELS');\n    if (!channels) {\n      return null;\n    }\n    const channelcountstring = channels.split('/')[0];\n    const count = parseInt(channelcountstring, 10);\n    return count;\n  }\n\n  /**\n   * Get the closed captions map information for the EXT-X-STREAM-INF tag, to\n   * create the stream info.\n   * @param {!shaka.hls.Tag} tag\n   * @param {string} type\n   * @return {Map.<string, string>} closedCaptions\n   * @private\n   */\n  getClosedCaptions_(tag, type) {\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n    // The attribute of closed captions is optional, and the value may be\n    // 'NONE'.\n    const closedCaptionsAttr = tag.getAttributeValue('CLOSED-CAPTIONS');\n\n    // EXT-X-STREAM-INF tags may have CLOSED-CAPTIONS attributes.\n    // The value can be either a quoted-string or an enumerated-string with\n    // the value NONE. If the value is a quoted-string, it MUST match the\n    // value of the GROUP-ID attribute of an EXT-X-MEDIA tag elsewhere in the\n    // Playlist whose TYPE attribute is CLOSED-CAPTIONS.\n    if (type == ContentType.VIDEO && closedCaptionsAttr &&\n    closedCaptionsAttr != 'NONE') {\n      return this.groupIdToClosedCaptionsMap_.get(closedCaptionsAttr);\n    }\n    return null;\n  }\n\n  /**\n   * Get the language value.\n   *\n   * @param {!shaka.hls.Tag} tag\n   * @return {string}\n   * @private\n   */\n  getLanguage_(tag) {\n    const LanguageUtils = shaka.util.LanguageUtils;\n    const languageValue = tag.getAttributeValue('LANGUAGE') || 'und';\n    return LanguageUtils.normalize(languageValue);\n  }\n\n  /**\n   * Get the type value.\n   * Shaka recognizes the content types 'audio', 'video' and 'text'.\n   * The HLS 'subtitles' type needs to be mapped to 'text'.\n   * @param {!shaka.hls.Tag} tag\n   * @return {string}\n   * @private\n   */\n  getType_(tag) {\n    let type = tag.getRequiredAttrValue('TYPE').toLowerCase();\n    if (type == 'subtitles') {\n      type = shaka.util.ManifestParserUtils.ContentType.TEXT;\n    }\n    return type;\n  }\n\n  /**\n   * Filters out unsupported codec strings from an array of stream infos.\n   * @param {shaka.hls.HlsParser.StreamInfos} streamInfos\n   * @private\n   */\n  filterLegacyCodecs_(streamInfos) {\n    for (const streamInfo of streamInfos.audio.concat(streamInfos.video)) {\n      if (!streamInfo) {\n        continue;\n      }\n      let codecs = streamInfo.stream.codecs.split(',');\n      codecs = codecs.filter((codec) => {\n        // mp4a.40.34 is a nonstandard codec string that is sometimes used in\n        // HLS for legacy reasons.  It is not recognized by non-Apple MSE.\n        // See https://bugs.chromium.org/p/chromium/issues/detail?id=489520\n        // Therefore, ignore this codec string.\n        return codec != 'mp4a.40.34';\n      });\n      streamInfo.stream.codecs = codecs.join(',');\n    }\n  }\n\n  /**\n   * @param {!Array.<shaka.hls.HlsParser.StreamInfo>} audioInfos\n   * @param {!Array.<shaka.hls.HlsParser.StreamInfo>} videoInfos\n   * @param {number} bandwidth\n   * @param {?string} width\n   * @param {?string} height\n   * @param {?string} frameRate\n   * @return {!Array.<!shaka.extern.Variant>}\n   * @private\n   */\n  createVariants_(audioInfos, videoInfos, bandwidth, width, height, frameRate) {\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n    const DrmEngine = shaka.media.DrmEngine;\n\n    for (const info of videoInfos) {\n      this.addVideoAttributes_(info.stream, width, height, frameRate);\n    }\n\n    // In case of audio-only or video-only content or the audio/video is\n    // disabled by the config, we create an array of one item containing\n    // a null. This way, the double-loop works for all kinds of content.\n    // NOTE: we currently don't have support for audio-only content.\n    const disableAudio = this.config_.disableAudio;\n    if (!audioInfos.length || disableAudio) {\n      audioInfos = [null];\n    }\n    const disableVideo = this.config_.disableVideo;\n    if (!videoInfos.length || disableVideo) {\n      videoInfos = [null];\n    }\n\n    const variants = [];\n    for (const audioInfo of audioInfos) {\n      for (const videoInfo of videoInfos) {\n        const audioStream = audioInfo ? audioInfo.stream : null;\n        const videoStream = videoInfo ? videoInfo.stream : null;\n        const audioDrmInfos = audioInfo ? audioInfo.stream.drmInfos : null;\n        const videoDrmInfos = videoInfo ? videoInfo.stream.drmInfos : null;\n        const videoStreamUri =\n            videoInfo ? videoInfo.verbatimMediaPlaylistUri : '';\n        const audioStreamUri =\n            audioInfo ? audioInfo.verbatimMediaPlaylistUri : '';\n        const variantUriKey = videoStreamUri + ' - ' + audioStreamUri;\n\n        if (audioStream && videoStream) {\n          if (!DrmEngine.areDrmCompatible(audioDrmInfos, videoDrmInfos)) {\n            shaka.log.warning(\n                'Incompatible DRM info in HLS variant.  Skipping.');\n            continue;\n          }\n        }\n\n        if (this.variantUriSet_.has(variantUriKey)) {\n          // This happens when two variants only differ in their text streams.\n          shaka.log.debug(\n              'Skipping variant which only differs in text streams.');\n          continue;\n        }\n\n        // Since both audio and video are of the same type, this assertion will\n        // catch certain mistakes at runtime that the compiler would miss.\n        goog.asserts.assert(!audioStream ||\n            audioStream.type == ContentType.AUDIO, 'Audio parameter mismatch!');\n        goog.asserts.assert(!videoStream ||\n            videoStream.type == ContentType.VIDEO, 'Video parameter mismatch!');\n\n        const variant = {\n          id: this.globalId_++,\n          language: audioStream ? audioStream.language : 'und',\n          primary: (!!audioStream && audioStream.primary) ||\n              (!!videoStream && videoStream.primary),\n          audio: audioStream,\n          video: videoStream,\n          bandwidth,\n          allowedByApplication: true,\n          allowedByKeySystem: true,\n        };\n\n        variants.push(variant);\n        this.variantUriSet_.add(variantUriKey);\n      }\n    }\n    return variants;\n  }\n\n  /**\n   * Parses an array of EXT-X-MEDIA tags, then stores the values of all tags\n   * with TYPE=\"CLOSED-CAPTIONS\" into a map of group id to closed captions.\n   *\n   * @param {!Array.<!shaka.hls.Tag>} mediaTags\n   * @private\n   */\n  parseClosedCaptions_(mediaTags) {\n    const closedCaptionsTags =\n        shaka.hls.Utils.filterTagsByType(mediaTags, 'CLOSED-CAPTIONS');\n    for (const tag of closedCaptionsTags) {\n      goog.asserts.assert(tag.name == 'EXT-X-MEDIA',\n          'Should only be called on media tags!');\n      const language = this.getLanguage_(tag);\n\n      // The GROUP-ID value is a quoted-string that specifies the group to which\n      // the Rendition belongs.\n      const groupId = tag.getRequiredAttrValue('GROUP-ID');\n\n      // The value of INSTREAM-ID is a quoted-string that specifies a Rendition\n      // within the segments in the Media Playlist. This attribute is REQUIRED\n      // if the TYPE attribute is CLOSED-CAPTIONS.\n      const instreamId = tag.getRequiredAttrValue('INSTREAM-ID');\n      if (!this.groupIdToClosedCaptionsMap_.get(groupId)) {\n        this.groupIdToClosedCaptionsMap_.set(groupId, new Map());\n      }\n      this.groupIdToClosedCaptionsMap_.get(groupId).set(instreamId, language);\n    }\n  }\n\n  /**\n   * Parse EXT-X-MEDIA media tag into a Stream object.\n   *\n   * @param {shaka.hls.Tag} tag\n   * @return {!Promise.<?shaka.hls.HlsParser.StreamInfo>}\n   * @private\n   */\n  async createStreamInfoFromMediaTag_(tag) {\n    goog.asserts.assert(tag.name == 'EXT-X-MEDIA',\n        'Should only be called on media tags!');\n    const groupId = tag.getRequiredAttrValue('GROUP-ID');\n    let codecs = '';\n    /** @type {string} */\n    const type = this.getType_(tag);\n    // Text does not require a codec.\n    if (type != shaka.util.ManifestParserUtils.ContentType.TEXT && groupId &&\n        this.groupIdToCodecsMap_.has(groupId)) {\n      codecs = this.groupIdToCodecsMap_.get(groupId);\n    }\n\n    const verbatimMediaPlaylistUri = this.variableSubstitution_(\n        tag.getRequiredAttrValue('URI'), this.globalVariables_);\n\n    // Check if the stream has already been created as part of another Variant\n    // and return it if it has.\n    if (this.uriToStreamInfosMap_.has(verbatimMediaPlaylistUri)) {\n      return this.uriToStreamInfosMap_.get(verbatimMediaPlaylistUri);\n    }\n\n    const language = this.getLanguage_(tag);\n    const name = tag.getAttributeValue('NAME');\n\n    // NOTE: According to the HLS spec, \"DEFAULT=YES\" requires \"AUTOSELECT=YES\".\n    // However, we don't bother to validate \"AUTOSELECT\", since we don't\n    // actually use it in our streaming model, and we treat everything as\n    // \"AUTOSELECT=YES\".  A value of \"AUTOSELECT=NO\" would imply that it may\n    // only be selected explicitly by the user, and we don't have a way to\n    // represent that in our model.\n    const defaultAttrValue = tag.getAttribute('DEFAULT');\n    const primary = defaultAttrValue == 'YES';\n\n    const channelsCount = type == 'audio' ? this.getChannelsCount_(tag) : null;\n    const characteristics = tag.getAttributeValue('CHARACTERISTICS');\n    // TODO: Should we take into account some of the currently ignored\n    // attributes: FORCED, INSTREAM-ID, CHARACTERISTICS? Attribute\n    // descriptions: https://bit.ly/2lpjOhj\n    const streamInfo = await this.createStreamInfo_(\n        verbatimMediaPlaylistUri, codecs, type, language, primary, name,\n        channelsCount, /* closedCaptions= */ null, characteristics);\n    if (this.groupIdToStreamInfosMap_.has(groupId)) {\n      this.groupIdToStreamInfosMap_.get(groupId).push(streamInfo);\n    } else {\n      this.groupIdToStreamInfosMap_.set(groupId, [streamInfo]);\n    }\n    if (streamInfo == null) {\n      return null;\n    }\n\n    // TODO: This check is necessary because of the possibility of multiple\n    // calls to createStreamInfoFromMediaTag_ before either has resolved.\n    if (this.uriToStreamInfosMap_.has(verbatimMediaPlaylistUri)) {\n      return this.uriToStreamInfosMap_.get(verbatimMediaPlaylistUri);\n    }\n    this.uriToStreamInfosMap_.set(verbatimMediaPlaylistUri, streamInfo);\n    return streamInfo;\n  }\n\n  /**\n   * Parse an EXT-X-STREAM-INF media tag into a Stream object.\n   *\n   * @param {!shaka.hls.Tag} tag\n   * @param {!Array.<string>} allCodecs\n   * @param {string} type\n   * @return {!Promise.<?shaka.hls.HlsParser.StreamInfo>}\n   * @private\n   */\n  async createStreamInfoFromVariantTag_(tag, allCodecs, type) {\n    goog.asserts.assert(tag.name == 'EXT-X-STREAM-INF',\n        'Should only be called on variant tags!');\n    const verbatimMediaPlaylistUri = this.variableSubstitution_(\n        tag.getRequiredAttrValue('URI'), this.globalVariables_);\n\n    if (this.uriToStreamInfosMap_.has(verbatimMediaPlaylistUri)) {\n      return this.uriToStreamInfosMap_.get(verbatimMediaPlaylistUri);\n    }\n\n    const closedCaptions = this.getClosedCaptions_(tag, type);\n    const codecs = this.guessCodecs_(type, allCodecs);\n    const streamInfo = await this.createStreamInfo_(verbatimMediaPlaylistUri,\n        codecs, type, /* language= */ 'und', /* primary= */ false,\n        /* name= */ null, /* channelcount= */ null, closedCaptions,\n        /* characteristics= */ null);\n    if (streamInfo == null) {\n      return null;\n    }\n    // TODO: This check is necessary because of the possibility of multiple\n    // calls to createStreamInfoFromVariantTag_ before either has resolved.\n    if (this.uriToStreamInfosMap_.has(verbatimMediaPlaylistUri)) {\n      return this.uriToStreamInfosMap_.get(verbatimMediaPlaylistUri);\n    }\n\n    this.uriToStreamInfosMap_.set(verbatimMediaPlaylistUri, streamInfo);\n    return streamInfo;\n  }\n\n\n  /**\n   * @param {string} verbatimMediaPlaylistUri\n   * @param {string} codecs\n   * @param {string} type\n   * @param {string} language\n   * @param {boolean} primary\n   * @param {?string} name\n   * @param {?number} channelsCount\n   * @param {Map.<string, string>} closedCaptions\n   * @param {?string} characteristics\n   * @return {!Promise.<?shaka.hls.HlsParser.StreamInfo>}\n   * @private\n   */\n  async createStreamInfo_(verbatimMediaPlaylistUri, codecs, type, language,\n      primary, name, channelsCount, closedCaptions, characteristics) {\n    // TODO: Refactor, too many parameters\n    let absoluteMediaPlaylistUri = shaka.hls.Utils.constructAbsoluteUri(\n        this.masterPlaylistUri_, verbatimMediaPlaylistUri);\n\n    const response = await this.requestManifest_(absoluteMediaPlaylistUri);\n    // Record the final URI after redirects.\n    absoluteMediaPlaylistUri = response.uri;\n\n    // Record the redirected, final URI of this media playlist when we parse it.\n    /** @type {!shaka.hls.Playlist} */\n    const playlist = this.manifestTextParser_.parsePlaylist(\n        response.data, absoluteMediaPlaylistUri);\n\n    if (playlist.type != shaka.hls.PlaylistType.MEDIA) {\n      // EXT-X-MEDIA tags should point to media playlists.\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.MANIFEST,\n          shaka.util.Error.Code.HLS_INVALID_PLAYLIST_HIERARCHY);\n    }\n\n    /** @type {!Array.<!shaka.hls.Tag>} */\n    const drmTags = [];\n    if (playlist.segments) {\n      for (const segment of playlist.segments) {\n        const segmentKeyTags = shaka.hls.Utils.filterTagsByName(segment.tags,\n            'EXT-X-KEY');\n        drmTags.push(...segmentKeyTags);\n      }\n    }\n\n    let encrypted = false;\n    /** @type {!Array.<shaka.extern.DrmInfo>}*/\n    const drmInfos = [];\n    const keyIds = new Set();\n\n    // TODO: May still need changes to support key rotation.\n    for (const drmTag of drmTags) {\n      const method = drmTag.getRequiredAttrValue('METHOD');\n      if (method != 'NONE') {\n        encrypted = true;\n\n        // We do not support AES-128 encryption with HLS yet. So, do not create\n        // StreamInfo for the playlist encrypted with AES-128.\n        // TODO: Remove the error message once we add support for AES-128.\n        if (method == 'AES-128') {\n          shaka.log.warning('Unsupported HLS Encryption', method);\n          this.aesEncrypted_ = true;\n          return null;\n        }\n\n        const keyFormat = drmTag.getRequiredAttrValue('KEYFORMAT');\n        const drmParser =\n            shaka.hls.HlsParser.KEYFORMATS_TO_DRM_PARSERS_[keyFormat];\n\n        const drmInfo = drmParser ? drmParser(drmTag) : null;\n        if (drmInfo) {\n          if (drmInfo.keyIds) {\n            for (const keyId of drmInfo.keyIds) {\n              keyIds.add(keyId);\n            }\n          }\n          drmInfos.push(drmInfo);\n        } else {\n          shaka.log.warning('Unsupported HLS KEYFORMAT', keyFormat);\n        }\n      }\n    }\n\n    if (encrypted && !drmInfos.length) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.MANIFEST,\n          shaka.util.Error.Code.HLS_KEYFORMATS_NOT_SUPPORTED);\n    }\n\n    /** @type {!Array.<!shaka.hls.Tag>} */\n    const variablesTags = shaka.hls.Utils.filterTagsByName(playlist.tags,\n        'EXT-X-DEFINE');\n\n    const mediaVariables = this.parseMediaVariables_(variablesTags);\n\n    goog.asserts.assert(playlist.segments != null,\n        'Media playlist should have segments!');\n\n    this.determinePresentationType_(playlist);\n\n    /** @type {string} */\n    const mimeType = await this.guessMimeType_(type, codecs, playlist,\n        mediaVariables);\n\n    // MediaSource expects no codec strings combined with raw formats.\n    // TODO(#2337): Instead, create a Stream flag indicating a raw format.\n    if (shaka.hls.HlsParser.RAW_FORMATS_.includes(mimeType)) {\n      codecs = '';\n    }\n\n    /** @type {!Map.<number, number>} */\n    const mediaSequenceToStartTime = new Map();\n\n    let segments;\n    try {\n      segments = await this.createSegments_(verbatimMediaPlaylistUri,\n          playlist, type, mimeType, mediaSequenceToStartTime, mediaVariables);\n    } catch (error) {\n      if (error.code == shaka.util.Error.Code.HLS_INTERNAL_SKIP_STREAM) {\n        shaka.log.alwaysWarn('Skipping unsupported HLS stream',\n            mimeType, verbatimMediaPlaylistUri);\n        return null;\n      }\n\n      throw error;\n    }\n\n    const minTimestamp = segments[0].startTime;\n    const lastEndTime = segments[segments.length - 1].endTime;\n    /** @type {!shaka.media.SegmentIndex} */\n    const segmentIndex = new shaka.media.SegmentIndex(segments);\n\n    const kind = (type == shaka.util.ManifestParserUtils.ContentType.TEXT) ?\n        shaka.util.ManifestParserUtils.TextStreamKind.SUBTITLE : undefined;\n\n    const roles = [];\n    if (characteristics) {\n      for (const characteristic of characteristics.split(',')) {\n        roles.push(characteristic);\n      }\n    }\n\n    /** @type {shaka.extern.Stream} */\n    const stream = {\n      id: this.globalId_++,\n      originalId: name,\n      createSegmentIndex: () => Promise.resolve(),\n      segmentIndex,\n      mimeType,\n      codecs,\n      kind,\n      encrypted,\n      drmInfos,\n      keyIds,\n      language,\n      label: name,  // For historical reasons, since before \"originalId\".\n      type,\n      primary,\n      // TODO: trick mode\n      trickModeVideo: null,\n      emsgSchemeIdUris: null,\n      frameRate: undefined,\n      pixelAspectRatio: undefined,\n      width: undefined,\n      height: undefined,\n      bandwidth: undefined,\n      roles: roles,\n      channelsCount,\n      audioSamplingRate: null,\n      closedCaptions,\n    };\n\n    return {\n      stream,\n      verbatimMediaPlaylistUri,\n      absoluteMediaPlaylistUri,\n      minTimestamp,\n      maxTimestamp: lastEndTime,\n      mediaSequenceToStartTime,\n    };\n  }\n\n\n  /**\n   * @param {!shaka.hls.Playlist} playlist\n   * @private\n   */\n  determinePresentationType_(playlist) {\n    const PresentationType = shaka.hls.HlsParser.PresentationType_;\n    const presentationTypeTag =\n        shaka.hls.Utils.getFirstTagWithName(playlist.tags,\n            'EXT-X-PLAYLIST-TYPE');\n    const endListTag =\n        shaka.hls.Utils.getFirstTagWithName(playlist.tags, 'EXT-X-ENDLIST');\n\n    const isVod = (presentationTypeTag && presentationTypeTag.value == 'VOD') ||\n        endListTag;\n    const isEvent = presentationTypeTag &&\n        presentationTypeTag.value == 'EVENT' && !isVod;\n    const isLive = !isVod && !isEvent;\n\n    if (isVod) {\n      this.setPresentationType_(PresentationType.VOD);\n    } else {\n      // If it's not VOD, it must be presentation type LIVE or an ongoing EVENT.\n      if (isLive) {\n        this.setPresentationType_(PresentationType.LIVE);\n      } else {\n        this.setPresentationType_(PresentationType.EVENT);\n      }\n\n      const targetDurationTag = this.getRequiredTag_(playlist.tags,\n          'EXT-X-TARGETDURATION');\n      const targetDuration = Number(targetDurationTag.value);\n\n      // According to the HLS spec, updates should not happen more often than\n      // once in targetDuration.  It also requires us to only update the active\n      // variant.  We might implement that later, but for now every variant\n      // will be updated.  To get the update period, choose the smallest\n      // targetDuration value across all playlists.\n\n      // Update the longest target duration if need be to use as a presentation\n      // delay later.\n      this.maxTargetDuration_ = Math.max(\n          targetDuration, this.maxTargetDuration_);\n      // Update the shortest one to use as update period and segment\n      // availability time (for LIVE).\n      this.minTargetDuration_ = Math.min(\n          targetDuration, this.minTargetDuration_);\n    }\n  }\n\n  /**\n   * @private\n   */\n  createPresentationTimeline_() {\n    if (this.isLive_()) {\n      // The live edge will be calculated from segments, so we don't need to\n      // set a presentation start time.  We will assert later that this is\n      // working as expected.\n\n      // The HLS spec (RFC 8216) states in 6.3.3:\n      //\n      // \"The client SHALL choose which Media Segment to play first ... the\n      // client SHOULD NOT choose a segment that starts less than three target\n      // durations from the end of the Playlist file.  Doing so can trigger\n      // playback stalls.\"\n      //\n      // We accomplish this in our DASH-y model by setting a presentation\n      // delay of configured value, or 3 segments duration if not configured.\n      // This will be the \"live edge\" of the presentation.\n      const presentationDelay =\n          this.config_.defaultPresentationDelay || this.maxTargetDuration_ * 3;\n      this.presentationTimeline_ = new shaka.media.PresentationTimeline(\n      /* presentationStartTime= */ 0, /* delay= */ presentationDelay);\n      this.presentationTimeline_.setStatic(false);\n    } else {\n      this.presentationTimeline_ = new shaka.media.PresentationTimeline(\n      /* presentationStartTime= */ null, /* delay= */ 0);\n      this.presentationTimeline_.setStatic(true);\n    }\n\n    this.notifySegments_();\n\n    // This asserts that the live edge is being calculated from segment times.\n    // For VOD and event streams, this check should still pass.\n    goog.asserts.assert(\n        !this.presentationTimeline_.usingPresentationStartTime(),\n        'We should not be using the presentation start time in HLS!');\n  }\n\n  /**\n   * Get the InitSegmentReference for a segment if it has a EXT-X-MAP tag.\n   * @param {string} playlistUri The absolute uri of the media playlist.\n   * @param {!Array.<!shaka.hls.Tag>} tags Segment tags\n   * @param {!Map.<string, string>} variables\n   * @return {shaka.media.InitSegmentReference}\n   * @private\n   */\n  getInitSegmentReference_(playlistUri, tags, variables) {\n    /** @type {?shaka.hls.Tag} */\n    const mapTag = shaka.hls.Utils.getFirstTagWithName(tags, 'EXT-X-MAP');\n\n    if (!mapTag) {\n      return null;\n    }\n    // Map tag example: #EXT-X-MAP:URI=\"main.mp4\",BYTERANGE=\"720@0\"\n    const verbatimInitSegmentUri = mapTag.getRequiredAttrValue('URI');\n    const absoluteInitSegmentUri = this.variableSubstitution_(\n        shaka.hls.Utils.constructAbsoluteUri(\n            playlistUri, verbatimInitSegmentUri),\n        variables);\n\n    const mapTagKey = [\n      absoluteInitSegmentUri,\n      mapTag.getAttributeValue('BYTERANGE', ''),\n    ].join('-');\n    if (!this.mapTagToInitSegmentRefMap_.has(mapTagKey)) {\n      const initSegmentRef = this.createInitSegmentReference_(\n          absoluteInitSegmentUri, mapTag);\n      this.mapTagToInitSegmentRefMap_.set(mapTagKey, initSegmentRef);\n    }\n    return this.mapTagToInitSegmentRefMap_.get(mapTagKey);\n  }\n\n  /**\n   * Create an InitSegmentReference object for the EXT-X-MAP tag in the media\n   * playlist.\n   * @param {string} absoluteInitSegmentUri\n   * @param {!shaka.hls.Tag} mapTag EXT-X-MAP\n   * @return {!shaka.media.InitSegmentReference}\n   * @private\n   */\n  createInitSegmentReference_(absoluteInitSegmentUri, mapTag) {\n    let startByte = 0;\n    let endByte = null;\n    const byterange = mapTag.getAttributeValue('BYTERANGE');\n    // If a BYTERANGE attribute is not specified, the segment consists\n    // of the entire resource.\n    if (byterange) {\n      const blocks = byterange.split('@');\n      const byteLength = Number(blocks[0]);\n      startByte = Number(blocks[1]);\n      endByte = startByte + byteLength - 1;\n    }\n\n    const initSegmentRef = new shaka.media.InitSegmentReference(\n        () => [absoluteInitSegmentUri],\n        startByte,\n        endByte);\n    return initSegmentRef;\n  }\n\n  /**\n   * Parses one shaka.hls.Segment object into a shaka.media.SegmentReference.\n   *\n   * @param {shaka.media.InitSegmentReference} initSegmentReference\n   * @param {shaka.media.SegmentReference} previousReference\n   * @param {!shaka.hls.Segment} hlsSegment\n   * @param {number} startTime\n   * @param {number} timestampOffset\n   * @param {!Map.<string, string>} variables\n   * @return {!shaka.media.SegmentReference}\n   * @private\n   */\n  createSegmentReference_(\n      initSegmentReference, previousReference, hlsSegment, startTime,\n      timestampOffset, variables) {\n    const tags = hlsSegment.tags;\n    const absoluteSegmentUri = this.variableSubstitution_(\n        hlsSegment.absoluteUri, variables);\n\n    const extinfTag = this.getRequiredTag_(tags, 'EXTINF');\n    // The EXTINF tag format is '#EXTINF:<duration>,[<title>]'.\n    // We're interested in the duration part.\n    const extinfValues = extinfTag.value.split(',');\n    const duration = Number(extinfValues[0]);\n    const endTime = startTime + duration;\n\n    let startByte = 0;\n    let endByte = null;\n    const byterange =\n         shaka.hls.Utils.getFirstTagWithName(tags, 'EXT-X-BYTERANGE');\n\n    // If BYTERANGE is not specified, the segment consists of the entire\n    // resource.\n    if (byterange) {\n      const blocks = byterange.value.split('@');\n      const byteLength = Number(blocks[0]);\n      if (blocks[1]) {\n        startByte = Number(blocks[1]);\n      } else {\n        goog.asserts.assert(previousReference,\n            'Cannot refer back to previous HLS segment!');\n        startByte = previousReference.endByte + 1;\n      }\n      endByte = startByte + byteLength - 1;\n    }\n\n    return new shaka.media.SegmentReference(\n        startTime,\n        endTime,\n        () => [absoluteSegmentUri],\n        startByte,\n        endByte,\n        initSegmentReference,\n        timestampOffset,\n        /* appendWindowStart= */ 0,\n        /* appendWindowEnd= */ Infinity);\n  }\n\n  /** @private */\n  notifySegments_() {\n    // The presentation timeline may or may not be set yet.\n    // If it does not yet exist, hold onto the segments until it does.\n    if (!this.presentationTimeline_) {\n      return;\n    }\n    for (const segments of this.segmentsToNotifyByStream_) {\n      this.presentationTimeline_.notifySegments(segments);\n    }\n    this.segmentsToNotifyByStream_ = [];\n  }\n\n  /**\n   * Parses shaka.hls.Segment objects into shaka.media.SegmentReferences.\n   *\n   * @param {string} verbatimMediaPlaylistUri\n   * @param {!shaka.hls.Playlist} playlist\n   * @param {string} type\n   * @param {string} mimeType\n   * @param {!Map.<number, number>} mediaSequenceToStartTime\n   * @param {!Map.<string, string>} variables\n   * @return {!Promise<!Array.<!shaka.media.SegmentReference>>}\n   * @private\n   */\n  async createSegments_(verbatimMediaPlaylistUri, playlist, type, mimeType,\n      mediaSequenceToStartTime, variables) {\n    /** @type {Array.<!shaka.hls.Segment>} */\n    const hlsSegments = playlist.segments;\n    goog.asserts.assert(hlsSegments.length, 'Playlist should have segments!');\n\n    /** @type {shaka.media.InitSegmentReference} */\n    let initSegmentRef;\n\n    // We may need to look at the media itself to determine a segment start\n    // time.\n    const mediaSequenceNumber = shaka.hls.Utils.getFirstTagWithNameAsNumber(\n        playlist.tags, 'EXT-X-MEDIA-SEQUENCE', 0);\n\n    let firstStartTime;\n    // For live stream, use the cached value in the mediaSequenceToStartTime\n    // map if available.\n    // Since createSegments_() is asynchronous and we are updating the streams\n    // in parallel, the global playlistStartTime_ may get updated by other\n    // playlist updates rather than the current one.\n    if (this.isLive_() && mediaSequenceToStartTime.has(mediaSequenceNumber)) {\n      firstStartTime = mediaSequenceToStartTime.get(mediaSequenceNumber);\n    } else {\n      if (this.playlistStartTime_ == null) {\n        // For VOD and EVENT playlists, all variants must start at the same\n        // time, so we can fetch the start time once and reuse for the others.\n        // This is not guaranteed when updating a LIVE stream. We assume the\n        // first segment in each live playlist is no more than one segment out\n        // of sync with the other playlists, so we can fetch the start time for\n        // once.\n        initSegmentRef = this.getInitSegmentReference_(\n            playlist.absoluteUri, hlsSegments[0].tags, variables);\n        goog.asserts.assert(\n            type != shaka.util.ManifestParserUtils.ContentType.TEXT,\n            'Should only get start time from audio or video streams');\n        this.playlistStartTime_ = await this.getStartTime_(\n            verbatimMediaPlaylistUri, initSegmentRef, mimeType,\n            mediaSequenceNumber, /* isDiscontinuity= */ false,\n            hlsSegments[0], variables);\n      }\n      firstStartTime = this.playlistStartTime_;\n    }\n\n    const firstSegmentUri = hlsSegments[0].absoluteUri;\n    shaka.log.debug('First segment', firstSegmentUri.split('/').pop(),\n        'starts at', firstStartTime);\n\n    let discontintuitySequenceNum = shaka.hls.Utils.getFirstTagWithNameAsNumber(\n        playlist.tags, 'EXT-X-DISCONTINUITY-SEQUENCE');\n    let timestampOffset =\n        this.discontinuityToTso_.get(discontintuitySequenceNum) || 0;\n\n    /** @type {!Array.<!shaka.media.SegmentReference>} */\n    const references = [];\n\n    const enumerate = (it) => shaka.util.Iterables.enumerate(it);\n    for (const {i, item} of enumerate(hlsSegments)) {\n      const previousReference = references[references.length - 1];\n      const startTime = (i == 0) ? firstStartTime :\n          previousReference.endTime;\n      const position = mediaSequenceNumber + i;\n\n      mediaSequenceToStartTime.set(position, startTime);\n\n      initSegmentRef = this.getInitSegmentReference_(playlist.absoluteUri,\n          item.tags, variables);\n\n      const discontintuityTag = shaka.hls.Utils.getFirstTagWithName(item.tags,\n          'EXT-X-DISCONTINUITY');\n      if (discontintuityTag) {\n        discontintuitySequenceNum++;\n\n        // eslint-disable-next-line no-await-in-loop\n        timestampOffset = await this.getTimestampOffset_(\n            discontintuitySequenceNum, verbatimMediaPlaylistUri, initSegmentRef,\n            mimeType, position, item, variables, startTime);\n      }\n\n      const reference = this.createSegmentReference_(\n          initSegmentRef,\n          previousReference,\n          item,\n          startTime,\n          timestampOffset,\n          variables);\n      references.push(reference);\n    }\n\n    this.segmentsToNotifyByStream_.push(references);\n    this.notifySegments_();\n\n    return references;\n  }\n\n  /**\n   * Gets the start time of the first segment of the playlist from existing\n   * value (if possible) or by downloading it and parsing it otherwise.\n   *\n   * @param {number} discontintuitySequenceNum\n   * @param {string} verbatimMediaPlaylistUri\n   * @param {shaka.media.InitSegmentReference} initSegmentRef\n   * @param {string} mimeType\n   * @param {number} mediaSequenceNumber\n   * @param {!shaka.hls.Segment} segment\n   * @param {!Map.<string, string>} variables\n   * @param {number} startTime\n   * @return {!Promise.<number>}\n   * @throws {shaka.util.Error}\n   * @private\n   */\n  async getTimestampOffset_(discontintuitySequenceNum,\n      verbatimMediaPlaylistUri, initSegmentRef,\n      mimeType, mediaSequenceNumber, segment, variables, startTime) {\n    let timestampOffset = 0;\n    if (this.discontinuityToTso_.has(discontintuitySequenceNum)) {\n      timestampOffset =\n          this.discontinuityToTso_.get(discontintuitySequenceNum);\n    } else {\n      // eslint-disable-next-line no-await-in-loop\n      const mediaStartTime = await this.getStartTime_(\n          verbatimMediaPlaylistUri, initSegmentRef, mimeType,\n          mediaSequenceNumber, /* isDiscontinuity= */ true, segment,\n          variables);\n      timestampOffset = startTime - mediaStartTime;\n      shaka.log.v1('Segment timestampOffset =', timestampOffset);\n      this.discontinuityToTso_.set(\n          discontintuitySequenceNum, timestampOffset);\n    }\n    return timestampOffset;\n  }\n\n  /**\n   * Try to fetch the starting part of a segment, and fall back to a full\n   * segment if we have to.\n   *\n   * @param {!shaka.media.AnySegmentReference} reference\n   * @return {!Promise.<shaka.extern.Response>}\n   * @private\n   */\n  async fetchStartOfSegment_(reference) {\n    const requestType = shaka.net.NetworkingEngine.RequestType.SEGMENT;\n\n    // Create two requests:\n    //  1. A partial request meant to fetch the smallest part of the segment\n    //     required to get the time stamp.\n    //  2. A full request meant as a fallback for when the server does not\n    //     support partial requests.\n    const fullRequest = shaka.util.Networking.createSegmentRequest(\n        reference.getUris(),\n        reference.startByte,\n        reference.endByte,\n        this.config_.retryParameters);\n\n    if (this.config_.hls.useFullSegmentsForStartTime) {\n      return this.makeNetworkRequest_(fullRequest, requestType);\n    }\n\n    const partialRequest = shaka.util.Networking.createSegmentRequest(\n        reference.getUris(),\n        reference.startByte,\n        reference.startByte + shaka.hls.HlsParser.START_OF_SEGMENT_SIZE_ - 1,\n        this.config_.retryParameters);\n\n    // TODO(vaage): The need to do fall back requests is not likely to be unique\n    //    to here. It would be nice if the fallback(s) could be included into\n    //    the same abortable operation as the original request.\n    //\n    //    What would need to change with networking engine to support requests\n    //    with fallback(s)?\n    try {\n      const response = await this.makeNetworkRequest_(\n          partialRequest, requestType);\n\n      return response;\n    } catch (e) {\n      // If the networking operation was aborted, we don't want to treat it as\n      // a request failure. We surface the error so that the OPERATION_ABORTED\n      // error will be handled correctly.\n      if (e.code == shaka.util.Error.Code.OPERATION_ABORTED) {\n        throw e;\n      }\n\n      // The partial request may fail for a number of reasons.\n      // Some servers do not support Range requests, and others do not support\n      // the OPTIONS request which must be made before any cross-origin Range\n      // request.  Since this fallback is expensive, warn the app developer.\n      shaka.log.alwaysWarn('Unable to fetch a partial HLS segment! ' +\n                           'Falling back to a full segment request, ' +\n                           'which is expensive!  Your server should ' +\n                           'support Range requests and CORS preflights.',\n      partialRequest.uris[0]);\n\n      const response = await this.makeNetworkRequest_(fullRequest, requestType);\n\n      return response;\n    }\n  }\n\n  /**\n   * Gets the start time of a segment from the existing manifest (if possible)\n   * or by downloading it and parsing it otherwise.\n   *\n   * @param {string} verbatimMediaPlaylistUri\n   * @param {shaka.media.InitSegmentReference} initSegmentRef\n   * @param {string} mimeType\n   * @param {number} mediaSequenceNumber\n   * @param {boolean} isDiscontinuity\n   * @param {!shaka.hls.Segment} segment\n   * @param {!Map.<string, string>} variables\n   * @return {!Promise.<number>}\n   * @private\n   */\n  async getStartTime_(\n      verbatimMediaPlaylistUri, initSegmentRef, mimeType, mediaSequenceNumber,\n      isDiscontinuity, segment, variables) {\n    const segmentRef = this.createSegmentReference_(\n        initSegmentRef,\n        /* previousReference= */ null,\n        segment,\n        /* startTime= */ 0,\n        /* timestampOffset= */ 0,\n        variables);\n    // If we are updating the manifest, we can usually skip fetching the segment\n    // by examining the references we already have.  This won't be possible if\n    // there was some kind of lag or delay updating the manifest on the server,\n    // in which extreme case we would fall back to fetching a segment.  This\n    // allows us to both avoid fetching segments when possible, and recover from\n    // certain server-side issues gracefully.\n    // Do not use cached start time for the segments with discontinuity tags.\n    if (this.manifest_ && !isDiscontinuity) {\n      const streamInfo =\n          this.uriToStreamInfosMap_.get(verbatimMediaPlaylistUri);\n      const startTime = streamInfo.mediaSequenceToStartTime.get(\n          mediaSequenceNumber);\n      if (startTime != undefined) {\n        // We found it!  Avoid fetching and parsing the segment.\n        shaka.log.v1('Found segment start time in previous manifest',\n            startTime);\n        return startTime;\n      }\n\n      shaka.log.debug(\n          'Unable to find segment start time in previous manifest!');\n    }\n\n    // TODO: Introduce a new tag to extend HLS and provide the first segment's\n    // start time.  This will avoid the need for these fetches in content\n    // packaged with Shaka Packager.  This web-friendly extension to HLS can\n    // then be proposed to Apple for inclusion in a future version of HLS.\n    // See https://github.com/google/shaka-packager/issues/294\n\n    shaka.log.v1('Fetching segment to find start time');\n    mimeType = mimeType.toLowerCase();\n\n    if (shaka.hls.HlsParser.RAW_FORMATS_.includes(mimeType)) {\n      // Raw formats contain no timestamps.  Even if there is an ID3 tag with a\n      // timestamp, that's not going to be honored by MediaSource, which will\n      // use sequence mode for these segments.  We don't yet support sequence\n      // mode, so we must reject these streams.\n      // TODO(#2337): Support sequence mode and align raw format timestamps to\n      // other streams.\n      shaka.log.alwaysWarn(\n          'Raw formats are not yet supported.  Skipping ' + mimeType);\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.RECOVERABLE,\n          shaka.util.Error.Category.MANIFEST,\n          shaka.util.Error.Code.HLS_INTERNAL_SKIP_STREAM);\n    }\n\n    if (mimeType == 'video/webm') {\n      shaka.log.alwaysWarn('WebM in HLS is not yet supported.  Skipping.');\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.RECOVERABLE,\n          shaka.util.Error.Category.MANIFEST,\n          shaka.util.Error.Code.HLS_INTERNAL_SKIP_STREAM);\n    }\n\n    if (mimeType == 'video/mp4' || mimeType == 'audio/mp4') {\n      // We also need the init segment to get the correct timescale. But if the\n      // stream is self-initializing, use the same response for both.\n      const fetches = [this.fetchStartOfSegment_(segmentRef)];\n\n      if (initSegmentRef) {\n        fetches.push(this.fetchStartOfSegment_(initSegmentRef));\n      }\n\n      const responses = await Promise.all(fetches);\n\n      // If the stream is self-initializing, use the main segment in-place of\n      // the init segment.\n      const segmentResponse = responses[0];\n      const initSegmentResponse = responses[1] || responses[0];\n\n      return this.getStartTimeFromMp4Segment_(\n          verbatimMediaPlaylistUri, segmentResponse.uri,\n          segmentResponse.data, initSegmentResponse.data);\n    }\n\n    if (mimeType == 'video/mp2t') {\n      const response = await this.fetchStartOfSegment_(segmentRef);\n      goog.asserts.assert(response.data, 'Should have a response body!');\n      return this.getStartTimeFromTsSegment_(\n          verbatimMediaPlaylistUri, response.uri, response.data);\n    }\n\n    throw new shaka.util.Error(\n        shaka.util.Error.Severity.CRITICAL,\n        shaka.util.Error.Category.MANIFEST,\n        shaka.util.Error.Code.HLS_COULD_NOT_PARSE_SEGMENT_START_TIME,\n        verbatimMediaPlaylistUri);\n  }\n\n  /**\n   * Parses an mp4 segment to get its start time.\n   *\n   * @param {string} playlistUri\n   * @param {string} segmentUri\n   * @param {BufferSource} mediaData\n   * @param {BufferSource} initData\n   * @return {number}\n   * @private\n   */\n  getStartTimeFromMp4Segment_(playlistUri, segmentUri, mediaData, initData) {\n    const Mp4Parser = shaka.util.Mp4Parser;\n\n    let timescale = 0;\n    new Mp4Parser()\n        .box('moov', Mp4Parser.children)\n        .box('trak', Mp4Parser.children)\n        .box('mdia', Mp4Parser.children)\n        .fullBox('mdhd', (box) => {\n          goog.asserts.assert(\n              box.version == 0 || box.version == 1,\n              'MDHD version can only be 0 or 1');\n\n          // Skip \"creation_time\" and \"modification_time\".\n          // They are 4 bytes each if the mdhd box is version 0, 8 bytes each\n          // if it is version 1.\n          box.reader.skip(box.version == 0 ? 8 : 16);\n\n          timescale = box.reader.readUint32();\n          box.parser.stop();\n        }).parse(initData, /* partialOkay= */ true);\n\n    if (!timescale) {\n      shaka.log.error('Unable to find timescale in init segment!');\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.MANIFEST,\n          shaka.util.Error.Code.HLS_COULD_NOT_PARSE_SEGMENT_START_TIME,\n          playlistUri, segmentUri);\n    }\n\n    let startTime = 0;\n    let parsedMedia = false;\n    new Mp4Parser()\n        .box('moof', Mp4Parser.children)\n        .box('traf', Mp4Parser.children)\n        .fullBox('tfdt', (box) => {\n          goog.asserts.assert(\n              box.version == 0 || box.version == 1,\n              'TFDT version can only be 0 or 1');\n          const baseTime = (box.version == 0) ?\n          box.reader.readUint32() :\n          box.reader.readUint64();\n          startTime = baseTime / timescale;\n          parsedMedia = true;\n          box.parser.stop();\n        }).parse(mediaData, /* partialOkay= */ true);\n\n    if (!parsedMedia) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.MANIFEST,\n          shaka.util.Error.Code.HLS_COULD_NOT_PARSE_SEGMENT_START_TIME,\n          playlistUri, segmentUri);\n    }\n    return startTime;\n  }\n\n  /**\n   * Parses a TS segment to get its start time.\n   *\n   * @param {string} playlistUri\n   * @param {string} segmentUri\n   * @param {BufferSource} data\n   * @return {number}\n   * @private\n   */\n  getStartTimeFromTsSegment_(playlistUri, segmentUri, data) {\n    const reader = new shaka.util.DataViewReader(\n        data, shaka.util.DataViewReader.Endianness.BIG_ENDIAN);\n\n    const fail = () => {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.MANIFEST,\n          shaka.util.Error.Code.HLS_COULD_NOT_PARSE_SEGMENT_START_TIME,\n          playlistUri, segmentUri);\n    };\n\n    let packetStart = 0;\n    let syncByte = 0;\n\n    const skipPacket = () => {\n      // 188-byte packets are standard, so assume that.\n      reader.seek(packetStart + 188);\n      syncByte = reader.readUint8();\n      if (syncByte != 0x47) {\n        // We haven't found the sync byte, so try it as a 192-byte packet.\n        reader.seek(packetStart + 192);\n        syncByte = reader.readUint8();\n      }\n      if (syncByte != 0x47) {\n        // We still haven't found the sync byte, so try as a 204-byte packet.\n        reader.seek(packetStart + 204);\n        syncByte = reader.readUint8();\n      }\n      if (syncByte != 0x47) {\n        // We still haven't found the sync byte, so the packet was of a\n        // non-standard size.\n        fail();\n      }\n      // Put the sync byte back so we can read it in the next loop.\n      reader.rewind(1);\n    };\n\n    // TODO: refactor this while loop for better readability.\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      // Format reference: https://bit.ly/TsPacket\n      packetStart = reader.getPosition();\n\n      syncByte = reader.readUint8();\n      if (syncByte != 0x47) {\n        fail();\n      }\n\n      const flagsAndPacketId = reader.readUint16();\n      const packetId = flagsAndPacketId & 0x1fff;\n      if (packetId == 0x1fff) {\n        // A \"null\" TS packet.  Skip this TS packet and try again.\n        skipPacket();\n        continue;\n      }\n\n      const hasPesPacket = flagsAndPacketId & 0x4000;\n      if (!hasPesPacket) {\n        // Not a PES packet yet.  Skip this TS packet and try again.\n        skipPacket();\n        continue;\n      }\n\n      const flags = reader.readUint8();\n      const adaptationFieldControl = (flags & 0x30) >> 4;\n      if (adaptationFieldControl == 0 /* reserved */ ||\n          adaptationFieldControl == 2 /* adaptation field, no payload */) {\n        fail();\n      }\n\n      if (adaptationFieldControl == 3) {\n        // Skip over adaptation field.\n        const length = reader.readUint8();\n        reader.skip(length);\n      }\n\n      // Now we come to the PES header (hopefully).\n      // Format reference: https://bit.ly/TsPES\n      const startCode = reader.readUint32();\n      const startCodePrefix = startCode >> 8;\n      if (startCodePrefix != 1) {\n        // Not a PES packet yet.  Skip this TS packet and try again.\n        skipPacket();\n        continue;\n      }\n\n      // Skip the 16-bit PES length and the first 8 bits of the optional header.\n      reader.skip(3);\n      // The next 8 bits contain flags about DTS & PTS.\n      const ptsDtsIndicator = reader.readUint8() >> 6;\n      if (ptsDtsIndicator == 0 /* no timestamp */ ||\n          ptsDtsIndicator == 1 /* forbidden */) {\n        fail();\n      }\n\n      const pesHeaderLengthRemaining = reader.readUint8();\n      if (pesHeaderLengthRemaining == 0) {\n        fail();\n      }\n\n      if (ptsDtsIndicator == 2 /* PTS only */) {\n        goog.asserts.assert(pesHeaderLengthRemaining == 5, 'Bad PES header?');\n      } else if (ptsDtsIndicator == 3 /* PTS and DTS */) {\n        goog.asserts.assert(pesHeaderLengthRemaining == 10, 'Bad PES header?');\n      }\n\n      const pts0 = reader.readUint8();\n      const pts1 = reader.readUint16();\n      const pts2 = reader.readUint16();\n      // Reconstruct 33-bit PTS from the 5-byte, padded structure.\n      const ptsHigh3 = (pts0 & 0x0e) >> 1;\n      const ptsLow30 = ((pts1 & 0xfffe) << 14) | ((pts2 & 0xfffe) >> 1);\n      // Reconstruct the PTS as a float.  Avoid bitwise operations to combine\n      // because bitwise ops treat the values as 32-bit ints.\n      const pts = ptsHigh3 * (1 << 30) + ptsLow30;\n      return pts / shaka.hls.HlsParser.TS_TIMESCALE_;\n    }\n  }\n\n  /**\n   * Attempts to guess which codecs from the codecs list belong to a given\n   * content type.\n   * Assumes that at least one codec is correct, and throws if none are.\n   *\n   * @param {string} contentType\n   * @param {!Array.<string>} codecs\n   * @return {string}\n   * @private\n   */\n  guessCodecs_(contentType, codecs) {\n    if (codecs.length == 1) {\n      return codecs[0];\n    }\n\n    const match = this.guessCodecsSafe_(contentType, codecs);\n    // A failure is specifically denoted by null; an empty string represents a\n    // valid match of no codec.\n    if (match != null) {\n      return match;\n    }\n\n    // Unable to guess codecs.\n    throw new shaka.util.Error(\n        shaka.util.Error.Severity.CRITICAL,\n        shaka.util.Error.Category.MANIFEST,\n        shaka.util.Error.Code.HLS_COULD_NOT_GUESS_CODECS,\n        codecs);\n  }\n\n  /**\n   * Attempts to guess which codecs from the codecs list belong to a given\n   * content type. Does not assume a single codec is anything special, and does\n   * not throw if it fails to match.\n   *\n   * @param {string} contentType\n   * @param {!Array.<string>} codecs\n   * @return {?string} or null if no match is found\n   * @private\n   */\n  guessCodecsSafe_(contentType, codecs) {\n    const formats =\n        shaka.hls.HlsParser.CODEC_REGEXPS_BY_CONTENT_TYPE_[contentType];\n    for (const format of formats) {\n      for (const codec of codecs) {\n        if (format.test(codec.trim())) {\n          return codec.trim();\n        }\n      }\n    }\n\n    // Text does not require a codec string.\n    if (contentType == shaka.util.ManifestParserUtils.ContentType.TEXT) {\n      return '';\n    }\n\n    return null;\n  }\n\n  /**\n   * Replaces the variables of a given URI.\n   *\n   * @param {string} uri\n   * @param {!Map.<string, string>} variables\n   * @return {string}\n   * @private\n   */\n  variableSubstitution_(uri, variables) {\n    let newUri = String(uri).replace(/%7B/g, '{').replace(/%7D/g, '}');\n\n    const uriVariables = newUri.match(/{\\$\\w*}/g);\n    if (uriVariables) {\n      for (const variable of uriVariables) {\n        // Note: All variables have the structure {$...}\n        const variableName = variable.slice(2, variable.length - 1);\n        const replaceValue = variables.get(variableName);\n        if (replaceValue) {\n          newUri = newUri.replace(variable, replaceValue);\n        } else {\n          shaka.log.error('A variable has been found that is not declared',\n              variableName);\n          throw new shaka.util.Error(\n              shaka.util.Error.Severity.CRITICAL,\n              shaka.util.Error.Category.MANIFEST,\n              shaka.util.Error.Code.HLS_VARIABLE_NOT_FOUND,\n              variableName);\n        }\n      }\n    }\n    return newUri;\n  }\n\n  /**\n   * Attempts to guess stream's mime type based on content type and URI.\n   *\n   * @param {string} contentType\n   * @param {string} codecs\n   * @param {!shaka.hls.Playlist} playlist\n   * @param {!Map.<string, string>} variables\n   * @return {!Promise.<string>}\n   * @private\n   */\n  async guessMimeType_(contentType, codecs, playlist, variables) {\n    const HlsParser = shaka.hls.HlsParser;\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n    const requestType = shaka.net.NetworkingEngine.RequestType.SEGMENT;\n\n    goog.asserts.assert(playlist.segments.length,\n        'Playlist should have segments!');\n    const firstSegmentUri = this.variableSubstitution_(\n        playlist.segments[0].absoluteUri, variables);\n\n    const parsedUri = new goog.Uri(firstSegmentUri);\n    const extension = parsedUri.getPath().split('.').pop();\n    const map = HlsParser.EXTENSION_MAP_BY_CONTENT_TYPE_[contentType];\n\n    const mimeType = map[extension];\n    if (mimeType) {\n      return mimeType;\n    }\n\n    if (contentType == ContentType.TEXT) {\n      // The extension map didn't work.\n      if (!codecs || codecs == 'vtt' || codecs == 'wvtt') {\n        // If codecs is 'vtt', it's WebVTT.\n        // If there was no codecs string, assume HLS text streams are WebVTT.\n        return 'text/vtt';\n      } else {\n        // Otherwise, assume MP4-embedded text, since text-based formats tend\n        // not to have a codecs string at all.\n        return 'application/mp4';\n      }\n    }\n\n    // If unable to guess mime type, request a segment and try getting it\n    // from the response.\n    const headRequest = shaka.net.NetworkingEngine.makeRequest(\n        [firstSegmentUri], this.config_.retryParameters);\n    headRequest.method = 'HEAD';\n\n    const response = await this.makeNetworkRequest_(\n        headRequest, requestType);\n\n    const contentMimeType = response.headers['content-type'];\n\n    if (!contentMimeType) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.MANIFEST,\n          shaka.util.Error.Code.HLS_COULD_NOT_GUESS_MIME_TYPE,\n          extension);\n    }\n\n    // Split the MIME type in case the server sent additional parameters.\n    return contentMimeType.split(';')[0];\n  }\n\n  /**\n   * Returns a tag with a given name.\n   * Throws an error if tag was not found.\n   *\n   * @param {!Array.<shaka.hls.Tag>} tags\n   * @param {string} tagName\n   * @return {!shaka.hls.Tag}\n   * @private\n   */\n  getRequiredTag_(tags, tagName) {\n    const tag = shaka.hls.Utils.getFirstTagWithName(tags, tagName);\n    if (!tag) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.MANIFEST,\n          shaka.util.Error.Code.HLS_REQUIRED_TAG_MISSING, tagName);\n    }\n\n    return tag;\n  }\n\n  /**\n   * @param {shaka.extern.Stream} stream\n   * @param {?string} width\n   * @param {?string} height\n   * @param {?string} frameRate\n   * @private\n   */\n  addVideoAttributes_(stream, width, height, frameRate) {\n    if (stream) {\n      stream.width = Number(width) || undefined;\n      stream.height = Number(height) || undefined;\n      stream.frameRate = Number(frameRate) || undefined;\n    }\n  }\n\n  /**\n   * Makes a network request for the manifest and returns a Promise\n   * with the resulting data.\n   *\n   * @param {string} absoluteUri\n   * @return {!Promise.<!shaka.extern.Response>}\n   * @private\n   */\n  requestManifest_(absoluteUri) {\n    const requestType = shaka.net.NetworkingEngine.RequestType.MANIFEST;\n\n    const request = shaka.net.NetworkingEngine.makeRequest(\n        [absoluteUri], this.config_.retryParameters);\n\n    return this.makeNetworkRequest_(request, requestType);\n  }\n\n  /**\n   * Called when the update timer ticks. Because parsing a manifest is async,\n   * this method is async. To work with this, this method will schedule the next\n   * update when it finished instead of using a repeating-start.\n   *\n   * @return {!Promise}\n   * @private\n   */\n  async onUpdate_() {\n    shaka.log.info('Updating manifest...');\n\n    goog.asserts.assert(\n        this.updatePlaylistDelay_ > 0,\n        'We should only call |onUpdate_| when we are suppose to be updating.');\n\n    // Detect a call to stop()\n    if (!this.playerInterface_) {\n      return;\n    }\n\n    try {\n      await this.update();\n\n      const delay = this.updatePlaylistDelay_;\n      this.updatePlaylistTimer_.tickAfter(/* seconds= */ delay);\n    } catch (error) {\n      // Detect a call to stop() during this.update()\n      if (!this.playerInterface_) {\n        return;\n      }\n\n      goog.asserts.assert(error instanceof shaka.util.Error,\n          'Should only receive a Shaka error');\n\n      // We will retry updating, so override the severity of the error.\n      error.severity = shaka.util.Error.Severity.RECOVERABLE;\n      this.playerInterface_.onError(error);\n\n      // Try again very soon.\n      this.updatePlaylistTimer_.tickAfter(/* seconds= */ 0.1);\n    }\n  }\n\n\n  /**\n   * @return {boolean}\n   * @private\n   */\n  isLive_() {\n    const PresentationType = shaka.hls.HlsParser.PresentationType_;\n    return this.presentationType_ != PresentationType.VOD;\n  }\n\n\n  /**\n   * @param {shaka.hls.HlsParser.PresentationType_} type\n   * @private\n   */\n  setPresentationType_(type) {\n    this.presentationType_ = type;\n\n    if (this.presentationTimeline_) {\n      this.presentationTimeline_.setStatic(!this.isLive_());\n    }\n\n    // If this manifest is not for live content, then we have no reason to\n    // update it.\n    if (!this.isLive_()) {\n      this.updatePlaylistTimer_.stop();\n    }\n  }\n\n\n  /**\n   * Create a networking request. This will manage the request using the\n   * parser's operation manager. If the parser has already been stopped, the\n   * request will not be made.\n   *\n   * @param {shaka.extern.Request} request\n   * @param {shaka.net.NetworkingEngine.RequestType} type\n   * @return {!Promise.<shaka.extern.Response>}\n   * @private\n   */\n  makeNetworkRequest_(request, type) {\n    if (!this.operationManager_) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.PLAYER,\n          shaka.util.Error.Code.OPERATION_ABORTED);\n    }\n\n    const op = this.playerInterface_.networkingEngine.request(type, request);\n    this.operationManager_.manage(op);\n\n    return op.promise;\n  }\n\n  /**\n   * @param {!shaka.hls.Tag} drmTag\n   * @return {?shaka.extern.DrmInfo}\n   * @private\n   */\n  static widevineDrmParser_(drmTag) {\n    const method = drmTag.getRequiredAttrValue('METHOD');\n    const VALID_METHODS = ['SAMPLE-AES', 'SAMPLE-AES-CTR'];\n    if (!VALID_METHODS.includes(method)) {\n      shaka.log.error('Widevine in HLS is only supported with [',\n          VALID_METHODS.join(', '), '], not', method);\n      return null;\n    }\n\n    const uri = drmTag.getRequiredAttrValue('URI');\n    const parsedData = shaka.net.DataUriPlugin.parseRaw(uri);\n\n    // The data encoded in the URI is a PSSH box to be used as init data.\n    const pssh = shaka.util.BufferUtils.toUint8(parsedData.data);\n    const drmInfo = shaka.util.ManifestParserUtils.createDrmInfo(\n        'com.widevine.alpha', [\n          {initDataType: 'cenc', initData: pssh},\n        ]);\n\n    const keyId = drmTag.getAttributeValue('KEYID');\n    if (keyId) {\n      const keyIdLowerCase = keyId.toLowerCase();\n      // This value should begin with '0x':\n      goog.asserts.assert(\n          keyIdLowerCase.startsWith('0x'), 'Incorrect KEYID format!');\n      // But the output should not contain the '0x':\n      drmInfo.keyIds = new Set([keyIdLowerCase.substr(2)]);\n    }\n    return drmInfo;\n  }\n};\n\n\n/**\n * @typedef {{\n *   stream: !shaka.extern.Stream,\n *   verbatimMediaPlaylistUri: string,\n *   absoluteMediaPlaylistUri: string,\n *   minTimestamp: number,\n *   maxTimestamp: number,\n *   mediaSequenceToStartTime: !Map.<number, number>\n * }}\n *\n * @description\n * Contains a stream and information about it.\n *\n * @property {!shaka.extern.Stream} stream\n *   The Stream itself.\n * @property {string} verbatimMediaPlaylistUri\n *   The verbatim media playlist URI, as it appeared in the master playlist.\n *   This has not been canonicalized into an absolute URI.  This gives us a\n *   consistent key for this playlist, even if redirects cause us to update\n *   from different origins each time.\n * @property {string} absoluteMediaPlaylistUri\n *   The absolute media playlist URI, resolved relative to the master playlist\n *   and updated to reflect any redirects.\n * @property {number} minTimestamp\n *   The minimum timestamp found in the stream.\n * @property {number} maxTimestamp\n *   The maximum timestamp found in the stream.\n * @property {!Map.<number, number>} mediaSequenceToStartTime\n *   A map of media sequence numbers to media start times.\n */\nshaka.hls.HlsParser.StreamInfo;\n\n\n/**\n * @typedef {{\n *   audio: !Array.<shaka.hls.HlsParser.StreamInfo>,\n *   video: !Array.<shaka.hls.HlsParser.StreamInfo>\n * }}\n *\n * @description Audio and video stream infos.\n * @property {!Array.<shaka.hls.HlsParser.StreamInfo>} audio\n * @property {!Array.<shaka.hls.HlsParser.StreamInfo>} video\n */\nshaka.hls.HlsParser.StreamInfos;\n\n\n/**\n * A list of regexps to detect well-known video codecs.\n *\n * @const {!Array.<!RegExp>}\n * @private\n */\nshaka.hls.HlsParser.VIDEO_CODEC_REGEXPS_ = [\n  /^avc/,\n  /^hev/,\n  /^hvc/,\n  /^vp0?[89]/,\n  /^av1$/,\n];\n\n\n/**\n * A list of regexps to detect well-known audio codecs.\n *\n * @const {!Array.<!RegExp>}\n * @private\n */\nshaka.hls.HlsParser.AUDIO_CODEC_REGEXPS_ = [\n  /^vorbis$/,\n  /^opus$/,\n  /^flac$/,\n  /^mp4a/,\n  /^[ae]c-3$/,\n];\n\n\n/**\n * A list of regexps to detect well-known text codecs.\n *\n * @const {!Array.<!RegExp>}\n * @private\n */\nshaka.hls.HlsParser.TEXT_CODEC_REGEXPS_ = [\n  /^vtt$/,\n  /^wvtt/,\n  /^stpp/,\n];\n\n\n/**\n * @const {!Object.<string, !Array.<!RegExp>>}\n * @private\n */\nshaka.hls.HlsParser.CODEC_REGEXPS_BY_CONTENT_TYPE_ = {\n  'audio': shaka.hls.HlsParser.AUDIO_CODEC_REGEXPS_,\n  'video': shaka.hls.HlsParser.VIDEO_CODEC_REGEXPS_,\n  'text': shaka.hls.HlsParser.TEXT_CODEC_REGEXPS_,\n};\n\n\n/**\n * @const {!Object.<string, string>}\n * @private\n */\nshaka.hls.HlsParser.AUDIO_EXTENSIONS_TO_MIME_TYPES_ = {\n  'mp4': 'audio/mp4',\n  'mp4a': 'audio/mp4',\n  'm4s': 'audio/mp4',\n  'm4i': 'audio/mp4',\n  'm4a': 'audio/mp4',\n  'cmfa': 'audio/mp4',\n  // MPEG2-TS also uses video/ for audio: https://bit.ly/TsMse\n  'ts': 'video/mp2t',\n\n  // Raw formats:\n  'aac': 'audio/aac',\n  'ac3': 'audio/ac3',\n  'ec3': 'audio/ec3',\n  'mp3': 'audio/mpeg',\n};\n\n\n/**\n * MIME types of raw formats.\n * TODO(#2337): Support raw formats and share this list among parsers.\n *\n * @const {!Array.<string>}\n * @private\n */\nshaka.hls.HlsParser.RAW_FORMATS_ = [\n  'audio/aac',\n  'audio/ac3',\n  'audio/ec3',\n  'audio/mpeg',\n];\n\n\n/**\n * @const {!Object.<string, string>}\n * @private\n */\nshaka.hls.HlsParser.VIDEO_EXTENSIONS_TO_MIME_TYPES_ = {\n  'mp4': 'video/mp4',\n  'mp4v': 'video/mp4',\n  'm4s': 'video/mp4',\n  'm4i': 'video/mp4',\n  'm4v': 'video/mp4',\n  'cmfv': 'video/mp4',\n  'ts': 'video/mp2t',\n};\n\n\n/**\n * @const {!Object.<string, string>}\n * @private\n */\nshaka.hls.HlsParser.TEXT_EXTENSIONS_TO_MIME_TYPES_ = {\n  'mp4': 'application/mp4',\n  'm4s': 'application/mp4',\n  'm4i': 'application/mp4',\n  'cmft': 'application/mp4',\n  'vtt': 'text/vtt',\n  'ttml': 'application/ttml+xml',\n};\n\n\n/**\n * @const {!Object.<string, !Object.<string, string>>}\n * @private\n */\nshaka.hls.HlsParser.EXTENSION_MAP_BY_CONTENT_TYPE_ = {\n  'audio': shaka.hls.HlsParser.AUDIO_EXTENSIONS_TO_MIME_TYPES_,\n  'video': shaka.hls.HlsParser.VIDEO_EXTENSIONS_TO_MIME_TYPES_,\n  'text': shaka.hls.HlsParser.TEXT_EXTENSIONS_TO_MIME_TYPES_,\n};\n\n\n/**\n * @typedef {function(!shaka.hls.Tag):?shaka.extern.DrmInfo}\n * @private\n */\nshaka.hls.HlsParser.DrmParser_;\n\n\n/**\n * @const {!Object.<string, shaka.hls.HlsParser.DrmParser_>}\n * @private\n */\nshaka.hls.HlsParser.KEYFORMATS_TO_DRM_PARSERS_ = {\n  /* TODO: https://github.com/google/shaka-player/issues/382\n  'com.apple.streamingkeydelivery':\n      shaka.hls.HlsParser.fairplayDrmParser_,\n  */\n  'urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed':\n      shaka.hls.HlsParser.widevineDrmParser_,\n};\n\n\n/**\n * @enum {string}\n * @private\n */\nshaka.hls.HlsParser.PresentationType_ = {\n  VOD: 'VOD',\n  EVENT: 'EVENT',\n  LIVE: 'LIVE',\n};\n\n\n/**\n * @const {number}\n * @private\n */\nshaka.hls.HlsParser.TS_TIMESCALE_ = 90000;\n\n\n/**\n * The amount of data from the start of a segment we will try to fetch when we\n * need to know the segment start time.  This allows us to avoid fetching the\n * entire segment in many cases.\n *\n * @const {number}\n * @private\n */\nshaka.hls.HlsParser.START_OF_SEGMENT_SIZE_ = 2048;\n\n\nshaka.media.ManifestParser.registerParserByExtension(\n    'm3u8', () => new shaka.hls.HlsParser());\nshaka.media.ManifestParser.registerParserByMime(\n    'application/x-mpegurl', () => new shaka.hls.HlsParser());\nshaka.media.ManifestParser.registerParserByMime(\n    'application/vnd.apple.mpegurl', () => new shaka.hls.HlsParser());\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.net.HttpPluginUtils');\n\ngoog.require('shaka.log');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.StringUtils');\ngoog.requireType('shaka.net.NetworkingEngine');\n\n\n/**\n * @summary A set of http networking utility functions.\n * @exportDoc\n */\nshaka.net.HttpPluginUtils = class {\n  /**\n   * @param {!Object.<string,string>} headers\n   * @param {BufferSource} data\n   * @param {number} status\n   * @param {string} uri\n   * @param {string} responseURL\n   * @param {shaka.net.NetworkingEngine.RequestType} requestType\n   * @return {!shaka.extern.Response}\n   */\n  static makeResponse(headers, data, status, uri, responseURL, requestType) {\n    if (status >= 200 && status <= 299 && status != 202) {\n      // Most 2xx HTTP codes are success cases.\n      /** @type {shaka.extern.Response} */\n      const response = {\n        uri: responseURL || uri,\n        originalUri: uri,\n        data: data,\n        headers: headers,\n        fromCache: !!headers['x-shaka-from-cache'],\n      };\n      return response;\n    } else {\n      let responseText = null;\n      try {\n        responseText = shaka.util.StringUtils.fromBytesAutoDetect(data);\n      } catch (exception) {}\n      shaka.log.debug('HTTP error text:', responseText);\n\n      const severity = status == 401 || status == 403 ?\n      shaka.util.Error.Severity.CRITICAL :\n      shaka.util.Error.Severity.RECOVERABLE;\n      throw new shaka.util.Error(\n          severity,\n          shaka.util.Error.Category.NETWORK,\n          shaka.util.Error.Code.BAD_HTTP_STATUS,\n          uri,\n          status,\n          responseText,\n          headers,\n          requestType);\n    }\n  }\n};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.net.HttpFetchPlugin');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.net.HttpPluginUtils');\ngoog.require('shaka.net.NetworkingEngine');\ngoog.require('shaka.util.AbortableOperation');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.MapUtils');\ngoog.require('shaka.util.Timer');\n\n\n/**\n * @summary A networking plugin to handle http and https URIs via the Fetch API.\n * @export\n */\nshaka.net.HttpFetchPlugin = class {\n  /**\n   * @param {string} uri\n   * @param {shaka.extern.Request} request\n   * @param {shaka.net.NetworkingEngine.RequestType} requestType\n   * @param {shaka.extern.ProgressUpdated} progressUpdated Called when a\n   *   progress event happened.\n   * @return {!shaka.extern.IAbortableOperation.<shaka.extern.Response>}\n   * @export\n   */\n  static parse(uri, request, requestType, progressUpdated) {\n    const headers = new shaka.net.HttpFetchPlugin.Headers_();\n    shaka.util.MapUtils.asMap(request.headers).forEach((value, key) => {\n      headers.append(key, value);\n    });\n\n    const controller = new shaka.net.HttpFetchPlugin.AbortController_();\n\n    /** @type {!RequestInit} */\n    const init = {\n      // Edge does not treat null as undefined for body; https://bit.ly/2luyE6x\n      body: request.body || undefined,\n      headers: headers,\n      method: request.method,\n      signal: controller.signal,\n      credentials: request.allowCrossSiteCredentials ? 'include' : undefined,\n    };\n\n    /** @type {shaka.net.HttpFetchPlugin.AbortStatus} */\n    const abortStatus = {\n      canceled: false,\n      timedOut: false,\n    };\n\n    const pendingRequest = shaka.net.HttpFetchPlugin.request_(\n        uri, requestType, init, abortStatus, progressUpdated);\n\n    /** @type {!shaka.util.AbortableOperation} */\n    const op = new shaka.util.AbortableOperation(pendingRequest, () => {\n      abortStatus.canceled = true;\n      controller.abort();\n      return Promise.resolve();\n    });\n\n    // The fetch API does not timeout natively, so do a timeout manually using\n    // the AbortController.\n    const timeoutMs = request.retryParameters.timeout;\n    if (timeoutMs) {\n      const timer = new shaka.util.Timer(() => {\n        abortStatus.timedOut = true;\n        controller.abort();\n      });\n\n      timer.tickAfter(timeoutMs / 1000);\n\n      // To avoid calling |abort| on the network request after it finished, we\n      // will stop the timer when the requests resolves/rejects.\n      op.finally(() => {\n        timer.stop();\n      });\n    }\n\n    return op;\n  }\n\n  /**\n   * @param {string} uri\n   * @param {shaka.net.NetworkingEngine.RequestType} requestType\n   * @param {!RequestInit} init\n   * @param {shaka.net.HttpFetchPlugin.AbortStatus} abortStatus\n   * @param {shaka.extern.ProgressUpdated} progressUpdated\n   * @return {!Promise<!shaka.extern.Response>}\n   * @private\n   */\n  static async request_(uri, requestType, init, abortStatus, progressUpdated) {\n    const fetch = shaka.net.HttpFetchPlugin.fetch_;\n    const ReadableStream = shaka.net.HttpFetchPlugin.ReadableStream_;\n    let response;\n    let arrayBuffer;\n    let loaded = 0;\n    let lastLoaded = 0;\n\n    // Last time stamp when we got a progress event.\n    let lastTime = Date.now();\n\n    try {\n      // The promise returned by fetch resolves as soon as the HTTP response\n      // headers are available. The download itself isn't done until the promise\n      // for retrieving the data (arrayBuffer, blob, etc) has resolved.\n      response = await fetch(uri, init);\n      // Getting the reader in this way allows us to observe the process of\n      // downloading the body, instead of just waiting for an opaque promise to\n      // resolve.\n      // We first clone the response because calling getReader locks the body\n      // stream; if we didn't clone it here, we would be unable to get the\n      // response's arrayBuffer later.\n      const reader = response.clone().body.getReader();\n\n      const contentLengthRaw = response.headers.get('Content-Length');\n      const contentLength =\n          contentLengthRaw ? parseInt(contentLengthRaw, 10) : 0;\n\n      const start = (controller) => {\n        const push = async () => {\n          let readObj;\n          try {\n            readObj = await reader.read();\n          } catch (e) {\n            // If we abort the request, we'll get an error here.  Just ignore it\n            // since real errors will be reported when we read the buffer below.\n            shaka.log.v1('error reading from stream', e.message);\n            return;\n          }\n\n          if (!readObj.done) {\n            loaded += readObj.value.byteLength;\n          }\n\n          const currentTime = Date.now();\n          // If the time between last time and this time we got progress event\n          // is long enough, or if a whole segment is downloaded, call\n          // progressUpdated().\n          if (currentTime - lastTime > 100 || readObj.done) {\n            progressUpdated(currentTime - lastTime, loaded - lastLoaded,\n                contentLength - loaded);\n            lastLoaded = loaded;\n            lastTime = currentTime;\n          }\n\n          if (readObj.done) {\n            goog.asserts.assert(!readObj.value,\n                'readObj should be unset when \"done\" is true.');\n            controller.close();\n          } else {\n            controller.enqueue(readObj.value);\n            push();\n          }\n        };\n        push();\n      };\n      // Create a ReadableStream to use the reader. We don't need to use the\n      // actual stream for anything, though, as we are using the response's\n      // arrayBuffer method to get the body, so we don't store the\n      // ReadableStream.\n      new ReadableStream({start}); // eslint-disable-line no-new\n      arrayBuffer = await response.arrayBuffer();\n    } catch (error) {\n      if (abortStatus.canceled) {\n        throw new shaka.util.Error(\n            shaka.util.Error.Severity.RECOVERABLE,\n            shaka.util.Error.Category.NETWORK,\n            shaka.util.Error.Code.OPERATION_ABORTED,\n            uri, requestType);\n      } else if (abortStatus.timedOut) {\n        throw new shaka.util.Error(\n            shaka.util.Error.Severity.RECOVERABLE,\n            shaka.util.Error.Category.NETWORK,\n            shaka.util.Error.Code.TIMEOUT,\n            uri, requestType);\n      } else {\n        throw new shaka.util.Error(\n            shaka.util.Error.Severity.RECOVERABLE,\n            shaka.util.Error.Category.NETWORK,\n            shaka.util.Error.Code.HTTP_ERROR,\n            uri, error, requestType);\n      }\n    }\n\n    const headers = {};\n    /** @type {Headers} */\n    const responseHeaders = response.headers;\n    responseHeaders.forEach((value, key) => {\n      // Since IE/Edge incorrectly return the header with a leading new line\n      // character ('\\n'), we trim the header here.\n      headers[key.trim()] = value;\n    });\n\n    return shaka.net.HttpPluginUtils.makeResponse(\n        headers, arrayBuffer, response.status, uri, response.url, requestType);\n  }\n\n  /**\n   * Determine if the Fetch API is supported in the browser. Note: this is\n   * deliberately exposed as a method to allow the client app to use the same\n   * logic as Shaka when determining support.\n   * @return {boolean}\n   * @export\n   */\n  static isSupported() {\n    // On Edge, ReadableStream exists, but attempting to construct it results in\n    // an error. See https://bit.ly/2zwaFLL\n    // So this has to check that ReadableStream is present AND usable.\n    if (window.ReadableStream) {\n      try {\n        new ReadableStream({}); // eslint-disable-line no-new\n      } catch (e) {\n        return false;\n      }\n    } else {\n      return false;\n    }\n    return !!(window.fetch && window.AbortController);\n  }\n};\n\n\n/**\n * @typedef {{\n *   canceled: boolean,\n *   timedOut: boolean\n * }}\n * @property {boolean} canceled\n *   Indicates if the request was canceled.\n * @property {boolean} timedOut\n *   Indicates if the request timed out.\n */\nshaka.net.HttpFetchPlugin.AbortStatus;\n\n\n/**\n * Overridden in unit tests, but compiled out in production.\n *\n * @const {function(string, !RequestInit)}\n * @private\n */\nshaka.net.HttpFetchPlugin.fetch_ = window.fetch;\n\n\n/**\n * Overridden in unit tests, but compiled out in production.\n *\n * @const {function(new: AbortController)}\n * @private\n */\nshaka.net.HttpFetchPlugin.AbortController_ = window.AbortController;\n\n\n/**\n * Overridden in unit tests, but compiled out in production.\n *\n * @const {function(new: ReadableStream, !Object)}\n * @private\n */\nshaka.net.HttpFetchPlugin.ReadableStream_ = window.ReadableStream;\n\n\n/**\n * Overridden in unit tests, but compiled out in production.\n *\n * @const {function(new: Headers)}\n * @private\n */\nshaka.net.HttpFetchPlugin.Headers_ = window.Headers;\n\n\nif (shaka.net.HttpFetchPlugin.isSupported()) {\n  shaka.net.NetworkingEngine.registerScheme(\n      'http', shaka.net.HttpFetchPlugin.parse,\n      shaka.net.NetworkingEngine.PluginPriority.PREFERRED);\n  shaka.net.NetworkingEngine.registerScheme(\n      'https', shaka.net.HttpFetchPlugin.parse,\n      shaka.net.NetworkingEngine.PluginPriority.PREFERRED);\n}\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.net.HttpXHRPlugin');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.net.HttpPluginUtils');\ngoog.require('shaka.net.NetworkingEngine');\ngoog.require('shaka.util.AbortableOperation');\ngoog.require('shaka.util.Error');\n\n\n/**\n * @summary A networking plugin to handle http and https URIs via XHR.\n * @export\n */\nshaka.net.HttpXHRPlugin = class {\n  /**\n   * @param {string} uri\n   * @param {shaka.extern.Request} request\n   * @param {shaka.net.NetworkingEngine.RequestType} requestType\n   * @param {shaka.extern.ProgressUpdated} progressUpdated Called when a\n   *   progress event happened.\n   * @return {!shaka.extern.IAbortableOperation.<shaka.extern.Response>}\n   * @export\n   */\n  static parse(uri, request, requestType, progressUpdated) {\n    const xhr = new shaka.net.HttpXHRPlugin.Xhr_();\n\n    // Last time stamp when we got a progress event.\n    let lastTime = Date.now();\n    // Last number of bytes loaded, from progress event.\n    let lastLoaded = 0;\n\n    const promise = new Promise(((resolve, reject) => {\n      xhr.open(request.method, uri, true);\n      xhr.responseType = 'arraybuffer';\n      xhr.timeout = request.retryParameters.timeout;\n      xhr.withCredentials = request.allowCrossSiteCredentials;\n\n      xhr.onabort = () => {\n        reject(new shaka.util.Error(\n            shaka.util.Error.Severity.RECOVERABLE,\n            shaka.util.Error.Category.NETWORK,\n            shaka.util.Error.Code.OPERATION_ABORTED,\n            uri, requestType));\n      };\n      xhr.onload = (event) => {\n        const target = event.target;\n        goog.asserts.assert(target, 'XHR onload has no target!');\n        // Since IE and Edge incorrectly return the header with a leading new\n        // line character ('\\n'), we trim the header here.\n        const headerLines = target.getAllResponseHeaders().trim().split('\\r\\n');\n        const headers = {};\n        for (const header of headerLines) {\n          /** @type {!Array.<string>} */\n          const parts = header.split(': ');\n          headers[parts[0].toLowerCase()] = parts.slice(1).join(': ');\n        }\n\n        try {\n          const response = shaka.net.HttpPluginUtils.makeResponse(headers,\n              target.response, target.status, uri, target.responseURL,\n              requestType);\n          resolve(response);\n        } catch (error) {\n          goog.asserts.assert(error instanceof shaka.util.Error,\n              'Wrong error type!');\n          reject(error);\n        }\n      };\n      xhr.onerror = (event) => {\n        reject(new shaka.util.Error(\n            shaka.util.Error.Severity.RECOVERABLE,\n            shaka.util.Error.Category.NETWORK,\n            shaka.util.Error.Code.HTTP_ERROR,\n            uri, event, requestType));\n      };\n      xhr.ontimeout = (event) => {\n        reject(new shaka.util.Error(\n            shaka.util.Error.Severity.RECOVERABLE,\n            shaka.util.Error.Category.NETWORK,\n            shaka.util.Error.Code.TIMEOUT,\n            uri, requestType));\n      };\n      xhr.onprogress = (event) => {\n        const currentTime = Date.now();\n        // If the time between last time and this time we got progress event\n        // is long enough, or if a whole segment is downloaded, call\n        // progressUpdated().\n        if (currentTime - lastTime > 100 ||\n            (event.lengthComputable && event.loaded == event.total)) {\n          progressUpdated(currentTime - lastTime, event.loaded - lastLoaded,\n              event.total - event.loaded);\n          lastLoaded = event.loaded;\n          lastTime = currentTime;\n        }\n      };\n\n      for (const key in request.headers) {\n        // The Fetch API automatically normalizes outgoing header keys to\n        // lowercase. For consistency's sake, do it here too.\n        const lowercasedKey = key.toLowerCase();\n        xhr.setRequestHeader(lowercasedKey, request.headers[key]);\n      }\n      xhr.send(request.body);\n    }));\n\n    return new shaka.util.AbortableOperation(\n        promise,\n        () => {\n          xhr.abort();\n          return Promise.resolve();\n        });\n  }\n};\n\n\n/**\n * Overridden in unit tests, but compiled out in production.\n *\n * @const {function(new: XMLHttpRequest)}\n * @private\n */\nshaka.net.HttpXHRPlugin.Xhr_ = window.XMLHttpRequest;\n\n\nshaka.net.NetworkingEngine.registerScheme(\n    'http', shaka.net.HttpXHRPlugin.parse,\n    shaka.net.NetworkingEngine.PluginPriority.FALLBACK);\nshaka.net.NetworkingEngine.registerScheme(\n    'https', shaka.net.HttpXHRPlugin.parse,\n    shaka.net.NetworkingEngine.PluginPriority.FALLBACK);\n\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.offline.DownloadProgressEstimator');\n\n\n/**\n * The download progress estimator class encapsulates all the logic for tracking\n * how much content has been downloaded and estimating its progress.\n *\n * @final\n */\nshaka.offline.DownloadProgressEstimator = class {\n  constructor() {\n    /**\n     * This is the sum of all estimates passed to |open|. This is used as the\n     * denominator when measuring progress.\n     *\n     * @private {number}\n     */\n    this.estimatedTotal_ = 0;\n\n    /**\n     * This is the sum of all estimates pass to |open| but only after |close|\n     * has been called. This is used as the numerator when measuring progress so\n     * that |estimatedTotal_ == estimatedDownloaded_| after everything is\n     * downloaded.\n     *\n     * @private {number}\n     */\n    this.estimatedDownloaded_ = 0;\n\n    /**\n     * This is the total number of bytes actually downloaded. This will most\n     * likely differ from |estimatedTotal_| after everything is downloaded since\n     * our estimates will be off.\n     *\n     * @private {number}\n     */\n    this.actualDownloaded_ = 0;\n\n    /**\n     * This is a map of all pending downloads. This maps their download id (an\n     * internal id) to the estimate. This will allow us to update\n     * |estimatedDownloaded_| when |close| is called.\n     *\n     * @private {!Map.<number, number>}\n     */\n    this.pending_ = new Map();\n\n    /**\n     * This number is used to provide unique (to estimator) ids for each\n     * download. This allows us to track each download in |pending_|.\n     *\n     * @private {number}\n     */\n    this.nextId_ = 0;\n  }\n\n  /**\n   * Open a new download in the progress estimator. This will create an entry so\n   * that we can track the download progress.\n   *\n   * This will return an id for the download. This id must be passed to |close|\n   * in order for the |close| to be paired with this call to |open|.\n   *\n   * @param {number} estimate\n   * @return {number}\n   */\n  open(estimate) {\n    this.estimatedTotal_ += estimate;\n\n    const id = this.nextId_;\n    this.nextId_++;\n\n    this.pending_.set(id, estimate);\n    return id;\n  }\n\n  /**\n   * Close a download in the estimator. This will signal that we have finished\n   * downloading a segment and we can update the progress estimate.\n   *\n   * @param {number} id\n   * @param {number} actual\n   */\n  close(id, actual) {\n    if (!this.pending_.has(id)) {\n      return;\n    }\n\n    const estimate = this.pending_.get(id);\n    this.pending_.delete(id);\n\n    this.estimatedDownloaded_ += estimate;\n    this.actualDownloaded_ += actual;\n  }\n\n  /**\n   * Get the current estimate for how much progress we've made downloading the\n   * content. Progress will be between 0 and 1.\n   *\n   * Depending on the order of calls to |open| and |close|,\n   * |getEstimatedProgress| will fluctuate and is not guaranteed to always be\n   * increasing.\n   *\n   * @return {number}\n   */\n  getEstimatedProgress() {\n    return this.estimatedTotal_ == 0 ?\n           0 :\n           this.estimatedDownloaded_ / this.estimatedTotal_;\n  }\n\n  /**\n   * Get the total number of bytes that were actually downloaded.\n   *\n   * @return {number}\n   */\n  getTotalDownloaded() {\n    return this.actualDownloaded_;\n  }\n};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.offline.DownloadManager');\n\ngoog.require('shaka.net.NetworkingEngine');\ngoog.require('shaka.offline.DownloadProgressEstimator');\ngoog.require('shaka.util.ArrayUtils');\ngoog.require('shaka.util.BufferUtils');\ngoog.require('shaka.util.Destroyer');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.IDestroyable');\ngoog.require('shaka.util.Pssh');\n\n\n/**\n * This manages downloading segments.\n *\n * @implements {shaka.util.IDestroyable}\n * @final\n */\nshaka.offline.DownloadManager = class {\n  /**\n   * Create a new download manager. It will use (but not own) |networkingEngine|\n   * and call |onProgress| after each download.\n   *\n   * @param {!shaka.net.NetworkingEngine} networkingEngine\n   */\n  constructor(networkingEngine) {\n    /** @private {shaka.net.NetworkingEngine} */\n    this.networkingEngine_ = networkingEngine;\n\n    /**\n     * We group downloads. Within each group, the requests are executed in\n     * series. Between groups, the requests are executed in parallel. We store\n     * the promise chain that is doing the work.\n     *\n     * @private {!Map.<number, !Promise>}\n     */\n    this.groups_ = new Map();\n\n    /** @private {!shaka.util.Destroyer} */\n    this.destroyer_ = new shaka.util.Destroyer(() => {\n      const promises = Array.from(this.groups_.values());\n      // Add a \"catch\" block to stop errors from being returned.\n      return Promise.all(promises.map((p) => p.catch(() => {})));\n    });\n\n    /**\n     * A list of callback functions to cancel any in-progress downloads.\n     *\n     * @private {!Array.<function():!Promise>}\n     */\n    this.abortCallbacks_ = [];\n\n    /**\n     * A callback for when a segment has been downloaded. The first parameter\n     * is the progress of all segments, a number between 0.0 (0% complete) and\n     * 1.0 (100% complete). The second parameter is the total number of bytes\n     * that have been downloaded.\n     *\n     * @private {function(number, number)}\n     */\n    this.onProgress_ = (progress, size) => {};\n\n    /**\n     * A callback for when a segment has new PSSH data and we pass\n     * on the initData to storage\n     *\n     * @private {function(!Uint8Array, string)}\n     */\n    this.onInitData_ = (initData, systemId) => {};\n\n    /** @private {shaka.offline.DownloadProgressEstimator} */\n    this.estimator_ = new shaka.offline.DownloadProgressEstimator();\n  }\n\n  /** @override */\n  destroy() {\n    return this.destroyer_.destroy();\n  }\n\n  /**\n   * @param {function(number, number)} onProgress\n   * @param {function(!Uint8Array, string)} onInitData\n   */\n  setCallbacks(onProgress, onInitData) {\n    this.onProgress_ = onProgress;\n    this.onInitData_ = onInitData;\n  }\n\n  /**\n   * Aborts all in-progress downloads.\n   * @return {!Promise} A promise that will resolve once the downloads are fully\n   *   aborted.\n   */\n  abortAll() {\n    const promises = this.abortCallbacks_.map((callback) => callback());\n    this.abortCallbacks_ = [];\n    return Promise.all(promises);\n  }\n\n  /**\n   * Add a request to be downloaded as part of a group.\n   *\n   * @param {number} groupId\n   *    The group to add this segment to. If the group does not exist, a new\n   *    group will be created.\n   * @param {shaka.extern.Request} request\n   * @param {number} estimatedByteLength\n   * @param {boolean} isInitSegment\n   * @param {function(BufferSource):!Promise} onDownloaded\n   *   The callback for when this request has been downloaded. Downloading for\n   *   |group| will pause until the promise returned by |onDownloaded| resolves.\n   * @return {!Promise} Resolved when this request is complete.\n   */\n  queue(groupId, request, estimatedByteLength, isInitSegment, onDownloaded) {\n    this.destroyer_.ensureNotDestroyed();\n\n    const id = this.estimator_.open(estimatedByteLength);\n\n    const group = this.groups_.get(groupId) || Promise.resolve();\n\n    // Add another download to the group.\n    const newPromise = group.then(async () => {\n      const response = await this.fetchSegment_(request);\n\n      // Make sure we stop downloading if we have been destroyed.\n      if (this.destroyer_.destroyed()) {\n        throw new shaka.util.Error(\n            shaka.util.Error.Severity.CRITICAL,\n            shaka.util.Error.Category.STORAGE,\n            shaka.util.Error.Code.OPERATION_ABORTED);\n      }\n\n      // Update initData\n      if (isInitSegment) {\n        const segmentBytes = shaka.util.BufferUtils.toUint8(response);\n        const pssh = new shaka.util.Pssh(segmentBytes);\n        for (const key in pssh.data) {\n          const index = Number(key);\n          const data = pssh.data[index];\n          const systemId = pssh.systemIds[index];\n          this.onInitData_(data, systemId);\n        }\n      }\n\n      // Update all our internal stats.\n      this.estimator_.close(id, response.byteLength);\n      this.onProgress_(\n          this.estimator_.getEstimatedProgress(),\n          this.estimator_.getTotalDownloaded());\n\n      return onDownloaded(response);\n    });\n\n    this.groups_.set(groupId, newPromise);\n    return newPromise;\n  }\n\n  /**\n   * Add additional async work to the group work queue.\n   *\n   * @param {number} groupId\n   *    The group to add this group to. If the group does not exist, a new\n   *    group will be created.\n   * @param {function():!Promise} callback\n   *   The callback for the async work.  Downloading for this group will be\n   *   blocked until the Promise returned by |callback| resolves.\n   * @return {!Promise} Resolved when this work is complete.\n   */\n  queueWork(groupId, callback) {\n    this.destroyer_.ensureNotDestroyed();\n    const group = this.groups_.get(groupId) || Promise.resolve();\n    const newPromise = group.then(async () => {\n      await callback();\n    });\n    this.groups_.set(groupId, newPromise);\n    return newPromise;\n  }\n\n  /**\n   * Get a promise that will resolve when all currently queued downloads have\n   * finished.\n   *\n   * @return {!Promise.<number>}\n   */\n  async waitToFinish() {\n    await Promise.all(this.groups_.values());\n    return this.estimator_.getTotalDownloaded();\n  }\n\n  /**\n   * Download a segment and return the data in the response.\n   *\n   * @param {shaka.extern.Request} request\n   * @return {!Promise.<BufferSource>}\n   * @private\n   */\n  async fetchSegment_(request) {\n    const type = shaka.net.NetworkingEngine.RequestType.SEGMENT;\n    /** @type {!shaka.net.NetworkingEngine.PendingRequest} */\n    const action = this.networkingEngine_.request(type, request);\n    const abortCallback = () => {\n      return action.abort();\n    };\n    this.abortCallbacks_.push(abortCallback);\n    const response = await action.promise;\n    shaka.util.ArrayUtils.remove(this.abortCallbacks_, abortCallback);\n    return response.data;\n  }\n};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.offline.indexeddb.DBOperation');\n\n\ngoog.require('shaka.util.PublicPromise');\n\n\n/**\n * A DBOperation wraps an IndexedDB transaction in a promise.\n */\nshaka.offline.indexeddb.DBOperation = class {\n  /**\n   * @param {IDBTransaction} transaction\n   * @param {string} storeName\n   */\n  constructor(transaction, storeName) {\n    /** @private {IDBTransaction} */\n    this.transaction_ = transaction;\n    /** @private {IDBObjectStore} */\n    this.store_ = transaction.objectStore(storeName);\n    /** @private {!shaka.util.PublicPromise} */\n    this.promise_ = new shaka.util.PublicPromise();\n\n    // Connect the transaction and the promise together.\n    // |event.preventDefault()| is used on all non-successful callbacks to\n    // prevent Firefox from surfacing the error on the main thread.\n    transaction.onabort = (event) => {\n      event.preventDefault();\n      this.promise_.reject();\n    };\n    transaction.onerror = (event) => {\n      event.preventDefault();\n      this.promise_.reject();\n    };\n    transaction.oncomplete = (event) => {\n      this.promise_.resolve();\n    };\n  }\n\n  /**\n   * @return {!Promise}\n   */\n  async abort() {\n    try {\n      this.transaction_.abort();\n    } catch (e) {\n      // Ignore any exceptions that may be thrown as a result of aborting\n      // the transaction.\n    }\n\n    try {\n      // Wait for the promise to be rejected, but ignore the rejection error.\n      await this.promise_;\n    } catch (e) {}\n  }\n\n  /**\n   * Calls the given callback for each entry in the database.\n   *\n   * @param {function(!IDBKeyType, T, !IDBCursorWithValue=):(Promise|undefined)}\n   *   callback\n   * @return {!Promise}\n   * @template T\n   */\n  forEachEntry(callback) {\n    return new Promise((resolve, reject) => {\n      const req = this.store_.openCursor();\n      req.onerror = reject;\n      req.onsuccess = async (event) => {\n        // When we reach the end of the data that the cursor is iterating over,\n        // |req.result| will be null to signal the end of the iteration.\n        // https://developer.mozilla.org/en-US/docs/Web/API/IDBCursor/continue\n        if (req.result == null) {\n          resolve();\n          return;\n        }\n\n        /** @type {!IDBCursorWithValue} */\n        const cursor = req.result;\n        await callback(cursor.key, cursor.value, cursor);\n        cursor.continue();\n      };\n    });\n  }\n\n  /**\n   * Get the store that the operation can interact with. Requests can be made\n   * on the store. All requests made on the store will complete successfully\n   * before the operation's promise will resolve. If any request fails, the\n   * operation's promise will be rejected.\n   *\n   * @return {IDBObjectStore}\n   */\n  store() { return this.store_; }\n\n  /**\n   * Get the promise that wraps the transaction. This promise will resolve when\n   * all requests on the object store complete successfully and the transaction\n   * completes. If any request fails or the operation is aborted, the promise\n   * will be rejected.\n   *\n   * @return {!Promise}\n   */\n  promise() { return this.promise_; }\n};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.offline.indexeddb.DBConnection');\n\ngoog.require('shaka.offline.indexeddb.DBOperation');\ngoog.require('shaka.util.ArrayUtils');\n\n\n/**\n * DBConnection is used to manage an IndexedDB connection. It can create new\n * operations. If the connection is killed (via |destroy|) all pending\n * operations will be cancelled.\n */\nshaka.offline.indexeddb.DBConnection = class {\n  /**\n   * @param {IDBDatabase} connection A connection to an IndexedDB instance.\n   */\n  constructor(connection) {\n    /** @private {IDBDatabase} */\n    this.connection_ = connection;\n    /** @private {!Array.<shaka.offline.indexeddb.DBOperation>} */\n    this.pending_ = [];\n  }\n\n  /**\n   * @return {!Promise}\n   */\n  destroy() {\n    return Promise.all(this.pending_.map((op) => {\n      return op.abort();\n    }));\n  }\n\n  /**\n   * @param {string} store The name of the store that the operation should\n   *                       occur on.\n   * @return {!shaka.offline.indexeddb.DBOperation}\n   */\n  startReadOnlyOperation(store) {\n    return this.startOperation_(store, 'readonly');\n  }\n\n  /**\n   * @param {string} store The name of the store that the operation should\n   *                       occur on.\n   * @return {!shaka.offline.indexeddb.DBOperation}\n   */\n  startReadWriteOperation(store) {\n    return this.startOperation_(store, 'readwrite');\n  }\n\n  /**\n   * @param {string} store The name of the store that the operation should\n   *                       occur on.\n   * @param {string} type The type of operation being performed on the store.\n   *                      This determines what commands may be performed. This\n   *                      can either be \"readonly\" or \"readwrite\".\n   * @return {!shaka.offline.indexeddb.DBOperation}\n   * @private\n   */\n  startOperation_(store, type) {\n    const transaction = this.connection_.transaction([store], type);\n    const operation =\n        new shaka.offline.indexeddb.DBOperation(transaction, store);\n\n    this.pending_.push(operation);\n\n    // Once the operation is done (regardless of outcome) stop tracking it.\n    operation.promise().then(\n        () => this.stopTracking_(operation),\n        () => this.stopTracking_(operation)\n    );\n\n    return operation;\n  }\n\n  /**\n   * @param {!shaka.offline.indexeddb.DBOperation} operation\n   * @private\n   */\n  stopTracking_(operation) {\n    shaka.util.ArrayUtils.remove(this.pending_, operation);\n  }\n};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.offline.indexeddb.BaseStorageCell');\n\ngoog.require('shaka.offline.indexeddb.DBConnection');\ngoog.require('shaka.util.Error');\ngoog.requireType('shaka.offline.indexeddb.DBOperation');\n\n\n/**\n * indexeddb.StorageCellBase is a base class for all stores that use IndexedDB.\n *\n * @implements {shaka.extern.StorageCell}\n */\nshaka.offline.indexeddb.BaseStorageCell = class {\n  /**\n   * @param {IDBDatabase} connection\n   * @param {string} segmentStore\n   * @param {string} manifestStore\n   */\n  constructor(connection, segmentStore, manifestStore) {\n    /** @protected {!shaka.offline.indexeddb.DBConnection} */\n    this.connection_ = new shaka.offline.indexeddb.DBConnection(connection);\n\n    /** @protected {string} */\n    this.segmentStore_ = segmentStore;\n\n    /** @protected {string} */\n    this.manifestStore_ = manifestStore;\n  }\n\n  /** @override */\n  destroy() {\n    return this.connection_.destroy();\n  }\n\n  /** @override */\n  hasFixedKeySpace() {\n    // By default, all IDB stores are read-only.  The latest one will need to\n    // override this default to be read-write.\n    return true;\n  }\n\n  /** @override */\n  addSegments(segments) {\n    // By default, reject all additions.\n    return this.rejectAdd(this.segmentStore_);\n  }\n\n  /** @override */\n  removeSegments(keys, onRemove) {\n    return this.remove_(this.segmentStore_, keys, onRemove);\n  }\n\n  /** @override */\n  async getSegments(keys) {\n    const rawSegments = await this.get_(this.segmentStore_, keys);\n    return rawSegments.map((s) => this.convertSegmentData(s));\n  }\n\n  /** @override */\n  addManifests(manifests) {\n    // By default, reject all additions.\n    return this.rejectAdd(this.manifestStore_);\n  }\n\n  /** @override */\n  updateManifestExpiration(key, newExpiration) {\n    const op = this.connection_.startReadWriteOperation(this.manifestStore_);\n    const store = op.store();\n    store.get(key).onsuccess = (e) => {\n      const manifest = e.target.result;\n      // If we can't find the value, then there is nothing for us to update.\n      if (manifest) {\n        manifest.expiration = newExpiration;\n        store.put(manifest, key);\n      }\n    };\n\n    return op.promise();\n  }\n\n  /** @override */\n  removeManifests(keys, onRemove) {\n    return this.remove_(this.manifestStore_, keys, onRemove);\n  }\n\n  /** @override */\n  async getManifests(keys) {\n    const rawManifests = await this.get_(this.manifestStore_, keys);\n    return Promise.all(rawManifests.map((m) => this.convertManifest(m)));\n  }\n\n  /** @override */\n  async getAllManifests() {\n    /** @type {!shaka.offline.indexeddb.DBOperation} */\n    const op = this.connection_.startReadOnlyOperation(this.manifestStore_);\n\n    /** @type {!Map.<number, shaka.extern.ManifestDB>} */\n    const values = new Map();\n\n    await op.forEachEntry(async (key, value) => {\n      const manifest = await this.convertManifest(value);\n      values.set(/** @type {number} */(key), manifest);\n    });\n\n    await op.promise();\n    return values;\n  }\n\n  /**\n   * @param {?} old\n   * @return {shaka.extern.SegmentDataDB}\n   * @protected\n   */\n  convertSegmentData(old) {\n    // Conversion is specific to each subclass.  By default, do nothing.\n    return /** @type {shaka.extern.SegmentDataDB} */(old);\n  }\n\n  /**\n   * @param {?} old\n   * @return {!Promise.<shaka.extern.ManifestDB>}\n   * @protected\n   */\n  convertManifest(old) {\n    // Conversion is specific to each subclass.  By default, do nothing.\n    return Promise.resolve(/** @type {shaka.extern.ManifestDB} */(old));\n  }\n\n  /**\n   * @param {string} storeName\n   * @return {!Promise}\n   * @protected\n   */\n  rejectAdd(storeName) {\n    return Promise.reject(new shaka.util.Error(\n        shaka.util.Error.Severity.CRITICAL,\n        shaka.util.Error.Category.STORAGE,\n        shaka.util.Error.Code.NEW_KEY_OPERATION_NOT_SUPPORTED,\n        'Cannot add new value to ' + storeName));\n  }\n\n  /**\n   * @param {string} storeName\n   * @param {!Array.<T>} values\n   * @return {!Promise.<!Array.<number>>}\n   * @template T\n   * @protected\n   */\n  async add(storeName, values) {\n    const op = this.connection_.startReadWriteOperation(storeName);\n    const store = op.store();\n\n    /** @type {!Array.<number>} */\n    const keys = [];\n\n    // Write each segment out. When each request completes, the key will\n    // be in |request.result| as can be seen in\n    // https://w3c.github.io/IndexedDB/#key-generator-construct.\n    for (const value of values) {\n      const request = store.add(value);\n      request.onsuccess = (event) => {\n        const key = request.result;\n        keys.push(key);\n      };\n    }\n\n    // Wait until the operation completes or else |keys| will not be fully\n    // populated.\n    await op.promise();\n    return keys;\n  }\n\n  /**\n   * @param {string} storeName\n   * @param {!Array.<number>} keys\n   * @param {function(number)} onRemove\n   * @return {!Promise}\n   * @private\n   */\n  remove_(storeName, keys, onRemove) {\n    const op = this.connection_.startReadWriteOperation(storeName);\n    const store = op.store();\n\n    for (const key of keys) {\n      store.delete(key).onsuccess = () => onRemove(key);\n    }\n\n    return op.promise();\n  }\n\n  /**\n   * @param {string} storeName\n   * @param {!Array.<number>} keys\n   * @return {!Promise.<!Array.<T>>}\n   * @template T\n   * @private\n   */\n  async get_(storeName, keys) {\n    const op = this.connection_.startReadOnlyOperation(storeName);\n    const store = op.store();\n\n    const values = {};\n    /** @type {!Array.<number>} */\n    const missing = [];\n\n    // Use a map to store the objects so that we can reorder the results to\n    // match the order of |keys|.\n    for (const key of keys) {\n      const request = store.get(key);\n      request.onsuccess = () => {\n        // Make sure a defined value was found. Indexeddb treats no-value found\n        // as a success with an undefined result.\n        if (request.result == undefined) {\n          missing.push(key);\n        }\n\n        values[key] = request.result;\n      };\n    }\n\n    // Wait until the operation completes or else values may be missing from\n    // |values|. Use the original key list to convert the map to a list so that\n    // the order will match.\n    await op.promise();\n    if (missing.length) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.STORAGE,\n          shaka.util.Error.Code.KEY_NOT_FOUND,\n          'Could not find values for ' + missing\n      );\n    }\n\n    return keys.map((key) => values[key]);\n  }\n};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.offline.indexeddb.EmeSessionStorageCell');\n\ngoog.require('shaka.offline.indexeddb.DBConnection');\ngoog.requireType('shaka.offline.indexeddb.DBOperation');\n\n\n/**\n * The implementation of the EME session storage cell.\n *\n * @implements {shaka.extern.EmeSessionStorageCell}\n */\nshaka.offline.indexeddb.EmeSessionStorageCell = class {\n  /**\n   * @param {IDBDatabase} connection\n   * @param {string} store\n   */\n  constructor(connection, store) {\n    /** @private {!shaka.offline.indexeddb.DBConnection} */\n    this.connection_ = new shaka.offline.indexeddb.DBConnection(connection);\n\n    /** @private {string} */\n    this.store_ = store;\n  }\n\n  /** @override */\n  destroy() { return this.connection_.destroy(); }\n\n  /** @override */\n  async getAll() {\n    /** @type {!shaka.offline.indexeddb.DBOperation} */\n    const op = this.connection_.startReadOnlyOperation(this.store_);\n    /** @type {!Array.<shaka.extern.EmeSessionDB>} */\n    const values = [];\n\n    await op.forEachEntry((key, value) => {\n      values.push(value);\n    });\n\n    await op.promise();\n    return values;\n  }\n\n  /** @override */\n  add(sessions) {\n    const op = this.connection_.startReadWriteOperation(this.store_);\n    const store = op.store();\n\n    for (const session of sessions) {\n      store.add(session);\n    }\n\n    return op.promise();\n  }\n\n  /** @override */\n  async remove(sessionIds) {\n    /** @type {!shaka.offline.indexeddb.DBOperation} */\n    const op = this.connection_.startReadWriteOperation(this.store_);\n\n    await op.forEachEntry((key, value, cursor) => {\n      if (sessionIds.includes(value.sessionId)) {\n        cursor.delete();\n      }\n    });\n\n    await op.promise();\n  }\n};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.offline.StorageCellHandle');\ngoog.provide('shaka.offline.StorageCellPath');\ngoog.provide('shaka.offline.StorageMuxer');\n\ngoog.require('shaka.log');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.IDestroyable');\n\n/**\n * @typedef {{\n *  mechanism: string,\n *  cell: string\n * }}\n *\n * @property {string} mechanism\n *  The name of the mechanism that holds the cell.\n * @property {string} cell\n *  The name of the cell in the mechanism.\n */\nshaka.offline.StorageCellPath;\n\n\n/**\n * @typedef {{\n *   path: shaka.offline.StorageCellPath,\n *   cell: !shaka.extern.StorageCell\n * }}\n *\n * @property {shaka.offline.StorageCellPath} path\n *   The path that maps to the cell.\n * @property {shaka.extern.StorageCell} cell\n *   The storage cell that the path points to within the storage muxer.\n */\nshaka.offline.StorageCellHandle;\n\n\n// TODO: revisit this when Closure Compiler supports partially-exported classes.\n/**\n * StorageMuxer is responsible for managing StorageMechanisms and addressing\n * cells. The primary purpose of the muxer is to give the caller the correct\n * cell for the operations they want to perform.\n *\n * |findActive| will be used when the caller wants a cell that supports\n * add-operations. This will be used when saving new content to storage.\n *\n * |findAll| will be used when the caller want to look at all the content\n * in storage.\n *\n * |resolvePath| will be used to convert a path (from |findActive| and\n * |findAll|) into a cell, which it then returns.\n *\n * @implements {shaka.util.IDestroyable}\n * @export\n */\nshaka.offline.StorageMuxer = class {\n  constructor() {\n    /**\n     * A key in this map is the name given when registering a StorageMechanism.\n     *\n     * @private {!Map.<string, !shaka.extern.StorageMechanism>}\n     */\n    this.mechanisms_ = new Map();\n  }\n\n  // TODO: revisit this when the compiler supports partially-exported classes.\n  /**\n   * Free all resources used by the muxer, mechanisms, and cells. This should\n   * not affect the stored content.\n   *\n   * @override\n   * @export\n   */\n  destroy() {\n    /** @type {!Array.<!Promise>} */\n    const destroys = [];\n    for (const mechanism of this.mechanisms_.values()) {\n      destroys.push(mechanism.destroy());\n    }\n\n    // Empty the map so that subsequent calls will be no-ops.\n    this.mechanisms_.clear();\n\n    return Promise.all(destroys);\n  }\n\n  /**\n   * Initialize the storage muxer. This must be called before any other calls.\n   * This will initialize the muxer to use all mechanisms that have been\n   * registered with |StorageMuxer.register|.\n   *\n   * @return {!Promise}\n   */\n  init() {\n    // Add the new instance of each mechanism to the muxer.\n    const registry = shaka.offline.StorageMuxer.getRegistry_();\n    registry.forEach((factory, name) => {\n      const mech = factory();\n      if (mech) {\n        this.mechanisms_.set(name, mech);\n      } else {\n        shaka.log.info(\n            'Skipping ' + name + ' as it is not supported on this platform');\n      }\n    });\n\n    /** @type {!Array.<!Promise>} */\n    const initPromises = [];\n    for (const mechanism of this.mechanisms_.values()) {\n      initPromises.push(mechanism.init());\n    }\n\n    return Promise.all(initPromises);\n  }\n\n  /**\n   * Get a promise that will resolve with a storage cell that supports\n   * add-operations. If no cell can be found, the promise will be rejected.\n   *\n   * @return {shaka.offline.StorageCellHandle}\n   */\n  getActive() {\n    /** @type {?shaka.offline.StorageCellHandle} */\n    let handle = null;\n\n    this.mechanisms_.forEach((mechanism, mechanismName) => {\n      mechanism.getCells().forEach((cell, cellName) => {\n        // If this cell is not useful to us or we already have a handle, then\n        // we don't need to make a new handle.\n        if (cell.hasFixedKeySpace() || handle) {\n          return;\n        }\n\n        const path = {\n          mechanism: mechanismName,\n          cell: cellName,\n        };\n\n        handle = {\n          path: path,\n          cell: cell,\n        };\n      });\n    });\n\n    if (handle) {\n      return /** @type {shaka.offline.StorageCellHandle} */(handle);\n    }\n\n    throw new shaka.util.Error(\n        shaka.util.Error.Severity.CRITICAL,\n        shaka.util.Error.Category.STORAGE,\n        shaka.util.Error.Code.MISSING_STORAGE_CELL,\n        'Could not find a cell that supports add-operations');\n  }\n\n  /**\n   * @param {function(!shaka.offline.StorageCellPath,\n   *                  !shaka.extern.StorageCell)} callback\n   */\n  forEachCell(callback) {\n    this.mechanisms_.forEach((mechanism, mechanismName) => {\n      mechanism.getCells().forEach((cell, cellName) => {\n        const path = {\n          mechanism: mechanismName,\n          cell: cellName,\n        };\n\n        callback(path, cell);\n      });\n    });\n  }\n\n  /**\n   * Get a specific storage cell. The promise will resolve with the storage\n   * cell if it is found. If the storage cell is not found, the promise will\n   * be rejected.\n   *\n   * @param {string} mechanismName\n   * @param {string} cellName\n   * @return {!shaka.extern.StorageCell}\n   */\n  getCell(mechanismName, cellName) {\n    const mechanism = this.mechanisms_.get(mechanismName);\n    if (!mechanism) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.STORAGE,\n          shaka.util.Error.Code.MISSING_STORAGE_CELL,\n          'Could not find mechanism with name ' + mechanismName);\n    }\n\n    const cell = mechanism.getCells().get(cellName);\n    if (!cell) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.STORAGE,\n          shaka.util.Error.Code.MISSING_STORAGE_CELL,\n          'Could not find cell with name ' + cellName);\n    }\n\n    return cell;\n  }\n\n  /**\n   * @param {function(!shaka.extern.EmeSessionStorageCell)} callback\n   */\n  forEachEmeSessionCell(callback) {\n    this.mechanisms_.forEach((mechanism, name) => {\n      callback(mechanism.getEmeSessionCell());\n    });\n  }\n\n  /**\n   * Gets an arbitrary EME session cell that can be used for storing new session\n   * info.\n   *\n   * @return {!shaka.extern.EmeSessionStorageCell}\n   */\n  getEmeSessionCell() {\n    const mechanisms = Array.from(this.mechanisms_.keys());\n    if (!mechanisms.length) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.STORAGE,\n          shaka.util.Error.Code.STORAGE_NOT_SUPPORTED,\n          'No supported storage mechanisms found');\n    }\n\n    return this.mechanisms_.get(mechanisms[0]).getEmeSessionCell();\n  }\n\n  /**\n   * Find the cell that the path points to. A path is made up of a mount point\n   * and a cell id. If a cell can be found, the cell will be returned. If no\n   * cell is found, null will be returned.\n   *\n   * @param {shaka.offline.StorageCellPath} path\n   * @return {shaka.extern.StorageCell}\n   */\n  resolvePath(path) {\n    const mechanism = this.mechanisms_.get(path.mechanism);\n\n    if (!mechanism) {\n      return null;\n    }\n\n    return mechanism.getCells().get(path.cell);\n  }\n\n  /**\n   * This will erase all previous content from storage. Using paths obtained\n   * before calling |erase| is discouraged, as cells may have changed during a\n   * erase.\n   *\n   * @return {!Promise}\n   */\n  async erase() {\n    // If we have initialized, we will use the existing mechanism instances.\n    /** @type {!Array.<!shaka.extern.StorageMechanism>} */\n    const mechanisms = Array.from(this.mechanisms_.values());\n    const alreadyInitialized = mechanisms.length > 0;\n\n    // If we have not initialized, we should still be able to erase.  This is\n    // critical to our ability to wipe the DB in case of a version mismatch.\n    // If there are no instances, create temporary ones and destroy them later.\n    if (!alreadyInitialized) {\n      const registry = shaka.offline.StorageMuxer.getRegistry_();\n      registry.forEach((factory, name) => {\n        const mech = factory();\n        if (mech) {\n          mechanisms.push(mech);\n        }\n      });\n    }\n\n    // Erase all storage mechanisms.\n    await Promise.all(mechanisms.map((m) => m.erase()));\n\n    // If we were erasing temporary instances, destroy them, too.\n    if (!alreadyInitialized) {\n      await Promise.all(mechanisms.map((m) => m.destroy()));\n    }\n  }\n\n  /**\n   * Register a storage mechanism for use with the default storage muxer. This\n   * will have no effect on any storage muxer already in main memory.\n   *\n   * @param {string} name\n   * @param {function():shaka.extern.StorageMechanism} factory\n   * @export\n   */\n  static register(name, factory) {\n    shaka.offline.StorageMuxer.registry_.set(name, factory);\n  }\n\n\n  /**\n   * Unregister a storage mechanism for use with the default storage muxer. This\n   * will have no effect on any storage muxer already in main memory.\n   *\n   * @param {string} name The name that the storage mechanism was registered\n   *                      under.\n   * @export\n   */\n  static unregister(name) {\n    shaka.offline.StorageMuxer.registry_.delete(name);\n  }\n\n  /**\n   * Check if there is support for storage on this platform. It is assumed that\n   * if there are any mechanisms registered, it means that storage is supported\n   * on this platform. We do not check if the mechanisms have any cells.\n   *\n   * @return {boolean}\n   */\n  static support() {\n    const registry = shaka.offline.StorageMuxer.getRegistry_();\n    // Make sure that we will have SOME mechanisms created by creating a\n    // mechanism and immediately destroying it.\n    for (const create of registry.values()) {\n      const instance = create();\n\n      if (instance) {\n        instance.destroy();\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * Replace the mechanism map used by the muxer. This should only be used\n   * in testing.\n   *\n   * @param {Map.<string, function():shaka.extern.StorageMechanism>} map\n   */\n  static overrideSupport(map) {\n    shaka.offline.StorageMuxer.override_ = map;\n  }\n\n  /**\n   * Undo a previous call to |overrideSupport|.\n   */\n  static clearOverride() {\n    shaka.offline.StorageMuxer.override_ = null;\n  }\n\n  /**\n   * Get the registry. If the support has been disabled, this will always\n   * an empty registry. Reading should always be done via |getRegistry_|.\n   *\n   * @return {!Map.<string, function():shaka.extern.StorageMechanism>}\n   * @private\n   */\n  static getRegistry_() {\n    const override = shaka.offline.StorageMuxer.override_;\n    const registry = shaka.offline.StorageMuxer.registry_;\n\n    if (COMPILED) {\n      return registry;\n    } else {\n      return override || registry;\n    }\n  }\n};\n\n\n/**\n * @private {Map.<string, function():shaka.extern.StorageMechanism>}\n */\nshaka.offline.StorageMuxer.override_ = null;\n\n\n/**\n * @private {!Map.<string, function():shaka.extern.StorageMechanism>}\n */\nshaka.offline.StorageMuxer.registry_ = new Map();\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.offline.indexeddb.StorageMechanism');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.offline.StorageMuxer');\ngoog.require('shaka.offline.indexeddb.EmeSessionStorageCell');\ngoog.require('shaka.offline.indexeddb.V1StorageCell');\ngoog.require('shaka.offline.indexeddb.V2StorageCell');\ngoog.require('shaka.offline.indexeddb.V5StorageCell');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.PublicPromise');\ngoog.require('shaka.util.Platform');\n\n\n/**\n * A storage mechanism to manage storage cells for an indexed db instance.\n * The cells are just for interacting with the stores that are found in the\n * database instance. The mechanism is responsible for creating new stores\n * when opening the database. If the database is too old of a version, a\n * cell will be added for the old stores but the cell won't support add\n * operations. The mechanism will create the new versions of the stores and\n * will allow add operations for those stores.\n *\n * @implements {shaka.extern.StorageMechanism}\n */\nshaka.offline.indexeddb.StorageMechanism = class {\n  constructor() {\n    /** @private {IDBDatabase} */\n    this.db_ = null;\n\n    /** @private {shaka.extern.StorageCell} */\n    this.v1_ = null;\n    /** @private {shaka.extern.StorageCell} */\n    this.v2_ = null;\n    /** @private {shaka.extern.StorageCell} */\n    this.v3_ = null;\n    /** @private {shaka.extern.StorageCell} */\n    this.v5_ = null;\n    /** @private {shaka.extern.EmeSessionStorageCell} */\n    this.sessions_ = null;\n  }\n\n  /**\n   * @override\n   */\n  init() {\n    const name = shaka.offline.indexeddb.StorageMechanism.DB_NAME;\n    const version = shaka.offline.indexeddb.StorageMechanism.VERSION;\n\n    const p = new shaka.util.PublicPromise();\n    const open = window.indexedDB.open(name, version);\n    open.onsuccess = (event) => {\n      const db = open.result;\n      this.db_ = db;\n      this.v1_ = shaka.offline.indexeddb.StorageMechanism.createV1_(db);\n      this.v2_ = shaka.offline.indexeddb.StorageMechanism.createV2_(db);\n      this.v3_ = shaka.offline.indexeddb.StorageMechanism.createV3_(db);\n      // NOTE: V4 of the database was when we introduced a special table to\n      // store EME session IDs.  It has no separate storage cell, so we skip to\n      // V5.\n      this.v5_ = shaka.offline.indexeddb.StorageMechanism.createV5_(db);\n      this.sessions_ =\n          shaka.offline.indexeddb.StorageMechanism.createEmeSessionCell_(db);\n      p.resolve();\n    };\n    open.onupgradeneeded = (event) => {\n      // Add object stores for the latest version only.\n      this.createStores_(open.result);\n    };\n    open.onerror = (event) => {\n      p.reject(new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.STORAGE,\n          shaka.util.Error.Code.INDEXED_DB_ERROR,\n          open.error));\n\n      // Firefox will raise an error on the main thread unless we stop it here.\n      event.preventDefault();\n    };\n\n    return p;\n  }\n\n  /**\n   * @override\n   */\n  async destroy() {\n    if (this.v1_) {\n      await this.v1_.destroy();\n    }\n    if (this.v2_) {\n      await this.v2_.destroy();\n    }\n    if (this.v3_) {\n      await this.v3_.destroy();\n    }\n    if (this.v5_) {\n      await this.v5_.destroy();\n    }\n    if (this.sessions_) {\n      await this.sessions_.destroy();\n    }\n\n    // If we were never initialized, then |db_| will still be null.\n    if (this.db_) {\n      this.db_.close();\n    }\n  }\n\n  /**\n   * @override\n   */\n  getCells() {\n    const map = new Map();\n\n    if (this.v1_) {\n      map.set('v1', this.v1_);\n    }\n    if (this.v2_) {\n      map.set('v2', this.v2_);\n    }\n    if (this.v3_) {\n      map.set('v3', this.v3_);\n    }\n    if (this.v5_) {\n      map.set('v5', this.v5_);\n    }\n\n    return map;\n  }\n\n  /**\n   * @override\n   */\n  getEmeSessionCell() {\n    goog.asserts.assert(this.sessions_, 'Cannot be destroyed.');\n    return this.sessions_;\n  }\n\n  /**\n   * @override\n   */\n  async erase() {\n    // Not all cells may have been created, so only destroy the ones that\n    // were created.\n    if (this.v1_) {\n      await this.v1_.destroy();\n    }\n    if (this.v2_) {\n      await this.v2_.destroy();\n    }\n    if (this.v3_) {\n      await this.v3_.destroy();\n    }\n    if (this.v5_) {\n      await this.v5_.destroy();\n    }\n\n    // |db_| will only be null if the muxer was not initialized. We need to\n    // close the connection in order delete the database without it being\n    // blocked.\n    if (this.db_) {\n      this.db_.close();\n    }\n\n    await shaka.offline.indexeddb.StorageMechanism.deleteAll_();\n\n    // Reset before initializing.\n    this.db_ = null;\n    this.v1_ = null;\n    this.v2_ = null;\n    this.v3_ = null;\n    this.v5_ = null;\n\n    await this.init();\n  }\n\n  /**\n   * @param {!IDBDatabase} db\n   * @return {shaka.extern.StorageCell}\n   * @private\n   */\n  static createV1_(db) {\n    const StorageMechanism = shaka.offline.indexeddb.StorageMechanism;\n    const segmentStore = StorageMechanism.V1_SEGMENT_STORE;\n    const manifestStore = StorageMechanism.V1_MANIFEST_STORE;\n    const stores = db.objectStoreNames;\n    if (stores.contains(manifestStore) && stores.contains(segmentStore)) {\n      shaka.log.debug('Mounting v1 idb storage cell');\n\n      return new shaka.offline.indexeddb.V1StorageCell(\n          db,\n          segmentStore,\n          manifestStore);\n    }\n    return null;\n  }\n\n  /**\n   * @param {!IDBDatabase} db\n   * @return {shaka.extern.StorageCell}\n   * @private\n   */\n  static createV2_(db) {\n    const StorageMechanism = shaka.offline.indexeddb.StorageMechanism;\n    const segmentStore = StorageMechanism.V2_SEGMENT_STORE;\n    const manifestStore = StorageMechanism.V2_MANIFEST_STORE;\n    const stores = db.objectStoreNames;\n    if (stores.contains(manifestStore) && stores.contains(segmentStore)) {\n      shaka.log.debug('Mounting v2 idb storage cell');\n\n      return new shaka.offline.indexeddb.V2StorageCell(\n          db,\n          segmentStore,\n          manifestStore);\n    }\n    return null;\n  }\n\n  /**\n   * @param {!IDBDatabase} db\n   * @return {shaka.extern.StorageCell}\n   * @private\n   */\n  static createV3_(db) {\n    const StorageMechanism = shaka.offline.indexeddb.StorageMechanism;\n    const segmentStore = StorageMechanism.V3_SEGMENT_STORE;\n    const manifestStore = StorageMechanism.V3_MANIFEST_STORE;\n    const stores = db.objectStoreNames;\n    if (stores.contains(manifestStore) && stores.contains(segmentStore)) {\n      shaka.log.debug('Mounting v3 idb storage cell');\n\n      // Version 3 uses the same structure as version 2, so we can use the same\n      // cells but it can support new entries.\n      return new shaka.offline.indexeddb.V2StorageCell(\n          db,\n          segmentStore,\n          manifestStore);\n    }\n    return null;\n  }\n\n  /**\n   * @param {!IDBDatabase} db\n   * @return {shaka.extern.StorageCell}\n   * @private\n   */\n  static createV5_(db) {\n    const StorageMechanism = shaka.offline.indexeddb.StorageMechanism;\n    const segmentStore = StorageMechanism.V5_SEGMENT_STORE;\n    const manifestStore = StorageMechanism.V5_MANIFEST_STORE;\n    const stores = db.objectStoreNames;\n    if (stores.contains(manifestStore) && stores.contains(segmentStore)) {\n      shaka.log.debug('Mounting v5 idb storage cell');\n\n      return new shaka.offline.indexeddb.V5StorageCell(\n          db,\n          segmentStore,\n          manifestStore);\n    }\n    return null;\n  }\n\n  /**\n   * @param {!IDBDatabase} db\n   * @return {shaka.extern.EmeSessionStorageCell}\n   * @private\n   */\n  static createEmeSessionCell_(db) {\n    const StorageMechanism = shaka.offline.indexeddb.StorageMechanism;\n    const store = StorageMechanism.SESSION_ID_STORE;\n    if (db.objectStoreNames.contains(store)) {\n      shaka.log.debug('Mounting session ID idb storage cell');\n      return new shaka.offline.indexeddb.EmeSessionStorageCell(db, store);\n    }\n    return null;\n  }\n\n  /**\n   * @param {!IDBDatabase} db\n   * @private\n   */\n  createStores_(db) {\n    const storeNames = [\n      shaka.offline.indexeddb.StorageMechanism.V5_SEGMENT_STORE,\n      shaka.offline.indexeddb.StorageMechanism.V5_MANIFEST_STORE,\n      shaka.offline.indexeddb.StorageMechanism.SESSION_ID_STORE,\n    ];\n\n    for (const name of storeNames) {\n      if (!db.objectStoreNames.contains(name)) {\n        db.createObjectStore(name, {autoIncrement: true});\n      }\n    }\n  }\n\n  /**\n   * Delete the indexed db instance so that all stores are deleted and cleared.\n   * This will force the database to a like-new state next time it opens.\n   *\n   * @return {!Promise}\n   * @private\n   */\n  static deleteAll_() {\n    const name = shaka.offline.indexeddb.StorageMechanism.DB_NAME;\n\n    const p = new shaka.util.PublicPromise();\n\n    const del = window.indexedDB.deleteDatabase(name);\n    del.onblocked = (event) => {\n      shaka.log.warning('Deleting', name, 'is being blocked');\n    };\n    del.onsuccess = (event) => {\n      p.resolve();\n    };\n    del.onerror = (event) => {\n      p.reject(new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.STORAGE,\n          shaka.util.Error.Code.INDEXED_DB_ERROR,\n          del.error));\n\n      // Firefox will raise an error on the main thread unless we stop it here.\n      event.preventDefault();\n    };\n\n    return p;\n  }\n};\n\n/** @const {string} */\nshaka.offline.indexeddb.StorageMechanism.DB_NAME = 'shaka_offline_db';\n/** @const {number} */\nshaka.offline.indexeddb.StorageMechanism.VERSION = 5;\n/** @const {string} */\nshaka.offline.indexeddb.StorageMechanism.V1_SEGMENT_STORE = 'segment';\n/** @const {string} */\nshaka.offline.indexeddb.StorageMechanism.V2_SEGMENT_STORE = 'segment-v2';\n/** @const {string} */\nshaka.offline.indexeddb.StorageMechanism.V3_SEGMENT_STORE = 'segment-v3';\n/** @const {string} */\nshaka.offline.indexeddb.StorageMechanism.V5_SEGMENT_STORE = 'segment-v5';\n/** @const {string} */\nshaka.offline.indexeddb.StorageMechanism.V1_MANIFEST_STORE = 'manifest';\n/** @const {string} */\nshaka.offline.indexeddb.StorageMechanism.V2_MANIFEST_STORE = 'manifest-v2';\n/** @const {string} */\nshaka.offline.indexeddb.StorageMechanism.V3_MANIFEST_STORE = 'manifest-v3';\n/** @const {string} */\nshaka.offline.indexeddb.StorageMechanism.V5_MANIFEST_STORE = 'manifest-v5';\n/** @const {string} */\nshaka.offline.indexeddb.StorageMechanism.SESSION_ID_STORE = 'session-ids';\n\n\n// Since this may be called before the polyfills remove indexeddb support from\n// some platforms (looking at you Chromecast), we need to check for support\n// when we create the mechanism.\n//\n// Thankfully the storage muxer api allows us to return a null mechanism\n// to indicate that the mechanism is not supported on this platform.\nshaka.offline.StorageMuxer.register(\n    'idb',\n    () => {\n      // Offline storage is not supported on the Chromecast platform.\n      if (shaka.util.Platform.isChromecast()) {\n        return null;\n      }\n      // Offline storage requires the IndexedDB API.\n      if (!window.indexedDB) {\n        return null;\n      }\n      return new shaka.offline.indexeddb.StorageMechanism();\n    });\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.offline.indexeddb.V1StorageCell');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.offline.indexeddb.BaseStorageCell');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.ManifestParserUtils');\ngoog.require('shaka.util.PeriodCombiner');\ngoog.require('shaka.util.PublicPromise');\n\n\n/**\n * The V1StorageCell is for all stores that follow the shaka.externs V1 offline\n * types, introduced in Shaka Player v2.0 and deprecated in v2.3.\n *\n * @implements {shaka.extern.StorageCell}\n */\nshaka.offline.indexeddb.V1StorageCell = class\n  extends shaka.offline.indexeddb.BaseStorageCell {\n  /** @override */\n  async updateManifestExpiration(key, newExpiration) {\n    const op = this.connection_.startReadWriteOperation(this.manifestStore_);\n\n    /** @type {IDBObjectStore} */\n    const store = op.store();\n\n    /** @type {!shaka.util.PublicPromise} */\n    const p = new shaka.util.PublicPromise();\n\n    store.get(key).onsuccess = (event) => {\n      // Make sure a defined value was found. Indexeddb treats \"no value found\"\n      // as a success with an undefined result.\n      const manifest = /** @type {shaka.extern.ManifestDBV1} */(\n        event.target.result);\n\n      // Indexeddb does not fail when you get a value that is not in the\n      // database. It will return an undefined value. However, we expect\n      // the value to never be null, so something is wrong if we get a\n      // falsey value.\n      if (manifest) {\n        // Since this store's scheme uses in-line keys, we don't specify the key\n        // with |put|.  This difference is why we must override the base class.\n        goog.asserts.assert(\n            manifest.key == key,\n            'With in-line keys, the keys should match');\n\n        manifest.expiration = newExpiration;\n        store.put(manifest);\n\n        p.resolve();\n      } else {\n        p.reject(new shaka.util.Error(\n            shaka.util.Error.Severity.CRITICAL,\n            shaka.util.Error.Category.STORAGE,\n            shaka.util.Error.Code.KEY_NOT_FOUND,\n            'Could not find values for ' + key));\n      }\n    };\n\n    await Promise.all([op.promise(), p]);\n  }\n\n  /**\n   * @override\n   * @param {shaka.extern.ManifestDBV1} old\n   * @return {!Promise.<shaka.extern.ManifestDB>}\n   */\n  async convertManifest(old) {\n    const V1StorageCell = shaka.offline.indexeddb.V1StorageCell;\n\n    const streamsPerPeriod = [];\n\n    for (let i = 0; i < old.periods.length; ++i) {\n      // The last period ends at the end of the presentation.\n      const periodEnd = i == old.periods.length - 1 ?\n          old.duration : old.periods[i + 1].startTime;\n      const duration = periodEnd - old.periods[i].startTime;\n      const streams = V1StorageCell.convertPeriod_(old.periods[i], duration);\n\n      streamsPerPeriod.push(streams);\n    }\n\n    const streams = await shaka.util.PeriodCombiner.combineDbStreams(\n        streamsPerPeriod);\n\n    return {\n      creationTime: 0,\n      originalManifestUri: old.originalManifestUri,\n      duration: old.duration,\n      size: old.size,\n      expiration: old.expiration == null ? Infinity : old.expiration,\n      streams,\n      sessionIds: old.sessionIds,\n      drmInfo: old.drmInfo,\n      appMetadata: old.appMetadata,\n    };\n  }\n\n  /**\n   * @param {shaka.extern.PeriodDBV1} old\n   * @param {number} periodDuration\n   * @return {!Array.<shaka.extern.StreamDB>}\n   * @private\n   */\n  static convertPeriod_(old, periodDuration) {\n    const V1StorageCell = shaka.offline.indexeddb.V1StorageCell;\n\n    // In the case that this is really old (like really old, like dinosaurs\n    // roaming the Earth old) there may be no variants, so we need to add those.\n    V1StorageCell.fillMissingVariants_(old);\n\n    for (const stream of old.streams) {\n      const message = 'After filling in missing variants, ' +\n                      'each stream should have variant ids';\n      goog.asserts.assert(stream.variantIds, message);\n    }\n\n    return old.streams.map((stream) => V1StorageCell.convertStream_(\n        stream, old.startTime, periodDuration));\n  }\n\n  /**\n   * @param {shaka.extern.StreamDBV1} old\n   * @param {number} periodStart\n   * @param {number} periodDuration\n   * @return {shaka.extern.StreamDB}\n   * @private\n   */\n  static convertStream_(old, periodStart, periodDuration) {\n    const V1StorageCell = shaka.offline.indexeddb.V1StorageCell;\n\n    const initSegmentKey = old.initSegmentUri ?\n        V1StorageCell.getKeyFromSegmentUri_(old.initSegmentUri) : null;\n\n    // timestampOffset in the new format is the inverse of\n    // presentationTimeOffset in the old format.  Also, PTO did not include the\n    // period start, while TO does.\n    const timestampOffset = periodStart + old.presentationTimeOffset;\n\n    const appendWindowStart = periodStart;\n    const appendWindowEnd = periodStart + periodDuration;\n\n    return {\n      id: old.id,\n      originalId: null,\n      primary: old.primary,\n      type: old.contentType,\n      mimeType: old.mimeType,\n      codecs: old.codecs,\n      frameRate: old.frameRate,\n      pixelAspectRatio: undefined,\n      kind: old.kind,\n      language: old.language,\n      label: old.label,\n      width: old.width,\n      height: old.height,\n      initSegmentKey: initSegmentKey,\n      encrypted: old.encrypted,\n      keyIds: new Set([old.keyId]),\n      segments: old.segments.map((segment) => V1StorageCell.convertSegment_(\n          segment, initSegmentKey, appendWindowStart, appendWindowEnd,\n          timestampOffset)),\n      variantIds: old.variantIds,\n      roles: [],\n      audioSamplingRate: null,\n      channelsCount: null,\n      closedCaptions: null,\n    };\n  }\n\n  /**\n   * @param {shaka.extern.SegmentDBV1} old\n   * @param {?number} initSegmentKey\n   * @param {number} appendWindowStart\n   * @param {number} appendWindowEnd\n   * @param {number} timestampOffset\n   * @return {shaka.extern.SegmentDB}\n   * @private\n   */\n  static convertSegment_(\n      old, initSegmentKey, appendWindowStart, appendWindowEnd,\n      timestampOffset) {\n    const V1StorageCell = shaka.offline.indexeddb.V1StorageCell;\n\n    // Since we don't want to use the uri anymore, we need to parse the key\n    // from it.\n    const dataKey = V1StorageCell.getKeyFromSegmentUri_(old.uri);\n\n    return {\n      startTime: appendWindowStart + old.startTime,\n      endTime: appendWindowStart + old.endTime,\n      dataKey,\n      initSegmentKey,\n      appendWindowStart,\n      appendWindowEnd,\n      timestampOffset,\n    };\n  }\n\n  /**\n   * @override\n   * @param {shaka.extern.SegmentDataDBV1} old\n   * @return {shaka.extern.SegmentDataDB}\n   */\n  convertSegmentData(old) {\n    return {data: old.data};\n  }\n\n  /**\n   * @param {string} uri\n   * @return {number}\n   * @private\n   */\n  static getKeyFromSegmentUri_(uri) {\n    let parts = null;\n\n    // Try parsing the uri as the original Shaka Player 2.0 uri.\n    parts = /^offline:[0-9]+\\/[0-9]+\\/([0-9]+)$/.exec(uri);\n    if (parts) {\n      return Number(parts[1]);\n    }\n\n    // Just before Shaka Player 2.3 the uri format was changed to remove some\n    // of the un-used information from the uri and make the segment uri and\n    // manifest uri follow a similar format. However the old storage system\n    // was still in place, so it is possible for Storage V1 Cells to have\n    // Storage V2 uris.\n    parts = /^offline:segment\\/([0-9]+)$/.exec(uri);\n    if (parts) {\n      return Number(parts[1]);\n    }\n\n    throw new shaka.util.Error(\n        shaka.util.Error.Severity.CRITICAL,\n        shaka.util.Error.Category.STORAGE,\n        shaka.util.Error.Code.MALFORMED_OFFLINE_URI,\n        'Could not parse uri ' + uri);\n  }\n\n  /**\n   * Take a period and check if the streams need to have variants generated.\n   * Before Shaka Player moved to its variants model, there were no variants.\n   * This will fill missing variants into the given object.\n   *\n   * @param {shaka.extern.PeriodDBV1} period\n   * @private\n   */\n  static fillMissingVariants_(period) {\n    const AUDIO = shaka.util.ManifestParserUtils.ContentType.AUDIO;\n    const VIDEO = shaka.util.ManifestParserUtils.ContentType.VIDEO;\n\n    // There are three cases:\n    //  1. All streams' variant ids are null\n    //  2. All streams' variant ids are non-null\n    //  3. Some streams' variant ids are null and other are non-null\n    // Case 3 is invalid and should never happen in production.\n\n    const audio = period.streams.filter((s) => s.contentType == AUDIO);\n    const video = period.streams.filter((s) => s.contentType == VIDEO);\n\n    // Case 2 - There is nothing we need to do, so let's just get out of here.\n    if (audio.every((s) => s.variantIds) && video.every((s) => s.variantIds)) {\n      return;\n    }\n\n    // Case 3... We don't want to be in case three.\n    goog.asserts.assert(\n        audio.every((s) => !s.variantIds),\n        'Some audio streams have variant ids and some do not.');\n    goog.asserts.assert(\n        video.every((s) => !s.variantIds),\n        'Some video streams have variant ids and some do not.');\n\n    // Case 1 - Populate all the variant ids (putting us back to case 2).\n    // Since all the variant ids are null, we need to first make them into\n    // valid arrays.\n    for (const s of audio) {\n      s.variantIds = [];\n    }\n    for (const s of video) {\n      s.variantIds = [];\n    }\n\n    let nextId = 0;\n\n    // It is not possible in Shaka Player's pre-variant world to have audio-only\n    // and video-only content mixed in with audio-video content. So we can\n    // assume that there is only audio-only or video-only if one group is empty.\n\n    // Everything is video-only content - so each video stream gets to be its\n    // own variant.\n    if (video.length && !audio.length) {\n      shaka.log.debug('Found video-only content. Creating variants for video.');\n      const variantId = nextId++;\n      for (const s of video) {\n        s.variantIds.push(variantId);\n      }\n    }\n\n    // Everything is audio-only content - so each audio stream gets to be its\n    // own variant.\n    if (!video.length && audio.length) {\n      shaka.log.debug('Found audio-only content. Creating variants for audio.');\n      const variantId = nextId++;\n      for (const s of audio) {\n        s.variantIds.push(variantId);\n      }\n    }\n\n    // Everything is audio-video content.\n    if (video.length && audio.length) {\n      shaka.log.debug('Found audio-video content. Creating variants.');\n      for (const a of audio) {\n        for (const v of video) {\n          const variantId = nextId++;\n          a.variantIds.push(variantId);\n          v.variantIds.push(variantId);\n        }\n      }\n    }\n  }\n};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.offline.indexeddb.V2StorageCell');\n\ngoog.require('shaka.offline.indexeddb.BaseStorageCell');\ngoog.require('shaka.util.PeriodCombiner');\n\n\n/**\n * The V2StorageCell is for all stores that follow the shaka.externs V2 and V3\n * offline types.  V2 was introduced in Shaka Player v2.3.0 and quickly\n * replaced with V3 in Shaka Player v2.3.2.  V3 was then deprecated in v3.0.\n *\n * Upgrading from V1 to V2 initially broke the database in a way that prevented\n * adding new records.  The problem was with the upgrade process, not with the\n * database format.  Once database upgrades were removed, we increased the\n * database version to V3 and marked V2 as read-only.  Therefore, V2 and V3\n * databases can both be read by this cell.\n *\n * The manifest and segment stores didn't change in database V4, but a separate\n * table for session IDs was added.  So this cell also covers DB V4.\n *\n * @implements {shaka.extern.StorageCell}\n */\nshaka.offline.indexeddb.V2StorageCell = class\n  extends shaka.offline.indexeddb.BaseStorageCell {\n  /**\n   * @override\n   * @param {shaka.extern.ManifestDBV2} old\n   * @return {!Promise.<shaka.extern.ManifestDB>}\n   */\n  async convertManifest(old) {\n    const streamsPerPeriod = [];\n\n    for (let i = 0; i < old.periods.length; ++i) {\n      // The last period ends at the end of the presentation.\n      const periodEnd = i == old.periods.length - 1 ?\n          old.duration : old.periods[i + 1].startTime;\n      const duration = periodEnd - old.periods[i].startTime;\n      const streams = this.convertPeriod_(old.periods[i], duration);\n\n      streamsPerPeriod.push(streams);\n    }\n\n    const streams = await shaka.util.PeriodCombiner.combineDbStreams(\n        streamsPerPeriod);\n\n    return {\n      appMetadata: old.appMetadata,\n      creationTime: 0,\n      drmInfo: old.drmInfo,\n      duration: old.duration,\n      // JSON serialization turns Infinity into null, so turn it back now.\n      expiration: old.expiration == null ? Infinity : old.expiration,\n      originalManifestUri: old.originalManifestUri,\n      sessionIds: old.sessionIds,\n      size: old.size,\n      streams,\n    };\n  }\n\n  /**\n   * @param {shaka.extern.PeriodDBV2} period\n   * @param {number} periodDuration\n   * @return {!Array.<shaka.extern.StreamDB>}\n   * @private\n   */\n  convertPeriod_(period, periodDuration) {\n    const streams = [];\n    for (const stream of period.streams) {\n      // The v4 version of the database as written by v2.5.0 - v2.5.9 might have\n      // been corrupted slightly.  A bug caused the stream metadata from all\n      // periods to be written to each period.  This was corrected in v2.5.10.\n      // To fix this, we can identify the extra streams by their lack of\n      // variantIds and skip them.\n      if (stream.variantIds.length == 0) {\n        continue;\n      }\n\n      streams.push(this.convertStream_(\n          stream, period.startTime, period.startTime + periodDuration));\n    }\n    return streams;\n  }\n\n  /**\n   * @param {shaka.extern.StreamDBV2} old\n   * @param {number} periodStart\n   * @param {number} periodEnd\n   * @return {shaka.extern.StreamDB}\n   * @private\n   */\n  convertStream_(old, periodStart, periodEnd) {\n    return {\n      id: old.id,\n      originalId: old.originalId,\n      primary: old.primary,\n      type: old.contentType,\n      mimeType: old.mimeType,\n      codecs: old.codecs,\n      frameRate: old.frameRate,\n      pixelAspectRatio: old.pixelAspectRatio,\n      kind: old.kind,\n      language: old.language,\n      label: old.label,\n      width: old.width,\n      height: old.height,\n      encrypted: old.encrypted,\n      keyIds: new Set([old.keyId]),\n      segments: old.segments.map((segment) =>\n        this.convertSegment_(\n            segment, old.initSegmentKey, periodStart, periodEnd,\n            old.presentationTimeOffset)),\n      variantIds: old.variantIds,\n      roles: [],\n      audioSamplingRate: null,\n      channelsCount: null,\n      closedCaptions: null,\n    };\n  }\n\n  /**\n   * @param {shaka.extern.SegmentDBV2} old\n   * @param {?number} initSegmentKey\n   * @param {number} periodStart\n   * @param {number} periodEnd\n   * @param {number} presentationTimeOffset\n   * @return {shaka.extern.SegmentDB}\n   * @private\n   */\n  convertSegment_(\n      old, initSegmentKey, periodStart, periodEnd, presentationTimeOffset) {\n    const timestampOffset = periodStart - presentationTimeOffset;\n\n    return {\n      startTime: periodStart + old.startTime,\n      endTime: periodStart + old.endTime,\n      initSegmentKey,\n      appendWindowStart: periodStart,\n      appendWindowEnd: periodEnd,\n      timestampOffset,\n      dataKey: old.dataKey,\n    };\n  }\n};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.offline.indexeddb.V5StorageCell');\n\ngoog.require('shaka.offline.indexeddb.BaseStorageCell');\n\n\n/**\n * The V5StorageCell is for all stores that follow the shaka.externs V5 offline\n * types introduced in v3.0.\n *\n * @implements {shaka.extern.StorageCell}\n */\nshaka.offline.indexeddb.V5StorageCell = class\n  extends shaka.offline.indexeddb.BaseStorageCell {\n  /** @override */\n  hasFixedKeySpace() {\n    // This makes the cell read-write.\n    return false;\n  }\n\n  /** @override */\n  addSegments(segments) {\n    return this.add(this.segmentStore_, segments);\n  }\n\n  /** @override */\n  addManifests(manifests) {\n    return this.add(this.manifestStore_, manifests);\n  }\n\n  /** @override */\n  convertManifest(old) {\n    // JSON serialization turns Infinity into null, so turn it back now.\n    if (old.expiration == null) {\n      old.expiration = Infinity;\n    }\n    return Promise.resolve(/** @type {shaka.extern.ManifestDB} */(old));\n  }\n};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.offline.OfflineUri');\n\n\n/**\n * The OfflineUri class contains all the components that make up the offline\n * uri. The components are:\n *    TYPE: Used to know what type of data the uri points to. It can either\n *          be \"manifest\" or \"segment\".\n *    MECHANISM: The name of the mechanism that manages the storage cell that\n *               holds the data.\n *    CELL: The name of the cell that holds the data.\n *    KEY: The key that the data is stored under in the cell.\n */\nshaka.offline.OfflineUri = class {\n  /**\n   * @param {string} type\n   * @param {string} mechanism\n   * @param {string} cell\n   * @param {number} key\n   */\n  constructor(type, mechanism, cell, key) {\n    /**\n     * @private {string}\n     * @const\n     */\n    this.type_ = type;\n    /**\n     * @private {string}\n     * @const\n     */\n    this.mechanism_ = mechanism;\n    /**\n     * @private {string}\n     * @const\n     */\n    this.cell_ = cell;\n    /**\n     * @private {number}\n     * @const\n     */\n    this.key_ = key;\n\n    /**\n     * @private {string}\n     * @const\n     */\n    this.asString_ = [\n      'offline:', type, '/', mechanism, '/', cell, '/', key,\n    ].join('');\n  }\n\n  /** @return {boolean} */\n  isManifest() { return this.type_ == 'manifest'; }\n\n  /** @return {boolean} */\n  isSegment() { return this.type_ == 'segment'; }\n\n  /** @return {string} */\n  mechanism() { return this.mechanism_; }\n\n  /** @return {string} */\n  cell() { return this.cell_; }\n\n  /** @return {number} */\n  key() { return this.key_; }\n\n  /** @override */\n  toString() { return this.asString_; }\n\n  /**\n   * @param {string} uri\n   * @return {?shaka.offline.OfflineUri}\n   */\n  static parse(uri) {\n    const parts = /^offline:([a-z]+)\\/([^/]+)\\/([^/]+)\\/([0-9]+)$/.exec(uri);\n    if (parts == null) {\n      return null;\n    }\n\n    const type = parts[1];\n    if (type != 'manifest' && type != 'segment') {\n      return null;\n    }\n\n    const mechanism = parts[2];\n    if (!mechanism) {\n      return null;\n    }\n\n    const cell = parts[3];\n    if (!cell) {\n      return null;\n    }\n\n    const key = Number(parts[4]);\n    if (type == null) {\n      return null;\n    }\n\n    return new shaka.offline.OfflineUri(type, mechanism, cell, key);\n  }\n\n  /**\n   * @param {string} mechanism\n   * @param {string} cell\n   * @param {number} key\n   * @return {!shaka.offline.OfflineUri}\n   */\n  static manifest(mechanism, cell, key) {\n    return new shaka.offline.OfflineUri('manifest', mechanism, cell, key);\n  }\n\n  /**\n   * @param {string} mechanism\n   * @param {string} cell\n   * @param {number} key\n   * @return {!shaka.offline.OfflineUri}\n   */\n  static segment(mechanism, cell, key) {\n    return new shaka.offline.OfflineUri('segment', mechanism, cell, key);\n  }\n};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.offline.ManifestConverter');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.media.InitSegmentReference');\ngoog.require('shaka.media.PresentationTimeline');\ngoog.require('shaka.media.SegmentIndex');\ngoog.require('shaka.media.SegmentReference');\ngoog.require('shaka.offline.OfflineUri');\ngoog.require('shaka.util.ManifestParserUtils');\n\n\n/**\n * Utility class for converting database manifest objects back to normal\n * player-ready objects. Used by the offline system to convert on-disk\n * objects back to the in-memory objects.\n */\nshaka.offline.ManifestConverter = class {\n  /**\n   * Create a new manifest converter. Need to know the mechanism and cell that\n   * the manifest is from so that all segments paths can be created.\n   *\n   * @param {string} mechanism\n   * @param {string} cell\n   */\n  constructor(mechanism, cell) {\n    /** @private {string} */\n    this.mechanism_ = mechanism;\n\n    /** @private {string} */\n    this.cell_ = cell;\n  }\n\n  /**\n   * Convert a |shaka.extern.ManifestDB| object to a |shaka.extern.Manifest|\n   * object.\n   *\n   * @param {shaka.extern.ManifestDB} manifestDB\n   * @return {shaka.extern.Manifest}\n   */\n  fromManifestDB(manifestDB) {\n    const timeline = new shaka.media.PresentationTimeline(null, 0);\n    timeline.setDuration(manifestDB.duration);\n\n    /** @type {!Array.<shaka.extern.StreamDB>} */\n    const audioStreams =\n        manifestDB.streams.filter((streamDB) => this.isAudio_(streamDB));\n\n    /** @type {!Array.<shaka.extern.StreamDB>} */\n    const videoStreams =\n        manifestDB.streams.filter((streamDB) => this.isVideo_(streamDB));\n\n    /** @type {!Map.<number, shaka.extern.Variant>} */\n    const variants = this.createVariants(audioStreams, videoStreams, timeline);\n\n    /** @type {!Array.<shaka.extern.Stream>} */\n    const textStreams =\n        manifestDB.streams.filter((streamDB) => this.isText_(streamDB))\n            .map((streamDB) => this.fromStreamDB_(streamDB, timeline));\n\n    const drmInfos = manifestDB.drmInfo ? [manifestDB.drmInfo] : [];\n    if (manifestDB.drmInfo) {\n      for (const variant of variants.values()) {\n        if (variant.audio && variant.audio.encrypted) {\n          variant.audio.drmInfos = drmInfos;\n        }\n        if (variant.video && variant.video.encrypted) {\n          variant.video.drmInfos = drmInfos;\n        }\n      }\n    }\n\n    return {\n      presentationTimeline: timeline,\n      minBufferTime: 2,\n      offlineSessionIds: manifestDB.sessionIds,\n      variants: Array.from(variants.values()),\n      textStreams: textStreams,\n    };\n  }\n\n  /**\n   * Recreates Variants from audio and video StreamDB collections.\n   *\n   * @param {!Array.<!shaka.extern.StreamDB>} audios\n   * @param {!Array.<!shaka.extern.StreamDB>} videos\n   * @param {shaka.media.PresentationTimeline} timeline\n   * @return {!Map.<number, !shaka.extern.Variant>}\n   */\n  createVariants(audios, videos, timeline) {\n    // Get all the variant ids from all audio and video streams.\n    /** @type {!Set.<number>} */\n    const variantIds = new Set();\n    for (const streamDB of audios) {\n      for (const id of streamDB.variantIds) {\n        variantIds.add(id);\n      }\n    }\n    for (const streamDB of videos) {\n      for (const id of streamDB.variantIds) {\n        variantIds.add(id);\n      }\n    }\n\n    /** @type {!Map.<number, shaka.extern.Variant>} */\n    const variantMap = new Map();\n    for (const id of variantIds) {\n      variantMap.set(id, this.createEmptyVariant_(id));\n    }\n\n    // Assign each audio stream to its variants.\n    for (const audio of audios) {\n      /** @type {shaka.extern.Stream} */\n      const stream = this.fromStreamDB_(audio, timeline);\n\n      for (const variantId of audio.variantIds) {\n        const variant = variantMap.get(variantId);\n\n        goog.asserts.assert(\n            !variant.audio, 'A variant should only have one audio stream');\n\n        variant.language = stream.language;\n        variant.primary = variant.primary || stream.primary;\n        variant.audio = stream;\n      }\n    }\n\n    // Assign each video stream to its variants.\n    for (const video of videos) {\n      /** @type {shaka.extern.Stream} */\n      const stream = this.fromStreamDB_(video, timeline);\n\n      for (const variantId of video.variantIds) {\n        const variant = variantMap.get(variantId);\n\n        goog.asserts.assert(\n            !variant.video, 'A variant should only have one video stream');\n\n        variant.primary = variant.primary || stream.primary;\n        variant.video = stream;\n      }\n    }\n\n    return variantMap;\n  }\n\n  /**\n   * @param {shaka.extern.StreamDB} streamDB\n   * @param {shaka.media.PresentationTimeline} timeline\n   * @return {shaka.extern.Stream}\n   * @private\n   */\n  fromStreamDB_(streamDB, timeline) {\n    /** @type {!Array.<!shaka.media.SegmentReference>} */\n    const segments = streamDB.segments.map(\n        (segment, index) => this.fromSegmentDB_(index, segment));\n\n    timeline.notifySegments(segments);\n\n    /** @type {!shaka.media.SegmentIndex} */\n    const segmentIndex = new shaka.media.SegmentIndex(segments);\n\n    /** @type {shaka.extern.Stream} */\n    const stream = {\n      id: streamDB.id,\n      originalId: streamDB.originalId,\n      createSegmentIndex: () => Promise.resolve(),\n      segmentIndex,\n      mimeType: streamDB.mimeType,\n      codecs: streamDB.codecs,\n      width: streamDB.width || undefined,\n      height: streamDB.height || undefined,\n      frameRate: streamDB.frameRate,\n      pixelAspectRatio: streamDB.pixelAspectRatio,\n      kind: streamDB.kind,\n      encrypted: streamDB.encrypted,\n      drmInfos: [],\n      keyIds: streamDB.keyIds,\n      language: streamDB.language,\n      label: streamDB.label,\n      type: streamDB.type,\n      primary: streamDB.primary,\n      trickModeVideo: null,\n      emsgSchemeIdUris: null,\n      roles: streamDB.roles,\n      channelsCount: streamDB.channelsCount,\n      audioSamplingRate: streamDB.audioSamplingRate,\n      closedCaptions: streamDB.closedCaptions,\n    };\n\n    return stream;\n  }\n\n  /**\n   * @param {number} index\n   * @param {shaka.extern.SegmentDB} segmentDB\n   * @return {!shaka.media.SegmentReference}\n   * @private\n   */\n  fromSegmentDB_(index, segmentDB) {\n    /** @type {!shaka.offline.OfflineUri} */\n    const uri = shaka.offline.OfflineUri.segment(\n        this.mechanism_, this.cell_, segmentDB.dataKey);\n\n    const initSegmentReference = segmentDB.initSegmentKey != null ?\n        this.fromInitSegmentDB_(segmentDB.initSegmentKey) : null;\n\n    return new shaka.media.SegmentReference(\n        segmentDB.startTime,\n        segmentDB.endTime,\n        () => [uri.toString()],\n        /* startByte= */ 0,\n        /* endByte= */ null,\n        initSegmentReference,\n        segmentDB.timestampOffset,\n        segmentDB.appendWindowStart,\n        segmentDB.appendWindowEnd);\n  }\n\n  /**\n   * @param {number} key\n   * @return {!shaka.media.InitSegmentReference}\n   * @private\n   */\n  fromInitSegmentDB_(key) {\n    /** @type {!shaka.offline.OfflineUri} */\n    const uri = shaka.offline.OfflineUri.segment(\n        this.mechanism_, this.cell_, key);\n\n    return new shaka.media.InitSegmentReference(\n        () => [uri.toString()],\n        /* startBytes= */ 0,\n        /* endBytes= */ null );\n  }\n\n  /**\n   * @param {shaka.extern.StreamDB} streamDB\n   * @return {boolean}\n   * @private\n   */\n  isAudio_(streamDB) {\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n    return streamDB.type == ContentType.AUDIO;\n  }\n\n  /**\n   * @param {shaka.extern.StreamDB} streamDB\n   * @return {boolean}\n   * @private\n   */\n  isVideo_(streamDB) {\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n    return streamDB.type == ContentType.VIDEO;\n  }\n\n  /**\n   * @param {shaka.extern.StreamDB} streamDB\n   * @return {boolean}\n   * @private\n   */\n  isText_(streamDB) {\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n    return streamDB.type == ContentType.TEXT;\n  }\n\n  /**\n   * Creates an empty Variant.\n   *\n   * @param {number} id\n   * @return {!shaka.extern.Variant}\n   * @private\n   */\n  createEmptyVariant_(id) {\n    return {\n      id: id,\n      language: '',\n      primary: false,\n      audio: null,\n      video: null,\n      bandwidth: 0,\n      allowedByApplication: true,\n      allowedByKeySystem: true,\n    };\n  }\n};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.offline.OfflineScheme');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.net.NetworkingEngine');\ngoog.require('shaka.offline.OfflineUri');\ngoog.require('shaka.offline.StorageMuxer');\ngoog.require('shaka.util.AbortableOperation');\ngoog.require('shaka.util.Error');\n\n\n/**\n * @summary A plugin that handles requests for offline content.\n * @export\n */\nshaka.offline.OfflineScheme = class {\n  /**\n   * @param {string} uri\n   * @param {shaka.extern.Request} request\n   * @param {shaka.net.NetworkingEngine.RequestType} requestType\n   * @param {shaka.extern.ProgressUpdated} progressUpdated Called when a\n   *   progress event happened.\n   * @return {!shaka.extern.IAbortableOperation.<shaka.extern.Response>}\n   * @export\n   */\n  static plugin(uri, request, requestType, progressUpdated) {\n    const offlineUri = shaka.offline.OfflineUri.parse(uri);\n\n    if (offlineUri && offlineUri.isManifest()) {\n      return shaka.offline.OfflineScheme.getManifest_(uri);\n    }\n\n    if (offlineUri && offlineUri.isSegment()) {\n      return shaka.offline.OfflineScheme.getSegment_(\n          offlineUri.key(), offlineUri);\n    }\n\n    return shaka.util.AbortableOperation.failed(\n        new shaka.util.Error(\n            shaka.util.Error.Severity.CRITICAL,\n            shaka.util.Error.Category.NETWORK,\n            shaka.util.Error.Code.MALFORMED_OFFLINE_URI,\n            uri));\n  }\n\n  /**\n   * @param {string} uri\n   * @return {!shaka.extern.IAbortableOperation.<shaka.extern.Response>}\n   * @private\n   */\n  static getManifest_(uri) {\n    /** @type {shaka.extern.Response} */\n    const response = {\n      uri: uri,\n      originalUri: uri,\n      data: new ArrayBuffer(0),\n      headers: {'content-type': 'application/x-offline-manifest'},\n    };\n\n    return shaka.util.AbortableOperation.completed(response);\n  }\n\n  /**\n   * @param {number} id\n   * @param {!shaka.offline.OfflineUri} uri\n   * @return {!shaka.extern.IAbortableOperation.<shaka.extern.Response>}\n   * @private\n   */\n  static getSegment_(id, uri) {\n    goog.asserts.assert(\n        uri.isSegment(),\n        'Only segment uri\\'s should be given to getSegment');\n\n    /** @type {!shaka.offline.StorageMuxer} */\n    const muxer = new shaka.offline.StorageMuxer();\n\n    return shaka.util.AbortableOperation.completed(undefined)\n        .chain(() => muxer.init())\n        .chain(() => muxer.getCell(uri.mechanism(), uri.cell()))\n        .chain((cell) => cell.getSegments([uri.key()]))\n        .chain((segments) => {\n          const segment = segments[0];\n\n          return {\n            uri: uri,\n            data: segment.data,\n            headers: {},\n          };\n        })\n        .finally(() => muxer.destroy());\n  }\n};\n\nshaka.net.NetworkingEngine.registerScheme(\n    'offline', shaka.offline.OfflineScheme.plugin);\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.offline.SessionDeleter');\n\n\ngoog.require('shaka.log');\ngoog.require('shaka.media.DrmEngine');\ngoog.require('shaka.util.ArrayUtils');\ngoog.requireType('shaka.net.NetworkingEngine');\n\n\n/**\n * Contains a utility method to delete persistent EME sessions.\n */\nshaka.offline.SessionDeleter = class {\n  /**\n   * Deletes the given sessions.  This never fails and instead logs the error.\n   *\n   * @param {shaka.extern.DrmConfiguration} config\n   * @param {!shaka.net.NetworkingEngine} netEngine\n   * @param {!Array.<shaka.extern.EmeSessionDB>} sessions\n   * @return {!Promise.<!Array.<string>>} The session IDs that were deleted.\n   */\n  async delete(config, netEngine, sessions) {\n    const SessionDeleter = shaka.offline.SessionDeleter;\n\n    let deleted = [];\n    for (const bucket of SessionDeleter.createBuckets_(sessions)) {\n      // Run these sequentially to avoid creating multiple CDM instances at one\n      // time.  Some embedded platforms may not support multiples.\n      const p = this.doDelete_(config, netEngine, bucket);\n      const cur = await p;  // eslint-disable-line no-await-in-loop\n      deleted = deleted.concat(cur);\n    }\n    return deleted;\n  }\n\n\n  /**\n   * Performs the deletion of the given session IDs.\n   *\n   * @param {shaka.extern.DrmConfiguration} config\n   * @param {!shaka.net.NetworkingEngine} netEngine\n   * @param {shaka.offline.SessionDeleter.Bucket_} bucket\n   * @return {!Promise.<!Array.<string>>} The sessions that were deleted\n   * @private\n   */\n  async doDelete_(config, netEngine, bucket) {\n    /** @type {!shaka.media.DrmEngine} */\n    const drmEngine = new shaka.media.DrmEngine({\n      netEngine: netEngine,\n      onError: () => {},\n      onKeyStatus: () => {},\n      onExpirationUpdated: () => {},\n      onEvent: () => {},\n    });\n\n    try {\n      drmEngine.configure(config);\n      await drmEngine.initForRemoval(\n          bucket.info.keySystem, bucket.info.licenseUri,\n          bucket.info.serverCertificate,\n          bucket.info.audioCapabilities, bucket.info.videoCapabilities);\n    } catch (e) {\n      shaka.log.warning('Error initializing EME', e);\n      await drmEngine.destroy();\n      return [];\n    }\n\n    try {\n      await drmEngine.setServerCertificate();\n    } catch (e) {\n      shaka.log.warning('Error setting server certificate', e);\n      await drmEngine.destroy();\n      return [];\n    }\n\n    /** @type {!Array.<string>} */\n    const sessionIds = [];\n    await Promise.all(bucket.sessionIds.map(async (sessionId) => {\n      // This method is in a .map(), so this starts multiple removes at once,\n      // so this removes the sessions in parallel.\n      try {\n        await drmEngine.removeSession(sessionId);\n        sessionIds.push(sessionId);\n      } catch (e) {\n        shaka.log.warning('Error deleting offline session', e);\n      }\n    }));\n    await drmEngine.destroy();\n    return sessionIds;\n  }\n\n\n  /**\n   * Collects the given sessions into buckets that can be done at the same time.\n   * Since querying with different parameters can give us back different CDMs,\n   * we can't just use one CDM instance to delete everything.\n   *\n   * @param {!Array.<shaka.extern.EmeSessionDB>} sessions\n   * @return {!Array.<shaka.offline.SessionDeleter.Bucket_>}\n   * @private\n   */\n  static createBuckets_(sessions) {\n    const SessionDeleter = shaka.offline.SessionDeleter;\n\n    /** @type {!Array.<shaka.offline.SessionDeleter.Bucket_>} */\n    const ret = [];\n    for (const session of sessions) {\n      let found = false;\n      for (const bucket of ret) {\n        if (SessionDeleter.isCompatible_(bucket.info, session)) {\n          bucket.sessionIds.push(session.sessionId);\n          found = true;\n          break;\n        }\n      }\n      if (!found) {\n        ret.push({info: session, sessionIds: [session.sessionId]});\n      }\n    }\n\n    return ret;\n  }\n\n\n  /**\n   * Returns whether the given session infos are compatible with each other.\n   * @param {shaka.extern.EmeSessionDB} a\n   * @param {shaka.extern.EmeSessionDB} b\n   * @return {boolean}\n   * @private\n   */\n  static isCompatible_(a, b) {\n    const ArrayUtils = shaka.util.ArrayUtils;\n\n    // TODO: Add a way to change the license server in DrmEngine to avoid\n    // resetting EME for different license servers.\n    const comp = (x, y) =>\n      x.robustness == y.robustness && x.contentType == y.contentType;\n    return a.keySystem == b.keySystem && a.licenseUri == b.licenseUri &&\n        ArrayUtils.hasSameElements(\n            a.audioCapabilities, b.audioCapabilities, comp) &&\n        ArrayUtils.hasSameElements(\n            a.videoCapabilities, b.videoCapabilities, comp);\n  }\n};\n\n\n/**\n * @typedef {{\n *   info: shaka.extern.EmeSessionDB,\n *   sessionIds: !Array.<string>\n * }}\n */\nshaka.offline.SessionDeleter.Bucket_;\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.offline.StoredContentUtils');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.offline.ManifestConverter');\ngoog.require('shaka.offline.OfflineUri');\ngoog.require('shaka.util.StreamUtils');\n\n\n/**\n * A utility class used to create |shaka.extern.StoredContent| from different\n * types of input.\n */\nshaka.offline.StoredContentUtils = class {\n  /**\n   * @param {string} originalUri\n   * @param {shaka.extern.Manifest} manifest\n   * @param {number} size\n   * @param {!Object} metadata\n   * @return {shaka.extern.StoredContent}\n   */\n  static fromManifest(originalUri, manifest, size, metadata) {\n    goog.asserts.assert(\n        manifest.variants.length,\n        'Cannot create stored content from manifest with no variants.');\n\n    /** @type {number} */\n    const duration = manifest.presentationTimeline.getDuration();\n\n    /** @type {!Array.<shaka.extern.Track>} */\n    const tracks = shaka.offline.StoredContentUtils.getTracks_(manifest);\n\n    /** @type {shaka.extern.StoredContent} */\n    const content = {\n      offlineUri: null,\n      originalManifestUri: originalUri,\n      duration: duration,\n      size: size,\n      // This expiration value is temporary and will be used in progress reports\n      // during the storage process.  The real value would have to come from\n      // DrmEngine.\n      expiration: Infinity,\n      tracks: tracks,\n      appMetadata: metadata,\n    };\n\n    return content;\n  }\n\n  /**\n   * @param {!shaka.offline.OfflineUri} offlineUri\n   * @param {shaka.extern.ManifestDB} manifestDB\n   * @return {shaka.extern.StoredContent}\n   */\n  static fromManifestDB(offlineUri, manifestDB) {\n    goog.asserts.assert(\n        manifestDB.streams.length,\n        'Cannot create stored content from manifestDB with no streams.');\n\n    const converter = new shaka.offline.ManifestConverter(\n        offlineUri.mechanism(), offlineUri.cell());\n\n    /** @type {shaka.extern.Manifest} */\n    const manifest = converter.fromManifestDB(manifestDB);\n\n    /** @type {!Object} */\n    const metadata = manifestDB.appMetadata || {};\n\n    /** @type {!Array.<shaka.extern.Track>} */\n    const tracks = shaka.offline.StoredContentUtils.getTracks_(manifest);\n\n    goog.asserts.assert(\n        manifestDB.expiration != null,\n        'Manifest expiration must be set by now!');\n\n    /** @type {shaka.extern.StoredContent} */\n    const content = {\n      offlineUri: offlineUri.toString(),\n      originalManifestUri: manifestDB.originalManifestUri,\n      duration: manifestDB.duration,\n      size: manifestDB.size,\n      expiration: manifestDB.expiration,\n      tracks: tracks,\n      appMetadata: metadata,\n    };\n\n    return content;\n  }\n\n  /**\n   * Gets track representations of all playable variants and all text streams.\n   *\n   * @param {shaka.extern.Manifest} manifest\n   * @return {!Array.<shaka.extern.Track>}\n   * @private\n   */\n  static getTracks_(manifest) {\n    const StreamUtils = shaka.util.StreamUtils;\n\n    const tracks = [];\n\n    const variants = StreamUtils.getPlayableVariants(manifest.variants);\n    for (const variant of variants) {\n      tracks.push(StreamUtils.variantToTrack(variant));\n    }\n\n    const textStreams = manifest.textStreams;\n    for (const stream of textStreams) {\n      tracks.push(StreamUtils.textStreamToTrack(stream));\n    }\n\n    return tracks;\n  }\n};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.offline.StreamBandwidthEstimator');\n\ngoog.require('shaka.log');\ngoog.requireType('shaka.media.SegmentReference');\n\n\n/**\n * A utility class to help estimate the size of streams based on stream and\n * variant bandwidths. This class's main purpose is to isolate the logic in\n * creating non-zero bandwidth estimates for all streams so that each stream\n * will have some influence over the progress of the download.\n */\nshaka.offline.StreamBandwidthEstimator = class {\n  constructor() {\n    /** @private {!Object.<number, number>} */\n    this.estimateByStreamId_ = {};\n  }\n\n  /**\n   * Add a new variant to the estimator. This will update the estimates for all\n   * streams in the variant.\n   *\n   * @param {shaka.extern.Variant} variant\n   */\n  addVariant(variant) {\n    // Three cases:\n    //  1 - Only Audio\n    //  2 - Only Video\n    //  3 - Audio and Video\n\n    const audio = variant.audio;\n    const video = variant.video;\n\n    // Case 1\n    if (audio && !video) {\n      const audioBitRate = audio.bandwidth || variant.bandwidth;\n      this.setBitrate_(audio.id, audioBitRate);\n    }\n\n    // Case 2\n    if (!audio && video) {\n      const videoBitRate = video.bandwidth || variant.bandwidth;\n      this.setBitrate_(video.id, videoBitRate);\n    }\n\n    // Case 3\n    if (audio && video) {\n      // Get the audio's bandwidth. If it is missing, default to our default\n      // audio bandwidth.\n      const audioBitRate =\n          audio.bandwidth ||\n          shaka.offline.StreamBandwidthEstimator.DEFAULT_AUDIO_BITRATE_;\n\n      // Get the video's bandwidth. If it is missing, use the variant bandwidth\n      // less the audio. If we get a negative bit rate, fall back to our\n      // default video bandwidth.\n      let videoBitRate = video.bandwidth || (variant.bandwidth - audioBitRate);\n      if (videoBitRate <= 0) {\n        shaka.log.warning(\n            'Audio bit rate consumes variants bandwidth. Setting video ' +\n            'bandwidth to match variant\\'s bandwidth.');\n        videoBitRate = variant.bandwidth;\n      }\n\n      this.setBitrate_(audio.id, audioBitRate);\n      this.setBitrate_(video.id, videoBitRate);\n    }\n  }\n\n  /**\n   * @param {number} stream\n   * @param {number} bitRate\n   * @private\n   */\n  setBitrate_(stream, bitRate) {\n    this.estimateByStreamId_[stream] = bitRate;\n  }\n\n  /**\n   * Create an estimate for the text stream.\n   *\n   * @param {shaka.extern.Stream} text\n   */\n  addText(text) {\n    this.estimateByStreamId_[text.id] =\n        shaka.offline.StreamBandwidthEstimator.DEFAULT_TEXT_BITRATE_;\n  }\n\n  /**\n   * Get the estimate for a segment that is part of a stream that has already\n   * added to the estimator.\n   *\n   * @param {number} id\n   * @param {!shaka.media.SegmentReference} segment\n   * @return {number}\n   */\n  getSegmentEstimate(id, segment) {\n    const duration = segment.endTime - segment.startTime;\n    return this.getEstimate_(id) * duration;\n  }\n\n  /**\n   * Get the estimate for an init segment for a stream that has already\n   * added to the estimator.\n   *\n   * @param {number} id\n   * @return {number}\n   */\n  getInitSegmentEstimate(id) {\n    // Assume that the init segment is worth approximately half a second of\n    // content.\n    const duration = 0.5;\n    return this.getEstimate_(id) * duration;\n  }\n\n  /**\n   * @param {number} id\n   * @return {number}\n   * @private\n   */\n  getEstimate_(id) {\n    let bitRate = this.estimateByStreamId_[id];\n\n    if (bitRate == null) {\n      bitRate = 0;\n      shaka.log.error(\n          'Asking for bitrate of stream not given to the estimator');\n    }\n\n    if (bitRate == 0) {\n      shaka.log.warning(\n          'Using bitrate of 0, this stream won\\'t affect progress');\n    }\n\n    return bitRate;\n  }\n};\n\n\n/**\n * Since audio bandwidth does not vary much, we are going to use a constant\n * approximation for audio bit rate allowing use to more accurately guess at\n * the video bitrate.\n *\n * YouTube's suggested bitrate for stereo audio is 384 kbps so we are going to\n * assume that: https://support.google.com/youtube/answer/1722171?hl=en\n *\n * @const {number}\n * @private\n */\nshaka.offline.StreamBandwidthEstimator.DEFAULT_AUDIO_BITRATE_ = 393216;\n\n\n/**\n * Since we don't normally get the bitrate for text, we still want to create\n * some approximation so that it can influence progress. This will use the\n * bitrate from \"Tears of Steal\" to give some kind of data-driven result.\n *\n * The file size for English subtitles is 4.7 KB. The video is 12:14 long,\n * which means that the text's bit rate is around 52 bps.\n *\n * @const {number}\n * @private\n */\nshaka.offline.StreamBandwidthEstimator.DEFAULT_TEXT_BITRATE_ = 52;\n\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.offline.Storage');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.Deprecate');\ngoog.require('shaka.Player');\ngoog.require('shaka.log');\ngoog.require('shaka.media.DrmEngine');\ngoog.require('shaka.media.ManifestParser');\ngoog.require('shaka.net.NetworkingEngine');\ngoog.require('shaka.offline.DownloadManager');\ngoog.require('shaka.offline.OfflineUri');\ngoog.require('shaka.offline.SessionDeleter');\ngoog.require('shaka.offline.StorageMuxer');\ngoog.require('shaka.offline.StoredContentUtils');\ngoog.require('shaka.offline.StreamBandwidthEstimator');\ngoog.require('shaka.util.AbortableOperation');\ngoog.require('shaka.util.ArrayUtils');\ngoog.require('shaka.util.ConfigUtils');\ngoog.require('shaka.util.Destroyer');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.Functional');\ngoog.require('shaka.util.IDestroyable');\ngoog.require('shaka.util.Iterables');\ngoog.require('shaka.util.ManifestFilter');\ngoog.require('shaka.util.MimeUtils');\ngoog.require('shaka.util.Networking');\ngoog.require('shaka.util.Platform');\ngoog.require('shaka.util.PlayerConfiguration');\ngoog.require('shaka.util.StreamUtils');\ngoog.requireType('shaka.media.InitSegmentReference');\ngoog.requireType('shaka.media.SegmentReference');\ngoog.requireType('shaka.offline.StorageCellHandle');\n\n\n/**\n * @summary\n * This manages persistent offline data including storage, listing, and deleting\n * stored manifests.  Playback of offline manifests are done through the Player\n * using a special URI (see shaka.offline.OfflineUri).\n *\n * First, check support() to see if offline is supported by the platform.\n * Second, configure() the storage object with callbacks to your application.\n * Third, call store(), remove(), or list() as needed.\n * When done, call destroy().\n *\n * @implements {shaka.util.IDestroyable}\n * @export\n */\nshaka.offline.Storage = class {\n  /**\n   * @param {!shaka.Player=} player\n   *    A player instance to share a networking engine and configuration with.\n   *    When initializing with a player, storage is only valid as long as\n   *    |destroy| has not been called on the player instance. When omitted,\n   *    storage will manage its own networking engine and configuration.\n   */\n  constructor(player) {\n    // It is an easy mistake to make to pass a Player proxy from CastProxy.\n    // Rather than throw a vague exception later, throw an explicit and clear\n    // one now.\n    //\n    // TODO(vaage): After we decide whether or not we want to support\n    //  initializing storage with a player proxy, we should either remove\n    //  this error or rename the error.\n    if (player && player.constructor != shaka.Player) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.STORAGE,\n          shaka.util.Error.Code.LOCAL_PLAYER_INSTANCE_REQUIRED);\n    }\n\n    /** @private {?shaka.extern.PlayerConfiguration} */\n    this.config_ = null;\n\n    /** @private {shaka.net.NetworkingEngine} */\n    this.networkingEngine_ = null;\n\n    // Initialize |config_| and |networkingEngine_| based on whether or not\n    // we were given a player instance.\n    if (player) {\n      this.config_ = player.getSharedConfiguration();\n      this.networkingEngine_ = player.getNetworkingEngine();\n\n      goog.asserts.assert(\n          this.networkingEngine_,\n          'Storage should not be initialized with a player that had ' +\n              '|destroy| called on it.');\n    } else {\n      this.config_ = shaka.util.PlayerConfiguration.createDefault();\n      this.networkingEngine_ = new shaka.net.NetworkingEngine();\n    }\n\n    /**\n     * A list of segment ids for all the segments that were added during the\n     * current store. If the store fails or is aborted, these need to be\n     * removed from storage.\n     * @private {!Array.<number>}\n     */\n    this.segmentsFromStore_ = [];\n\n    /**\n     * A list of open operations that are being performed by this instance of\n     * |shaka.offline.Storage|.\n     *\n     * @private {!Array.<!Promise>}\n     */\n    this.openOperations_ = [];\n\n    /**\n     * A list of open download managers that are being used to download things.\n     *\n     * @private {!Array.<!shaka.offline.DownloadManager>}\n     */\n    this.openDownloadManagers_ = [];\n\n    /**\n     * A cache mapping init segment references to Promises to their DB key.\n     *\n     * @private {!Map.<shaka.media.InitSegmentReference, !Promise.<?number>>}\n     */\n    this.initSegmentDbKeyCache_ = new Map();\n\n    // A null init segment reference always maps to a null DB key.\n    this.initSegmentDbKeyCache_.set(\n        null, /** @type {!Promise.<?number>} */(Promise.resolve(null)));\n\n    /**\n     * A cache mapping equivalent segment references to Promises to their DB\n     * key.  The key in this map is a string of the form\n     * \"<URI>-<startByte>-<endByte>\".\n     *\n     * @private {!Map.<string, !Promise.<number>>}\n     */\n    this.segmentDbKeyCache_ = new Map();\n\n    /**\n     * Storage should only destroy the networking engine if it was initialized\n     * without a player instance. Store this as a flag here to avoid including\n     * the player object in the destoyer's closure.\n     *\n     * @type {boolean}\n     */\n    const destroyNetworkingEngine = !player;\n\n    /** @private {!shaka.util.Destroyer} */\n    this.destroyer_ = new shaka.util.Destroyer(async () => {\n      // Cancel all in-progress store operations.\n      await Promise.all(this.openDownloadManagers_.map((dl) => dl.abortAll()));\n\n      // Wait for all remaining open operations to end. Wrap each operations so\n      // that a single rejected promise won't cause |Promise.all| to return\n      // early or to return a rejected Promise.\n      const noop = () => {};\n      const awaits = [];\n      for (const op of this.openOperations_) {\n        awaits.push(op.then(noop, noop));\n      }\n      await Promise.all(awaits);\n\n      // Wait until after all the operations have finished before we destroy\n      // the networking engine to avoid any unexpected errors.\n      if (destroyNetworkingEngine) {\n        await this.networkingEngine_.destroy();\n      }\n\n      // Drop all references to internal objects to help with GC.\n      this.config_ = null;\n      this.networkingEngine_ = null;\n    });\n  }\n\n\n  /**\n   * Gets whether offline storage is supported.  Returns true if offline storage\n   * is supported for clear content.  Support for offline storage of encrypted\n   * content will not be determined until storage is attempted.\n   *\n   * @return {boolean}\n   * @export\n   */\n  static support() {\n    // Our Storage system is useless without MediaSource.  MediaSource allows us\n    // to pull data from anywhere (including our Storage system) and feed it to\n    // the video element.\n    if (!shaka.util.Platform.supportsMediaSource()) {\n      return false;\n    }\n\n    return shaka.offline.StorageMuxer.support();\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  destroy() {\n    return this.destroyer_.destroy();\n  }\n\n  /**\n   * Sets configuration values for Storage.  This is associated with\n   * Player.configure and will change the player instance given at\n   * initialization.\n   *\n   * @param {string|!Object} config This should either be a field name or an\n   *   object following the form of {@link shaka.extern.PlayerConfiguration},\n   *   where you may omit any field you do not wish to change.\n   * @param {*=} value This should be provided if the previous parameter\n   *   was a string field name.\n   * @return {boolean}\n   * @export\n   */\n  configure(config, value) {\n    goog.asserts.assert(typeof(config) == 'object' || arguments.length == 2,\n        'String configs should have values!');\n\n    // ('fieldName', value) format\n    if (arguments.length == 2 && typeof(config) == 'string') {\n      config = shaka.util.ConfigUtils.convertToConfigObject(config, value);\n    }\n\n    goog.asserts.assert(typeof(config) == 'object', 'Should be an object!');\n\n    // Deprecate 'manifest.dash.defaultPresentationDelay' configuration.\n    if (config['manifest'] && config['manifest']['dash'] &&\n          'defaultPresentationDelay' in config['manifest']['dash']) {\n      shaka.Deprecate.deprecateFeature(4,\n          'manifest.dash.defaultPresentationDelay configuration',\n          'Please Use manifest.defaultPresentationDelay instead.');\n      config['manifest']['defaultPresentationDelay'] =\n          config['manifest']['dash']['defaultPresentationDelay'];\n      delete config['manifest']['dash']['defaultPresentationDelay'];\n    }\n\n    goog.asserts.assert(\n        this.config_, 'Cannot reconfigure stroage after calling destroy.');\n    return shaka.util.PlayerConfiguration.mergeConfigObjects(\n        /* destination= */ this.config_, /* updates= */ config );\n  }\n\n  /**\n   * Return a copy of the current configuration.  Modifications of the returned\n   * value will not affect the Storage instance's active configuration.  You\n   * must call storage.configure() to make changes.\n   *\n   * @return {shaka.extern.PlayerConfiguration}\n   * @export\n   */\n  getConfiguration() {\n    goog.asserts.assert(this.config_, 'Config must not be null!');\n\n    const ret = shaka.util.PlayerConfiguration.createDefault();\n    shaka.util.PlayerConfiguration.mergeConfigObjects(\n        ret, this.config_, shaka.util.PlayerConfiguration.createDefault());\n    return ret;\n  }\n\n  /**\n   * Return the networking engine that storage is using. If storage was\n   * initialized with a player instance, then the networking engine returned\n   * will be the same as |player.getNetworkingEngine()|.\n   *\n   * The returned value will only be null if |destroy| was called before\n   * |getNetworkingEngine|.\n   *\n   * @return {shaka.net.NetworkingEngine}\n   * @export\n   */\n  getNetworkingEngine() {\n    return this.networkingEngine_;\n  }\n\n  /**\n   * Stores the given manifest.  If the content is encrypted, and encrypted\n   * content cannot be stored on this platform, the Promise will be rejected\n   * with error code 6001, REQUESTED_KEY_SYSTEM_CONFIG_UNAVAILABLE.\n   * Multiple assets can be downloaded at the same time, but note that since\n   * the storage instance has a single networking engine, multiple storage\n   * objects will be necessary if some assets require unique network filters.\n   * This snapshots the storage config at the time of the call, so it will not\n   * honor any changes to config mid-store operation.\n   *\n   * @param {string} uri The URI of the manifest to store.\n   * @param {!Object=} appMetadata An arbitrary object from the application\n   *   that will be stored along-side the offline content.  Use this for any\n   *   application-specific metadata you need associated with the stored\n   *   content.  For details on the data types that can be stored here, please\n   *   refer to {@link https://bit.ly/StructClone}\n   * @param {string=} mimeType\n   *   The mime type for the content |manifestUri| points to.\n   * @return {!shaka.extern.IAbortableOperation.<shaka.extern.StoredContent>}\n   *   An AbortableOperation that resolves with a structure representing what\n   *   was stored.  The \"offlineUri\" member is the URI that should be given to\n   *   Player.load() to play this piece of content offline.  The \"appMetadata\"\n   *   member is the appMetadata argument you passed to store().\n   *   If you want to cancel this download, call the \"abort\" method on\n   *   AbortableOperation.\n   * @export\n   */\n  store(uri, appMetadata, mimeType) {\n    goog.asserts.assert(\n        this.networkingEngine_,\n        'Cannot call |downloadManifest_| after calling |destroy|.');\n\n    // Get a copy of the current config.\n    const config = this.getConfiguration();\n\n    const getParser = async () => {\n      goog.asserts.assert(\n          this.networkingEngine_, 'Should not call |store| after |destroy|');\n\n      const factory = await shaka.media.ManifestParser.getFactory(\n          uri,\n          this.networkingEngine_,\n          config.manifest.retryParameters,\n          mimeType || null);\n\n      return shaka.util.Functional.callFactory(factory);\n    };\n\n    /** @type {!shaka.offline.DownloadManager} */\n    const downloader =\n        new shaka.offline.DownloadManager(this.networkingEngine_);\n    this.openDownloadManagers_.push(downloader);\n\n    const storeOp = this.store_(\n        uri, appMetadata || {}, getParser, config, downloader);\n    const abortableStoreOp = new shaka.util.AbortableOperation(storeOp, () => {\n      return downloader.abortAll();\n    });\n    abortableStoreOp.finally(() => {\n      shaka.util.ArrayUtils.remove(this.openDownloadManagers_, downloader);\n    });\n\n    // Provide a temporary shim for \"then\" for backward compatibility.\n    /** @type {!Object} */ (abortableStoreOp)['then'] = (onSuccess) => {\n      shaka.Deprecate.deprecateFeature(4,\n          'shaka.offline.Storage.store.then',\n          'Storage operations now return a shaka.util.AbortableOperation, ' +\n          'rather than a promise.  Please update to conform to this new API; ' +\n          'you can use the |chain| method instead.');\n      return abortableStoreOp.promise.then(onSuccess);\n    };\n\n    return this.startAbortableOperation_(abortableStoreOp);\n  }\n\n  /**\n   * Returns true if an asset is currently downloading.\n   *\n   * @return {boolean}\n   * @deprecated\n   * @export\n   */\n  getStoreInProgress() {\n    shaka.Deprecate.deprecateFeature(4,\n        'shaka.offline.Storage.getStoreInProgress',\n        'Multiple concurrent downloads are now supported.');\n    return false;\n  }\n\n  /**\n   * See |shaka.offline.Storage.store| for details.\n   *\n   * @param {string} uri\n   * @param {!Object} appMetadata\n   * @param {function():!Promise.<shaka.extern.ManifestParser>} getParser\n   * @param {shaka.extern.PlayerConfiguration} config\n   * @param {!shaka.offline.DownloadManager} downloader\n   * @return {!Promise.<shaka.extern.StoredContent>}\n   * @private\n   */\n  async store_(uri, appMetadata, getParser, config, downloader) {\n    this.requireSupport_();\n\n    // Since we will need to use |parser|, |drmEngine|, |activeHandle|, and\n    // |muxer| in the catch/finally blocks, we need to define them out here.\n    // Since they may not get initialized when we enter the catch/finally block,\n    // we need to assume that they may be null/undefined when we get there.\n\n    /** @type {?shaka.extern.ManifestParser} */\n    let parser = null;\n    /** @type {?shaka.media.DrmEngine} */\n    let drmEngine = null;\n    /** @type {shaka.offline.StorageMuxer} */\n    const muxer = new shaka.offline.StorageMuxer();\n    /** @type {?shaka.offline.StorageCellHandle} */\n    let activeHandle = null;\n\n    // This will be used to store any errors from drm engine. Whenever drm\n    // engine is passed to another function to do work, we should check if this\n    // was set.\n    let drmError = null;\n\n    try {\n      parser = await getParser();\n\n      const manifest = await this.parseManifest(uri, parser, config);\n\n      // Check if we were asked to destroy ourselves while we were \"away\"\n      // downloading the manifest.\n      this.ensureNotDestroyed_();\n\n      // Check if we can even download this type of manifest before trying to\n      // create the drm engine.\n      const canDownload = !manifest.presentationTimeline.isLive() &&\n                          !manifest.presentationTimeline.isInProgress();\n      if (!canDownload) {\n        throw new shaka.util.Error(\n            shaka.util.Error.Severity.CRITICAL,\n            shaka.util.Error.Category.STORAGE,\n            shaka.util.Error.Code.CANNOT_STORE_LIVE_OFFLINE,\n            uri);\n      }\n\n      drmEngine = await this.createDrmEngine(\n          manifest,\n          (e) => { drmError = drmError || e; },\n          config);\n\n      // We could have been asked to destroy ourselves while we were \"away\"\n      // creating the drm engine.\n      this.ensureNotDestroyed_();\n      if (drmError) {\n        throw drmError;\n      }\n\n      await this.filterManifest_(manifest, drmEngine, config);\n\n      await muxer.init();\n      this.ensureNotDestroyed_();\n\n      // Get the cell that we are saving the manifest to. Once we get a cell\n      // we will only reference the cell and not the muxer so that the manifest\n      // and segments will all be saved to the same cell.\n      activeHandle = await muxer.getActive();\n      this.ensureNotDestroyed_();\n\n      goog.asserts.assert(drmEngine, 'drmEngine should be non-null here.');\n\n      const manifestDB = await this.downloadManifest_(\n          activeHandle.cell, drmEngine, manifest, uri, appMetadata, config,\n          downloader);\n      this.ensureNotDestroyed_();\n      if (drmError) {\n        throw drmError;\n      }\n\n      const ids = await activeHandle.cell.addManifests([manifestDB]);\n      this.ensureNotDestroyed_();\n\n      const offlineUri = shaka.offline.OfflineUri.manifest(\n          activeHandle.path.mechanism, activeHandle.path.cell, ids[0]);\n\n      return shaka.offline.StoredContentUtils.fromManifestDB(\n          offlineUri, manifestDB);\n    } catch (e) {\n      // If we did start saving some data, we need to remove it all to avoid\n      // wasting storage. However if the muxer did not manage to initialize,\n      // then we won't have an active cell to remove the segments from.\n      if (activeHandle) {\n        await activeHandle.cell.removeSegments(\n            this.segmentsFromStore_, () => {});\n      }\n\n      // If we already had an error, ignore this error to avoid hiding\n      // the original error.\n      throw drmError || e;\n    } finally {\n      this.segmentsFromStore_ = [];\n\n      await muxer.destroy();\n\n      if (parser) {\n        await parser.stop();\n      }\n\n      if (drmEngine) {\n        await drmEngine.destroy();\n      }\n    }\n  }\n\n  /**\n   * Filter |manifest| such that it will only contain the variants and text\n   * streams that we want to store and can actually play.\n   *\n   * @param {shaka.extern.Manifest} manifest\n   * @param {!shaka.media.DrmEngine} drmEngine\n   * @param {shaka.extern.PlayerConfiguration} config\n   * @return {!Promise}\n   * @private\n   */\n  async filterManifest_(manifest, drmEngine, config) {\n    const StreamUtils = shaka.util.StreamUtils;\n\n    // Filter the manifest based on the restrictions given in the player\n    // configuration.\n    const maxHwRes = {width: Infinity, height: Infinity};\n    shaka.util.ManifestFilter.filterByRestrictions(\n        manifest, config.restrictions, maxHwRes);\n\n    // Filter the manifest based on what we know media source will be able to\n    // play later (no point storing something we can't play).\n    shaka.util.ManifestFilter.filterByMediaSourceSupport(manifest);\n\n    // Filter the manifest based on what we know our drm system will support\n    // playing later.\n    shaka.util.ManifestFilter.filterByDrmSupport(manifest, drmEngine);\n\n    // Gather all tracks.\n    const allTracks = [];\n\n    // Choose the codec that has the lowest average bandwidth.\n    const preferredAudioChannelCount = config.preferredAudioChannelCount;\n    shaka.util.StreamUtils.chooseCodecsAndFilterManifest(\n        manifest, preferredAudioChannelCount);\n\n    for (const variant of manifest.variants) {\n      goog.asserts.assert(\n          StreamUtils.isPlayable(variant),\n          'We should have already filtered by \"is playable\"');\n\n      allTracks.push(StreamUtils.variantToTrack(variant));\n    }\n\n    for (const text of manifest.textStreams) {\n      allTracks.push(StreamUtils.textStreamToTrack(text));\n    }\n\n    // Let the application choose which tracks to store.\n    const chosenTracks =\n        await config.offline.trackSelectionCallback(allTracks);\n\n    /** @type {!Set.<number>} */\n    const variantIds = new Set();\n    /** @type {!Set.<number>} */\n    const textIds = new Set();\n\n    // Collect the IDs of the chosen tracks.\n    for (const track of chosenTracks) {\n      if (track.type == 'variant') {\n        variantIds.add(track.id);\n      }\n      if (track.type == 'text') {\n        textIds.add(track.id);\n      }\n    }\n\n    // Filter the manifest to keep only what the app chose.\n    manifest.variants =\n        manifest.variants.filter((variant) => variantIds.has(variant.id));\n    manifest.textStreams =\n        manifest.textStreams.filter((stream) => textIds.has(stream.id));\n\n    // Check the post-filtered manifest for characteristics that may indicate\n    // issues with how the app selected tracks.\n    shaka.offline.Storage.validateManifest_(manifest);\n  }\n\n  /**\n   * Create a download manager and download the manifest.\n   *\n   * @param {shaka.extern.StorageCell} storage\n   * @param {!shaka.media.DrmEngine} drmEngine\n   * @param {shaka.extern.Manifest} manifest\n   * @param {string} uri\n   * @param {!Object} metadata\n   * @param {shaka.extern.PlayerConfiguration} config\n   * @param {!shaka.offline.DownloadManager} downloader\n   * @return {!Promise.<shaka.extern.ManifestDB>}\n   * @private\n   */\n  async downloadManifest_(\n      storage, drmEngine, manifest, uri, metadata, config, downloader) {\n    const pendingContent = shaka.offline.StoredContentUtils.fromManifest(\n        uri, manifest, /* size= */ 0, metadata);\n    // In https://github.com/google/shaka-player/issues/2652, we found that this\n    // callback would be removed by the compiler if we reference the config in\n    // the onProgress closure below.  Reading it into a local variable first\n    // seems to work around this apparent compiler bug.\n    const progressCallback = config.offline.progressCallback;\n\n    const onProgress = (progress, size) => {\n      // Update the size of the stored content before issuing a progress\n      // update.\n      pendingContent.size = size;\n      progressCallback(pendingContent, progress);\n    };\n    const onInitData = (initData, systemId) => {\n      if (needsInitData && config.offline.usePersistentLicense &&\n          currentSystemId == systemId) {\n        drmEngine.newInitData('cenc', initData);\n      }\n    };\n    downloader.setCallbacks(onProgress, onInitData);\n\n    const isEncrypted = manifest.variants.some((variant) => {\n      const videoEncrypted = variant.video && variant.video.encrypted;\n      const audioEncrypted = variant.audio && variant.audio.encrypted;\n      return videoEncrypted || audioEncrypted;\n    });\n    const includesInitData = manifest.variants.some((variant) => {\n      const videoDrmInfos = variant.video ? variant.video.drmInfos : [];\n      const audioDrmInfos = variant.audio ? variant.audio.drmInfos : [];\n      const drmInfos = videoDrmInfos.concat(audioDrmInfos);\n      return drmInfos.some((drmInfos) => {\n        return drmInfos.initData && drmInfos.initData.length;\n      });\n    });\n    const needsInitData = isEncrypted && !includesInitData;\n\n    let currentSystemId = null;\n    if (needsInitData) {\n      const drmInfo = drmEngine.getDrmInfo();\n      currentSystemId =\n          shaka.offline.Storage.defaultSystemIds_.get(drmInfo.keySystem);\n    }\n\n    try {\n      const manifestDB = this.createOfflineManifest_(\n          downloader, storage, drmEngine, manifest, uri, metadata, config);\n\n      manifestDB.size = await downloader.waitToFinish();\n      manifestDB.expiration = drmEngine.getExpiration();\n      const sessions = drmEngine.getSessionIds();\n      manifestDB.sessionIds = config.offline.usePersistentLicense ?\n          sessions : [];\n\n      if (isEncrypted && config.offline.usePersistentLicense &&\n          !sessions.length) {\n        throw new shaka.util.Error(\n            shaka.util.Error.Severity.CRITICAL,\n            shaka.util.Error.Category.STORAGE,\n            shaka.util.Error.Code.NO_INIT_DATA_FOR_OFFLINE);\n      }\n\n      return manifestDB;\n    } finally {\n      await downloader.destroy();\n    }\n  }\n\n  /**\n   * Removes the given stored content.  This will also attempt to release the\n   * licenses, if any.\n   *\n   * @param {string} contentUri\n   * @return {!Promise}\n   * @export\n   */\n  remove(contentUri) {\n    return this.startOperation_(this.remove_(contentUri));\n  }\n\n  /**\n   * See |shaka.offline.Storage.remove| for details.\n   *\n   * @param {string} contentUri\n   * @return {!Promise}\n   * @private\n   */\n  async remove_(contentUri) {\n    this.requireSupport_();\n\n    const nullableUri = shaka.offline.OfflineUri.parse(contentUri);\n    if (nullableUri == null || !nullableUri.isManifest()) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.STORAGE,\n          shaka.util.Error.Code.MALFORMED_OFFLINE_URI,\n          contentUri);\n    }\n\n    /** @type {!shaka.offline.OfflineUri} */\n    const uri = nullableUri;\n\n    /** @type {!shaka.offline.StorageMuxer} */\n    const muxer = new shaka.offline.StorageMuxer();\n\n    try {\n      await muxer.init();\n\n      const cell = await muxer.getCell(uri.mechanism(), uri.cell());\n      const manifests = await cell.getManifests([uri.key()]);\n      const manifest = manifests[0];\n\n      await Promise.all([\n        this.removeFromDRM_(uri, manifest, muxer),\n        this.removeFromStorage_(cell, uri, manifest),\n      ]);\n    } finally {\n      await muxer.destroy();\n    }\n  }\n\n  /**\n   * @param {shaka.extern.ManifestDB} manifestDb\n   * @param {boolean} isVideo\n   * @return {!Array.<MediaKeySystemMediaCapability>}\n   * @private\n   */\n  static getCapabilities_(manifestDb, isVideo) {\n    const MimeUtils = shaka.util.MimeUtils;\n\n    const ret = [];\n    for (const stream of manifestDb.streams) {\n      if (isVideo && stream.type == 'video') {\n        ret.push({\n          contentType: MimeUtils.getFullType(stream.mimeType, stream.codecs),\n          robustness: manifestDb.drmInfo.videoRobustness,\n        });\n      } else if (!isVideo && stream.type == 'audio') {\n        ret.push({\n          contentType: MimeUtils.getFullType(stream.mimeType, stream.codecs),\n          robustness: manifestDb.drmInfo.audioRobustness,\n        });\n      }\n    }\n    return ret;\n  }\n\n  /**\n   * @param {!shaka.offline.OfflineUri} uri\n   * @param {shaka.extern.ManifestDB} manifestDb\n   * @param {!shaka.offline.StorageMuxer} muxer\n   * @return {!Promise}\n   * @private\n   */\n  async removeFromDRM_(uri, manifestDb, muxer) {\n    goog.asserts.assert(this.networkingEngine_, 'Cannot be destroyed');\n    await shaka.offline.Storage.deleteLicenseFor_(\n        this.networkingEngine_, this.config_.drm, muxer, manifestDb);\n  }\n\n  /**\n   * @param {shaka.extern.StorageCell} storage\n   * @param {!shaka.offline.OfflineUri} uri\n   * @param {shaka.extern.ManifestDB} manifest\n   * @return {!Promise}\n   * @private\n   */\n  removeFromStorage_( storage, uri, manifest) {\n    /** @type {!Array.<number>} */\n    const segmentIds = shaka.offline.Storage.getAllSegmentIds_(manifest);\n\n    // Count(segments) + Count(manifests)\n    const toRemove = segmentIds.length + 1;\n    let removed = 0;\n\n    const pendingContent = shaka.offline.StoredContentUtils.fromManifestDB(\n        uri, manifest);\n\n    const onRemove = (key) => {\n      removed += 1;\n      this.config_.offline.progressCallback(pendingContent, removed / toRemove);\n    };\n\n    return Promise.all([\n      storage.removeSegments(segmentIds, onRemove),\n      storage.removeManifests([uri.key()], onRemove),\n    ]);\n  }\n\n  /**\n   * Removes any EME sessions that were not successfully removed before.  This\n   * returns whether all the sessions were successfully removed.\n   *\n   * @return {!Promise.<boolean>}\n   * @export\n   */\n  removeEmeSessions() {\n    return this.startOperation_(this.removeEmeSessions_());\n  }\n\n  /**\n   * @return {!Promise.<boolean>}\n   * @private\n   */\n  async removeEmeSessions_() {\n    this.requireSupport_();\n\n    goog.asserts.assert(this.networkingEngine_, 'Cannot be destroyed');\n    const net = this.networkingEngine_;\n    const config = this.config_.drm;\n\n    /** @type {!shaka.offline.StorageMuxer} */\n    const muxer = new shaka.offline.StorageMuxer();\n    /** @type {!shaka.offline.SessionDeleter} */\n    const deleter = new shaka.offline.SessionDeleter();\n\n    let hasRemaining = false;\n\n    try {\n      await muxer.init();\n\n      /** @type {!Array.<shaka.extern.EmeSessionStorageCell>} */\n      const cells = [];\n      muxer.forEachEmeSessionCell((c) => cells.push(c));\n\n      // Run these sequentially to avoid creating too many DrmEngine instances\n      // and having multiple CDMs alive at once.  Some embedded platforms may\n      // not support that.\n      for (const sessionIdCell of cells) {\n        /* eslint-disable no-await-in-loop */\n        const sessions = await sessionIdCell.getAll();\n        const deletedSessionIds = await deleter.delete(config, net, sessions);\n        await sessionIdCell.remove(deletedSessionIds);\n\n        if (deletedSessionIds.length != sessions.length) {\n          hasRemaining = true;\n        }\n        /* eslint-enable no-await-in-loop */\n      }\n    } finally {\n      await muxer.destroy();\n    }\n\n    return !hasRemaining;\n  }\n\n  /**\n   * Lists all the stored content available.\n   *\n   * @return {!Promise.<!Array.<shaka.extern.StoredContent>>}  A Promise to an\n   *   array of structures representing all stored content.  The \"offlineUri\"\n   *   member of the structure is the URI that should be given to Player.load()\n   *   to play this piece of content offline.  The \"appMetadata\" member is the\n   *   appMetadata argument you passed to store().\n   * @export\n   */\n  list() {\n    return this.startOperation_(this.list_());\n  }\n\n  /**\n   * See |shaka.offline.Storage.list| for details.\n   *\n   * @return {!Promise.<!Array.<shaka.extern.StoredContent>>}\n   * @private\n   */\n  async list_() {\n    this.requireSupport_();\n\n    /** @type {!Array.<shaka.extern.StoredContent>} */\n    const result = [];\n\n    /** @type {!shaka.offline.StorageMuxer} */\n    const muxer = new shaka.offline.StorageMuxer();\n    try {\n      await muxer.init();\n\n      let p = Promise.resolve();\n      muxer.forEachCell((path, cell) => {\n        p = p.then(async () => {\n          const manifests = await cell.getAllManifests();\n\n          manifests.forEach((manifest, key) => {\n            const uri = shaka.offline.OfflineUri.manifest(\n                path.mechanism,\n                path.cell,\n                key);\n\n            const content = shaka.offline.StoredContentUtils.fromManifestDB(\n                uri,\n                manifest);\n\n            result.push(content);\n          });\n        });\n      });\n\n      await p;\n    } finally {\n      await muxer.destroy();\n    }\n\n    return result;\n  }\n\n\n  /**\n   * This method is public so that it can be overridden in testing.\n   *\n   * @param {string} uri\n   * @param {shaka.extern.ManifestParser} parser\n   * @param {shaka.extern.PlayerConfiguration} config\n   * @return {!Promise.<shaka.extern.Manifest>}\n   */\n  async parseManifest(uri, parser, config) {\n    let error = null;\n\n    const networkingEngine = this.networkingEngine_;\n    goog.asserts.assert(networkingEngine, 'Should be initialized!');\n\n    /** @type {shaka.extern.ManifestParser.PlayerInterface} */\n    const playerInterface = {\n      networkingEngine: networkingEngine,\n\n      // Don't bother filtering now. We will do that later when we have all the\n      // information we need to filter.\n      filter: () => Promise.resolve(),\n\n      // The responsibility for making mock text streams for closed captions is\n      // handled inside shaka.offline.OfflineManifestParser, before playback.\n      makeTextStreamsForClosedCaptions: (manifest) => {},\n\n      onTimelineRegionAdded: () => {},\n      onEvent: () => {},\n\n      // Used to capture an error from the manifest parser. We will check the\n      // error before returning.\n      onError: (e) => {\n        error = e;\n      },\n    };\n\n    parser.configure(config.manifest);\n\n    // We may have been destroyed while we were waiting on |getParser| to\n    // resolve.\n    this.ensureNotDestroyed_();\n\n    const manifest = await parser.start(uri, playerInterface);\n\n    // We may have been destroyed while we were waiting on |start| to\n    // resolve.\n    this.ensureNotDestroyed_();\n\n    // Get all the streams that are used in the manifest.\n    const streams =\n        shaka.offline.Storage.getAllStreamsFromManifest_(manifest);\n\n    // Wait for each stream to create their segment indexes.\n    await Promise.all(shaka.util.Iterables.map(streams, (stream) => {\n      return stream.createSegmentIndex();\n    }));\n\n    // We may have been destroyed while we were waiting on\n    // |createSegmentIndex| to resolve for each stream.\n    this.ensureNotDestroyed_();\n\n    // If we saw an error while parsing, surface the error.\n    if (error) {\n      throw error;\n    }\n\n    return manifest;\n  }\n\n  /**\n   * This method is public so that it can be override in testing.\n   *\n   * @param {shaka.extern.Manifest} manifest\n   * @param {function(shaka.util.Error)} onError\n   * @param {shaka.extern.PlayerConfiguration} config\n   * @return {!Promise.<!shaka.media.DrmEngine>}\n   */\n  async createDrmEngine(manifest, onError, config) {\n    goog.asserts.assert(\n        this.networkingEngine_,\n        'Cannot call |createDrmEngine| after |destroy|');\n\n    /** @type {!shaka.media.DrmEngine} */\n    const drmEngine = new shaka.media.DrmEngine({\n      netEngine: this.networkingEngine_,\n      onError: onError,\n      onKeyStatus: () => {},\n      onExpirationUpdated: () => {},\n      onEvent: () => {},\n    });\n\n    drmEngine.configure(config.drm);\n    await drmEngine.initForStorage(\n        manifest.variants, config.offline.usePersistentLicense);\n    await drmEngine.setServerCertificate();\n    await drmEngine.createOrLoad();\n\n    return drmEngine;\n  }\n\n  /**\n   * Creates an offline 'manifest' for the real manifest.  This does not store\n   * the segments yet, only adds them to the download manager through\n   * createStreams_.\n   *\n   * @param {!shaka.offline.DownloadManager} downloader\n   * @param {shaka.extern.StorageCell} storage\n   * @param {!shaka.media.DrmEngine} drmEngine\n   * @param {shaka.extern.Manifest} manifest\n   * @param {string} originalManifestUri\n   * @param {!Object} metadata\n   * @param {shaka.extern.PlayerConfiguration} config\n   * @return {shaka.extern.ManifestDB}\n   * @private\n   */\n  createOfflineManifest_(\n      downloader, storage, drmEngine, manifest, originalManifestUri, metadata,\n      config) {\n    const estimator = new shaka.offline.StreamBandwidthEstimator();\n\n    const streams = this.createStreams_(\n        downloader, storage, estimator, drmEngine, manifest, config);\n\n    const usePersistentLicense = config.offline.usePersistentLicense;\n    const drmInfo = drmEngine.getDrmInfo();\n\n    if (drmInfo && usePersistentLicense) {\n      // Don't store init data, since we have stored sessions.\n      drmInfo.initData = [];\n    }\n\n    return {\n      creationTime: Date.now(),\n      originalManifestUri: originalManifestUri,\n      duration: manifest.presentationTimeline.getDuration(),\n      size: 0,\n      expiration: drmEngine.getExpiration(),\n      streams: streams,\n      sessionIds: usePersistentLicense ? drmEngine.getSessionIds() : [],\n      drmInfo: drmInfo,\n      appMetadata: metadata,\n    };\n  }\n\n  /**\n   * Converts manifest Streams to database Streams.  This will use the current\n   * configuration to get the tracks to use, then it will search each segment\n   * index and add all the segments to the download manager through\n   * createStream_.\n   *\n   * @param {!shaka.offline.DownloadManager} downloader\n   * @param {shaka.extern.StorageCell} storage\n   * @param {shaka.offline.StreamBandwidthEstimator} estimator\n   * @param {!shaka.media.DrmEngine} drmEngine\n   * @param {shaka.extern.Manifest} manifest\n   * @param {shaka.extern.PlayerConfiguration} config\n   * @return {!Array.<shaka.extern.StreamDB>}\n   * @private\n   */\n  createStreams_(downloader, storage, estimator, drmEngine, manifest, config) {\n    // Pass all variants and text streams to the estimator so that we can\n    // get the best estimate for each stream later.\n    for (const variant of manifest.variants) {\n      estimator.addVariant(variant);\n    }\n    for (const text of manifest.textStreams) {\n      estimator.addText(text);\n    }\n\n    // Find the streams we want to download and create a stream db instance\n    // for each of them.\n    const streamSet =\n        shaka.offline.Storage.getAllStreamsFromManifest_(manifest);\n    const streamDBs = new Map();\n\n    for (const stream of streamSet) {\n      const streamDB = this.createStream_(\n          downloader, storage, estimator, manifest, stream, config);\n      streamDBs.set(stream.id, streamDB);\n    }\n\n    // Connect streams and variants together.\n    for (const variant of manifest.variants) {\n      if (variant.audio) {\n        streamDBs.get(variant.audio.id).variantIds.push(variant.id);\n      }\n      if (variant.video) {\n        streamDBs.get(variant.video.id).variantIds.push(variant.id);\n      }\n    }\n\n    return Array.from(streamDBs.values());\n  }\n\n  /**\n   * Converts a manifest stream to a database stream.  This will search the\n   * segment index and add all the segments to the download manager.\n   *\n   * @param {!shaka.offline.DownloadManager} downloader\n   * @param {shaka.extern.StorageCell} storage\n   * @param {shaka.offline.StreamBandwidthEstimator} estimator\n   * @param {shaka.extern.Manifest} manifest\n   * @param {shaka.extern.Stream} stream\n   * @param {shaka.extern.PlayerConfiguration} config\n   * @return {shaka.extern.StreamDB}\n   * @private\n   */\n  createStream_(downloader, storage, estimator, manifest, stream, config) {\n    /** @type {shaka.extern.StreamDB} */\n    const streamDb = {\n      id: stream.id,\n      originalId: stream.originalId,\n      primary: stream.primary,\n      type: stream.type,\n      mimeType: stream.mimeType,\n      codecs: stream.codecs,\n      frameRate: stream.frameRate,\n      pixelAspectRatio: stream.pixelAspectRatio,\n      kind: stream.kind,\n      language: stream.language,\n      label: stream.label,\n      width: stream.width || null,\n      height: stream.height || null,\n      encrypted: stream.encrypted,\n      keyIds: stream.keyIds,\n      segments: [],\n      variantIds: [],\n      roles: stream.roles,\n      channelsCount: stream.channelsCount,\n      audioSamplingRate: stream.audioSamplingRate,\n      closedCaptions: stream.closedCaptions,\n    };\n\n    // Download each stream in parallel.\n    const downloadGroup = stream.id;\n\n    const startTime =\n        manifest.presentationTimeline.getSegmentAvailabilityStart();\n\n    shaka.offline.Storage.forEachSegment_(stream, startTime, (segment) => {\n      const initSegmentKeyPromise = this.getInitSegmentDbKey_(\n          downloader, downloadGroup, stream.id, storage, estimator,\n          segment.initSegmentReference, config);\n\n      const segmentKeyPromise = this.getSegmentDbKey_(\n          downloader, downloadGroup, stream.id, storage, estimator, segment,\n          config);\n\n      downloader.queueWork(downloadGroup, async () => {\n        const initSegmentKey = await initSegmentKeyPromise;\n        const dataKey = await segmentKeyPromise;\n\n        streamDb.segments.push({\n          initSegmentKey,\n          startTime: segment.startTime,\n          endTime: segment.endTime,\n          appendWindowStart: segment.appendWindowStart,\n          appendWindowEnd: segment.appendWindowEnd,\n          timestampOffset: segment.timestampOffset,\n          dataKey,\n        });\n      });\n    });\n\n    return streamDb;\n  }\n\n  /**\n   * Get a Promise to the DB key for a given init segment reference.\n   *\n   * The return values will be cached so that multiple calls with the same init\n   * segment reference will only trigger one request.\n   *\n   * @param {!shaka.offline.DownloadManager} downloader\n   * @param {number} downloadGroup\n   * @param {number} streamId\n   * @param {shaka.extern.StorageCell} storage\n   * @param {shaka.offline.StreamBandwidthEstimator} estimator\n   * @param {shaka.media.InitSegmentReference} initSegmentReference\n   * @param {shaka.extern.PlayerConfiguration} config\n   * @return {!Promise.<?number>}\n   * @private\n   */\n  getInitSegmentDbKey_(\n      downloader, downloadGroup, streamId, storage, estimator,\n      initSegmentReference, config) {\n    if (this.initSegmentDbKeyCache_.has(initSegmentReference)) {\n      return this.initSegmentDbKeyCache_.get(initSegmentReference);\n    }\n\n    const request = shaka.util.Networking.createSegmentRequest(\n        initSegmentReference.getUris(),\n        initSegmentReference.startByte,\n        initSegmentReference.endByte,\n        config.streaming.retryParameters);\n\n    const promise = downloader.queue(\n        downloadGroup,\n        request,\n        estimator.getInitSegmentEstimate(streamId),\n        /* isInitSegment= */ true,\n        async (data) => {\n          /** @type {!Array.<number>} */\n          const ids = await storage.addSegments([{data: data}]);\n          this.segmentsFromStore_.push(ids[0]);\n          return ids[0];\n        });\n\n    this.initSegmentDbKeyCache_.set(initSegmentReference, promise);\n    return promise;\n  }\n\n  /**\n   * Get a Promise to the DB key for a given segment reference.\n   *\n   * The return values will be cached so that multiple calls with the same\n   * segment reference will only trigger one request.\n   *\n   * @param {!shaka.offline.DownloadManager} downloader\n   * @param {number} downloadGroup\n   * @param {number} streamId\n   * @param {shaka.extern.StorageCell} storage\n   * @param {shaka.offline.StreamBandwidthEstimator} estimator\n   * @param {shaka.media.SegmentReference} segmentReference\n   * @param {shaka.extern.PlayerConfiguration} config\n   * @return {!Promise.<number>}\n   * @private\n   */\n  getSegmentDbKey_(\n      downloader, downloadGroup, streamId, storage, estimator,\n      segmentReference, config) {\n    const mapKey = [\n      segmentReference.getUris()[0],\n      segmentReference.startByte,\n      segmentReference.endByte,\n    ].join('-');\n\n    if (this.segmentDbKeyCache_.has(mapKey)) {\n      return this.segmentDbKeyCache_.get(mapKey);\n    }\n\n    const request = shaka.util.Networking.createSegmentRequest(\n        segmentReference.getUris(),\n        segmentReference.startByte,\n        segmentReference.endByte,\n        config.streaming.retryParameters);\n\n    const promise = downloader.queue(\n        downloadGroup,\n        request,\n        estimator.getSegmentEstimate(streamId, segmentReference),\n        /* isInitSegment= */ false,\n        async (data) => {\n          /** @type {!Array.<number>} */\n          const ids = await storage.addSegments([{data: data}]);\n          this.segmentsFromStore_.push(ids[0]);\n          return ids[0];\n        });\n\n    this.segmentDbKeyCache_.set(mapKey, promise);\n    return promise;\n  }\n\n  /**\n   * @param {shaka.extern.Stream} stream\n   * @param {number} startTime\n   * @param {function(!shaka.media.SegmentReference)} callback\n   * @private\n   */\n  static forEachSegment_(stream, startTime, callback) {\n    /** @type {?number} */\n    let i = stream.segmentIndex.find(startTime);\n\n    if (i == null) {\n      return;\n    }\n\n    /** @type {?shaka.media.SegmentReference} */\n    let ref = stream.segmentIndex.get(i);\n    while (ref) {\n      callback(ref);\n      ref = stream.segmentIndex.get(++i);\n    }\n  }\n\n  /**\n   * Throws an error if the object is destroyed.\n   * @private\n   */\n  ensureNotDestroyed_() {\n    if (this.destroyer_.destroyed()) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.STORAGE,\n          shaka.util.Error.Code.OPERATION_ABORTED);\n    }\n  }\n\n  /**\n   * Used by functions that need storage support to ensure that the current\n   * platform has storage support before continuing. This should only be\n   * needed to be used at the start of public methods.\n   *\n   * @private\n   */\n  requireSupport_() {\n    if (!shaka.offline.Storage.support()) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.STORAGE,\n          shaka.util.Error.Code.STORAGE_NOT_SUPPORTED);\n    }\n  }\n\n  /**\n   * Perform an action. Track the action's progress so that when we destroy\n   * we will wait until all the actions have completed before allowing destroy\n   * to resolve.\n   *\n   * @param {!Promise<T>} action\n   * @return {!Promise<T>}\n   * @template T\n   * @private\n   */\n  async startOperation_(action) {\n    this.openOperations_.push(action);\n\n    try {\n      // Await |action| so we can use the finally statement to remove |action|\n      // from |openOperations_| when we still have a reference to |action|.\n      return await action;\n    } finally {\n      shaka.util.ArrayUtils.remove(this.openOperations_, action);\n    }\n  }\n\n  /**\n   * The equivalent of startOperation_, but for abortable operations.\n   *\n   * @param {!shaka.extern.IAbortableOperation<T>} action\n   * @return {!shaka.extern.IAbortableOperation<T>}\n   * @template T\n   * @private\n   */\n  startAbortableOperation_(action) {\n    const promise = action.promise;\n    this.openOperations_.push(promise);\n\n    // Remove the open operation once the action has completed. So that we\n    // can still return the AbortableOperation, this is done using a |finally|\n    // block, rather than awaiting the result.\n    return action.finally(() => {\n      shaka.util.ArrayUtils.remove(this.openOperations_, promise);\n    });\n  }\n\n  /**\n   * @param {shaka.extern.ManifestDB} manifest\n   * @return {!Array.<number>}\n   * @private\n   */\n  static getAllSegmentIds_(manifest) {\n    /** @type {!Array.<number>} */\n    const ids = [];\n\n    // Get every segment for every stream in the manifest.\n    for (const stream of manifest.streams) {\n      for (const segment of stream.segments) {\n        if (segment.initSegmentKey != null) {\n          ids.push(segment.initSegmentKey);\n        }\n\n        ids.push(segment.dataKey);\n      }\n    }\n\n    return ids;\n  }\n\n  /**\n   * Delete the on-disk storage and all the content it contains. This should not\n   * be done in normal circumstances. Only do it when storage is rendered\n   * unusable, such as by a version mismatch. No business logic will be run, and\n   * licenses will not be released.\n   *\n   * @return {!Promise}\n   * @export\n   */\n  static async deleteAll() {\n    /** @type {!shaka.offline.StorageMuxer} */\n    const muxer = new shaka.offline.StorageMuxer();\n    try {\n      // Wipe all content from all storage mechanisms.\n      await muxer.erase();\n    } finally {\n      // Destroy the muxer, whether or not erase() succeeded.\n      await muxer.destroy();\n    }\n  }\n\n  /**\n   * @param {!shaka.net.NetworkingEngine} net\n   * @param {!shaka.extern.DrmConfiguration} drmConfig\n   * @param {!shaka.offline.StorageMuxer} muxer\n   * @param {shaka.extern.ManifestDB} manifestDb\n   * @return {!Promise}\n   * @private\n   */\n  static async deleteLicenseFor_(net, drmConfig, muxer, manifestDb) {\n    if (!manifestDb.drmInfo) {\n      return;\n    }\n\n    const sessionIdCell = muxer.getEmeSessionCell();\n\n    /** @type {!Array.<shaka.extern.EmeSessionDB>} */\n    const sessions = manifestDb.sessionIds.map((sessionId) => {\n      return {\n        sessionId: sessionId,\n        keySystem: manifestDb.drmInfo.keySystem,\n        licenseUri: manifestDb.drmInfo.licenseServerUri,\n        serverCertificate: manifestDb.drmInfo.serverCertificate,\n        audioCapabilities: shaka.offline.Storage.getCapabilities_(\n            manifestDb,\n            /* isVideo= */ false),\n        videoCapabilities: shaka.offline.Storage.getCapabilities_(\n            manifestDb,\n            /* isVideo= */ true),\n      };\n    });\n    // Try to delete the sessions; any sessions that weren't deleted get stored\n    // in the database so we can try to remove them again later.  This allows us\n    // to still delete the stored content but not \"forget\" about these sessions.\n    // Later, we can remove the sessions to free up space.\n    const deleter = new shaka.offline.SessionDeleter();\n    const deletedSessionIds = await deleter.delete(drmConfig, net, sessions);\n    await sessionIdCell.remove(deletedSessionIds);\n    await sessionIdCell.add(sessions.filter(\n        (session) => !deletedSessionIds.includes(session.sessionId)));\n  }\n\n  /**\n   * Get the set of all streams in |manifest|.\n   *\n   * @param {shaka.extern.Manifest} manifest\n   * @return {!Set.<shaka.extern.Stream>}\n   * @private\n   */\n  static getAllStreamsFromManifest_(manifest) {\n    /** @type {!Set.<shaka.extern.Stream>} */\n    const set = new Set();\n\n    for (const text of manifest.textStreams) {\n      set.add(text);\n    }\n\n    for (const variant of manifest.variants) {\n      if (variant.audio) {\n        set.add(variant.audio);\n      }\n      if (variant.video) {\n        set.add(variant.video);\n      }\n    }\n\n    return set;\n  }\n\n  /**\n   * Go over a manifest and issue warnings for any suspicious properties.\n   *\n   * @param {shaka.extern.Manifest} manifest\n   * @private\n   */\n  static validateManifest_(manifest) {\n    const videos = new Set(manifest.variants.map((v) => v.video));\n    const audios = new Set(manifest.variants.map((v) => v.audio));\n    const texts = manifest.textStreams;\n\n    if (videos.size > 1) {\n      shaka.log.warning('Multiple video tracks selected to be stored');\n    }\n\n    for (const audio1 of audios) {\n      for (const audio2 of audios) {\n        if (audio1 != audio2 && audio1.language == audio2.language) {\n          shaka.log.warning(\n              'Similar audio tracks were selected to be stored',\n              audio1.id,\n              audio2.id);\n        }\n      }\n    }\n\n    for (const text1 of texts) {\n      for (const text2 of texts) {\n        if (text1 != text2 && text1.language == text2.language) {\n          shaka.log.warning(\n              'Similar text tracks were selected to be stored',\n              text1.id,\n              text2.id);\n        }\n      }\n    }\n  }\n};\n\nshaka.offline.Storage.defaultSystemIds_ = new Map()\n    .set('org.w3.clearkey', '1077efecc0b24d02ace33c1e52e2fb4b')\n    .set('com.widevine.alpha', 'edef8ba979d64acea3c827dcd51d21ed')\n    .set('com.microsoft.playready', '9a04f07998404286ab92e65be0885f95')\n    .set('com.adobe.primetime', 'f239e769efa348509c16a903c6932efb');\n\nshaka.Player.registerSupportPlugin('offline', shaka.offline.Storage.support);\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.util.ManifestFilter');\n\ngoog.require('shaka.media.MediaSourceEngine');\ngoog.require('shaka.util.StreamUtils');\ngoog.requireType('shaka.media.DrmEngine');\n\n\n/**\n * This utility class contains all the functions used to filter manifests\n * before playback and before storage.\n */\nshaka.util.ManifestFilter = class {\n  /**\n   * Filter the variants in |manifest| to only include the variants that meet\n   * the given restrictions.\n   *\n   * @param {shaka.extern.Manifest} manifest\n   * @param {shaka.extern.Restrictions} restrictions\n   * @param {{width: number, height:number}} maxHwResolution\n   */\n  static filterByRestrictions(manifest, restrictions, maxHwResolution) {\n    manifest.variants = manifest.variants.filter((variant) => {\n      return shaka.util.StreamUtils.meetsRestrictions(\n          variant, restrictions, maxHwResolution);\n    });\n  }\n\n\n  /**\n   * Filter the variants in the |manifest| to only include those that are\n   * supported by media source.\n   *\n   * @param {shaka.extern.Manifest} manifest\n   */\n  static filterByMediaSourceSupport(manifest) {\n    const MediaSourceEngine = shaka.media.MediaSourceEngine;\n\n    manifest.variants = manifest.variants.filter((variant) => {\n      let supported = true;\n      if (variant.audio) {\n        supported =\n            supported && MediaSourceEngine.isStreamSupported(variant.audio);\n      }\n      if (variant.video) {\n        supported =\n            supported && MediaSourceEngine.isStreamSupported(variant.video);\n      }\n      return supported;\n    });\n  }\n\n  /**\n   * Filter the variants in |manifest| to only include those that are supported\n   * by |drm|.\n   *\n   * @param {shaka.extern.Manifest} manifest\n   * @param {!shaka.media.DrmEngine} drmEngine\n   */\n  static filterByDrmSupport(manifest, drmEngine) {\n    manifest.variants = manifest.variants.filter((variant) => {\n      return drmEngine.supportsVariant(variant);\n    });\n  }\n};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.polyfill');\n\ngoog.require('shaka.log');\ngoog.require('shaka.util.Iterables');\n\n\n/**\n * @summary A one-stop installer for all polyfills.\n * @see http://enwp.org/polyfill\n * @export\n */\nshaka.polyfill = class {\n  /**\n   * Install all polyfills.\n   * @export\n   */\n  static installAll() {\n    for (const polyfill of shaka.polyfill.polyfills_) {\n      try {\n        polyfill.callback();\n      } catch (error) {\n        shaka.log.alwaysWarn('Error installing polyfill!', error);\n      }\n    }\n  }\n\n  /**\n   * Registers a new polyfill to be installed.\n   *\n   * @param {function()} polyfill\n   * @param {number=} priority An optional number priority.  Higher priorities\n   *   will be executed before lower priority ones.  Default is 0.\n   * @export\n   */\n  static register(polyfill, priority) {\n    const newItem = {priority: priority || 0, callback: polyfill};\n    const enumerate = (it) => shaka.util.Iterables.enumerate(it);\n    for (const {i, item} of enumerate(shaka.polyfill.polyfills_)) {\n      if (item.priority < newItem.priority) {\n        shaka.polyfill.polyfills_.splice(i, 0, newItem);\n        return;\n      }\n    }\n    shaka.polyfill.polyfills_.push(newItem);\n  }\n};\n\n\n/**\n * Contains the polyfills that will be installed.\n * @private {!Array.<{priority: number, callback: function()}>}\n */\nshaka.polyfill.polyfills_ = [];\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.polyfill.Fullscreen');\n\ngoog.require('shaka.polyfill');\n\n\n/**\n * @summary A polyfill to unify fullscreen APIs across browsers.\n * Many browsers have prefixed fullscreen methods on Element and document.\n * See {@link https://mzl.la/2K0xcHo Using fullscreen mode} on MDN for more\n * information.\n */\nshaka.polyfill.Fullscreen = class {\n  /**\n   * Install the polyfill if needed.\n   */\n  static install() {\n    if (!window.Document) {\n      // Avoid errors on very old browsers.\n      return;\n    }\n\n    // eslint-disable-next-line no-restricted-syntax\n    let proto = Element.prototype;\n    proto.requestFullscreen = proto.requestFullscreen ||\n                              proto.mozRequestFullScreen ||\n                              proto.msRequestFullscreen ||\n                              proto.webkitRequestFullscreen;\n\n    // eslint-disable-next-line no-restricted-syntax\n    proto = Document.prototype;\n    proto.exitFullscreen = proto.exitFullscreen ||\n                           proto.mozCancelFullScreen ||\n                           proto.msExitFullscreen ||\n                           proto.webkitCancelFullScreen;\n\n    if (!('fullscreenElement' in document)) {\n      Object.defineProperty(document, 'fullscreenElement', {\n        get: () => {\n          return document.mozFullScreenElement ||\n                 document.msFullscreenElement ||\n                 document.webkitCurrentFullScreenElement ||\n                 document.webkitFullscreenElement;\n        },\n      });\n      Object.defineProperty(document, 'fullscreenEnabled', {\n        get: () => {\n          return document.mozFullScreenEnabled ||\n                 document.msFullscreenEnabled ||\n                 document.webkitFullscreenEnabled;\n        },\n      });\n    }\n\n    const proxy = shaka.polyfill.Fullscreen.proxyEvent_;\n    document.addEventListener('webkitfullscreenchange', proxy);\n    document.addEventListener('webkitfullscreenerror', proxy);\n    document.addEventListener('mozfullscreenchange', proxy);\n    document.addEventListener('mozfullscreenerror', proxy);\n    document.addEventListener('MSFullscreenChange', proxy);\n    document.addEventListener('MSFullscreenError', proxy);\n  }\n\n  /**\n   * Proxy fullscreen events after changing their name.\n   * @param {!Event} event\n   * @private\n   */\n  static proxyEvent_(event) {\n    const eventType = event.type.replace(/^(webkit|moz|MS)/, '').toLowerCase();\n\n    let newEvent;\n    // IE 11 does not have an Event constructor\n    if (typeof(Event) === 'function') {\n      newEvent = new Event(eventType, /** @type {EventInit} */(event));\n    } else {\n      newEvent = document.createEvent('Event');\n      newEvent.initEvent(eventType, event.bubbles, event.cancelable);\n    }\n\n    event.target.dispatchEvent(newEvent);\n  }\n};\n\n\nshaka.polyfill.register(shaka.polyfill.Fullscreen.install);\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.polyfill.InputEvent');\n\ngoog.require('shaka.log');\ngoog.require('shaka.polyfill');\ngoog.require('shaka.util.Platform');\n\n\n/**\n * @summary A polyfill to patch 'input' event support in IE11.\n */\nshaka.polyfill.InputEvent = class {\n  /**\n   * Install the polyfill if needed.\n   */\n  static install() {\n    shaka.log.debug('InputEvent.install');\n\n    // IE11 doesn't treat the 'input' event correctly.\n    // https://bit.ly/2loLsuX\n\n    if (!shaka.util.Platform.isIE()) {\n      // Not IE, so don't patch anything.\n      return;\n    }\n\n    // In our tests, we can end up with multiple independent \"shaka\" namespaces.\n    // So we can't compare addEventListener with the polyfill directly.\n    // Instead, store the original in a globally accessible place and check if\n    // that has been used yet.\n    // eslint-disable-next-line no-restricted-syntax\n    if (HTMLInputElement.prototype['originalAddEventListener']) {\n      // The polyfill was already installed.\n      return;\n    }\n\n    shaka.log.info('Patching input event support on IE.');\n\n    // eslint-disable-next-line no-restricted-syntax\n    HTMLInputElement.prototype['originalAddEventListener'] =\n        // eslint-disable-next-line no-restricted-syntax\n        HTMLInputElement.prototype.addEventListener;\n\n    // eslint-disable-next-line no-restricted-syntax\n    HTMLInputElement.prototype['addEventListener'] =\n        // eslint-disable-next-line no-restricted-syntax\n        shaka.polyfill.InputEvent.addEventListener_;\n  }\n\n  /**\n   * Add an event listener to this object and translate the event types to those\n   * that work on IE11.\n   *\n   * @param {string} type\n   * @param {EventListener|function(!Event):(boolean|undefined)} listener\n   * @param {(!AddEventListenerOptions|boolean)=} options\n   * @this {HTMLInputElement}\n   * @private\n   */\n  static addEventListener_(type, listener, options) {\n    if (type == 'input') {\n      // Based on the type of input element, translate the HTML5 'input' event\n      // to one that IE11 will actually dispatch.\n\n      switch (this.type) {\n        // For range inputs, we use the 'change' event.\n        case 'range':\n          type = 'change';\n          break;\n      }\n    }\n\n    // eslint-disable-next-line no-restricted-syntax\n    HTMLInputElement.prototype['originalAddEventListener'].call(\n        this, type, listener, options);\n  }\n};\n\n\nshaka.polyfill.register(shaka.polyfill.InputEvent.install);\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.polyfill.MediaSource');\n\ngoog.require('shaka.log');\ngoog.require('shaka.polyfill');\ngoog.require('shaka.util.MimeUtils');\ngoog.require('shaka.util.Platform');\n\n/**\n * @summary A polyfill to patch MSE bugs.\n */\nshaka.polyfill.MediaSource = class {\n  /**\n   * Install the polyfill if needed.\n   */\n  static install() {\n    shaka.log.debug('MediaSource.install');\n\n    // MediaSource bugs are difficult to detect without checking for the\n    // affected platform.  SourceBuffer is not always exposed on window, for\n    // example, and instances are only accessible after setting up MediaSource\n    // on a video element.  Because of this, we use UA detection and other\n    // platform detection tricks to decide which patches to install.\n    const safariVersion = shaka.util.Platform.safariVersion();\n\n    if (!window.MediaSource) {\n      shaka.log.info('No MSE implementation available.');\n    } else if (window.cast && cast.__platform__ &&\n               cast.__platform__.canDisplayType) {\n      shaka.log.info('Patching Chromecast MSE bugs.');\n      // Chromecast cannot make accurate determinations via isTypeSupported.\n      shaka.polyfill.MediaSource.patchCastIsTypeSupported_();\n    } else if (safariVersion) {\n      // TS content is broken on Safari in general.\n      // See https://github.com/google/shaka-player/issues/743\n      // and https://bugs.webkit.org/show_bug.cgi?id=165342\n      shaka.polyfill.MediaSource.rejectTsContent_();\n\n      // NOTE:  shaka.Player.isBrowserSupported() has its own restrictions on\n      // Safari version.\n      if (safariVersion <= 12) {\n        shaka.log.info('Patching Safari 11 & 12 MSE bugs.');\n        // Safari 11 & 12 do not correctly implement abort() on SourceBuffer.\n        // Calling abort() before appending a segment causes that segment to be\n        // incomplete in the buffer.\n        // Bug filed: https://bugs.webkit.org/show_bug.cgi?id=165342\n        shaka.polyfill.MediaSource.stubAbort_();\n\n        // If you remove up to a keyframe, Safari 11 & 12 incorrectly will also\n        // remove that keyframe and the content up to the next.\n        // Offsetting the end of the removal range seems to help.\n        // Bug filed: https://bugs.webkit.org/show_bug.cgi?id=177884\n        shaka.polyfill.MediaSource.patchRemovalRange_();\n      } else {\n        shaka.log.info('Patching Safari 13 MSE bugs.');\n        // Safari 13 does not correctly implement abort() on SourceBuffer.\n        // Calling abort() before appending a segment causes that segment to be\n        // incomplete in the buffer.\n        // Bug filed: https://bugs.webkit.org/show_bug.cgi?id=165342\n        shaka.polyfill.MediaSource.stubAbort_();\n      }\n    } else if (shaka.util.Platform.isTizen2() ||\n        shaka.util.Platform.isTizen3() ||\n        shaka.util.Platform.isTizen4()) {\n      // Tizen's implementation of MSE does not work well with opus. To prevent\n      // the player from trying to play opus on Tizen, we will override media\n      // source to always reject opus content.\n\n      shaka.polyfill.MediaSource.rejectCodec_('opus');\n    } else {\n      shaka.log.info('Using native MSE as-is.');\n    }\n  }\n\n  /**\n   * Stub out abort().  On some buggy MSE implementations, calling abort()\n   * causes various problems.\n   *\n   * @private\n   */\n  static stubAbort_() {\n    /* eslint-disable no-restricted-syntax */\n    const addSourceBuffer = MediaSource.prototype.addSourceBuffer;\n    MediaSource.prototype.addSourceBuffer = function(...varArgs) {\n      const sourceBuffer = addSourceBuffer.apply(this, varArgs);\n      sourceBuffer.abort = function() {}; // Stub out for buggy implementations.\n      return sourceBuffer;\n    };\n    /* eslint-enable no-restricted-syntax */\n  }\n\n  /**\n   * Patch remove().  On Safari 11, if you call remove() to remove the content\n   * up to a keyframe, Safari will also remove the keyframe and all of the data\n   * up to the next one. For example, if the keyframes are at 0s, 5s, and 10s,\n   * and you tried to remove 0s-5s, it would instead remove 0s-10s.\n   *\n   * Offsetting the end of the range seems to be a usable workaround.\n   *\n   * @private\n   */\n  static patchRemovalRange_() {\n    // eslint-disable-next-line no-restricted-syntax\n    const originalRemove = SourceBuffer.prototype.remove;\n\n    // eslint-disable-next-line no-restricted-syntax\n    SourceBuffer.prototype.remove = function(startTime, endTime) {\n      // eslint-disable-next-line no-restricted-syntax\n      return originalRemove.call(this, startTime, endTime - 0.001);\n    };\n  }\n\n  /**\n   * Patch isTypeSupported() to reject TS content.  Used to avoid TS-related MSE\n   * bugs on Safari.\n   *\n   * @private\n   */\n  static rejectTsContent_() {\n    const originalIsTypeSupported = MediaSource.isTypeSupported;\n\n    MediaSource.isTypeSupported = (mimeType) => {\n      // Parse the basic MIME type from its parameters.\n      const pieces = mimeType.split(/ *; */);\n      const basicMimeType = pieces[0];\n      const container = basicMimeType.split('/')[1];\n\n      if (container.toLowerCase() == 'mp2t') {\n        return false;\n      }\n\n      return originalIsTypeSupported(mimeType);\n    };\n  }\n\n  /**\n   * Patch |MediaSource.isTypeSupported| to always reject |codec|. This is used\n   * when we know that we are on a platform that does not work well with a given\n   * codec.\n   *\n   * @param {string} codec\n   * @private\n   */\n  static rejectCodec_(codec) {\n    const isTypeSupported = MediaSource.isTypeSupported;\n\n    MediaSource.isTypeSupported = (mimeType) => {\n      const actualCodec = shaka.util.MimeUtils.getCodecBase(mimeType);\n      return actualCodec != codec && isTypeSupported(mimeType);\n    };\n  }\n\n  /**\n   * Patch isTypeSupported() to chain to a private API on the Chromecast which\n   * can query for support of detailed content parameters.\n   *\n   * @private\n   */\n  static patchCastIsTypeSupported_() {\n    const originalIsTypeSupported = MediaSource.isTypeSupported;\n\n    MediaSource.isTypeSupported = (mimeType) => {\n      // Parse the basic MIME type from its parameters.\n      const pieces = mimeType.split(/ *; */);\n      pieces.shift();  // Remove basic MIME type from pieces.\n\n      const hasCodecs = pieces.some((piece) => piece.startsWith('codecs='));\n      if (!hasCodecs) {\n        // Though the original reason for this special case was not documented,\n        // it is presumed to be because the platform won't accept a MIME type\n        // without codecs in canDisplayType.  It is valid, however, in\n        // isTypeSupported.\n        return originalIsTypeSupported(mimeType);\n      }\n\n      // Only canDisplayType can check extended MIME type parameters on this\n      // platform (such as frame rate, resolution, etc).\n      // In previous versions of this polyfill, the MIME type parameters were\n      // manipulated, filtered, or extended.  This is no longer true, so we pass\n      // the full MIME type to the platform as we received it.\n      return cast.__platform__.canDisplayType(mimeType);\n    };\n  }\n};\n\n\nshaka.polyfill.register(shaka.polyfill.MediaSource.install);\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.polyfill.PatchedMediaKeysApple');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.media.DrmEngine');\ngoog.require('shaka.polyfill');\ngoog.require('shaka.util.BufferUtils');\ngoog.require('shaka.util.EventManager');\ngoog.require('shaka.util.FakeEvent');\ngoog.require('shaka.util.FakeEventTarget');\ngoog.require('shaka.util.MediaReadyState');\ngoog.require('shaka.util.PublicPromise');\ngoog.require('shaka.util.StringUtils');\n\n\n/**\n * @summary A polyfill to implement modern, standardized EME on top of Apple's\n * prefixed EME in Safari.\n */\nshaka.polyfill.PatchedMediaKeysApple = class {\n  /**\n   * Installs the polyfill if needed.\n   */\n  static install() {\n    if (!window.HTMLVideoElement || !window.WebKitMediaKeys) {\n      // No HTML5 video or no prefixed EME.\n      return;\n    }\n\n    // TODO: Prefer unprefixed EME once we know how to use it.\n    // See: https://bugs.webkit.org/show_bug.cgi?id=197433\n    /*\n    if (navigator.requestMediaKeySystemAccess &&\n        MediaKeySystemAccess.prototype.getConfiguration) {\n      // Prefixed EME is preferable.\n      return;\n    }\n    */\n\n    shaka.log.info('Using Apple-prefixed EME');\n\n    // Alias\n    const PatchedMediaKeysApple = shaka.polyfill.PatchedMediaKeysApple;\n\n    // Delete mediaKeys to work around strict mode compatibility issues.\n    // eslint-disable-next-line no-restricted-syntax\n    delete HTMLMediaElement.prototype['mediaKeys'];\n    // Work around read-only declaration for mediaKeys by using a string.\n    // eslint-disable-next-line no-restricted-syntax\n    HTMLMediaElement.prototype['mediaKeys'] = null;\n    // eslint-disable-next-line no-restricted-syntax\n    HTMLMediaElement.prototype.setMediaKeys =\n        PatchedMediaKeysApple.setMediaKeys;\n\n    // Install patches\n    window.MediaKeys = PatchedMediaKeysApple.MediaKeys;\n    window.MediaKeySystemAccess = PatchedMediaKeysApple.MediaKeySystemAccess;\n    navigator.requestMediaKeySystemAccess =\n        PatchedMediaKeysApple.requestMediaKeySystemAccess;\n  }\n\n  /**\n   * An implementation of navigator.requestMediaKeySystemAccess.\n   * Retrieves a MediaKeySystemAccess object.\n   *\n   * @this {!Navigator}\n   * @param {string} keySystem\n   * @param {!Array.<!MediaKeySystemConfiguration>} supportedConfigurations\n   * @return {!Promise.<!MediaKeySystemAccess>}\n   */\n  static requestMediaKeySystemAccess(keySystem, supportedConfigurations) {\n    shaka.log.debug('PatchedMediaKeysApple.requestMediaKeySystemAccess');\n    goog.asserts.assert(this == navigator,\n        'bad \"this\" for requestMediaKeySystemAccess');\n\n    // Alias.\n    const PatchedMediaKeysApple = shaka.polyfill.PatchedMediaKeysApple;\n    try {\n      const access = new PatchedMediaKeysApple.MediaKeySystemAccess(\n          keySystem, supportedConfigurations);\n      return Promise.resolve(/** @type {!MediaKeySystemAccess} */ (access));\n    } catch (exception) {\n      return Promise.reject(exception);\n    }\n  }\n\n  /**\n   * An implementation of HTMLMediaElement.prototype.setMediaKeys.\n   * Attaches a MediaKeys object to the media element.\n   *\n   * @this {!HTMLMediaElement}\n   * @param {MediaKeys} mediaKeys\n   * @return {!Promise}\n   */\n  static setMediaKeys(mediaKeys) {\n    shaka.log.debug('PatchedMediaKeysApple.setMediaKeys');\n    goog.asserts.assert(this instanceof HTMLMediaElement,\n        'bad \"this\" for setMediaKeys');\n\n    // Alias\n    const PatchedMediaKeysApple = shaka.polyfill.PatchedMediaKeysApple;\n\n    const newMediaKeys =\n    /** @type {shaka.polyfill.PatchedMediaKeysApple.MediaKeys} */ (\n        mediaKeys);\n    const oldMediaKeys =\n    /** @type {shaka.polyfill.PatchedMediaKeysApple.MediaKeys} */ (\n        this.mediaKeys);\n\n    if (oldMediaKeys && oldMediaKeys != newMediaKeys) {\n      goog.asserts.assert(\n          oldMediaKeys instanceof PatchedMediaKeysApple.MediaKeys,\n          'non-polyfill instance of oldMediaKeys');\n      // Have the old MediaKeys stop listening to events on the video tag.\n      oldMediaKeys.setMedia(null);\n    }\n\n    delete this['mediaKeys'];  // in case there is an existing getter\n    this['mediaKeys'] = mediaKeys;  // work around read-only declaration\n\n    if (newMediaKeys) {\n      goog.asserts.assert(\n          newMediaKeys instanceof PatchedMediaKeysApple.MediaKeys,\n          'non-polyfill instance of newMediaKeys');\n      return newMediaKeys.setMedia(this);\n    }\n\n    return Promise.resolve();\n  }\n\n  /**\n   * Handler for the native media elements webkitneedkey event.\n   *\n   * @this {!HTMLMediaElement}\n   * @param {!MediaKeyEvent} event\n   * @suppress {constantProperty} We reassign what would be const on a real\n   *   MediaEncryptedEvent, but in our look-alike event.\n   * @private\n   */\n  static onWebkitNeedKey_(event) {\n    shaka.log.debug('PatchedMediaKeysApple.onWebkitNeedKey_', event);\n\n    const PatchedMediaKeysApple = shaka.polyfill.PatchedMediaKeysApple;\n    const mediaKeys =\n    /** @type {shaka.polyfill.PatchedMediaKeysApple.MediaKeys} */(\n        this.mediaKeys);\n    goog.asserts.assert(mediaKeys instanceof PatchedMediaKeysApple.MediaKeys,\n        'non-polyfill instance of newMediaKeys');\n\n    goog.asserts.assert(event.initData != null, 'missing init data!');\n\n    // Convert the prefixed init data to match the native 'encrypted' event.\n    const uint8 = shaka.util.BufferUtils.toUint8(event.initData);\n    const dataview = shaka.util.BufferUtils.toDataView(uint8);\n    // The first part is a 4 byte little-endian int, which is the length of\n    // the second part.\n    const length = dataview.getUint32(\n        /* position= */ 0, /* littleEndian= */ true);\n    if (length + 4 != uint8.byteLength) {\n      throw new RangeError('Malformed FairPlay init data');\n    }\n    // The remainder is a UTF-16 skd URL.  Convert this to UTF-8 and pass on.\n    const str = shaka.util.StringUtils.fromUTF16(\n        uint8.subarray(4), /* littleEndian= */ true);\n    const initData = shaka.util.StringUtils.toUTF8(str);\n\n    // NOTE: Because \"this\" is a real EventTarget, the event we dispatch here\n    // must also be a real Event.\n    const event2 = new Event('encrypted');\n\n    const encryptedEvent =\n      /** @type {!MediaEncryptedEvent} */(/** @type {?} */(event2));\n    encryptedEvent.initDataType = 'skd';\n    encryptedEvent.initData = shaka.util.BufferUtils.toArrayBuffer(initData);\n\n    this.dispatchEvent(event2);\n  }\n};\n\n\n/**\n * An implementation of MediaKeySystemAccess.\n *\n * @implements {MediaKeySystemAccess}\n */\nshaka.polyfill.PatchedMediaKeysApple.MediaKeySystemAccess = class {\n  /**\n   * @param {string} keySystem\n   * @param {!Array.<!MediaKeySystemConfiguration>} supportedConfigurations\n   */\n  constructor(keySystem, supportedConfigurations) {\n    shaka.log.debug('PatchedMediaKeysApple.MediaKeySystemAccess');\n\n    /** @type {string} */\n    this.keySystem = keySystem;\n\n    /** @private {!MediaKeySystemConfiguration} */\n    this.configuration_;\n\n    // Optimization: WebKitMediaKeys.isTypeSupported delays responses by a\n    // significant amount of time, possibly to discourage fingerprinting.\n    // Since we know only FairPlay is supported here, let's skip queries for\n    // anything else to speed up the process.\n    if (keySystem.startsWith('com.apple.fps')) {\n      for (const cfg of supportedConfigurations) {\n        const newCfg = this.checkConfig_(cfg);\n        if (newCfg) {\n          this.configuration_ = newCfg;\n          return;\n        }\n      }\n    }\n\n    // According to the spec, this should be a DOMException, but there is not a\n    // public constructor for that.  So we make this look-alike instead.\n    const unsupportedKeySystemError = new Error('Unsupported keySystem');\n    unsupportedKeySystemError.name = 'NotSupportedError';\n    unsupportedKeySystemError['code'] = DOMException.NOT_SUPPORTED_ERR;\n    throw unsupportedKeySystemError;\n  }\n\n  /**\n   * Check a single config for MediaKeySystemAccess.\n   *\n   * @param {MediaKeySystemConfiguration} cfg The requested config.\n   * @return {?MediaKeySystemConfiguration} A matching config we can support, or\n   *   null if the input is not supportable.\n   * @private\n   */\n  checkConfig_(cfg) {\n    if (cfg.persistentState == 'required') {\n      // Not supported by the prefixed API.\n      return null;\n    }\n\n    // Create a new config object and start adding in the pieces which we find\n    // support for.  We will return this from getConfiguration() later if\n    // asked.\n\n    /** @type {!MediaKeySystemConfiguration} */\n    const newCfg = {\n      'audioCapabilities': [],\n      'videoCapabilities': [],\n      // It is technically against spec to return these as optional, but we\n      // don't truly know their values from the prefixed API:\n      'persistentState': 'optional',\n      'distinctiveIdentifier': 'optional',\n      // Pretend the requested init data types are supported, since we don't\n      // really know that either:\n      'initDataTypes': cfg.initDataTypes,\n      'sessionTypes': ['temporary'],\n      'label': cfg.label,\n    };\n\n    // PatchedMediaKeysApple tests for key system availability through\n    // WebKitMediaKeys.isTypeSupported.\n    let ranAnyTests = false;\n    let success = false;\n\n    if (cfg.audioCapabilities) {\n      for (const cap of cfg.audioCapabilities) {\n        if (cap.contentType) {\n          ranAnyTests = true;\n\n          const contentType = cap.contentType.split(';')[0];\n          if (WebKitMediaKeys.isTypeSupported(this.keySystem, contentType)) {\n            newCfg.audioCapabilities.push(cap);\n            success = true;\n          }\n        }\n      }\n    }\n\n    if (cfg.videoCapabilities) {\n      for (const cap of cfg.videoCapabilities) {\n        if (cap.contentType) {\n          ranAnyTests = true;\n\n          const contentType = cap.contentType.split(';')[0];\n          if (WebKitMediaKeys.isTypeSupported(this.keySystem, contentType)) {\n            newCfg.videoCapabilities.push(cap);\n            success = true;\n          }\n        }\n      }\n    }\n\n    if (!ranAnyTests) {\n      // If no specific types were requested, we check all common types to\n      // find out if the key system is present at all.\n      success = WebKitMediaKeys.isTypeSupported(this.keySystem, 'video/mp4');\n    }\n\n    if (success) {\n      return newCfg;\n    }\n    return null;\n  }\n\n  /** @override */\n  createMediaKeys() {\n    shaka.log.debug(\n        'PatchedMediaKeysApple.MediaKeySystemAccess.createMediaKeys');\n\n    // Alias\n    const PatchedMediaKeysApple = shaka.polyfill.PatchedMediaKeysApple;\n\n    const mediaKeys = new PatchedMediaKeysApple.MediaKeys(this.keySystem);\n    return Promise.resolve(/** @type {!MediaKeys} */ (mediaKeys));\n  }\n\n  /** @override */\n  getConfiguration() {\n    shaka.log.debug(\n        'PatchedMediaKeysApple.MediaKeySystemAccess.getConfiguration');\n    return this.configuration_;\n  }\n};\n\n\n/**\n * An implementation of MediaKeys.\n *\n * @implements {MediaKeys}\n */\nshaka.polyfill.PatchedMediaKeysApple.MediaKeys = class {\n  /** @param {string} keySystem */\n  constructor(keySystem) {\n    shaka.log.debug('PatchedMediaKeysApple.MediaKeys');\n\n    /** @private {!WebKitMediaKeys} */\n    this.nativeMediaKeys_ = new WebKitMediaKeys(keySystem);\n\n    /** @private {!shaka.util.EventManager} */\n    this.eventManager_ = new shaka.util.EventManager();\n  }\n\n  /** @override */\n  createSession(sessionType) {\n    shaka.log.debug('PatchedMediaKeysApple.MediaKeys.createSession');\n\n    sessionType = sessionType || 'temporary';\n    // For now, only the 'temporary' type is supported.\n    if (sessionType != 'temporary') {\n      throw new TypeError('Session type ' + sessionType +\n      ' is unsupported on this platform.');\n    }\n\n    // Alias\n    const PatchedMediaKeysApple = shaka.polyfill.PatchedMediaKeysApple;\n\n    return new PatchedMediaKeysApple.MediaKeySession(\n        this.nativeMediaKeys_, sessionType);\n  }\n\n  /** @override */\n  setServerCertificate(serverCertificate) {\n    shaka.log.debug('PatchedMediaKeysApple.MediaKeys.setServerCertificate');\n    return Promise.resolve(false);\n  }\n\n  /**\n   * @param {HTMLMediaElement} media\n   * @protected\n   * @return {!Promise}\n   */\n  setMedia(media) {\n    // Alias\n    const PatchedMediaKeysApple = shaka.polyfill.PatchedMediaKeysApple;\n\n    // Remove any old listeners.\n    this.eventManager_.removeAll();\n\n    // It is valid for media to be null; null is used to flag that event\n    // handlers need to be cleaned up.\n    if (!media) {\n      return Promise.resolve();\n    }\n\n    // Intercept and translate these prefixed EME events.\n    this.eventManager_.listen(media, 'webkitneedkey',\n    /** @type {shaka.util.EventManager.ListenerType} */\n        (PatchedMediaKeysApple.onWebkitNeedKey_));\n\n    // Wrap native HTMLMediaElement.webkitSetMediaKeys with a Promise.\n    try {\n      // Some browsers require that readyState >=1 before mediaKeys can be\n      // set, so check this and wait for loadedmetadata if we are not in the\n      // correct state\n      shaka.util.MediaReadyState.waitForReadyState(media,\n          HTMLMediaElement.HAVE_METADATA,\n          this.eventManager_, () => {\n            media.webkitSetMediaKeys(this.nativeMediaKeys_);\n          });\n\n      return Promise.resolve();\n    } catch (exception) {\n      return Promise.reject(exception);\n    }\n  }\n};\n\n\n/**\n * An implementation of MediaKeySession.\n *\n * @implements {MediaKeySession}\n */\nshaka.polyfill.PatchedMediaKeysApple.MediaKeySession =\nclass extends shaka.util.FakeEventTarget {\n  /**\n   * @param {WebKitMediaKeys} nativeMediaKeys\n   * @param {string} sessionType\n   */\n  constructor(nativeMediaKeys, sessionType) {\n    shaka.log.debug('PatchedMediaKeysApple.MediaKeySession');\n    super();\n\n    /**\n     * The native MediaKeySession, which will be created in generateRequest.\n     * @private {WebKitMediaKeySession}\n     */\n    this.nativeMediaKeySession_ = null;\n\n    /** @private {WebKitMediaKeys} */\n    this.nativeMediaKeys_ = nativeMediaKeys;\n\n    // Promises that are resolved later\n    /** @private {shaka.util.PublicPromise} */\n    this.generateRequestPromise_ = null;\n\n    /** @private {shaka.util.PublicPromise} */\n    this.updatePromise_ = null;\n\n    /** @private {!shaka.util.EventManager} */\n    this.eventManager_ = new shaka.util.EventManager();\n\n    /** @type {string} */\n    this.sessionId = '';\n\n    /** @type {number} */\n    this.expiration = NaN;\n\n    /** @type {!shaka.util.PublicPromise} */\n    this.closed = new shaka.util.PublicPromise();\n\n    /** @type {!shaka.polyfill.PatchedMediaKeysApple.MediaKeyStatusMap} */\n    this.keyStatuses =\n        new shaka.polyfill.PatchedMediaKeysApple.MediaKeyStatusMap();\n  }\n\n  /** @override */\n  generateRequest(initDataType, initData) {\n    shaka.log.debug(\n        'PatchedMediaKeysApple.MediaKeySession.generateRequest');\n\n    this.generateRequestPromise_ = new shaka.util.PublicPromise();\n\n    try {\n      // This EME spec version requires a MIME content type as the 1st param to\n      // createSession, but doesn't seem to matter what the value is.\n      // It also only accepts Uint8Array, not ArrayBuffer, so explicitly make\n      // initData into a Uint8Array.\n      const session = this.nativeMediaKeys_.createSession(\n          'video/mp4', shaka.util.BufferUtils.toUint8(initData));\n      this.nativeMediaKeySession_ = session;\n      this.sessionId = session.sessionId || '';\n\n      // Attach session event handlers here.\n      this.eventManager_.listen(\n          this.nativeMediaKeySession_, 'webkitkeymessage',\n          /** @type {shaka.util.EventManager.ListenerType} */\n          ((event) => this.onWebkitKeyMessage_(event)));\n      this.eventManager_.listen(session, 'webkitkeyadded',\n          /** @type {shaka.util.EventManager.ListenerType} */\n          ((event) => this.onWebkitKeyAdded_(event)));\n      this.eventManager_.listen(session, 'webkitkeyerror',\n          /** @type {shaka.util.EventManager.ListenerType} */\n          ((event) => this.onWebkitKeyError_(event)));\n\n      this.updateKeyStatus_('status-pending');\n    } catch (exception) {\n      this.generateRequestPromise_.reject(exception);\n    }\n\n    return this.generateRequestPromise_;\n  }\n\n  /** @override */\n  load() {\n    shaka.log.debug('PatchedMediaKeysApple.MediaKeySession.load');\n\n    return Promise.reject(new Error('MediaKeySession.load not yet supported'));\n  }\n\n  /** @override */\n  update(response) {\n    shaka.log.debug('PatchedMediaKeysApple.MediaKeySession.update');\n\n    this.updatePromise_ = new shaka.util.PublicPromise();\n\n    try {\n      // Pass through to the native session.\n      this.nativeMediaKeySession_.update(\n          shaka.util.BufferUtils.toUint8(response));\n    } catch (exception) {\n      this.updatePromise_.reject(exception);\n    }\n\n    return this.updatePromise_;\n  }\n\n  /** @override */\n  close() {\n    shaka.log.debug('PatchedMediaKeysApple.MediaKeySession.close');\n\n    try {\n      // Pass through to the native session.\n      this.nativeMediaKeySession_.close();\n\n      this.closed.resolve();\n      this.eventManager_.removeAll();\n    } catch (exception) {\n      this.closed.reject(exception);\n    }\n\n    return this.closed;\n  }\n\n  /** @override */\n  remove() {\n    shaka.log.debug('PatchedMediaKeysApple.MediaKeySession.remove');\n\n    return Promise.reject(new Error(\n        'MediaKeySession.remove is only applicable for persistent licenses, ' +\n        'which are not supported on this platform'));\n  }\n\n  /**\n   * Handler for the native keymessage event on WebKitMediaKeySession.\n   *\n   * @param {!MediaKeyEvent} event\n   * @private\n   */\n  onWebkitKeyMessage_(event) {\n    shaka.log.debug('PatchedMediaKeysApple.onWebkitKeyMessage_', event);\n\n    // We can now resolve this.generateRequestPromise, which should be non-null.\n    goog.asserts.assert(this.generateRequestPromise_,\n        'generateRequestPromise_ should be set before now!');\n    if (this.generateRequestPromise_) {\n      this.generateRequestPromise_.resolve();\n      this.generateRequestPromise_ = null;\n    }\n\n    const isNew = this.keyStatuses.getStatus() == undefined;\n\n    const event2 = new shaka.util.FakeEvent('message', {\n      messageType: isNew ? 'license-request' : 'license-renewal',\n      message: shaka.util.BufferUtils.toArrayBuffer(event.message),\n    });\n\n    this.dispatchEvent(event2);\n  }\n\n  /**\n   * Handler for the native keyadded event on WebKitMediaKeySession.\n   *\n   * @param {!MediaKeyEvent} event\n   * @private\n   */\n  onWebkitKeyAdded_(event) {\n    shaka.log.debug('PatchedMediaKeysApple.onWebkitKeyAdded_', event);\n\n    // This shouldn't fire while we're in the middle of generateRequest,\n    // but if it does, we will need to change the logic to account for it.\n    goog.asserts.assert(!this.generateRequestPromise_,\n        'Key added during generate!');\n\n    // We can now resolve this.updatePromise, which should be non-null.\n    goog.asserts.assert(this.updatePromise_,\n        'updatePromise_ should be set before now!');\n    if (this.updatePromise_) {\n      this.updateKeyStatus_('usable');\n      this.updatePromise_.resolve();\n      this.updatePromise_ = null;\n    }\n  }\n\n  /**\n   * Handler for the native keyerror event on WebKitMediaKeySession.\n   *\n   * @param {!MediaKeyEvent} event\n   * @private\n   */\n  onWebkitKeyError_(event) {\n    shaka.log.debug('PatchedMediaKeysApple.onWebkitKeyError_', event);\n\n    const error = new Error('EME PatchedMediaKeysApple key error');\n    error['errorCode'] = this.nativeMediaKeySession_.error;\n\n    if (this.generateRequestPromise_ != null) {\n      this.generateRequestPromise_.reject(error);\n      this.generateRequestPromise_ = null;\n    } else if (this.updatePromise_ != null) {\n      this.updatePromise_.reject(error);\n      this.updatePromise_ = null;\n    } else {\n      // Unexpected error - map native codes to standardised key statuses.\n      // Possible values of this.nativeMediaKeySession_.error.code:\n      // MEDIA_KEYERR_UNKNOWN        = 1\n      // MEDIA_KEYERR_CLIENT         = 2\n      // MEDIA_KEYERR_SERVICE        = 3\n      // MEDIA_KEYERR_OUTPUT         = 4\n      // MEDIA_KEYERR_HARDWARECHANGE = 5\n      // MEDIA_KEYERR_DOMAIN         = 6\n\n      switch (this.nativeMediaKeySession_.error.code) {\n        case WebKitMediaKeyError.MEDIA_KEYERR_OUTPUT:\n        case WebKitMediaKeyError.MEDIA_KEYERR_HARDWARECHANGE:\n          this.updateKeyStatus_('output-not-allowed');\n          break;\n        default:\n          this.updateKeyStatus_('internal-error');\n          break;\n      }\n    }\n  }\n\n  /**\n   * Updates key status and dispatch a 'keystatuseschange' event.\n   *\n   * @param {string} status\n   * @private\n   */\n  updateKeyStatus_(status) {\n    this.keyStatuses.setStatus(status);\n    const event = new shaka.util.FakeEvent('keystatuseschange');\n    this.dispatchEvent(event);\n  }\n};\n\n\n/**\n * @summary An implementation of MediaKeyStatusMap.\n * This fakes a map with a single key ID.\n *\n * @todo Consolidate the MediaKeyStatusMap types in these polyfills.\n * @implements {MediaKeyStatusMap}\n */\nshaka.polyfill.PatchedMediaKeysApple.MediaKeyStatusMap = class {\n  constructor() {\n    /**\n     * @type {number}\n     */\n    this.size = 0;\n\n    /**\n     * @private {string|undefined}\n     */\n    this.status_ = undefined;\n  }\n\n  /**\n   * An internal method used by the session to set key status.\n   * @param {string|undefined} status\n   */\n  setStatus(status) {\n    this.size = status == undefined ? 0 : 1;\n    this.status_ = status;\n  }\n\n  /**\n   * An internal method used by the session to get key status.\n   * @return {string|undefined}\n   */\n  getStatus() {\n    return this.status_;\n  }\n\n  /** @override */\n  forEach(fn) {\n    if (this.status_) {\n      fn(this.status_, shaka.media.DrmEngine.DUMMY_KEY_ID.value());\n    }\n  }\n\n  /** @override */\n  get(keyId) {\n    if (this.has(keyId)) {\n      return this.status_;\n    }\n    return undefined;\n  }\n\n  /** @override */\n  has(keyId) {\n    const fakeKeyId = shaka.media.DrmEngine.DUMMY_KEY_ID.value();\n    if (this.status_ && shaka.util.BufferUtils.equal(keyId, fakeKeyId)) {\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * @suppress {missingReturn}\n   * @override\n   */\n  entries() {\n    goog.asserts.assert(false, 'Not used!  Provided only for the compiler.');\n  }\n\n  /**\n   * @suppress {missingReturn}\n   * @override\n   */\n  keys() {\n    goog.asserts.assert(false, 'Not used!  Provided only for the compiler.');\n  }\n\n  /**\n   * @suppress {missingReturn}\n   * @override\n   */\n  values() {\n    goog.asserts.assert(false, 'Not used!  Provided only for the compiler.');\n  }\n};\n\n\nshaka.polyfill.register(shaka.polyfill.PatchedMediaKeysApple.install);\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.polyfill.PatchedMediaKeysMs');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.media.DrmEngine');\ngoog.require('shaka.polyfill');\ngoog.require('shaka.util.BufferUtils');\ngoog.require('shaka.util.EventManager');\ngoog.require('shaka.util.FakeEvent');\ngoog.require('shaka.util.FakeEventTarget');\ngoog.require('shaka.util.MediaReadyState');\ngoog.require('shaka.util.Pssh');\ngoog.require('shaka.util.PublicPromise');\n\n\n/**\n * @summary A polyfill to implement\n * {@link https://bit.ly/EmeMar15 EME draft 12 March 2015}\n * on top of ms-prefixed\n * {@link https://www.w3.org/TR/2014/WD-encrypted-media-20140218/ EME v20140218}\n */\nshaka.polyfill.PatchedMediaKeysMs = class {\n  /**\n   * Installs the polyfill if needed.\n   */\n  static install() {\n    if (!window.HTMLVideoElement || !window.MSMediaKeys ||\n        (navigator.requestMediaKeySystemAccess &&\n         // eslint-disable-next-line no-restricted-syntax\n         MediaKeySystemAccess.prototype.getConfiguration)) {\n      return;\n    }\n    shaka.log.info('Using ms-prefixed EME v20140218');\n\n    // Alias\n    const PatchedMediaKeysMs = shaka.polyfill.PatchedMediaKeysMs;\n\n    // Delete mediaKeys to work around strict mode compatibility issues.\n    // eslint-disable-next-line no-restricted-syntax\n    delete HTMLMediaElement.prototype['mediaKeys'];\n    // Work around read-only declaration for mediaKeys by using a string.\n    // eslint-disable-next-line no-restricted-syntax\n    HTMLMediaElement.prototype['mediaKeys'] = null;\n\n    // Install patches\n    window.MediaKeys = PatchedMediaKeysMs.MediaKeys;\n    window.MediaKeySystemAccess = PatchedMediaKeysMs.MediaKeySystemAccess;\n    navigator.requestMediaKeySystemAccess =\n        PatchedMediaKeysMs.requestMediaKeySystemAccess;\n    // eslint-disable-next-line no-restricted-syntax\n    HTMLMediaElement.prototype.setMediaKeys =\n        PatchedMediaKeysMs.MediaKeySystemAccess.setMediaKeys;\n  }\n\n  /**\n   * An implementation of navigator.requestMediaKeySystemAccess.\n   * Retrieves a MediaKeySystemAccess object.\n   *\n   * @this {!Navigator}\n   * @param {string} keySystem\n   * @param {!Array.<!MediaKeySystemConfiguration>} supportedConfigurations\n   * @return {!Promise.<!MediaKeySystemAccess>}\n   */\n  static requestMediaKeySystemAccess(keySystem, supportedConfigurations) {\n    shaka.log.debug('PatchedMediaKeysMs.requestMediaKeySystemAccess');\n    goog.asserts.assert(this == navigator,\n        'bad \"this\" for requestMediaKeySystemAccess');\n\n    // Alias.\n    const PatchedMediaKeysMs = shaka.polyfill.PatchedMediaKeysMs;\n    try {\n      const access = new PatchedMediaKeysMs.MediaKeySystemAccess(\n          keySystem, supportedConfigurations);\n      return Promise.resolve(/** @type {!MediaKeySystemAccess} */ (access));\n    } catch (exception) {\n      return Promise.reject(exception);\n    }\n  }\n\n  /**\n   * Handler for the native media elements msNeedKey event.\n   *\n   * @this {!HTMLMediaElement}\n   * @param {!MediaKeyEvent} event\n   * @suppress {constantProperty} We reassign what would be const on a real\n   *   MediaEncryptedEvent, but in our look-alike event.\n   * @private\n   */\n  static onMsNeedKey_(event) {\n    shaka.log.debug('PatchedMediaKeysMs.onMsNeedKey_', event);\n    if (!event.initData) {\n      return;\n    }\n\n    // NOTE: Because \"this\" is a real EventTarget, on IE, the event we dispatch\n    // here must also be a real Event.\n    const event2 =\n      /** @type {!CustomEvent} */(document.createEvent('CustomEvent'));\n    event2.initCustomEvent('encrypted', false, false, null);\n\n    const encryptedEvent =\n      /** @type {!MediaEncryptedEvent} */(/** @type {?} */(event2));\n    encryptedEvent.initDataType = 'cenc';\n    encryptedEvent.initData = shaka.util.BufferUtils.toArrayBuffer(\n        shaka.util.Pssh.normaliseInitData(event.initData));\n\n    this.dispatchEvent(event2);\n  }\n};\n\n\n/**\n * An implementation of MediaKeySystemAccess.\n *\n * @implements {MediaKeySystemAccess}\n */\nshaka.polyfill.PatchedMediaKeysMs.MediaKeySystemAccess = class {\n  /**\n   * @param {string} keySystem\n   * @param {!Array.<!MediaKeySystemConfiguration>} supportedConfigurations\n   */\n  constructor(keySystem, supportedConfigurations) {\n    shaka.log.debug('PatchedMediaKeysMs.MediaKeySystemAccess');\n\n    /** @type {string} */\n    this.keySystem = keySystem;\n\n    /** @private {!MediaKeySystemConfiguration} */\n    this.configuration_;\n\n    const allowPersistentState = false;\n\n    let success = false;\n    for (const cfg of supportedConfigurations) {\n      // Create a new config object and start adding in the pieces which we\n      // find support for.  We will return this from getConfiguration() if\n      // asked.\n      /** @type {!MediaKeySystemConfiguration} */\n      const newCfg = {\n        'audioCapabilities': [],\n        'videoCapabilities': [],\n        // It is technically against spec to return these as optional, but we\n        // don't truly know their values from the prefixed API:\n        'persistentState': 'optional',\n        'distinctiveIdentifier': 'optional',\n        // Pretend the requested init data types are supported, since we don't\n        // really know that either:\n        'initDataTypes': cfg.initDataTypes,\n        'sessionTypes': ['temporary'],\n        'label': cfg.label,\n      };\n\n      // PatchedMediaKeysMs tests for key system availability through\n      // MSMediaKeys.isTypeSupported\n      let ranAnyTests = false;\n      if (cfg.audioCapabilities) {\n        for (const cap of cfg.audioCapabilities) {\n          if (cap.contentType) {\n            ranAnyTests = true;\n            const contentType = cap.contentType.split(';')[0];\n            if (MSMediaKeys.isTypeSupported(this.keySystem, contentType)) {\n              newCfg.audioCapabilities.push(cap);\n              success = true;\n            }\n          }\n        }\n      }\n      if (cfg.videoCapabilities) {\n        for (const cap of cfg.videoCapabilities) {\n          if (cap.contentType) {\n            ranAnyTests = true;\n            const contentType = cap.contentType.split(';')[0];\n            if (MSMediaKeys.isTypeSupported(this.keySystem, contentType)) {\n              newCfg.videoCapabilities.push(cap);\n              success = true;\n            }\n          }\n        }\n      }\n\n      if (!ranAnyTests) {\n        // If no specific types were requested, we check all common types to\n        // find out if the key system is present at all.\n        success = MSMediaKeys.isTypeSupported(this.keySystem, 'video/mp4');\n      }\n      if (cfg.persistentState == 'required') {\n        if (allowPersistentState) {\n          newCfg.persistentState = 'required';\n          newCfg.sessionTypes = ['persistent-license'];\n        } else {\n          success = false;\n        }\n      }\n\n      if (success) {\n        this.configuration_ = newCfg;\n        return;\n      }\n    }  // for each cfg in supportedConfigurations\n\n    // According to the spec, this should be a DOMException, but there is not a\n    // public constructor for that.  So we make this look-alike instead.\n    const unsupportedKeySystemError = new Error('Unsupported keySystem');\n    unsupportedKeySystemError.name = 'NotSupportedError';\n    unsupportedKeySystemError['code'] = DOMException.NOT_SUPPORTED_ERR;\n    throw unsupportedKeySystemError;\n  }\n\n  /** @override */\n  createMediaKeys() {\n    shaka.log.debug(\n        'PatchedMediaKeysMs.MediaKeySystemAccess.createMediaKeys');\n\n    // Alias\n    const PatchedMediaKeysMs = shaka.polyfill.PatchedMediaKeysMs;\n\n    const mediaKeys = new PatchedMediaKeysMs.MediaKeys(this.keySystem);\n    return Promise.resolve(/** @type {!MediaKeys} */ (mediaKeys));\n  }\n\n  /** @override */\n  getConfiguration() {\n    shaka.log.debug(\n        'PatchedMediaKeysMs.MediaKeySystemAccess.getConfiguration');\n    return this.configuration_;\n  }\n\n  /**\n   * An implementation of HTMLMediaElement.prototype.setMediaKeys.\n   * Attaches a MediaKeys object to the media element.\n   *\n   * @this {!HTMLMediaElement}\n   * @param {MediaKeys} mediaKeys\n   * @return {!Promise}\n   */\n  static setMediaKeys(mediaKeys) {\n    shaka.log.debug('PatchedMediaKeysMs.setMediaKeys');\n    goog.asserts.assert(this instanceof HTMLMediaElement,\n        'bad \"this\" for setMediaKeys');\n\n    // Alias\n    const PatchedMediaKeysMs = shaka.polyfill.PatchedMediaKeysMs;\n\n    const newMediaKeys =\n    /** @type {shaka.polyfill.PatchedMediaKeysMs.MediaKeys} */ (\n        mediaKeys);\n    const oldMediaKeys =\n    /** @type {shaka.polyfill.PatchedMediaKeysMs.MediaKeys} */ (\n        this.mediaKeys);\n\n    if (oldMediaKeys && oldMediaKeys != newMediaKeys) {\n      goog.asserts.assert(oldMediaKeys instanceof PatchedMediaKeysMs.MediaKeys,\n          'non-polyfill instance of oldMediaKeys');\n      // Have the old MediaKeys stop listening to events on the video tag.\n      oldMediaKeys.setMedia(null);\n    }\n\n    delete this['mediaKeys'];  // in case there is an existing getter\n    this['mediaKeys'] = mediaKeys;  // work around read-only declaration\n\n    if (newMediaKeys) {\n      goog.asserts.assert(newMediaKeys instanceof PatchedMediaKeysMs.MediaKeys,\n          'non-polyfill instance of newMediaKeys');\n      return newMediaKeys.setMedia(this);\n    }\n\n    return Promise.resolve();\n  }\n};\n\n\n/**\n * An implementation of MediaKeys.\n *\n * @implements {MediaKeys}\n */\nshaka.polyfill.PatchedMediaKeysMs.MediaKeys = class {\n  /** @param {string} keySystem */\n  constructor(keySystem) {\n    shaka.log.debug('PatchedMediaKeysMs.MediaKeys');\n\n    /** @private {!MSMediaKeys} */\n    this.nativeMediaKeys_ = new MSMediaKeys(keySystem);\n\n    /** @private {!shaka.util.EventManager} */\n    this.eventManager_ = new shaka.util.EventManager();\n  }\n\n  /** @override */\n  createSession(sessionType) {\n    shaka.log.debug('PatchedMediaKeysMs.MediaKeys.createSession');\n\n    sessionType = sessionType || 'temporary';\n    // For now, only the 'temporary' type is supported.\n    if (sessionType != 'temporary') {\n      throw new TypeError('Session type ' + sessionType +\n      ' is unsupported on this platform.');\n    }\n\n    // Alias\n    const PatchedMediaKeysMs = shaka.polyfill.PatchedMediaKeysMs;\n\n    return new PatchedMediaKeysMs.MediaKeySession(\n        this.nativeMediaKeys_, sessionType);\n  }\n\n  /** @override */\n  setServerCertificate(serverCertificate) {\n    shaka.log.debug('PatchedMediaKeysMs.MediaKeys.setServerCertificate');\n\n    // There is no equivalent in PatchedMediaKeysMs, so return failure.\n    return Promise.resolve(false);\n  }\n\n  /**\n   * @param {HTMLMediaElement} media\n   * @protected\n   * @return {!Promise}\n   */\n  setMedia(media) {\n    // Alias\n    const PatchedMediaKeysMs = shaka.polyfill.PatchedMediaKeysMs;\n\n    // Remove any old listeners.\n    this.eventManager_.removeAll();\n\n    // It is valid for media to be null; null is used to flag that event\n    // handlers need to be cleaned up.\n    if (!media) {\n      return Promise.resolve();\n    }\n\n    // Intercept and translate these prefixed EME events.\n    this.eventManager_.listen(media, 'msneedkey',\n    /** @type {shaka.util.EventManager.ListenerType} */\n        (PatchedMediaKeysMs.onMsNeedKey_));\n\n    // Wrap native HTMLMediaElement.msSetMediaKeys with a Promise.\n    try {\n      // IE11/Edge requires that readyState >=1 before mediaKeys can be set,\n      // so check this and wait for loadedmetadata if we are not in the\n      // correct state\n      shaka.util.MediaReadyState.waitForReadyState(media,\n          HTMLMediaElement.HAVE_METADATA,\n          this.eventManager_, () => {\n            media.msSetMediaKeys(this.nativeMediaKeys_);\n          });\n\n      return Promise.resolve();\n    } catch (exception) {\n      return Promise.reject(exception);\n    }\n  }\n};\n\n\n/**\n * An implementation of MediaKeySession.\n *\n * @implements {MediaKeySession}\n */\nshaka.polyfill.PatchedMediaKeysMs.MediaKeySession =\nclass extends shaka.util.FakeEventTarget {\n  /**\n   * @param {MSMediaKeys} nativeMediaKeys\n   * @param {string} sessionType\n   */\n  constructor(nativeMediaKeys, sessionType) {\n    shaka.log.debug('PatchedMediaKeysMs.MediaKeySession');\n    super();\n\n    /**\n     * The native MediaKeySession, which will be created in generateRequest.\n     * @private {MSMediaKeySession}\n     */\n    this.nativeMediaKeySession_ = null;\n\n    /** @private {MSMediaKeys} */\n    this.nativeMediaKeys_ = nativeMediaKeys;\n\n    // Promises that are resolved later\n    /** @private {shaka.util.PublicPromise} */\n    this.generateRequestPromise_ = null;\n\n    /** @private {shaka.util.PublicPromise} */\n    this.updatePromise_ = null;\n\n    /** @private {!shaka.util.EventManager} */\n    this.eventManager_ = new shaka.util.EventManager();\n\n    /** @type {string} */\n    this.sessionId = '';\n\n    /** @type {number} */\n    this.expiration = NaN;\n\n    /** @type {!shaka.util.PublicPromise} */\n    this.closed = new shaka.util.PublicPromise();\n\n    /** @type {!shaka.polyfill.PatchedMediaKeysMs.MediaKeyStatusMap} */\n    this.keyStatuses =\n        new shaka.polyfill.PatchedMediaKeysMs.MediaKeyStatusMap();\n  }\n\n  /** @override */\n  generateRequest(initDataType, initData) {\n    shaka.log.debug('PatchedMediaKeysMs.MediaKeySession.generateRequest');\n\n    this.generateRequestPromise_ = new shaka.util.PublicPromise();\n\n    try {\n      // This EME spec version requires a MIME content type as the 1st param to\n      // createSession, but doesn't seem to matter what the value is.\n\n      // NOTE: IE11 takes either Uint8Array or ArrayBuffer, but Edge 12 only\n      // accepts Uint8Array.\n      this.nativeMediaKeySession_ = this.nativeMediaKeys_.createSession(\n          'video/mp4', shaka.util.BufferUtils.toUint8(initData), null);\n\n      // Attach session event handlers here.\n      this.eventManager_.listen(this.nativeMediaKeySession_, 'mskeymessage',\n      /** @type {shaka.util.EventManager.ListenerType} */\n          ((event) => this.onMsKeyMessage_(event)));\n      this.eventManager_.listen(this.nativeMediaKeySession_, 'mskeyadded',\n      /** @type {shaka.util.EventManager.ListenerType} */\n          ((event) => this.onMsKeyAdded_(event)));\n      this.eventManager_.listen(this.nativeMediaKeySession_, 'mskeyerror',\n      /** @type {shaka.util.EventManager.ListenerType} */\n          ((event) => this.onMsKeyError_(event)));\n\n      this.updateKeyStatus_('status-pending');\n    } catch (exception) {\n      this.generateRequestPromise_.reject(exception);\n    }\n\n    return this.generateRequestPromise_;\n  }\n\n  /** @override */\n  load() {\n    shaka.log.debug('PatchedMediaKeysMs.MediaKeySession.load');\n\n    return Promise.reject(new Error('MediaKeySession.load not yet supported'));\n  }\n\n  /** @override */\n  update(response) {\n    shaka.log.debug('PatchedMediaKeysMs.MediaKeySession.update');\n\n    this.updatePromise_ = new shaka.util.PublicPromise();\n\n    try {\n      // Pass through to the native session.\n      // NOTE: IE11 takes either Uint8Array or ArrayBuffer, but Edge 12 only\n      // accepts Uint8Array.\n      this.nativeMediaKeySession_.update(\n          shaka.util.BufferUtils.toUint8(response));\n    } catch (exception) {\n      this.updatePromise_.reject(exception);\n    }\n\n    return this.updatePromise_;\n  }\n\n  /** @override */\n  close() {\n    shaka.log.debug('PatchedMediaKeysMs.MediaKeySession.close');\n\n    try {\n      // Pass through to the native session.\n      // NOTE: IE seems to have a spec discrepancy here - v2010218 should have\n      // MediaKeySession.release, but actually uses \"close\". The next version of\n      // the spec is the initial Promise based one, so it's not the target spec\n      // either.\n      this.nativeMediaKeySession_.close();\n\n      this.closed.resolve();\n      this.eventManager_.removeAll();\n    } catch (exception) {\n      this.closed.reject(exception);\n    }\n\n    return this.closed;\n  }\n\n  /** @override */\n  remove() {\n    shaka.log.debug('PatchedMediaKeysMs.MediaKeySession.remove');\n\n    return Promise.reject(new Error(\n        'MediaKeySession.remove is only applicable for persistent licenses, ' +\n        'which are not supported on this platform'));\n  }\n\n  /**\n   * Handler for the native keymessage event on MSMediaKeySession.\n   *\n   * @param {!MediaKeyEvent} event\n   * @private\n   */\n  onMsKeyMessage_(event) {\n    shaka.log.debug('PatchedMediaKeysMs.onMsKeyMessage_', event);\n\n    // We can now resolve this.generateRequestPromise, which should be non-null.\n    goog.asserts.assert(this.generateRequestPromise_,\n        'generateRequestPromise_ not set in onMsKeyMessage_');\n    if (this.generateRequestPromise_) {\n      this.generateRequestPromise_.resolve();\n      this.generateRequestPromise_ = null;\n    }\n\n    const isNew = this.keyStatuses.getStatus() == undefined;\n\n    const event2 = new shaka.util.FakeEvent('message', {\n      messageType: isNew ? 'license-request' : 'license-renewal',\n      message: shaka.util.BufferUtils.toArrayBuffer(event.message),\n    });\n\n    this.dispatchEvent(event2);\n  }\n\n  /**\n   * Handler for the native keyadded event on MSMediaKeySession.\n   *\n   * @param {!MediaKeyEvent} event\n   * @private\n   */\n  onMsKeyAdded_(event) {\n    shaka.log.debug('PatchedMediaKeysMs.onMsKeyAdded_', event);\n\n    // PlayReady's concept of persistent licenses makes emulation difficult\n    // here. A license policy can say that the license persists, which causes\n    // the CDM to store it for use in a later session.  The result is that in\n    // IE11, the CDM fires 'mskeyadded' without ever firing 'mskeymessage'.\n    if (this.generateRequestPromise_) {\n      shaka.log.debug('Simulating completion for a PR persistent license.');\n      goog.asserts.assert(!this.updatePromise_,\n          'updatePromise_ and generateRequestPromise_ set in onMsKeyAdded_');\n      this.updateKeyStatus_('usable');\n      this.generateRequestPromise_.resolve();\n      this.generateRequestPromise_ = null;\n      return;\n    }\n\n    // We can now resolve this.updatePromise, which should be non-null.\n    goog.asserts.assert(this.updatePromise_,\n        'updatePromise_ not set in onMsKeyAdded_');\n    if (this.updatePromise_) {\n      this.updateKeyStatus_('usable');\n      this.updatePromise_.resolve();\n      this.updatePromise_ = null;\n    }\n  }\n\n  /**\n   * Handler for the native keyerror event on MSMediaKeySession.\n   *\n   * @param {!MediaKeyEvent} event\n   * @private\n   */\n  onMsKeyError_(event) {\n    shaka.log.debug('PatchedMediaKeysMs.onMsKeyError_', event);\n\n    const error = new Error('EME PatchedMediaKeysMs key error');\n    error['errorCode'] = this.nativeMediaKeySession_.error;\n\n    if (this.generateRequestPromise_ != null) {\n      this.generateRequestPromise_.reject(error);\n      this.generateRequestPromise_ = null;\n    } else if (this.updatePromise_ != null) {\n      this.updatePromise_.reject(error);\n      this.updatePromise_ = null;\n    } else {\n      // Unexpected error - map native codes to standardised key statuses.\n      // Possible values of this.nativeMediaKeySession_.error.code:\n      // MS_MEDIA_KEYERR_UNKNOWN        = 1\n      // MS_MEDIA_KEYERR_CLIENT         = 2\n      // MS_MEDIA_KEYERR_SERVICE        = 3\n      // MS_MEDIA_KEYERR_OUTPUT         = 4\n      // MS_MEDIA_KEYERR_HARDWARECHANGE = 5\n      // MS_MEDIA_KEYERR_DOMAIN         = 6\n\n      switch (this.nativeMediaKeySession_.error.code) {\n        case MSMediaKeyError.MS_MEDIA_KEYERR_OUTPUT:\n        case MSMediaKeyError.MS_MEDIA_KEYERR_HARDWARECHANGE:\n          this.updateKeyStatus_('output-not-allowed');\n          break;\n        default:\n          this.updateKeyStatus_('internal-error');\n          break;\n      }\n    }\n  }\n\n  /**\n   * Updates key status and dispatch a 'keystatuseschange' event.\n   *\n   * @param {string} status\n   * @private\n   */\n  updateKeyStatus_(status) {\n    this.keyStatuses.setStatus(status);\n    const event = new shaka.util.FakeEvent('keystatuseschange');\n    this.dispatchEvent(event);\n  }\n};\n\n\n/**\n * @summary An implementation of MediaKeyStatusMap.\n * This fakes a map with a single key ID.\n *\n * @todo Consolidate the MediaKeyStatusMap types in these polyfills.\n * @implements {MediaKeyStatusMap}\n */\nshaka.polyfill.PatchedMediaKeysMs.MediaKeyStatusMap = class {\n  constructor() {\n    /**\n     * @type {number}\n     */\n    this.size = 0;\n\n    /**\n     * @private {string|undefined}\n     */\n    this.status_ = undefined;\n  }\n\n  /**\n   * An internal method used by the session to set key status.\n   * @param {string|undefined} status\n   */\n  setStatus(status) {\n    this.size = status == undefined ? 0 : 1;\n    this.status_ = status;\n  }\n\n  /**\n   * An internal method used by the session to get key status.\n   * @return {string|undefined}\n   */\n  getStatus() {\n    return this.status_;\n  }\n\n  /** @override */\n  forEach(fn) {\n    if (this.status_) {\n      fn(this.status_, shaka.media.DrmEngine.DUMMY_KEY_ID.value());\n    }\n  }\n\n  /** @override */\n  get(keyId) {\n    if (this.has(keyId)) {\n      return this.status_;\n    }\n    return undefined;\n  }\n\n  /** @override */\n  has(keyId) {\n    const fakeKeyId = shaka.media.DrmEngine.DUMMY_KEY_ID.value();\n    if (this.status_ && shaka.util.BufferUtils.equal(keyId, fakeKeyId)) {\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * @suppress {missingReturn}\n   * @override\n   */\n  entries() {\n    goog.asserts.assert(false, 'Not used!  Provided only for the compiler.');\n  }\n\n  /**\n   * @suppress {missingReturn}\n   * @override\n   */\n  keys() {\n    goog.asserts.assert(false, 'Not used!  Provided only for the compiler.');\n  }\n\n  /**\n   * @suppress {missingReturn}\n   * @override\n   */\n  values() {\n    goog.asserts.assert(false, 'Not used!  Provided only for the compiler.');\n  }\n};\n\n\nshaka.polyfill.register(shaka.polyfill.PatchedMediaKeysMs.install);\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.polyfill.PatchedMediaKeysNop');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.polyfill');\n\n\n/**\n * @summary A polyfill to stub out\n * {@link https://bit.ly/EmeMar15 EME draft 12 March 2015} on browsers without\n * EME.\n * All methods will fail.\n */\nshaka.polyfill.PatchedMediaKeysNop = class {\n  /**\n   * Installs the polyfill if needed.\n   */\n  static install() {\n    if (!window.HTMLVideoElement ||\n        (navigator.requestMediaKeySystemAccess &&\n         // eslint-disable-next-line no-restricted-syntax\n         MediaKeySystemAccess.prototype.getConfiguration)) {\n      return;\n    }\n    shaka.log.info('EME not available.');\n\n    // Alias.\n    const PatchedMediaKeysNop = shaka.polyfill.PatchedMediaKeysNop;\n\n    // Install patches.\n    navigator.requestMediaKeySystemAccess =\n        PatchedMediaKeysNop.requestMediaKeySystemAccess;\n    // Delete mediaKeys to work around strict mode compatibility issues.\n    // eslint-disable-next-line no-restricted-syntax\n    delete HTMLMediaElement.prototype['mediaKeys'];\n    // Work around read-only declaration for mediaKeys by using a string.\n    // eslint-disable-next-line no-restricted-syntax\n    HTMLMediaElement.prototype['mediaKeys'] = null;\n    // eslint-disable-next-line no-restricted-syntax\n    HTMLMediaElement.prototype.setMediaKeys = PatchedMediaKeysNop.setMediaKeys;\n    // These are not usable, but allow Player.isBrowserSupported to pass.\n    window.MediaKeys = PatchedMediaKeysNop.MediaKeys;\n    window.MediaKeySystemAccess = PatchedMediaKeysNop.MediaKeySystemAccess;\n  }\n\n  /**\n   * An implementation of navigator.requestMediaKeySystemAccess.\n   * Retrieves a MediaKeySystemAccess object.\n   *\n   * @this {!Navigator}\n   * @param {string} keySystem\n   * @param {!Array.<!MediaKeySystemConfiguration>} supportedConfigurations\n   * @return {!Promise.<!MediaKeySystemAccess>}\n   */\n  static requestMediaKeySystemAccess(keySystem, supportedConfigurations) {\n    shaka.log.debug('PatchedMediaKeysNop.requestMediaKeySystemAccess');\n    goog.asserts.assert(this == navigator,\n        'bad \"this\" for requestMediaKeySystemAccess');\n\n    return Promise.reject(new Error(\n        'The key system specified is not supported.'));\n  }\n\n  /**\n   * An implementation of HTMLMediaElement.prototype.setMediaKeys.\n   * Attaches a MediaKeys object to the media element.\n   *\n   * @this {!HTMLMediaElement}\n   * @param {MediaKeys} mediaKeys\n   * @return {!Promise}\n   */\n  static setMediaKeys(mediaKeys) {\n    shaka.log.debug('PatchedMediaKeysNop.setMediaKeys');\n    goog.asserts.assert(this instanceof HTMLMediaElement,\n        'bad \"this\" for setMediaKeys');\n\n    if (mediaKeys == null) {\n      return Promise.resolve();\n    }\n\n    return Promise.reject(new Error('MediaKeys not supported.'));\n  }\n};\n\n\n/**\n * An unusable constructor for MediaKeys.\n * @implements {MediaKeys}\n */\nshaka.polyfill.PatchedMediaKeysNop.MediaKeys = class {\n  constructor() {\n    throw new TypeError('Illegal constructor.');\n  }\n\n  /** @override */\n  createSession() {}\n\n  /** @override */\n  setServerCertificate() {}\n};\n\n\n/**\n * An unusable constructor for MediaKeySystemAccess.\n * @implements {MediaKeySystemAccess}\n */\nshaka.polyfill.PatchedMediaKeysNop.MediaKeySystemAccess = class {\n  constructor() {\n    /** @override */\n    this.keySystem = '';  // For the compiler.\n\n    throw new TypeError('Illegal constructor.');\n  }\n\n  /** @override */\n  getConfiguration() {}\n\n  /** @override */\n  createMediaKeys() {}\n};\n\n\n// A low priority ensures this is the last and acts as a fallback.\nshaka.polyfill.register(shaka.polyfill.PatchedMediaKeysNop.install, -10);\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.polyfill.PatchedMediaKeysWebkit');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.media.DrmEngine');\ngoog.require('shaka.polyfill');\ngoog.require('shaka.util.BufferUtils');\ngoog.require('shaka.util.EventManager');\ngoog.require('shaka.util.FakeEvent');\ngoog.require('shaka.util.FakeEventTarget');\ngoog.require('shaka.util.PublicPromise');\ngoog.require('shaka.util.StringUtils');\ngoog.require('shaka.util.Timer');\ngoog.require('shaka.util.Uint8ArrayUtils');\n\n\n/**\n * @summary A polyfill to implement\n * {@link https://bit.ly/EmeMar15 EME draft 12 March 2015} on top of\n * webkit-prefixed {@link https://bit.ly/Eme01b EME v0.1b}.\n */\nshaka.polyfill.PatchedMediaKeysWebkit = class {\n  /**\n   * Installs the polyfill if needed.\n   */\n  static install() {\n    // Alias.\n    const PatchedMediaKeysWebkit = shaka.polyfill.PatchedMediaKeysWebkit;\n\n    if (!window.HTMLVideoElement ||\n        (navigator.requestMediaKeySystemAccess &&\n         // eslint-disable-next-line no-restricted-syntax\n         MediaKeySystemAccess.prototype.getConfiguration)) {\n      return;\n    }\n    // eslint-disable-next-line no-restricted-syntax\n    if (HTMLMediaElement.prototype.webkitGenerateKeyRequest) {\n      shaka.log.info('Using webkit-prefixed EME v0.1b');\n      PatchedMediaKeysWebkit.prefix_ = 'webkit';\n      // eslint-disable-next-line no-restricted-syntax\n    } else if (HTMLMediaElement.prototype.generateKeyRequest) {\n      shaka.log.info('Using nonprefixed EME v0.1b');\n    } else {\n      return;\n    }\n\n    goog.asserts.assert(\n        // eslint-disable-next-line no-restricted-syntax\n        HTMLMediaElement.prototype[\n            PatchedMediaKeysWebkit.prefixApi_('generateKeyRequest')],\n        'PatchedMediaKeysWebkit APIs not available!');\n\n    // Install patches.\n    navigator.requestMediaKeySystemAccess =\n        PatchedMediaKeysWebkit.requestMediaKeySystemAccess;\n    // Delete mediaKeys to work around strict mode compatibility issues.\n    // eslint-disable-next-line no-restricted-syntax\n    delete HTMLMediaElement.prototype['mediaKeys'];\n    // Work around read-only declaration for mediaKeys by using a string.\n    // eslint-disable-next-line no-restricted-syntax\n    HTMLMediaElement.prototype['mediaKeys'] = null;\n    // eslint-disable-next-line no-restricted-syntax\n    HTMLMediaElement.prototype.setMediaKeys =\n        PatchedMediaKeysWebkit.setMediaKeys;\n    window.MediaKeys = PatchedMediaKeysWebkit.MediaKeys;\n    window.MediaKeySystemAccess = PatchedMediaKeysWebkit.MediaKeySystemAccess;\n  }\n\n  /**\n   * Prefix the api with the stored prefix.\n   *\n   * @param {string} api\n   * @return {string}\n   * @private\n   */\n  static prefixApi_(api) {\n    const prefix = shaka.polyfill.PatchedMediaKeysWebkit.prefix_;\n    if (prefix) {\n      return prefix + api.charAt(0).toUpperCase() + api.slice(1);\n    }\n    return api;\n  }\n\n  /**\n   * An implementation of navigator.requestMediaKeySystemAccess.\n   * Retrieves a MediaKeySystemAccess object.\n   *\n   * @this {!Navigator}\n   * @param {string} keySystem\n   * @param {!Array.<!MediaKeySystemConfiguration>} supportedConfigurations\n   * @return {!Promise.<!MediaKeySystemAccess>}\n   */\n  static requestMediaKeySystemAccess(keySystem, supportedConfigurations) {\n    shaka.log.debug('PatchedMediaKeysWebkit.requestMediaKeySystemAccess');\n    goog.asserts.assert(this == navigator,\n        'bad \"this\" for requestMediaKeySystemAccess');\n\n    // Alias.\n    const PatchedMediaKeysWebkit = shaka.polyfill.PatchedMediaKeysWebkit;\n    try {\n      const access = new PatchedMediaKeysWebkit.MediaKeySystemAccess(\n          keySystem, supportedConfigurations);\n      return Promise.resolve(/** @type {!MediaKeySystemAccess} */ (access));\n    } catch (exception) {\n      return Promise.reject(exception);\n    }\n  }\n\n  /**\n   * An implementation of HTMLMediaElement.prototype.setMediaKeys.\n   * Attaches a MediaKeys object to the media element.\n   *\n   * @this {!HTMLMediaElement}\n   * @param {MediaKeys} mediaKeys\n   * @return {!Promise}\n   */\n  static setMediaKeys(mediaKeys) {\n    shaka.log.debug('PatchedMediaKeysWebkit.setMediaKeys');\n    goog.asserts.assert(this instanceof HTMLMediaElement,\n        'bad \"this\" for setMediaKeys');\n\n    // Alias.\n    const PatchedMediaKeysWebkit = shaka.polyfill.PatchedMediaKeysWebkit;\n\n    const newMediaKeys =\n    /** @type {shaka.polyfill.PatchedMediaKeysWebkit.MediaKeys} */ (\n        mediaKeys);\n    const oldMediaKeys =\n    /** @type {shaka.polyfill.PatchedMediaKeysWebkit.MediaKeys} */ (\n        this.mediaKeys);\n\n    if (oldMediaKeys && oldMediaKeys != newMediaKeys) {\n      goog.asserts.assert(\n          oldMediaKeys instanceof PatchedMediaKeysWebkit.MediaKeys,\n          'non-polyfill instance of oldMediaKeys');\n      // Have the old MediaKeys stop listening to events on the video tag.\n      oldMediaKeys.setMedia(null);\n    }\n\n    delete this['mediaKeys'];  // In case there is an existing getter.\n    this['mediaKeys'] = mediaKeys;  // Work around the read-only declaration.\n\n    if (newMediaKeys) {\n      goog.asserts.assert(\n          newMediaKeys instanceof PatchedMediaKeysWebkit.MediaKeys,\n          'non-polyfill instance of newMediaKeys');\n      newMediaKeys.setMedia(this);\n    }\n\n    return Promise.resolve();\n  }\n\n  /**\n   * For some of this polyfill's implementation, we need to query a video\n   * element.  But for some embedded systems, it is memory-expensive to create\n   * multiple video elements.  Therefore, we check the document to see if we can\n   * borrow one to query before we fall back to creating one temporarily.\n   *\n   * @return {!HTMLVideoElement}\n   * @private\n   */\n  static getVideoElement_() {\n    const videos = document.getElementsByTagName('video');\n    const video = videos.length ? videos[0] : document.createElement('video');\n    return /** @type {!HTMLVideoElement} */(video);\n  }\n};\n\n\n/**\n * An implementation of MediaKeySystemAccess.\n *\n * @implements {MediaKeySystemAccess}\n */\nshaka.polyfill.PatchedMediaKeysWebkit.MediaKeySystemAccess = class {\n  /**\n   * @param {string} keySystem\n   * @param {!Array.<!MediaKeySystemConfiguration>} supportedConfigurations\n   */\n  constructor(keySystem, supportedConfigurations) {\n    shaka.log.debug('PatchedMediaKeysWebkit.MediaKeySystemAccess');\n\n    /** @type {string} */\n    this.keySystem = keySystem;\n\n    /** @private {string} */\n    this.internalKeySystem_ = keySystem;\n\n    /** @private {!MediaKeySystemConfiguration} */\n    this.configuration_;\n\n    // This is only a guess, since we don't really know from the prefixed API.\n    let allowPersistentState = false;\n\n    if (keySystem == 'org.w3.clearkey') {\n      // ClearKey's string must be prefixed in v0.1b.\n      this.internalKeySystem_ = 'webkit-org.w3.clearkey';\n      // ClearKey doesn't support persistence.\n      allowPersistentState = false;\n    }\n\n    let success = false;\n    const tmpVideo = shaka.polyfill.PatchedMediaKeysWebkit.getVideoElement_();\n    for (const cfg of supportedConfigurations) {\n      // Create a new config object and start adding in the pieces which we\n      // find support for.  We will return this from getConfiguration() if\n      // asked.\n      /** @type {!MediaKeySystemConfiguration} */\n      const newCfg = {\n        'audioCapabilities': [],\n        'videoCapabilities': [],\n        // It is technically against spec to return these as optional, but we\n        // don't truly know their values from the prefixed API:\n        'persistentState': 'optional',\n        'distinctiveIdentifier': 'optional',\n        // Pretend the requested init data types are supported, since we don't\n        // really know that either:\n        'initDataTypes': cfg.initDataTypes,\n        'sessionTypes': ['temporary'],\n        'label': cfg.label,\n      };\n\n      // v0.1b tests for key system availability with an extra argument on\n      // canPlayType.\n      let ranAnyTests = false;\n      if (cfg.audioCapabilities) {\n        for (const cap of cfg.audioCapabilities) {\n          if (cap.contentType) {\n            ranAnyTests = true;\n            // In Chrome <= 40, if you ask about Widevine-encrypted audio\n            // support, you get a false-negative when you specify codec\n            // information. Work around this by stripping codec info for audio\n            // types.\n            const contentType = cap.contentType.split(';')[0];\n            if (tmpVideo.canPlayType(contentType, this.internalKeySystem_)) {\n              newCfg.audioCapabilities.push(cap);\n              success = true;\n            }\n          }\n        }\n      }\n      if (cfg.videoCapabilities) {\n        for (const cap of cfg.videoCapabilities) {\n          if (cap.contentType) {\n            ranAnyTests = true;\n            if (tmpVideo.canPlayType(\n                cap.contentType, this.internalKeySystem_)) {\n              newCfg.videoCapabilities.push(cap);\n              success = true;\n            }\n          }\n        }\n      }\n\n      if (!ranAnyTests) {\n        // If no specific types were requested, we check all common types to\n        // find out if the key system is present at all.\n        success =\n            tmpVideo.canPlayType('video/mp4', this.internalKeySystem_) ||\n            tmpVideo.canPlayType('video/webm', this.internalKeySystem_);\n      }\n      if (cfg.persistentState == 'required') {\n        if (allowPersistentState) {\n          newCfg.persistentState = 'required';\n          newCfg.sessionTypes = ['persistent-license'];\n        } else {\n          success = false;\n        }\n      }\n\n      if (success) {\n        this.configuration_ = newCfg;\n        return;\n      }\n    }  // for each cfg in supportedConfigurations\n\n    let message = 'Unsupported keySystem';\n    if (keySystem == 'org.w3.clearkey' || keySystem == 'com.widevine.alpha') {\n      message = 'None of the requested configurations were supported.';\n    }\n\n    // According to the spec, this should be a DOMException, but there is not a\n    // public constructor for that.  So we make this look-alike instead.\n    const unsupportedError = new Error(message);\n    unsupportedError.name = 'NotSupportedError';\n    unsupportedError['code'] = DOMException.NOT_SUPPORTED_ERR;\n    throw unsupportedError;\n  }\n\n  /** @override */\n  createMediaKeys() {\n    shaka.log.debug(\n        'PatchedMediaKeysWebkit.MediaKeySystemAccess.createMediaKeys');\n\n    // Alias.\n    const PatchedMediaKeysWebkit = shaka.polyfill.PatchedMediaKeysWebkit;\n    const mediaKeys =\n    new PatchedMediaKeysWebkit.MediaKeys(this.internalKeySystem_);\n    return Promise.resolve(/** @type {!MediaKeys} */ (mediaKeys));\n  }\n\n  /** @override */\n  getConfiguration() {\n    shaka.log.debug(\n        'PatchedMediaKeysWebkit.MediaKeySystemAccess.getConfiguration');\n    return this.configuration_;\n  }\n};\n\n\n/**\n * An implementation of MediaKeys.\n *\n * @implements {MediaKeys}\n */\nshaka.polyfill.PatchedMediaKeysWebkit.MediaKeys = class {\n  /**\n   * @param {string} keySystem\n   */\n  constructor(keySystem) {\n    shaka.log.debug('PatchedMediaKeysWebkit.MediaKeys');\n\n    /** @private {string} */\n    this.keySystem_ = keySystem;\n\n    /** @private {HTMLMediaElement} */\n    this.media_ = null;\n\n    /** @private {!shaka.util.EventManager} */\n    this.eventManager_ = new shaka.util.EventManager();\n\n    /**\n     * @private {Array.<!shaka.polyfill.PatchedMediaKeysWebkit.MediaKeySession>}\n     */\n    this.newSessions_ = [];\n\n    /**\n     * @private {!Map.<string,\n     *                 !shaka.polyfill.PatchedMediaKeysWebkit.MediaKeySession>}\n     */\n    this.sessionMap_ = new Map();\n  }\n\n  /**\n   * @param {HTMLMediaElement} media\n   * @protected\n   */\n  setMedia(media) {\n    this.media_ = media;\n\n    // Remove any old listeners.\n    this.eventManager_.removeAll();\n\n    const prefix = shaka.polyfill.PatchedMediaKeysWebkit.prefix_;\n    if (media) {\n      // Intercept and translate these prefixed EME events.\n      this.eventManager_.listen(media, prefix + 'needkey',\n      /** @type {shaka.util.EventManager.ListenerType} */ (\n            (event) => this.onWebkitNeedKey_(event)));\n\n      this.eventManager_.listen(media, prefix + 'keymessage',\n      /** @type {shaka.util.EventManager.ListenerType} */ (\n            (event) => this.onWebkitKeyMessage_(event)));\n\n      this.eventManager_.listen(media, prefix + 'keyadded',\n      /** @type {shaka.util.EventManager.ListenerType} */ (\n            (event) => this.onWebkitKeyAdded_(event)));\n\n      this.eventManager_.listen(media, prefix + 'keyerror',\n      /** @type {shaka.util.EventManager.ListenerType} */ (\n            (event) => this.onWebkitKeyError_(event)));\n    }\n  }\n\n  /** @override */\n  createSession(sessionType) {\n    shaka.log.debug('PatchedMediaKeysWebkit.MediaKeys.createSession');\n\n    sessionType = sessionType || 'temporary';\n    if (sessionType != 'temporary' && sessionType != 'persistent-license') {\n      throw new TypeError('Session type ' + sessionType +\n                      ' is unsupported on this platform.');\n    }\n\n    // Alias.\n    const PatchedMediaKeysWebkit = shaka.polyfill.PatchedMediaKeysWebkit;\n\n    // Unprefixed EME allows for session creation without a video tag or src.\n    // Prefixed EME requires both a valid HTMLMediaElement and a src.\n    const media = this.media_ || /** @type {!HTMLMediaElement} */(\n      document.createElement('video'));\n    if (!media.src) {\n      media.src = 'about:blank';\n    }\n\n    const session = new PatchedMediaKeysWebkit.MediaKeySession(\n        media, this.keySystem_, sessionType);\n    this.newSessions_.push(session);\n    return session;\n  }\n\n  /** @override */\n  setServerCertificate(serverCertificate) {\n    shaka.log.debug('PatchedMediaKeysWebkit.MediaKeys.setServerCertificate');\n\n    // There is no equivalent in v0.1b, so return failure.\n    return Promise.resolve(false);\n  }\n\n  /**\n   * @param {!MediaKeyEvent} event\n   * @suppress {constantProperty} We reassign what would be const on a real\n   *   MediaEncryptedEvent, but in our look-alike event.\n   * @private\n   */\n  onWebkitNeedKey_(event) {\n    shaka.log.debug('PatchedMediaKeysWebkit.onWebkitNeedKey_', event);\n    goog.asserts.assert(this.media_, 'media_ not set in onWebkitNeedKey_');\n\n    const event2 =\n      /** @type {!CustomEvent} */ (document.createEvent('CustomEvent'));\n    event2.initCustomEvent('encrypted', false, false, null);\n\n    const encryptedEvent =\n      /** @type {!MediaEncryptedEvent} */(/** @type {?} */(event2));\n    // initDataType is not used by v0.1b EME, so any valid value is fine here.\n    encryptedEvent.initDataType = 'cenc';\n    encryptedEvent.initData = shaka.util.BufferUtils.toArrayBuffer(\n        event.initData);\n\n    this.media_.dispatchEvent(event2);\n  }\n\n  /**\n   * @param {!MediaKeyEvent} event\n   * @private\n   */\n  onWebkitKeyMessage_(event) {\n    shaka.log.debug('PatchedMediaKeysWebkit.onWebkitKeyMessage_', event);\n\n    const session = this.findSession_(event.sessionId);\n    if (!session) {\n      shaka.log.error('Session not found', event.sessionId);\n      return;\n    }\n\n    const isNew = session.keyStatuses.getStatus() == undefined;\n\n    const event2 = new shaka.util.FakeEvent('message', {\n      messageType: isNew ? 'licenserequest' : 'licenserenewal',\n      message: event.message,\n    });\n\n    session.generated();\n    session.dispatchEvent(event2);\n  }\n\n  /**\n   * @param {!MediaKeyEvent} event\n   * @private\n   */\n  onWebkitKeyAdded_(event) {\n    shaka.log.debug('PatchedMediaKeysWebkit.onWebkitKeyAdded_', event);\n\n    const session = this.findSession_(event.sessionId);\n    goog.asserts.assert(\n        session, 'unable to find session in onWebkitKeyAdded_');\n    if (session) {\n      session.ready();\n    }\n  }\n\n  /**\n   * @param {!MediaKeyEvent} event\n   * @private\n   */\n  onWebkitKeyError_(event) {\n    shaka.log.debug('PatchedMediaKeysWebkit.onWebkitKeyError_', event);\n\n    const session = this.findSession_(event.sessionId);\n    goog.asserts.assert(\n        session, 'unable to find session in onWebkitKeyError_');\n    if (session) {\n      session.handleError(event);\n    }\n  }\n\n  /**\n   * @param {string} sessionId\n   * @return {shaka.polyfill.PatchedMediaKeysWebkit.MediaKeySession}\n   * @private\n   */\n  findSession_(sessionId) {\n    let session = this.sessionMap_.get(sessionId);\n    if (session) {\n      shaka.log.debug(\n          'PatchedMediaKeysWebkit.MediaKeys.findSession_', session);\n      return session;\n    }\n\n    session = this.newSessions_.shift();\n    if (session) {\n      session.sessionId = sessionId;\n      this.sessionMap_.set(sessionId, session);\n      shaka.log.debug(\n          'PatchedMediaKeysWebkit.MediaKeys.findSession_', session);\n      return session;\n    }\n\n    return null;\n  }\n};\n\n\n/**\n * An implementation of MediaKeySession.\n *\n * @implements {MediaKeySession}\n */\nshaka.polyfill.PatchedMediaKeysWebkit.MediaKeySession =\nclass extends shaka.util.FakeEventTarget {\n  /**\n   * @param {!HTMLMediaElement} media\n   * @param {string} keySystem\n   * @param {string} sessionType\n   */\n  constructor(media, keySystem, sessionType) {\n    shaka.log.debug('PatchedMediaKeysWebkit.MediaKeySession');\n    super();\n\n    /** @private {!HTMLMediaElement} */\n    this.media_ = media;\n\n    /** @private {boolean} */\n    this.initialized_ = false;\n\n    /** @private {shaka.util.PublicPromise} */\n    this.generatePromise_ = null;\n\n    /** @private {shaka.util.PublicPromise} */\n    this.updatePromise_ = null;\n\n    /** @private {string} */\n    this.keySystem_ = keySystem;\n\n    /** @private {string} */\n    this.type_ = sessionType;\n\n    /** @type {string} */\n    this.sessionId = '';\n\n    /** @type {number} */\n    this.expiration = NaN;\n\n    /** @type {!shaka.util.PublicPromise} */\n    this.closed = new shaka.util.PublicPromise();\n\n    /** @type {!shaka.polyfill.PatchedMediaKeysWebkit.MediaKeyStatusMap} */\n    this.keyStatuses =\n        new shaka.polyfill.PatchedMediaKeysWebkit.MediaKeyStatusMap();\n  }\n\n  /**\n   * Signals that the license request has been generated.  This resolves the\n   * 'generateRequest' promise.\n   *\n   * @protected\n   */\n  generated() {\n    shaka.log.debug('PatchedMediaKeysWebkit.MediaKeySession.generated');\n\n    if (this.generatePromise_) {\n      this.generatePromise_.resolve();\n      this.generatePromise_ = null;\n    }\n  }\n\n  /**\n   * Signals that the session is 'ready', which is the terminology used in older\n   * versions of EME.  The new signal is to resolve the 'update' promise.  This\n   * translates between the two.\n   *\n   * @protected\n   */\n  ready() {\n    shaka.log.debug('PatchedMediaKeysWebkit.MediaKeySession.ready');\n\n    this.updateKeyStatus_('usable');\n\n    if (this.updatePromise_) {\n      this.updatePromise_.resolve();\n    }\n    this.updatePromise_ = null;\n  }\n\n  /**\n   * Either rejects a promise, or dispatches an error event, as appropriate.\n   *\n   * @param {!MediaKeyEvent} event\n   */\n  handleError(event) {\n    shaka.log.debug(\n        'PatchedMediaKeysWebkit.MediaKeySession.handleError', event);\n\n    // This does not match the DOMException we get in current WD EME, but it\n    // will at least provide some information which can be used to look into the\n    // problem.\n    const error = new Error('EME v0.1b key error');\n    const errorCode = event.errorCode;\n    errorCode.systemCode = event.systemCode;\n    error['errorCode'] = errorCode;\n\n    // The presence or absence of sessionId indicates whether this corresponds\n    // to generateRequest() or update().\n    if (!event.sessionId && this.generatePromise_) {\n      if (event.systemCode == 45) {\n        error.message = 'Unsupported session type.';\n      }\n      this.generatePromise_.reject(error);\n      this.generatePromise_ = null;\n    } else if (event.sessionId && this.updatePromise_) {\n      this.updatePromise_.reject(error);\n      this.updatePromise_ = null;\n    } else {\n      // This mapping of key statuses is imperfect at best.\n      const code = event.errorCode.code;\n      const systemCode = event.systemCode;\n      if (code == MediaKeyError['MEDIA_KEYERR_OUTPUT']) {\n        this.updateKeyStatus_('output-restricted');\n      } else if (systemCode == 1) {\n        this.updateKeyStatus_('expired');\n      } else {\n        this.updateKeyStatus_('internal-error');\n      }\n    }\n  }\n\n  /**\n   * Logic which is shared between generateRequest() and load(), both of which\n   * are ultimately implemented with webkitGenerateKeyRequest in prefixed EME.\n   *\n   * @param {?BufferSource} initData\n   * @param {?string} offlineSessionId\n   * @return {!Promise}\n   * @private\n   */\n  generate_(initData, offlineSessionId) {\n    const PatchedMediaKeysWebkit = shaka.polyfill.PatchedMediaKeysWebkit;\n\n    if (this.initialized_) {\n      const error = new Error('The session is already initialized.');\n      return Promise.reject(error);\n    }\n\n    this.initialized_ = true;\n\n    /** @type {!Uint8Array} */\n    let mangledInitData;\n\n    try {\n      if (this.type_ == 'persistent-license') {\n        const StringUtils = shaka.util.StringUtils;\n        if (!offlineSessionId) {\n          goog.asserts.assert(initData, 'expecting init data');\n          // Persisting the initial license.\n          // Prefix the init data with a tag to indicate persistence.\n          const prefix = StringUtils.toUTF8('PERSISTENT|');\n          mangledInitData = shaka.util.Uint8ArrayUtils.concat(prefix, initData);\n        } else {\n          // Loading a stored license.\n          // Prefix the init data (which is really a session ID) with a tag to\n          // indicate that we are loading a persisted session.\n          mangledInitData = shaka.util.BufferUtils.toUint8(\n              StringUtils.toUTF8('LOAD_SESSION|' + offlineSessionId));\n        }\n      } else {\n        // Streaming.\n        goog.asserts.assert(this.type_ == 'temporary',\n            'expected temporary session');\n        goog.asserts.assert(!offlineSessionId,\n            'unexpected offline session ID');\n        goog.asserts.assert(initData, 'expecting init data');\n        mangledInitData = shaka.util.BufferUtils.toUint8(initData);\n      }\n\n      goog.asserts.assert(mangledInitData, 'init data not set!');\n    } catch (exception) {\n      return Promise.reject(exception);\n    }\n\n    goog.asserts.assert(this.generatePromise_ == null,\n        'generatePromise_ should be null');\n    this.generatePromise_ = new shaka.util.PublicPromise();\n\n    // Because we are hacking media.src in createSession to better emulate\n    // unprefixed EME's ability to create sessions and license requests without\n    // a video tag, we can get ourselves into trouble.  It seems that sometimes,\n    // the setting of media.src hasn't been processed by some other thread, and\n    // GKR can throw an exception.  If this occurs, wait 10 ms and try again at\n    // most once.  This situation should only occur when init data is available\n    // ahead of the 'needkey' event.\n\n    const generateKeyRequestName =\n        PatchedMediaKeysWebkit.prefixApi_('generateKeyRequest');\n    try {\n      this.media_[generateKeyRequestName](this.keySystem_, mangledInitData);\n    } catch (exception) {\n      if (exception.name != 'InvalidStateError') {\n        this.generatePromise_ = null;\n        return Promise.reject(exception);\n      }\n\n      const timer = new shaka.util.Timer(() => {\n        try {\n          this.media_[generateKeyRequestName](this.keySystem_, mangledInitData);\n        } catch (exception2) {\n          this.generatePromise_.reject(exception2);\n          this.generatePromise_ = null;\n        }\n      });\n\n      timer.tickAfter(/* seconds= */ 0.01);\n    }\n\n    return this.generatePromise_;\n  }\n\n  /**\n   * An internal version of update which defers new calls while old ones are in\n   * progress.\n   *\n   * @param {!shaka.util.PublicPromise} promise  The promise associated with\n   *   this call.\n   * @param {BufferSource} response\n   * @private\n   */\n  update_(promise, response) {\n    const PatchedMediaKeysWebkit = shaka.polyfill.PatchedMediaKeysWebkit;\n\n    if (this.updatePromise_) {\n      // We already have an update in-progress, so defer this one until after\n      // the old one is resolved.  Execute this whether the original one\n      // succeeds or fails.\n      this.updatePromise_.then(() => this.update_(promise, response))\n          .catch(() => this.update_(promise, response));\n      return;\n    }\n\n    this.updatePromise_ = promise;\n\n    let key;\n    let keyId;\n\n    if (this.keySystem_ == 'webkit-org.w3.clearkey') {\n      // The current EME version of clearkey wants a structured JSON response.\n      // The v0.1b version wants just a raw key.  Parse the JSON response and\n      // extract the key and key ID.\n      const StringUtils = shaka.util.StringUtils;\n      const Uint8ArrayUtils = shaka.util.Uint8ArrayUtils;\n      const licenseString = StringUtils.fromUTF8(response);\n      const jwkSet = /** @type {JWKSet} */ (JSON.parse(licenseString));\n      const kty = jwkSet.keys[0].kty;\n      if (kty != 'oct') {\n        // Reject the promise.\n        this.updatePromise_.reject(new Error(\n            'Response is not a valid JSON Web Key Set.'));\n        this.updatePromise_ = null;\n      }\n      key = Uint8ArrayUtils.fromBase64(jwkSet.keys[0].k);\n      keyId = Uint8ArrayUtils.fromBase64(jwkSet.keys[0].kid);\n    } else {\n      // The key ID is not required.\n      key = shaka.util.BufferUtils.toUint8(response);\n      keyId = null;\n    }\n\n    const addKeyName = PatchedMediaKeysWebkit.prefixApi_('addKey');\n    try {\n      this.media_[addKeyName](this.keySystem_, key, keyId, this.sessionId);\n    } catch (exception) {\n      // Reject the promise.\n      this.updatePromise_.reject(exception);\n      this.updatePromise_ = null;\n    }\n  }\n\n  /**\n   * Update key status and dispatch a 'keystatuseschange' event.\n   *\n   * @param {string} status\n   * @private\n   */\n  updateKeyStatus_(status) {\n    this.keyStatuses.setStatus(status);\n    const event = new shaka.util.FakeEvent('keystatuseschange');\n    this.dispatchEvent(event);\n  }\n\n  /** @override */\n  generateRequest(initDataType, initData) {\n    shaka.log.debug('PatchedMediaKeysWebkit.MediaKeySession.generateRequest');\n    return this.generate_(initData, null);\n  }\n\n  /** @override */\n  load(sessionId) {\n    shaka.log.debug('PatchedMediaKeysWebkit.MediaKeySession.load');\n    if (this.type_ == 'persistent-license') {\n      return this.generate_(null, sessionId);\n    } else {\n      return Promise.reject(new Error('Not a persistent session.'));\n    }\n  }\n\n  /** @override */\n  update(response) {\n    shaka.log.debug('PatchedMediaKeysWebkit.MediaKeySession.update', response);\n    goog.asserts.assert(this.sessionId, 'update without session ID');\n\n    const nextUpdatePromise = new shaka.util.PublicPromise();\n    this.update_(nextUpdatePromise, response);\n    return nextUpdatePromise;\n  }\n\n  /** @override */\n  close() {\n    const PatchedMediaKeysWebkit = shaka.polyfill.PatchedMediaKeysWebkit;\n\n    shaka.log.debug('PatchedMediaKeysWebkit.MediaKeySession.close');\n\n    // This will remove a persistent session, but it's also the only way to free\n    // CDM resources on v0.1b.\n    if (this.type_ != 'persistent-license') {\n      // sessionId may reasonably be null if no key request has been generated\n      // yet.  Unprefixed EME will return a rejected promise in this case.  We\n      // will use the same error message that Chrome 41 uses in its EME\n      // implementation.\n      if (!this.sessionId) {\n        this.closed.reject(new Error('The session is not callable.'));\n        return this.closed;\n      }\n\n      // This may throw an exception, but we ignore it because we are only using\n      // it to clean up resources in v0.1b.  We still consider the session\n      // closed. We can't let the exception propagate because\n      // MediaKeySession.close() should not throw.\n      const cancelKeyRequestName =\n          PatchedMediaKeysWebkit.prefixApi_('cancelKeyRequest');\n      try {\n        this.media_[cancelKeyRequestName](this.keySystem_, this.sessionId);\n      } catch (exception) {}\n    }\n\n    // Resolve the 'closed' promise and return it.\n    this.closed.resolve();\n    return this.closed;\n  }\n\n  /** @override */\n  remove() {\n    shaka.log.debug('PatchedMediaKeysWebkit.MediaKeySession.remove');\n\n    if (this.type_ != 'persistent-license') {\n      return Promise.reject(new Error('Not a persistent session.'));\n    }\n\n    return this.close();\n  }\n};\n\n\n/**\n * An implementation of MediaKeyStatusMap.\n * This fakes a map with a single key ID.\n *\n * @todo Consolidate the MediaKeyStatusMap types in these polyfills.\n * @implements {MediaKeyStatusMap}\n */\nshaka.polyfill.PatchedMediaKeysWebkit.MediaKeyStatusMap = class {\n  constructor() {\n    /**\n     * @type {number}\n     */\n    this.size = 0;\n\n    /**\n     * @private {string|undefined}\n     */\n    this.status_ = undefined;\n  }\n\n  /**\n   * An internal method used by the session to set key status.\n   * @param {string|undefined} status\n   */\n  setStatus(status) {\n    this.size = status == undefined ? 0 : 1;\n    this.status_ = status;\n  }\n\n  /**\n   * An internal method used by the session to get key status.\n   * @return {string|undefined}\n   */\n  getStatus() {\n    return this.status_;\n  }\n\n  /** @override */\n  forEach(fn) {\n    if (this.status_) {\n      fn(this.status_, shaka.media.DrmEngine.DUMMY_KEY_ID.value());\n    }\n  }\n\n  /** @override */\n  get(keyId) {\n    if (this.has(keyId)) {\n      return this.status_;\n    }\n    return undefined;\n  }\n\n  /** @override */\n  has(keyId) {\n    const fakeKeyId = shaka.media.DrmEngine.DUMMY_KEY_ID.value();\n    if (this.status_ && shaka.util.BufferUtils.equal(keyId, fakeKeyId)) {\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * @suppress {missingReturn}\n   * @override\n   */\n  entries() {\n    goog.asserts.assert(false, 'Not used!  Provided only for compiler.');\n  }\n\n  /**\n   * @suppress {missingReturn}\n   * @override\n   */\n  keys() {\n    goog.asserts.assert(false, 'Not used!  Provided only for compiler.');\n  }\n\n  /**\n   * @suppress {missingReturn}\n   * @override\n   */\n  values() {\n    goog.asserts.assert(false, 'Not used!  Provided only for compiler.');\n  }\n};\n\n\n/**\n * Store api prefix.\n *\n * @private {string}\n */\nshaka.polyfill.PatchedMediaKeysWebkit.prefix_ = '';\n\n\nshaka.polyfill.register(shaka.polyfill.PatchedMediaKeysWebkit.install);\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.polyfill.EncryptionScheme');\n\ngoog.require('shaka.polyfill');\n\n/**\n * @summary A polyfill to add support for EncryptionScheme queries in EME.\n * @see https://wicg.github.io/encrypted-media-encryption-scheme/\n * @see https://github.com/w3c/encrypted-media/pull/457\n * @see https://github.com/google/eme-encryption-scheme-polyfill\n */\nshaka.polyfill.EncryptionScheme = class {\n  /**\n   * Install the polyfill if needed.\n   *\n   * @suppress {missingRequire}\n   */\n  static install() {\n    EncryptionSchemePolyfills.install();\n  }\n};\n\n// Install at a low priority so that other EME polyfills go first.\nshaka.polyfill.register(shaka.polyfill.EncryptionScheme.install, -1);\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.polyfill.Languages');\n\ngoog.require('shaka.polyfill');\n\n\n/**\n * @summary A polyfill to provide navigator.languages on all browsers.\n * This is necessary for IE and possibly others we have yet to discover.\n */\nshaka.polyfill.Languages = class {\n  /**\n   * Install the polyfill if needed.\n   */\n  static install() {\n    if (navigator.languages) {\n      // No need.\n      return;\n    }\n\n    Object.defineProperty(navigator, 'languages', {\n      get: () => {\n        // If the browser provides a single language (all that we've seen), then\n        // make an array out of that.  Otherwise, return English.\n        if (navigator.language) {\n          return [navigator.language];\n        }\n        return ['en'];\n      },\n    });\n  }\n};\n\n\nshaka.polyfill.register(shaka.polyfill.Languages.install);\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\ngoog.provide('shaka.polyfill.MathRound');\n\ngoog.require('shaka.log');\ngoog.require('shaka.polyfill');\n\n/**\n * @summary A polyfill to patch math round bug on some browsers.\n * @see https://stackoverflow.com/q/12830742\n */\nshaka.polyfill.MathRound = class {\n  /**\n   * Install the polyfill if needed.\n   */\n  static install() {\n    shaka.log.debug('mathRound.install');\n\n    const testNumber = shaka.polyfill.MathRound.MAX_ACCURATE_INPUT_ + 1;\n    if (Math.round(testNumber) != testNumber) {\n      shaka.log.debug('polyfill Math.round');\n      const originalMathRound = Math.round;\n      Math.round = (number) => {\n        let result = number;\n        // Due to the precision of JavaScript numbers, the number must be\n        // integer.\n        if (number <= shaka.polyfill.MathRound.MAX_ACCURATE_INPUT_) {\n          result = originalMathRound(number);\n        }\n        return result;\n      };\n    }\n  }\n};\n\n\n/**\n @const {number}\n @private\n */\nshaka.polyfill.MathRound.MAX_ACCURATE_INPUT_ = 0x10000000000000;\n\n\nshaka.polyfill.register(shaka.polyfill.MathRound.install);\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.polyfill.PiPWebkit');\n\ngoog.require('shaka.log');\ngoog.require('shaka.polyfill');\n\n/**\n * @summary A polyfill to provide PiP support in Safari.\n * Note that Safari only supports PiP on video elements, not audio.\n */\nshaka.polyfill.PiPWebkit = class {\n  /**\n   * Install the polyfill if needed.\n   */\n  static install() {\n    if (!window.HTMLVideoElement) {\n      // Avoid errors on very old browsers.\n      return;\n    }\n\n    // eslint-disable-next-line no-restricted-syntax\n    const proto = HTMLVideoElement.prototype;\n    if (proto.requestPictureInPicture &&\n      document.exitPictureInPicture) {\n      // No polyfill needed.\n      return;\n    }\n\n    if (!proto.webkitSupportsPresentationMode) {\n      // No Webkit PiP API available.\n      return;\n    }\n\n    const PiPWebkit = shaka.polyfill.PiPWebkit;\n    shaka.log.debug('PiPWebkit.install');\n\n    // Polyfill document.pictureInPictureEnabled.\n    // It's definitely enabled now.  :-)\n    document.pictureInPictureEnabled = true;\n\n    // Polyfill document.pictureInPictureElement.\n    // This is initially empty.  We don't need getter or setter because we don't\n    // need any special handling when this is set.  We assume in good faith that\n    // applications won't try to set this directly.\n    document.pictureInPictureElement = null;\n\n    // Polyfill HTMLVideoElement.requestPictureInPicture.\n    proto.requestPictureInPicture = PiPWebkit.requestPictureInPicture_;\n\n    // Polyfill HTMLVideoElement.disablePictureInPicture.\n    Object.defineProperty(proto, 'disablePictureInPicture', {\n      get: PiPWebkit.getDisablePictureInPicture_,\n      set: PiPWebkit.setDisablePictureInPicture_,\n      // You should be able to discover this property.\n      enumerable: true,\n      // And maybe we're not so smart.  Let someone else change it if they want.\n      configurable: true,\n    });\n\n    // Polyfill document.exitPictureInPicture.\n    document.exitPictureInPicture = PiPWebkit.exitPictureInPicture_;\n\n    // Use the \"capturing\" event phase to get the webkit presentation mode event\n    // from the document.  This way, we get the event on its way from document\n    // to the target element without having to intercept events in every\n    // possible video element.\n    document.addEventListener(\n        'webkitpresentationmodechanged', PiPWebkit.proxyEvent_,\n        /* useCapture= */ true);\n  }\n\n  /**\n   * @param {!Event} event\n   * @private\n   */\n  static proxyEvent_(event) {\n    const PiPWebkit = shaka.polyfill.PiPWebkit;\n    const element = /** @type {!HTMLVideoElement} */(event.target);\n\n    if (element.webkitPresentationMode == PiPWebkit.PIP_MODE_) {\n      // Keep track of the PiP element.  This element just entered PiP mode.\n      document.pictureInPictureElement = element;\n\n      // Dispatch a standard event to match.\n      const event2 = new Event('enterpictureinpicture');\n      element.dispatchEvent(event2);\n    } else {\n      // Keep track of the PiP element.  This element just left PiP mode.\n      // If something else hasn't already take its place, clear it.\n      if (document.pictureInPictureElement == element) {\n        document.pictureInPictureElement = null;\n      }\n\n      // Dispatch a standard event to match.\n      const event2 = new Event('leavepictureinpicture');\n      element.dispatchEvent(event2);\n    }\n  }\n\n  /**\n   * @this {HTMLVideoElement}\n   * @return {!Promise}\n   * @private\n   */\n  static requestPictureInPicture_() {\n    const PiPWebkit = shaka.polyfill.PiPWebkit;\n    // NOTE: \"this\" here is the video element.\n\n    // Check if PiP is enabled for this element.\n    if (!this.webkitSupportsPresentationMode(PiPWebkit.PIP_MODE_)) {\n      const error = new Error('PiP not allowed by video element');\n      return Promise.reject(error);\n    } else {\n      // Enter PiP mode.\n      this.webkitSetPresentationMode(PiPWebkit.PIP_MODE_);\n      document.pictureInPictureElement = this;\n      return Promise.resolve();\n    }\n  }\n\n  /**\n   * @this {Document}\n   * @return {!Promise}\n   * @private\n   */\n  static exitPictureInPicture_() {\n    const PiPWebkit = shaka.polyfill.PiPWebkit;\n\n    const pipElement =\n    /** @type {HTMLVideoElement} */(document.pictureInPictureElement);\n    if (pipElement) {\n      // Exit PiP mode.\n      pipElement.webkitSetPresentationMode(PiPWebkit.INLINE_MODE_);\n      document.pictureInPictureElement = null;\n      return Promise.resolve();\n    } else {\n      const error = new Error('No picture in picture element found');\n      return Promise.reject(error);\n    }\n  }\n\n  /**\n   * @this {HTMLVideoElement}\n   * @return {boolean}\n   * @private\n   */\n  static getDisablePictureInPicture_() {\n    // This respects the HTML attribute, which may have been set in HTML or\n    // through the JS setter.\n    if (this.hasAttribute('disablePictureInPicture')) {\n      return true;\n    }\n\n    // Use Apple's non-standard API to know if PiP is allowed on this\n    // device for this content. If not, say that PiP is disabled, even\n    // if not specified by the user through the setter or HTML attribute.\n    const PiPWebkit = shaka.polyfill.PiPWebkit;\n    return !this.webkitSupportsPresentationMode(PiPWebkit.PIP_MODE_);\n  }\n\n  /**\n   * @this {HTMLVideoElement}\n   * @param {boolean} value\n   * @private\n   */\n  static setDisablePictureInPicture_(value) {\n    // This mimics how the JS setter works in browsers that implement the spec.\n    if (value) {\n      this.setAttribute('disablePictureInPicture', '');\n    } else {\n      this.removeAttribute('disablePictureInPicture');\n    }\n  }\n};\n\n\n/**\n * The presentation mode string used to indicate PiP mode in Safari.\n *\n * @const {string}\n * @private\n */\nshaka.polyfill.PiPWebkit.PIP_MODE_ = 'picture-in-picture';\n\n\n/**\n * The presentation mode string used to indicate inline mode in Safari.\n *\n * @const {string}\n * @private\n */\nshaka.polyfill.PiPWebkit.INLINE_MODE_ = 'inline';\n\n\nshaka.polyfill.register(shaka.polyfill.PiPWebkit.install);\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.polyfill.VideoPlaybackQuality');\n\ngoog.require('shaka.polyfill');\n\n\n/**\n * @summary A polyfill to provide MSE VideoPlaybackQuality metrics.\n * Many browsers do not yet provide this API, and Chrome currently provides\n * similar data through individual prefixed attributes on HTMLVideoElement.\n */\nshaka.polyfill.VideoPlaybackQuality = class {\n  /**\n   * Install the polyfill if needed.\n   */\n  static install() {\n    if (!window.HTMLVideoElement) {\n      // Avoid errors on very old browsers.\n      return;\n    }\n\n    // eslint-disable-next-line no-restricted-syntax\n    const proto = HTMLVideoElement.prototype;\n    if (proto.getVideoPlaybackQuality) {\n      // No polyfill needed.\n      return;\n    }\n\n    if ('webkitDroppedFrameCount' in proto) {\n      proto.getVideoPlaybackQuality =\n          shaka.polyfill.VideoPlaybackQuality.webkit_;\n    }\n  }\n\n  /**\n   * @this {HTMLVideoElement}\n   * @return {!VideoPlaybackQuality}\n   * @private\n   */\n  static webkit_() {\n    return {\n      'droppedVideoFrames': this.webkitDroppedFrameCount,\n      'totalVideoFrames': this.webkitDecodedFrameCount,\n      // Not provided by this polyfill:\n      'corruptedVideoFrames': 0,\n      'creationTime': NaN,\n      'totalFrameDelay': 0,\n    };\n  }\n};\n\n\nshaka.polyfill.register(shaka.polyfill.VideoPlaybackQuality.install);\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.polyfill.VTTCue');\n\ngoog.require('shaka.log');\ngoog.require('shaka.polyfill');\n\n\n/**\n * @summary A polyfill to provide VTTCue.\n */\nshaka.polyfill.VTTCue = class {\n  /**\n   * Install the polyfill if needed.\n   */\n  static install() {\n    if (window.VTTCue) {\n      shaka.log.info('Using native VTTCue.');\n      return;\n    }\n\n    if (!window.TextTrackCue) {\n      shaka.log.error('VTTCue not available.');\n      return;\n    }\n\n    /** @type {?function(number, number, string):!TextTrackCue} */\n    let replacement = null;\n    const constructorLength = TextTrackCue.length;\n    if (constructorLength == 3) {\n      shaka.log.info('Using VTTCue polyfill from 3 argument TextTrackCue.');\n      replacement = shaka.polyfill.VTTCue.from3ArgsTextTrackCue_;\n    } else if (constructorLength == 6) {\n      shaka.log.info('Using VTTCue polyfill from 6 argument TextTrackCue.');\n      replacement = shaka.polyfill.VTTCue.from6ArgsTextTrackCue_;\n    } else if (shaka.polyfill.VTTCue.canUse3ArgsTextTrackCue_()) {\n      shaka.log.info('Using VTTCue polyfill from 3 argument TextTrackCue.');\n      replacement = shaka.polyfill.VTTCue.from3ArgsTextTrackCue_;\n    }\n\n    if (!replacement) {\n      shaka.log.error('No recognized signature for TextTrackCue found!');\n      return;\n    }\n\n    // The polyfilled VTTCue must be callable with \"new\", but the static methods\n    // in this class cannot be called that way on legacy Edge.  So we must wrap\n    // the replacement in a plain function.\n    // eslint-disable-next-line no-restricted-syntax\n    window['VTTCue'] = function(start, end, text) {\n      return replacement(start, end, text);\n    };\n  }\n\n  /**\n   * Draft spec TextTrackCue with 3 constructor arguments.\n   * @see {@link https://bit.ly/2IdyKbA W3C Working Draft 25 October 2012}.\n   *\n   * @param {number} startTime\n   * @param {number} endTime\n   * @param {string} text\n   * @return {!TextTrackCue}\n   * @private\n   */\n  static from3ArgsTextTrackCue_(startTime, endTime, text) {\n    return new window.TextTrackCue(startTime, endTime, text);\n  }\n\n  /**\n   * Draft spec TextTrackCue with 6 constructor arguments (5th & 6th are\n   * optional).\n   * @see {@link https://bit.ly/2KaGSP2 W3C Working Draft 29 March 2012}.\n   *\n   * @param {number} startTime\n   * @param {number} endTime\n   * @param {string} text\n   * @return {!TextTrackCue}\n   * @private\n   */\n  static from6ArgsTextTrackCue_(startTime, endTime, text) {\n    const id = startTime + '-' + endTime + '-' + text;\n    // Quoting the access to the TextTrackCue object to satisfy the compiler.\n    return new window['TextTrackCue'](id, startTime, endTime, text);\n  }\n\n  /**\n   * IE10, IE11 and Edge return TextTrackCue.length = 0, although they accept 3\n   * constructor arguments.\n   *\n   * @return {boolean}\n   * @private\n   */\n  static canUse3ArgsTextTrackCue_() {\n    try {\n      return !!shaka.polyfill.VTTCue.from3ArgsTextTrackCue_(1, 2, '');\n    } catch (error) {\n      return false;\n    }\n  }\n};\n\n\nshaka.polyfill.register(shaka.polyfill.VTTCue.install);\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.text.TtmlTextParser');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.text.Cue');\ngoog.require('shaka.text.CueRegion');\ngoog.require('shaka.text.TextEngine');\ngoog.require('shaka.util.ArrayUtils');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.StringUtils');\ngoog.require('shaka.util.XmlUtils');\n\n\n/**\n * @implements {shaka.extern.TextParser}\n * @export\n */\nshaka.text.TtmlTextParser = class {\n  /**\n   * @override\n   * @export\n   */\n  parseInit(data) {\n    goog.asserts.assert(false, 'TTML does not have init segments');\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  parseMedia(data, time) {\n    const TtmlTextParser = shaka.text.TtmlTextParser;\n    const XmlUtils = shaka.util.XmlUtils;\n    const ttpNs = TtmlTextParser.parameterNs_;\n    const ttsNs = TtmlTextParser.styleNs_;\n    const str = shaka.util.StringUtils.fromUTF8(data);\n    const ret = [];\n    const parser = new DOMParser();\n    let xml = null;\n\n    // dont try to parse empty string as\n    // DOMParser will not throw error but return an errored xml\n    if (str == '') {\n      return ret;\n    }\n\n    try {\n      xml = parser.parseFromString(str, 'text/xml');\n    } catch (exception) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.TEXT,\n          shaka.util.Error.Code.INVALID_XML,\n          'Failed to parse TTML.');\n    }\n\n    if (xml) {\n      const parserError = xml.getElementsByTagName('parsererror')[0];\n      if (parserError) {\n        throw new shaka.util.Error(\n            shaka.util.Error.Severity.CRITICAL,\n            shaka.util.Error.Category.TEXT,\n            shaka.util.Error.Code.INVALID_XML,\n            parserError.textContent);\n      }\n\n      // Try to get the framerate, subFrameRate and frameRateMultiplier\n      // if applicable\n      let frameRate = null;\n      let subFrameRate = null;\n      let frameRateMultiplier = null;\n      let tickRate = null;\n      let spaceStyle = null;\n      let extent = null;\n      let cellResolution = null;\n      const tts = xml.getElementsByTagName('tt');\n      const tt = tts[0];\n      // TTML should always have tt element.\n      if (!tt) {\n        throw new shaka.util.Error(\n            shaka.util.Error.Severity.CRITICAL,\n            shaka.util.Error.Category.TEXT,\n            shaka.util.Error.Code.INVALID_XML,\n            'TTML does not contain <tt> tag.');\n      } else {\n        frameRate = XmlUtils.getAttributeNS(tt, ttpNs, 'frameRate');\n        subFrameRate = XmlUtils.getAttributeNS(tt, ttpNs, 'subFrameRate');\n        frameRateMultiplier =\n            XmlUtils.getAttributeNS(tt, ttpNs, 'frameRateMultiplier');\n        tickRate = XmlUtils.getAttributeNS(tt, ttpNs, 'tickRate');\n        cellResolution = XmlUtils.getAttributeNS(tt, ttpNs, 'cellResolution');\n        spaceStyle = tt.getAttribute('xml:space') || 'default';\n        extent = XmlUtils.getAttributeNS(tt, ttsNs, 'extent');\n      }\n\n      if (spaceStyle != 'default' && spaceStyle != 'preserve') {\n        throw new shaka.util.Error(\n            shaka.util.Error.Severity.CRITICAL,\n            shaka.util.Error.Category.TEXT,\n            shaka.util.Error.Code.INVALID_XML,\n            'Invalid xml:space value: ' + spaceStyle);\n      }\n      const whitespaceTrim = spaceStyle == 'default';\n\n      const rateInfo = new TtmlTextParser.RateInfo_(\n          frameRate, subFrameRate, frameRateMultiplier, tickRate);\n\n      const cellResolutionInfo =\n        TtmlTextParser.getCellResolution_(cellResolution);\n\n      const metadataElements = TtmlTextParser.getLeafNodes_(\n          tt.getElementsByTagName('metadata')[0]);\n      const styles = TtmlTextParser.getLeafNodes_(\n          tt.getElementsByTagName('styling')[0]);\n      const regionElements = TtmlTextParser.getLeafNodes_(\n          tt.getElementsByTagName('layout')[0]);\n      const cueRegions = [];\n      for (const region of regionElements) {\n        const cueRegion =\n            TtmlTextParser.parseCueRegion_(region, styles, extent);\n        if (cueRegion) {\n          cueRegions.push(cueRegion);\n        }\n      }\n\n      const textNodes = TtmlTextParser.getLeafCues_(\n          tt.getElementsByTagName('body')[0]);\n      for (const node of textNodes) {\n        const cue = TtmlTextParser.parseCue_(\n            node, time.periodStart, rateInfo, metadataElements, styles,\n            regionElements, cueRegions, whitespaceTrim, false,\n            cellResolutionInfo);\n        if (cue) {\n          ret.push(cue);\n        }\n      }\n    }\n\n    return ret;\n  }\n\n  /**\n   * Gets the leaf nodes of the xml node tree. Ignores the text, br elements\n   * and the spans positioned inside paragraphs\n   *\n   * @param {Element} element\n   * @return {!Array.<!Element>}\n   * @private\n   */\n  static getLeafNodes_(element) {\n    let result = [];\n    if (!element) {\n      return result;\n    }\n\n    for (const node of element.childNodes) {\n      if (\n        node.nodeType == Node.ELEMENT_NODE &&\n        node.nodeName !== 'br'\n      ) {\n        // Get the leaves the child might contain.\n        goog.asserts.assert(node instanceof Element,\n            'Node should be Element!');\n        const leafChildren = shaka.text.TtmlTextParser.getLeafNodes_(\n            /** @type {Element} */(node));\n        goog.asserts.assert(leafChildren.length > 0,\n            'Only a null Element should return no leaves!');\n\n        result = result.concat(leafChildren);\n      }\n    }\n\n    // if no result at this point, the element itself must be a leaf.\n    if (!result.length) {\n      result.push(element);\n    }\n\n    return result;\n  }\n\n  /**\n   * Get the leaf nodes that can act as cues\n   * (at least begin attribute)\n   *\n   * @param {Element} element\n   * @return {!Array.<!Element>}\n   * @private\n   */\n  static getLeafCues_(element) {\n    if (!element) {\n      return [];\n    }\n\n    let ret = [];\n    // Recursively find any child elements that have a 'begin' attribute.\n    for (const child of element.childNodes) {\n      if (child instanceof Element) {\n        if (child.hasAttribute('begin')) {\n          ret.push(child);\n        } else {\n          ret = ret.concat(shaka.text.TtmlTextParser.getLeafCues_(child));\n        }\n      }\n    }\n    return ret;\n  }\n\n\n  /**\n   * Trims and removes multiple spaces from a string\n   *\n   * @param {Element} element\n   * @param {boolean} whitespaceTrim\n   * @return {string}\n   * @private\n   */\n  static sanitizeTextContent_(element, whitespaceTrim) {\n    let payload = '';\n\n    for (const node of element.childNodes) {\n      if (node.nodeName == 'br' && element.childNodes[0] !== node) {\n        payload += '\\n';\n      } else if (node.childNodes && node.childNodes.length > 0) {\n        payload += shaka.text.TtmlTextParser.sanitizeTextContent_(\n            /** @type {!Element} */ (node),\n            whitespaceTrim\n        );\n      } else if (whitespaceTrim) {\n        // Trim leading and trailing whitespace.\n        let trimmed = node.textContent.trim();\n        // Collapse multiple spaces into one.\n        trimmed = trimmed.replace(/\\s+/g, ' ');\n\n        payload += trimmed;\n      } else {\n        payload += node.textContent;\n      }\n    }\n\n    return payload;\n  }\n\n  /**\n   * Parses an Element into a TextTrackCue or VTTCue.\n   *\n   * @param {!Element} cueElement\n   * @param {number} offset\n   * @param {!shaka.text.TtmlTextParser.RateInfo_} rateInfo\n   * @param {!Array.<!Element>} metadataElements\n   * @param {!Array.<!Element>} styles\n   * @param {!Array.<!Element>} regionElements\n   * @param {!Array.<!shaka.text.CueRegion>} cueRegions\n   * @param {boolean} whitespaceTrim\n   * @param {boolean} isNested\n   * @param {?{columns: number, rows: number}} cellResolution\n   * @return {shaka.text.Cue}\n   * @private\n   */\n  static parseCue_(\n      cueElement, offset, rateInfo, metadataElements, styles, regionElements,\n      cueRegions, whitespaceTrim, isNested, cellResolution) {\n    if (isNested && cueElement.nodeName == 'br') {\n      const cue = new shaka.text.Cue(0, 0, '');\n      cue.spacer = true;\n\n      return cue;\n    }\n\n    const isTextContentEmpty = /^[\\s\\n]*$/.test(cueElement.textContent);\n    const hasNoTimeAttributes = cueElement.nodeType == Node.ELEMENT_NODE &&\n        !cueElement.hasAttribute('begin') &&\n        !cueElement.hasAttribute('end');\n\n    if (\n      cueElement.nodeType != Node.ELEMENT_NODE ||\n      /* Disregards empty elements without time attributes nor content\n       * <p begin=\"...\" smpte:backgroundImage=\"...\" /> will go through,\n       *    as some information could be holded by its attributes\n       * <p />, <div></div> won't,\n       *    as they don't have means to be displayed into a playback sequence\n       */\n      (hasNoTimeAttributes && isTextContentEmpty) ||\n      /*\n       * Let nested cue without time attributes through:\n       *    time attributes are holded by its parent\n       */\n      (hasNoTimeAttributes && !isNested)\n    ) {\n      return null;\n    }\n\n    // Get time.\n    let start = shaka.text.TtmlTextParser.parseTime_(\n        cueElement.getAttribute('begin'), rateInfo);\n    let end = shaka.text.TtmlTextParser.parseTime_(\n        cueElement.getAttribute('end'), rateInfo);\n    const duration = shaka.text.TtmlTextParser.parseTime_(\n        cueElement.getAttribute('dur'), rateInfo);\n\n    if (end == null && duration != null) {\n      end = start + duration;\n    }\n\n    if (!isNested && (start == null || end == null)) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.TEXT,\n          shaka.util.Error.Code.INVALID_TEXT_CUE);\n    }\n\n    if (isNested && start == null) {\n      start = 0;\n    } else {\n      start += offset;\n    }\n\n    if (isNested && end == null) {\n      end = 0;\n    } else {\n      end += offset;\n    }\n\n    let payload = '';\n    const nestedCues = [];\n    // If one of the children is a text node with something other than\n    // whitespace in it, stop going down and write the payload.\n    const isNonEmptyText = (node) => {\n      // In this regex, \"\\S+\" means \"one or more non-whitespace characters\".\n      return node.nodeType == Node.TEXT_NODE &&\n          /\\S+/.test(node.textContent);\n    };\n    if (Array.from(cueElement.childNodes).some(isNonEmptyText)) {\n      payload = shaka.text.TtmlTextParser.sanitizeTextContent_(\n          cueElement,\n          whitespaceTrim,\n      );\n    } else {\n      for (const childNode of cueElement.childNodes) {\n        const nestedCue = shaka.text.TtmlTextParser.parseCue_(\n            /** @type {!Element} */ (childNode),\n            offset,\n            rateInfo,\n            metadataElements,\n            styles,\n            regionElements,\n            cueRegions,\n            whitespaceTrim,\n            /* isNested= */ true,\n            cellResolution,\n        );\n\n        if (nestedCue) {\n          // Set the start time and end time for the nested cues.\n          nestedCue.startTime = nestedCue.startTime || start;\n          nestedCue.endTime = nestedCue.endTime || end;\n          nestedCues.push(nestedCue);\n        }\n      }\n    }\n\n    const cue = new shaka.text.Cue(start, end, payload);\n    cue.nestedCues = nestedCues;\n\n    if (cellResolution) {\n      cue.cellResolution = cellResolution;\n    }\n\n    // Get other properties if available.\n    const regionElement = shaka.text.TtmlTextParser.getElementsFromCollection_(\n        cueElement, 'region', regionElements, /* prefix= */ '')[0];\n    if (regionElement && regionElement.getAttribute('xml:id')) {\n      const regionId = regionElement.getAttribute('xml:id');\n      cue.region = cueRegions.filter((region) => region.id == regionId)[0];\n    }\n    const imageElement = shaka.text.TtmlTextParser.getElementsFromCollection_(\n        cueElement, 'backgroundImage', metadataElements, '#',\n        shaka.text.TtmlTextParser.smpteNs_)[0];\n\n    shaka.text.TtmlTextParser.addStyle_(\n        cue,\n        cueElement,\n        regionElement,\n        imageElement,\n        styles);\n\n    return cue;\n  }\n\n  /**\n   * Parses an Element into a TextTrackCue or VTTCue.\n   *\n   * @param {!Element} regionElement\n   * @param {!Array.<!Element>} styles Defined in the top of tt  element and\n   * used principally for images.\n   * @param {?string} globalExtent\n   * @return {shaka.text.CueRegion}\n   * @private\n   */\n  static parseCueRegion_(regionElement, styles, globalExtent) {\n    const TtmlTextParser = shaka.text.TtmlTextParser;\n    const region = new shaka.text.CueRegion();\n    const id = regionElement.getAttribute('xml:id');\n    if (!id) {\n      shaka.log.warning('TtmlTextParser parser encountered a region with ' +\n                        'no id. Region will be ignored.');\n      return null;\n    }\n    region.id = id;\n\n    let globalResults = null;\n    if (globalExtent) {\n      globalResults = TtmlTextParser.percentValues_.exec(globalExtent) ||\n        TtmlTextParser.pixelValues_.exec(globalExtent);\n    }\n    const globalWidth = globalResults ? Number(globalResults[1]) : null;\n    const globalHeight = globalResults ? Number(globalResults[2]) : null;\n\n    let results = null;\n    let percentage = null;\n    const extent = TtmlTextParser.getStyleAttributeFromRegion_(\n        regionElement, styles, 'extent');\n    if (extent) {\n      percentage = TtmlTextParser.percentValues_.exec(extent);\n      results = percentage || TtmlTextParser.pixelValues_.exec(extent);\n      if (results != null) {\n        if (globalWidth != null) {\n          region.width = Number(results[1]) * 100 / globalWidth;\n        } else {\n          region.width = Number(results[1]);\n        }\n        if (globalHeight != null) {\n          region.height = Number(results[2]) * 100 / globalHeight;\n        } else {\n          region.height = Number(results[2]);\n        }\n        region.widthUnits = percentage || globalWidth != null ?\n                           shaka.text.CueRegion.units.PERCENTAGE :\n                           shaka.text.CueRegion.units.PX;\n\n        region.heightUnits = percentage || globalHeight != null ?\n                           shaka.text.CueRegion.units.PERCENTAGE :\n                           shaka.text.CueRegion.units.PX;\n      }\n    }\n\n    const origin = TtmlTextParser.getStyleAttributeFromRegion_(\n        regionElement, styles, 'origin');\n    if (origin) {\n      percentage = TtmlTextParser.percentValues_.exec(origin);\n      results = percentage || TtmlTextParser.pixelValues_.exec(origin);\n      if (results != null) {\n        if (globalWidth != null) {\n          region.viewportAnchorX = Number(results[1]) * 100 / globalWidth;\n        } else {\n          region.viewportAnchorX = Number(results[1]);\n        }\n        if (globalHeight != null) {\n          region.viewportAnchorY = Number(results[2]) * 100 / globalHeight;\n        } else {\n          region.viewportAnchorY = Number(results[2]);\n        }\n        region.viewportAnchorUnits = percentage || globalWidth != null ?\n                  shaka.text.CueRegion.units.PERCENTAGE :\n                  shaka.text.CueRegion.units.PX;\n      }\n    }\n\n    return region;\n  }\n\n  /**\n   * Adds applicable style properties to a cue.\n   *\n   * @param {!shaka.text.Cue} cue\n   * @param {!Element} cueElement\n   * @param {Element} region\n   * @param {Element} imageElement\n   * @param {!Array.<!Element>} styles\n   * @private\n   */\n  static addStyle_(cue, cueElement, region, imageElement, styles) {\n    const TtmlTextParser = shaka.text.TtmlTextParser;\n    const Cue = shaka.text.Cue;\n\n    const direction = TtmlTextParser.getStyleAttribute_(\n        cueElement, region, styles, 'direction');\n    if (direction == 'rtl') {\n      cue.direction = Cue.direction.HORIZONTAL_RIGHT_TO_LEFT;\n    }\n\n    // Direction attribute specifies one-dimentional writing direction\n    // (left to right or right to left). Writing mode specifies that\n    // plus whether text is vertical or horizontal.\n    // They should not contradict each other. If they do, we give\n    // preference to writing mode.\n    const writingMode = TtmlTextParser.getStyleAttribute_(\n        cueElement, region, styles, 'writingMode');\n    // Set cue's direction if the text is horizontal, and cue's writingMode if\n    // it's vertical.\n    if (writingMode == 'tb' || writingMode == 'tblr') {\n      cue.writingMode = Cue.writingMode.VERTICAL_LEFT_TO_RIGHT;\n    } else if (writingMode == 'tbrl') {\n      cue.writingMode = Cue.writingMode.VERTICAL_RIGHT_TO_LEFT;\n    } else if (writingMode == 'rltb' || writingMode == 'rl') {\n      cue.direction = Cue.direction.HORIZONTAL_RIGHT_TO_LEFT;\n    } else if (writingMode) {\n      cue.direction = Cue.direction.HORIZONTAL_LEFT_TO_RIGHT;\n    }\n\n    const align = TtmlTextParser.getStyleAttribute_(\n        cueElement, region, styles, 'textAlign');\n    if (align) {\n      cue.positionAlign = TtmlTextParser.textAlignToPositionAlign_[align];\n      cue.lineAlign = TtmlTextParser.textAlignToLineAlign_[align];\n\n      goog.asserts.assert(align.toUpperCase() in Cue.textAlign,\n          align.toUpperCase() +\n                          ' Should be in Cue.textAlign values!');\n\n      cue.textAlign = Cue.textAlign[align.toUpperCase()];\n    } else {\n      // Default value is START: https://bit.ly/32OGmvo\n      cue.textAlign = Cue.textAlign.START;\n    }\n\n    const displayAlign = TtmlTextParser.getStyleAttribute_(\n        cueElement, region, styles, 'displayAlign');\n    if (displayAlign) {\n      goog.asserts.assert(displayAlign.toUpperCase() in Cue.displayAlign,\n          displayAlign.toUpperCase() +\n                          ' Should be in Cue.displayAlign values!');\n      cue.displayAlign = Cue.displayAlign[displayAlign.toUpperCase()];\n    }\n\n    const color = TtmlTextParser.getStyleAttribute_(\n        cueElement, region, styles, 'color');\n    if (color) {\n      cue.color = color;\n    }\n\n    const backgroundColor = TtmlTextParser.getStyleAttribute_(\n        cueElement, region, styles, 'backgroundColor');\n    if (backgroundColor) {\n      cue.backgroundColor = backgroundColor;\n    }\n\n    const border = TtmlTextParser.getStyleAttribute_(\n        cueElement, region, styles, 'border');\n    if (border) {\n      cue.border = border;\n    }\n\n    const fontFamily = TtmlTextParser.getStyleAttribute_(\n        cueElement, region, styles, 'fontFamily');\n    if (fontFamily) {\n      cue.fontFamily = fontFamily;\n    }\n\n    const fontWeight = TtmlTextParser.getStyleAttribute_(\n        cueElement, region, styles, 'fontWeight');\n    if (fontWeight && fontWeight == 'bold') {\n      cue.fontWeight = Cue.fontWeight.BOLD;\n    }\n\n    const wrapOption = TtmlTextParser.getStyleAttribute_(\n        cueElement, region, styles, 'wrapOption');\n    if (wrapOption && wrapOption == 'noWrap') {\n      cue.wrapLine = false;\n    }\n\n    const lineHeight = TtmlTextParser.getStyleAttribute_(\n        cueElement, region, styles, 'lineHeight');\n    if (lineHeight && lineHeight.match(TtmlTextParser.unitValues_)) {\n      cue.lineHeight = lineHeight;\n    }\n\n    const fontSize = TtmlTextParser.getStyleAttribute_(\n        cueElement, region, styles, 'fontSize');\n\n    if (fontSize) {\n      const isValidFontSizeUnit =\n          fontSize.match(TtmlTextParser.unitValues_) ||\n          fontSize.match(TtmlTextParser.percentValue_);\n\n      if (isValidFontSizeUnit) {\n        cue.fontSize = fontSize;\n      }\n    }\n\n    const fontStyle = TtmlTextParser.getStyleAttribute_(\n        cueElement, region, styles, 'fontStyle');\n    if (fontStyle) {\n      goog.asserts.assert(fontStyle.toUpperCase() in Cue.fontStyle,\n          fontStyle.toUpperCase() +\n                          ' Should be in Cue.fontStyle values!');\n      cue.fontStyle = Cue.fontStyle[fontStyle.toUpperCase()];\n    }\n\n    if (imageElement) {\n      const backgroundImageType = imageElement.getAttribute('imagetype');\n      const backgroundImageEncoding = imageElement.getAttribute('encoding');\n      const backgroundImageData = imageElement.textContent.trim();\n      if (backgroundImageType == 'PNG' &&\n          backgroundImageEncoding == 'Base64' &&\n          backgroundImageData) {\n        cue.backgroundImage = 'data:image/png;base64,' + backgroundImageData;\n      }\n    }\n\n    const letterSpacing = TtmlTextParser.getStyleAttribute_(\n        cueElement, region, styles, 'letterSpacing');\n    if (letterSpacing && letterSpacing.match(TtmlTextParser.unitValues_)) {\n      cue.letterSpacing = letterSpacing;\n    }\n\n    const linePadding = TtmlTextParser.getStyleAttribute_(\n        cueElement, region, styles, 'linePadding');\n    if (linePadding && linePadding.match(TtmlTextParser.unitValues_)) {\n      cue.linePadding = linePadding;\n    }\n\n    const opacity = TtmlTextParser.getStyleAttribute_(\n        cueElement, region, styles, 'opacity');\n    if (opacity) {\n      cue.opacity = parseFloat(opacity);\n    }\n\n    // Text decoration is an array of values which can come both from the\n    // element's style or be inherited from elements' parent nodes. All of those\n    // values should be applied as long as they don't contradict each other. If\n    // they do, elements' own style gets preference.\n    const textDecorationRegion = TtmlTextParser.getStyleAttributeFromRegion_(\n        region, styles, 'textDecoration');\n    if (textDecorationRegion) {\n      TtmlTextParser.addTextDecoration_(cue, textDecorationRegion);\n    }\n\n    const textDecorationElement = TtmlTextParser.getStyleAttributeFromElement_(\n        cueElement, styles, 'textDecoration');\n    if (textDecorationElement) {\n      TtmlTextParser.addTextDecoration_(cue, textDecorationElement);\n    }\n  }\n\n  /**\n   * Parses text decoration values and adds/removes them to/from the cue.\n   *\n   * @param {!shaka.text.Cue} cue\n   * @param {string} decoration\n   * @private\n   */\n  static addTextDecoration_(cue, decoration) {\n    const Cue = shaka.text.Cue;\n    for (const value of decoration.split(' ')) {\n      switch (value) {\n        case 'underline':\n          if (!cue.textDecoration.includes(Cue.textDecoration.UNDERLINE)) {\n            cue.textDecoration.push(Cue.textDecoration.UNDERLINE);\n          }\n          break;\n        case 'noUnderline':\n          if (cue.textDecoration.includes(Cue.textDecoration.UNDERLINE)) {\n            shaka.util.ArrayUtils.remove(cue.textDecoration,\n                Cue.textDecoration.UNDERLINE);\n          }\n          break;\n        case 'lineThrough':\n          if (!cue.textDecoration.includes(Cue.textDecoration.LINE_THROUGH)) {\n            cue.textDecoration.push(Cue.textDecoration.LINE_THROUGH);\n          }\n          break;\n        case 'noLineThrough':\n          if (cue.textDecoration.includes(Cue.textDecoration.LINE_THROUGH)) {\n            shaka.util.ArrayUtils.remove(cue.textDecoration,\n                Cue.textDecoration.LINE_THROUGH);\n          }\n          break;\n        case 'overline':\n          if (!cue.textDecoration.includes(Cue.textDecoration.OVERLINE)) {\n            cue.textDecoration.push(Cue.textDecoration.OVERLINE);\n          }\n          break;\n        case 'noOverline':\n          if (cue.textDecoration.includes(Cue.textDecoration.OVERLINE)) {\n            shaka.util.ArrayUtils.remove(cue.textDecoration,\n                Cue.textDecoration.OVERLINE);\n          }\n          break;\n      }\n    }\n  }\n\n  /**\n   * Finds a specified attribute on either the original cue element or its\n   * associated region and returns the value if the attribute was found.\n   *\n   * @param {!Element} cueElement\n   * @param {Element} region\n   * @param {!Array.<!Element>} styles\n   * @param {string} attribute\n   * @return {?string}\n   * @private\n   */\n  static getStyleAttribute_(cueElement, region, styles, attribute) {\n    // An attribute can be specified on region level or in a styling block\n    // associated with the region or original element.\n    const TtmlTextParser = shaka.text.TtmlTextParser;\n    const attr = TtmlTextParser.getStyleAttributeFromElement_(\n        cueElement, styles, attribute);\n    if (attr) {\n      return attr;\n    }\n\n    return TtmlTextParser.getStyleAttributeFromRegion_(\n        region, styles, attribute);\n  }\n\n  /**\n   * Finds a specified attribute on the element's associated region\n   * and returns the value if the attribute was found.\n   *\n   * @param {Element} region\n   * @param {!Array.<!Element>} styles\n   * @param {string} attribute\n   * @return {?string}\n   * @private\n   */\n  static getStyleAttributeFromRegion_(region, styles, attribute) {\n    const XmlUtils = shaka.util.XmlUtils;\n    const ttsNs = shaka.text.TtmlTextParser.styleNs_;\n\n    if (!region) {\n      return null;\n    }\n\n    const regionChildren = shaka.text.TtmlTextParser.getLeafNodes_(region);\n    for (const child of regionChildren) {\n      const attr = XmlUtils.getAttributeNS(child, ttsNs, attribute);\n      if (attr) {\n        return attr;\n      }\n    }\n\n    return shaka.text.TtmlTextParser.getInheritedStyleAttribute_(\n        region, styles, attribute);\n  }\n\n  /**\n   * Finds a specified attribute on the cue element and returns the value\n   * if the attribute was found.\n   *\n   * @param {!Element} cueElement\n   * @param {!Array.<!Element>} styles\n   * @param {string} attribute\n   * @return {?string}\n   * @private\n   */\n  static getStyleAttributeFromElement_(cueElement, styles, attribute) {\n    const XmlUtils = shaka.util.XmlUtils;\n    const ttsNs = shaka.text.TtmlTextParser.styleNs_;\n\n    // Styling on elements should take precedence\n    // over the main styling attributes\n    const elementAttribute = XmlUtils.getAttributeNS(\n        cueElement,\n        ttsNs,\n        attribute);\n\n    if (elementAttribute) {\n      return elementAttribute;\n    }\n\n    return shaka.text.TtmlTextParser.getInheritedStyleAttribute_(\n        cueElement, styles, attribute);\n  }\n\n  /**\n   * Finds a specified attribute on an element's styles and the styles those\n   * styles inherit from.\n   *\n   * @param {!Element} element\n   * @param {!Array.<!Element>} styles\n   * @param {string} attribute\n   * @return {?string}\n   * @private\n   */\n  static getInheritedStyleAttribute_(element, styles, attribute) {\n    const XmlUtils = shaka.util.XmlUtils;\n    const ttsNs = shaka.text.TtmlTextParser.styleNs_;\n    const ebuttsNs = shaka.text.TtmlTextParser.styleEbuttsNs_;\n\n    const inheritedStyles =\n        shaka.text.TtmlTextParser.getElementsFromCollection_(\n            element, 'style', styles, /* prefix= */ '');\n\n    let styleValue = null;\n\n    // The last value in our styles stack takes the precedence over the others\n    for (let i = 0; i < inheritedStyles.length; i++) {\n      // Check ebu namespace first.\n      let styleAttributeValue = XmlUtils.getAttributeNS(\n          inheritedStyles[i],\n          ebuttsNs,\n          attribute);\n\n      if (!styleAttributeValue) {\n        // Fall back to tts namespace.\n        styleAttributeValue = XmlUtils.getAttributeNS(\n            inheritedStyles[i],\n            ttsNs,\n            attribute);\n      }\n\n      if (!styleAttributeValue) {\n        // Next, check inheritance.\n        // Styles can inherit from other styles, so traverse up that chain.\n        styleAttributeValue =\n            shaka.text.TtmlTextParser.getStyleAttributeFromElement_(\n                inheritedStyles[i], styles, attribute);\n      }\n\n      if (styleAttributeValue) {\n        styleValue = styleAttributeValue;\n      }\n    }\n\n    return styleValue;\n  }\n\n\n  /**\n   * Selects items from |collection| whose id matches |attributeName|\n   * from |element|.\n   *\n   * @param {Element} element\n   * @param {string} attributeName\n   * @param {!Array.<Element>} collection\n   * @param {string} prefixName\n   * @param {string=} nsName\n   * @return {!Array.<!Element>}\n   * @private\n   */\n  static getElementsFromCollection_(\n      element, attributeName, collection, prefixName, nsName) {\n    const items = [];\n\n    if (!element || collection.length < 1) {\n      return items;\n    }\n\n    const attributeValue = shaka.text.TtmlTextParser.getInheritedAttribute_(\n        element, attributeName, nsName);\n\n    if (attributeValue) {\n      // There could be multiple items in one attribute\n      // <span style=\"style1 style2\">A cue</span>\n      const itemNames = attributeValue.split(' ');\n\n      for (const name of itemNames) {\n        for (const item of collection) {\n          if ((prefixName + item.getAttribute('xml:id')) == name) {\n            items.push(item);\n            break;\n          }\n        }\n      }\n    }\n\n    return items;\n  }\n\n\n  /**\n   * Traverses upwards from a given node until a given attribute is found.\n   *\n   * @param {!Element} element\n   * @param {string} attributeName\n   * @param {string=} nsName\n   * @return {?string}\n   * @private\n   */\n  static getInheritedAttribute_(element, attributeName, nsName) {\n    let ret = null;\n    const XmlUtils = shaka.util.XmlUtils;\n    while (element) {\n      ret = nsName ? XmlUtils.getAttributeNS(element, nsName, attributeName)\n                   : element.getAttribute(attributeName);\n      if (ret) {\n        break;\n      }\n\n      // Element.parentNode can lead to XMLDocument, which is not an Element and\n      // has no getAttribute().\n      const parentNode = element.parentNode;\n      if (parentNode instanceof Element) {\n        element = parentNode;\n      } else {\n        break;\n      }\n    }\n    return ret;\n  }\n\n  /**\n   * Parses a TTML time from the given word.\n   *\n   * @param {string} text\n   * @param {!shaka.text.TtmlTextParser.RateInfo_} rateInfo\n   * @return {?number}\n   * @private\n   */\n  static parseTime_(text, rateInfo) {\n    let ret = null;\n    const TtmlTextParser = shaka.text.TtmlTextParser;\n\n    if (TtmlTextParser.timeColonFormatFrames_.test(text)) {\n      ret = TtmlTextParser.parseColonTimeWithFrames_(rateInfo, text);\n    } else if (TtmlTextParser.timeColonFormat_.test(text)) {\n      ret = TtmlTextParser.parseTimeFromRegex_(\n          TtmlTextParser.timeColonFormat_, text);\n    } else if (TtmlTextParser.timeColonFormatMilliseconds_.test(text)) {\n      ret = TtmlTextParser.parseTimeFromRegex_(\n          TtmlTextParser.timeColonFormatMilliseconds_, text);\n    } else if (TtmlTextParser.timeFramesFormat_.test(text)) {\n      ret = TtmlTextParser.parseFramesTime_(rateInfo, text);\n    } else if (TtmlTextParser.timeTickFormat_.test(text)) {\n      ret = TtmlTextParser.parseTickTime_(rateInfo, text);\n    } else if (TtmlTextParser.timeHMSFormat_.test(text)) {\n      ret = TtmlTextParser.parseTimeFromRegex_(\n          TtmlTextParser.timeHMSFormat_, text);\n    }\n\n    return ret;\n  }\n\n  /**\n   * Parses a TTML time in frame format.\n   *\n   * @param {!shaka.text.TtmlTextParser.RateInfo_} rateInfo\n   * @param {string} text\n   * @return {?number}\n   * @private\n   */\n  static parseFramesTime_(rateInfo, text) {\n    // 75f or 75.5f\n    const results = shaka.text.TtmlTextParser.timeFramesFormat_.exec(text);\n    const frames = Number(results[1]);\n\n    return frames / rateInfo.frameRate;\n  }\n\n  /**\n   * Parses a TTML time in tick format.\n   *\n   * @param {!shaka.text.TtmlTextParser.RateInfo_} rateInfo\n   * @param {string} text\n   * @return {?number}\n   * @private\n   */\n  static parseTickTime_(rateInfo, text) {\n    // 50t or 50.5t\n    const results = shaka.text.TtmlTextParser.timeTickFormat_.exec(text);\n    const ticks = Number(results[1]);\n\n    return ticks / rateInfo.tickRate;\n  }\n\n  /**\n   * Parses a TTML colon formatted time containing frames.\n   *\n   * @param {!shaka.text.TtmlTextParser.RateInfo_} rateInfo\n   * @param {string} text\n   * @return {?number}\n   * @private\n   */\n  static parseColonTimeWithFrames_(rateInfo, text) {\n    // 01:02:43:07 ('07' is frames) or 01:02:43:07.1 (subframes)\n    const results = shaka.text.TtmlTextParser.timeColonFormatFrames_.exec(text);\n\n    const hours = Number(results[1]);\n    const minutes = Number(results[2]);\n    let seconds = Number(results[3]);\n    let frames = Number(results[4]);\n    const subframes = Number(results[5]) || 0;\n\n    frames += subframes / rateInfo.subFrameRate;\n    seconds += frames / rateInfo.frameRate;\n\n    return seconds + (minutes * 60) + (hours * 3600);\n  }\n\n  /**\n   * Parses a TTML time with a given regex. Expects regex to be some\n   * sort of a time-matcher to match hours, minutes, seconds and milliseconds\n   *\n   * @param {!RegExp} regex\n   * @param {string} text\n   * @return {?number}\n   * @private\n   */\n  static parseTimeFromRegex_(regex, text) {\n    const results = regex.exec(text);\n    if (results == null || results[0] == '') {\n      return null;\n    }\n    // This capture is optional, but will still be in the array as undefined,\n    // in which case it is 0.\n    const hours = Number(results[1]) || 0;\n    const minutes = Number(results[2]) || 0;\n    const seconds = Number(results[3]) || 0;\n    const milliseconds = Number(results[4]) || 0;\n\n    return (milliseconds / 1000) + seconds + (minutes * 60) + (hours * 3600);\n  }\n\n  /**\n   * If ttp:cellResolution provided returns cell resolution info\n   * with number of columns and rows into which the Root Container\n   * Region area is divided\n   *\n   * @param {?string} cellResolution\n   * @return {?{columns: number, rows: number}}\n   * @private\n   */\n  static getCellResolution_(cellResolution) {\n    if (!cellResolution) {\n      return null;\n    }\n    const matches = /^(\\d+) (\\d+)$/.exec(cellResolution);\n\n    if (!matches) {\n      return null;\n    }\n\n    const columns = parseInt(matches[1], 10);\n    const rows = parseInt(matches[2], 10);\n\n    return {columns, rows};\n  }\n};\n\n/**\n * @summary\n * Contains information about frame/subframe rate\n * and frame rate multiplier for time in frame format.\n *\n * @example 01:02:03:04(4 frames) or 01:02:03:04.1(4 frames, 1 subframe)\n * @private\n */\nshaka.text.TtmlTextParser.RateInfo_ = class {\n  /**\n   * @param {?string} frameRate\n   * @param {?string} subFrameRate\n   * @param {?string} frameRateMultiplier\n   * @param {?string} tickRate\n   */\n  constructor(frameRate, subFrameRate, frameRateMultiplier, tickRate) {\n    /**\n     * @type {number}\n     */\n    this.frameRate = Number(frameRate) || 30;\n\n    /**\n     * @type {number}\n     */\n    this.subFrameRate = Number(subFrameRate) || 1;\n\n    /**\n     * @type {number}\n     */\n    this.tickRate = Number(tickRate);\n    if (this.tickRate == 0) {\n      if (frameRate) {\n        this.tickRate = this.frameRate * this.subFrameRate;\n      } else {\n        this.tickRate = 1;\n      }\n    }\n\n    if (frameRateMultiplier) {\n      const multiplierResults = /^(\\d+) (\\d+)$/g.exec(frameRateMultiplier);\n      if (multiplierResults) {\n        const numerator = Number(multiplierResults[1]);\n        const denominator = Number(multiplierResults[2]);\n        const multiplierNum = numerator / denominator;\n        this.frameRate *= multiplierNum;\n      }\n    }\n  }\n};\n\n/**\n * @const\n * @private {!RegExp}\n * @example 50.17% 10%\n */\nshaka.text.TtmlTextParser.percentValues_ =\n    /^(\\d{1,2}(?:\\.\\d+)?|100(?:\\.0+)?)% (\\d{1,2}(?:\\.\\d+)?|100(?:\\.0+)?)%$/;\n\n/**\n * @const\n * @private {!RegExp}\n * @example 0.6% 90%\n */\nshaka.text.TtmlTextParser.percentValue_ = /^(\\d{1,2}(?:\\.\\d+)?|100)%$/;\n\n/**\n * @const\n * @private {!RegExp}\n * @example 100px, 8em, 0.80c\n */\nshaka.text.TtmlTextParser.unitValues_ = /^(\\d+px|\\d+em|\\d*\\.?\\d+c)$/;\n\n/**\n * @const\n * @private {!RegExp}\n * @example 100px\n */\nshaka.text.TtmlTextParser.pixelValues_ = /^(\\d+)px (\\d+)px$/;\n\n/**\n * @const\n * @private {!RegExp}\n * @example 00:00:40:07 (7 frames) or 00:00:40:07.1 (7 frames, 1 subframe)\n */\nshaka.text.TtmlTextParser.timeColonFormatFrames_ =\n    /^(\\d{2,}):(\\d{2}):(\\d{2}):(\\d{2})\\.?(\\d+)?$/;\n\n/**\n * @const\n * @private {!RegExp}\n * @example 00:00:40 or 00:40\n */\nshaka.text.TtmlTextParser.timeColonFormat_ = /^(?:(\\d{2,}):)?(\\d{2}):(\\d{2})$/;\n\n/**\n * @const\n * @private {!RegExp}\n * @example 01:02:43.0345555 or 02:43.03\n */\nshaka.text.TtmlTextParser.timeColonFormatMilliseconds_ =\n    /^(?:(\\d{2,}):)?(\\d{2}):(\\d{2}\\.\\d{2,})$/;\n\n/**\n * @const\n * @private {!RegExp}\n * @example 75f or 75.5f\n */\nshaka.text.TtmlTextParser.timeFramesFormat_ = /^(\\d*(?:\\.\\d*)?)f$/;\n\n/**\n * @const\n * @private {!RegExp}\n * @example 50t or 50.5t\n */\nshaka.text.TtmlTextParser.timeTickFormat_ = /^(\\d*(?:\\.\\d*)?)t$/;\n\n/**\n * @const\n * @private {!RegExp}\n * @example 3.45h, 3m or 4.20s\n */\nshaka.text.TtmlTextParser.timeHMSFormat_ =\n    new RegExp(['^(?:(\\\\d*(?:\\\\.\\\\d*)?)h)?',\n      '(?:(\\\\d*(?:\\\\.\\\\d*)?)m)?',\n      '(?:(\\\\d*(?:\\\\.\\\\d*)?)s)?',\n      '(?:(\\\\d*(?:\\\\.\\\\d*)?)ms)?$'].join(''));\n\n/**\n * @const\n * @private {!Object.<string, shaka.text.Cue.lineAlign>}\n */\nshaka.text.TtmlTextParser.textAlignToLineAlign_ = {\n  'left': shaka.text.Cue.lineAlign.START,\n  'center': shaka.text.Cue.lineAlign.CENTER,\n  'right': shaka.text.Cue.lineAlign.END,\n  'start': shaka.text.Cue.lineAlign.START,\n  'end': shaka.text.Cue.lineAlign.END,\n};\n\n/**\n * @const\n * @private {!Object.<string, shaka.text.Cue.positionAlign>}\n */\nshaka.text.TtmlTextParser.textAlignToPositionAlign_ = {\n  'left': shaka.text.Cue.positionAlign.LEFT,\n  'center': shaka.text.Cue.positionAlign.CENTER,\n  'right': shaka.text.Cue.positionAlign.RIGHT,\n};\n\n/**\n * The namespace URL for TTML parameters.  Can be assigned any name in the TTML\n * document, not just \"ttp:\", so we use this with getAttributeNS() to ensure\n * that we support arbitrary namespace names.\n *\n * @const {string}\n * @private\n */\nshaka.text.TtmlTextParser.parameterNs_ = 'http://www.w3.org/ns/ttml#parameter';\n\n/**\n * The namespace URL for TTML styles.  Can be assigned any name in the TTML\n * document, not just \"tts:\", so we use this with getAttributeNS() to ensure\n * that we support arbitrary namespace names.\n *\n * @const {string}\n * @private\n */\nshaka.text.TtmlTextParser.styleNs_ = 'http://www.w3.org/ns/ttml#styling';\n\n/**\n * The namespace URL for EBU TTML styles.  Can be assigned any name in the TTML\n * document, not just \"ebutts:\", so we use this with getAttributeNS() to ensure\n * that we support arbitrary namespace names.\n *\n * @const {string}\n * @private\n */\nshaka.text.TtmlTextParser.styleEbuttsNs_ = 'urn:ebu:tt:style';\n\n/**\n * The namespace URL for SMPTE fields.\n * @const {string}\n * @private\n */\nshaka.text.TtmlTextParser.smpteNs_ =\n    'http://www.smpte-ra.org/schemas/2052-1/2010/smpte-tt';\n\nshaka.text.TextEngine.registerParser(\n    'application/ttml+xml', () => new shaka.text.TtmlTextParser());\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.polyfill.VideoPlayPromise');\n\ngoog.require('shaka.log');\ngoog.require('shaka.polyfill');\n\n\n/**\n * @summary A polyfill to silence the play() Promise in HTML5 video.\n */\nshaka.polyfill.VideoPlayPromise = class {\n  /**\n   * Install the polyfill if needed.\n   */\n  static install() {\n    shaka.log.debug('VideoPlayPromise.install');\n\n    if (window.HTMLMediaElement) {\n      // eslint-disable-next-line no-restricted-syntax\n      const originalPlay = HTMLMediaElement.prototype.play;\n      // eslint-disable-next-line no-restricted-syntax\n      HTMLMediaElement.prototype.play = function() {\n        // eslint-disable-next-line no-restricted-syntax\n        const p = originalPlay.apply(this);\n        if (p) {\n          // This browser is returning a Promise from play().\n          // If the play() call fails or is interrupted, the Promise will be\n          // rejected.  Some apps, however, don't listen to this Promise,\n          // especially since it is not available cross-browser.  If the Promise\n          // is rejected without anyone listening for the failure, an error will\n          // appear in the JS console.\n          // To avoid confusion over this innocuous \"error\", we will install a\n          // catch handler on the Promise.  This does not prevent the app from\n          // also catching failures and handling them.  It only prevents the\n          // console message.\n          p.catch(() => {});\n        }\n        return p;\n      };\n    }\n  }\n};\n\n\nshaka.polyfill.register(shaka.polyfill.VideoPlayPromise.install);\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.text.Mp4TtmlParser');\n\ngoog.require('shaka.text.TextEngine');\ngoog.require('shaka.text.TtmlTextParser');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.Mp4Parser');\n\n\n/**\n * @implements {shaka.extern.TextParser}\n * @export\n */\nshaka.text.Mp4TtmlParser = class {\n  constructor() {\n    /**\n     * @type {!shaka.extern.TextParser}\n     * @private\n     */\n    this.parser_ = new shaka.text.TtmlTextParser();\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  parseInit(data) {\n    const Mp4Parser = shaka.util.Mp4Parser;\n\n    let sawSTPP = false;\n\n    new Mp4Parser()\n        .box('moov', Mp4Parser.children)\n        .box('trak', Mp4Parser.children)\n        .box('mdia', Mp4Parser.children)\n        .box('minf', Mp4Parser.children)\n        .box('stbl', Mp4Parser.children)\n        .fullBox('stsd', Mp4Parser.sampleDescription)\n        .box('stpp', (box) => {\n          sawSTPP = true;\n          box.parser.stop();\n        }).parse(data);\n\n    if (!sawSTPP) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.TEXT,\n          shaka.util.Error.Code.INVALID_MP4_TTML);\n    }\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  parseMedia(data, time) {\n    const Mp4Parser = shaka.util.Mp4Parser;\n\n    let sawMDAT = false;\n    let payload = [];\n\n    const parser = new Mp4Parser()\n        .box('mdat', Mp4Parser.allData((data) => {\n          sawMDAT = true;\n          // Join this to any previous payload, in case the mp4 has multiple\n          // mdats.\n          payload = payload.concat(this.parser_.parseMedia(data, time));\n        }));\n    parser.parse(data, /* partialOkay= */ false);\n\n    if (!sawMDAT) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.TEXT,\n          shaka.util.Error.Code.INVALID_MP4_TTML);\n    }\n\n    return payload;\n  }\n};\n\n\nshaka.text.TextEngine.registerParser(\n    'application/mp4; codecs=\"stpp\"', () => new shaka.text.Mp4TtmlParser());\nshaka.text.TextEngine.registerParser(\n    'application/mp4; codecs=\"stpp.ttml.im1t\"',\n    () => new shaka.text.Mp4TtmlParser());\n// Legacy codec string uses capital \"TTML\", i.e.: prior to HLS rfc8216bis:\n//   Note that if a Variant Stream specifies one or more Renditions that\n//   include IMSC subtitles, the CODECS attribute MUST indicate this with a\n//   format identifier such as \"stpp.ttml.im1t\".\n// (https://tools.ietf.org/html/draft-pantos-hls-rfc8216bis-05#section-4.4.5.2)\nshaka.text.TextEngine.registerParser(\n    'application/mp4; codecs=\"stpp.TTML.im1t\"',\n    () => new shaka.text.Mp4TtmlParser());\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.text.VttTextParser');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.text.Cue');\ngoog.require('shaka.text.CueRegion');\ngoog.require('shaka.text.TextEngine');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.StringUtils');\ngoog.require('shaka.util.TextParser');\n\n\n/**\n * @implements {shaka.extern.TextParser}\n * @export\n */\nshaka.text.VttTextParser = class {\n  /**\n   * @override\n   * @export\n   */\n  parseInit(data) {\n    goog.asserts.assert(false, 'VTT does not have init segments');\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  parseMedia(data, time) {\n    const VttTextParser = shaka.text.VttTextParser;\n    // Get the input as a string.  Normalize newlines to \\n.\n    let str = shaka.util.StringUtils.fromUTF8(data);\n    str = str.replace(/\\r\\n|\\r(?=[^\\n]|$)/gm, '\\n');\n    const blocks = str.split(/\\n{2,}/m);\n\n    if (!/^WEBVTT($|[ \\t\\n])/m.test(blocks[0])) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.TEXT,\n          shaka.util.Error.Code.INVALID_TEXT_HEADER);\n    }\n\n    // NOTE: \"periodStart\" is the timestamp offset applied via TextEngine.\n    // It is no longer closely tied to periods, but the name stuck around.\n    let offset = time.periodStart;\n\n    if (blocks[0].includes('X-TIMESTAMP-MAP')) {\n      // https://bit.ly/2K92l7y\n      // The 'X-TIMESTAMP-MAP' header is used in HLS to align text with\n      // the rest of the media.\n      // The header format is 'X-TIMESTAMP-MAP=MPEGTS:n,LOCAL:m'\n      // (the attributes can go in any order)\n      // where n is MPEG-2 time and m is cue time it maps to.\n      // For example 'X-TIMESTAMP-MAP=LOCAL:00:00:00.000,MPEGTS:900000'\n      // means an offset of 10 seconds\n      // 900000/MPEG_TIMESCALE - cue time.\n      const cueTimeMatch =\n            blocks[0].match(/LOCAL:((?:(\\d{1,}):)?(\\d{2}):(\\d{2})\\.(\\d{3}))/m);\n\n      const mpegTimeMatch = blocks[0].match(/MPEGTS:(\\d+)/m);\n      if (cueTimeMatch && mpegTimeMatch) {\n        const parser = new shaka.util.TextParser(cueTimeMatch[1]);\n        const cueTime = shaka.text.VttTextParser.parseTime_(parser);\n        if (cueTime == null) {\n          throw new shaka.util.Error(\n              shaka.util.Error.Severity.CRITICAL,\n              shaka.util.Error.Category.TEXT,\n              shaka.util.Error.Code.INVALID_TEXT_HEADER);\n        }\n\n        let mpegTime = Number(mpegTimeMatch[1]);\n        const mpegTimescale = shaka.text.VttTextParser.MPEG_TIMESCALE_;\n\n        const rolloverSeconds =\n            shaka.text.VttTextParser.TS_ROLLOVER_ / mpegTimescale;\n        let segmentStart = time.segmentStart;\n        while (segmentStart >= rolloverSeconds) {\n          segmentStart -= rolloverSeconds;\n          mpegTime += shaka.text.VttTextParser.TS_ROLLOVER_;\n        }\n\n        // Apple-encoded HLS content uses absolute timestamps, so assume the\n        // presence of the map tag means the content uses absolute timestamps.\n        offset = time.periodStart + mpegTime / mpegTimescale - cueTime;\n      }\n    }\n\n    // Parse VTT regions.\n    /* !Array.<!shaka.extern.CueRegion> */\n    const regions = [];\n    for (const line of blocks[0].split('\\n')) {\n      if (/^Region:/.test(line)) {\n        const region = VttTextParser.parseRegion_(line);\n        regions.push(region);\n      }\n    }\n\n    // Parse cues.\n    const ret = [];\n    for (const block of blocks.slice(1)) {\n      const lines = block.split('\\n');\n      const cue = VttTextParser.parseCue_(lines, offset, regions);\n      if (cue) {\n        ret.push(cue);\n      }\n    }\n\n    return ret;\n  }\n\n  /**\n   * Parses a string into a Region object.\n   *\n   * @param {string} text\n   * @return {!shaka.extern.CueRegion}\n   * @private\n   */\n  static parseRegion_(text) {\n    const VttTextParser = shaka.text.VttTextParser;\n    const parser = new shaka.util.TextParser(text);\n    // The region string looks like this:\n    // Region: id=fred width=50% lines=3 regionanchor=0%,100%\n    //         viewportanchor=10%,90% scroll=up\n    const region = new shaka.text.CueRegion();\n\n    // Skip 'Region:'\n    parser.readWord();\n    parser.skipWhitespace();\n\n    let word = parser.readWord();\n    while (word) {\n      if (!VttTextParser.parseRegionSetting_(region, word)) {\n        shaka.log.warning(\n            'VTT parser encountered an invalid VTTRegion setting: ', word,\n            ' The setting will be ignored.');\n      }\n      parser.skipWhitespace();\n      word = parser.readWord();\n    }\n\n    return region;\n  }\n\n  /**\n   * Parses a text block into a Cue object.\n   *\n   * @param {!Array.<string>} text\n   * @param {number} timeOffset\n   * @param {!Array.<!shaka.extern.CueRegion>} regions\n   * @return {shaka.text.Cue}\n   * @private\n   */\n  static parseCue_(text, timeOffset, regions) {\n    const VttTextParser = shaka.text.VttTextParser;\n\n    // Skip empty blocks.\n    if (text.length == 1 && !text[0]) {\n      return null;\n    }\n\n    // Skip comment blocks.\n    if (/^NOTE($|[ \\t])/.test(text[0])) {\n      return null;\n    }\n\n    // Skip style blocks.\n    if (text[0] == 'STYLE') {\n      return null;\n    }\n\n    let id = null;\n    if (!text[0].includes('-->')) {\n      id = text[0];\n      text.splice(0, 1);\n    }\n\n    // Parse the times.\n    const parser = new shaka.util.TextParser(text[0]);\n    let start = VttTextParser.parseTime_(parser);\n    const expect = parser.readRegex(/[ \\t]+-->[ \\t]+/g);\n    let end = VttTextParser.parseTime_(parser);\n\n    if (start == null || expect == null || end == null) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.TEXT,\n          shaka.util.Error.Code.INVALID_TEXT_CUE);\n    }\n\n    start += timeOffset;\n    end += timeOffset;\n\n    // Get the payload.\n    const payload = text.slice(1).join('\\n').trim();\n\n    const cue = new shaka.text.Cue(start, end, payload);\n\n    // Parse optional settings.\n    parser.skipWhitespace();\n    let word = parser.readWord();\n    while (word) {\n      if (!VttTextParser.parseCueSetting(cue, word, regions)) {\n        shaka.log.warning('VTT parser encountered an invalid VTT setting: ',\n            word,\n            ' The setting will be ignored.');\n      }\n      parser.skipWhitespace();\n      word = parser.readWord();\n    }\n\n    if (id != null) {\n      cue.id = id;\n    }\n    return cue;\n  }\n\n  /**\n   * Parses a WebVTT setting from the given word.\n   *\n   * @param {!shaka.text.Cue} cue\n   * @param {string} word\n   * @param {!Array.<!shaka.text.CueRegion>} regions\n   * @return {boolean} True on success.\n   */\n  static parseCueSetting(cue, word, regions) {\n    const VttTextParser = shaka.text.VttTextParser;\n    let results = null;\n    if ((results = /^align:(start|middle|center|end|left|right)$/.exec(word))) {\n      VttTextParser.setTextAlign_(cue, results[1]);\n    } else if ((results = /^vertical:(lr|rl)$/.exec(word))) {\n      VttTextParser.setVerticalWritingMode_(cue, results[1]);\n    } else if ((results = /^size:([\\d.]+)%$/.exec(word))) {\n      cue.size = Number(results[1]);\n    } else if ((results =\n        /^position:([\\d.]+)%(?:,(line-left|line-right|center|start|end))?$/\n            .exec(word))) {\n      cue.position = Number(results[1]);\n      if (results[2]) {\n        VttTextParser.setPositionAlign_(cue, results[2]);\n      }\n    } else if ((results = /^region:(.*)$/.exec(word))) {\n      const region = VttTextParser.getRegionById_(regions, results[1]);\n      if (region) {\n        cue.region = region;\n      }\n    } else {\n      return VttTextParser.parsedLineValueAndInterpretation_(cue, word);\n    }\n\n    return true;\n  }\n\n  /**\n   *\n   * @param {!Array.<!shaka.text.CueRegion>} regions\n   * @param {string} id\n   * @return {?shaka.text.CueRegion}\n   * @private\n   */\n  static getRegionById_(regions, id) {\n    const regionsWithId = regions.filter((region) => {\n      return region.id == id;\n    });\n    if (!regionsWithId.length) {\n      shaka.log.warning('VTT parser could not find a region with id: ',\n          id,\n          ' The region will be ignored.');\n      return null;\n    }\n    goog.asserts.assert(regionsWithId.length == 1,\n        'VTTRegion ids should be unique!');\n\n    return regionsWithId[0];\n  }\n\n  /**\n   * Parses a WebVTTRegion setting from the given word.\n   *\n   * @param {!shaka.text.CueRegion} region\n   * @param {string} word\n   * @return {boolean} True on success.\n   * @private\n   */\n  static parseRegionSetting_(region, word) {\n    let results = null;\n    if ((results = /^id=(.*)$/.exec(word))) {\n      region.id = results[1];\n    } else if ((results = /^width=(\\d{1,2}|100)%$/.exec(word))) {\n      region.width = Number(results[1]);\n    } else if ((results = /^lines=(\\d+)$/.exec(word))) {\n      region.height = Number(results[1]);\n      region.heightUnits = shaka.text.CueRegion.units.LINES;\n    } else if ((results = /^regionanchor=(\\d{1,2}|100)%,(\\d{1,2}|100)%$/\n        .exec(word))) {\n      region.regionAnchorX = Number(results[1]);\n      region.regionAnchorY = Number(results[2]);\n    } else if ((results = /^viewportanchor=(\\d{1,2}|100)%,(\\d{1,2}|100)%$/\n        .exec(word))) {\n      region.viewportAnchorX = Number(results[1]);\n      region.viewportAnchorY = Number(results[2]);\n    } else if ((results = /^scroll=up$/.exec(word))) {\n      region.scroll = shaka.text.CueRegion.scrollMode.UP;\n    } else {\n      return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * @param {!shaka.text.Cue} cue\n   * @param {string} align\n   * @private\n   */\n  static setTextAlign_(cue, align) {\n    const Cue = shaka.text.Cue;\n    if (align == 'middle') {\n      cue.textAlign = Cue.textAlign.CENTER;\n    } else {\n      goog.asserts.assert(align.toUpperCase() in Cue.textAlign,\n          align.toUpperCase() +\n                          ' Should be in Cue.textAlign values!');\n\n      cue.textAlign = Cue.textAlign[align.toUpperCase()];\n    }\n  }\n\n  /**\n   * @param {!shaka.text.Cue} cue\n   * @param {string} align\n   * @private\n   */\n  static setPositionAlign_(cue, align) {\n    const Cue = shaka.text.Cue;\n    if (align == 'line-left' || align == 'start') {\n      cue.positionAlign = Cue.positionAlign.LEFT;\n    } else if (align == 'line-right' || align == 'end') {\n      cue.positionAlign = Cue.positionAlign.RIGHT;\n    } else {\n      cue.positionAlign = Cue.positionAlign.CENTER;\n    }\n  }\n\n  /**\n   * @param {!shaka.text.Cue} cue\n   * @param {string} value\n   * @private\n   */\n  static setVerticalWritingMode_(cue, value) {\n    const Cue = shaka.text.Cue;\n    if (value == 'lr') {\n      cue.writingMode = Cue.writingMode.VERTICAL_LEFT_TO_RIGHT;\n    } else {\n      cue.writingMode = Cue.writingMode.VERTICAL_RIGHT_TO_LEFT;\n    }\n  }\n\n  /**\n   * @param {!shaka.text.Cue} cue\n   * @param {string} word\n   * @return {boolean}\n   * @private\n   */\n  static parsedLineValueAndInterpretation_(cue, word) {\n    const Cue = shaka.text.Cue;\n    let results = null;\n    if ((results = /^line:([\\d.]+)%(?:,(start|end|center))?$/.exec(word))) {\n      cue.lineInterpretation = Cue.lineInterpretation.PERCENTAGE;\n      cue.line = Number(results[1]);\n      if (results[2]) {\n        goog.asserts.assert(\n            results[2].toUpperCase() in Cue.lineAlign,\n            results[2].toUpperCase() + ' Should be in Cue.lineAlign values!');\n        cue.lineAlign = Cue.lineAlign[results[2].toUpperCase()];\n      }\n    } else if ((results =\n                    /^line:(-?\\d+)(?:,(start|end|center))?$/.exec(word))) {\n      cue.lineInterpretation = Cue.lineInterpretation.LINE_NUMBER;\n      cue.line = Number(results[1]);\n      if (results[2]) {\n        goog.asserts.assert(\n            results[2].toUpperCase() in Cue.lineAlign,\n            results[2].toUpperCase() + ' Should be in Cue.lineAlign values!');\n        cue.lineAlign = Cue.lineAlign[results[2].toUpperCase()];\n      }\n    } else {\n      return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Parses a WebVTT time from the given parser.\n   *\n   * @param {!shaka.util.TextParser} parser\n   * @return {?number}\n   * @private\n   */\n  static parseTime_(parser) {\n    // 00:00.000 or 00:00:00.000 or 0:00:00.000 or\n    // 00:00.00 or 00:00:00.00 or 0:00:00.00\n    const regexExpresion = /(?:(\\d{1,}):)?(\\d{2}):(\\d{2})\\.(\\d{2,3})/g;\n    const results = parser.readRegex(regexExpresion);\n    if (results == null) {\n      return null;\n    }\n    // This capture is optional, but will still be in the array as undefined,\n    // in which case it is 0.\n    const hours = Number(results[1]) || 0;\n    const minutes = Number(results[2]);\n    const seconds = Number(results[3]);\n    const milliseconds = Number(results[4]);\n    if (minutes > 59 || seconds > 59) {\n      return null;\n    }\n\n    return (milliseconds / 1000) + seconds + (minutes * 60) + (hours * 3600);\n  }\n};\n\n/**\n * @const {number}\n * @private\n */\nshaka.text.VttTextParser.MPEG_TIMESCALE_ = 90000;\n\n/**\n * At this value, timestamps roll over in TS content.\n * @const {number}\n * @private\n */\nshaka.text.VttTextParser.TS_ROLLOVER_ = 0x200000000;\n\nshaka.text.TextEngine.registerParser(\n    'text/vtt', () => new shaka.text.VttTextParser());\n\nshaka.text.TextEngine.registerParser(\n    'text/vtt; codecs=\"vtt\"', () => new shaka.text.VttTextParser());\n\nshaka.text.TextEngine.registerParser(\n    'text/vtt; codecs=\"wvtt\"', () => new shaka.text.VttTextParser());\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.text.Mp4VttParser');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.text.Cue');\ngoog.require('shaka.text.TextEngine');\ngoog.require('shaka.text.VttTextParser');\ngoog.require('shaka.util.DataViewReader');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.Functional');\ngoog.require('shaka.util.Iterables');\ngoog.require('shaka.util.Mp4Parser');\ngoog.require('shaka.util.StringUtils');\ngoog.require('shaka.util.TextParser');\n\n\n/**\n * @implements {shaka.extern.TextParser}\n * @export\n */\nshaka.text.Mp4VttParser = class {\n  constructor() {\n    /**\n     * The current time scale used by the VTT parser.\n     *\n     * @type {?number}\n     * @private\n     */\n    this.timescale_ = null;\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  parseInit(data) {\n    const Mp4Parser = shaka.util.Mp4Parser;\n\n    let sawWVTT = false;\n\n    new Mp4Parser()\n        .box('moov', Mp4Parser.children)\n        .box('trak', Mp4Parser.children)\n        .box('mdia', Mp4Parser.children)\n        .fullBox('mdhd', (box) => {\n          goog.asserts.assert(\n              box.version == 0 || box.version == 1,\n              'MDHD version can only be 0 or 1');\n          if (box.version == 0) {\n            box.reader.skip(4); // Skip \"creation_time\".\n            box.reader.skip(4); // Skip \"modification_time\".\n            this.timescale_ = box.reader.readUint32();\n            box.reader.skip(4); // Skip \"duration\".\n          } else {\n            box.reader.skip(8); // Skip \"creation_time\".\n            box.reader.skip(8); // Skip \"modification_time\".\n            this.timescale_ = box.reader.readUint32();\n            box.reader.skip(8); // Skip \"duration\".\n          }\n          box.reader.skip(4); // Skip \"pad\", \"language\", and \"pre-defined\".\n        })\n        .box('minf', Mp4Parser.children)\n        .box('stbl', Mp4Parser.children)\n        .fullBox('stsd', Mp4Parser.sampleDescription)\n        .box('wvtt', (box) => {\n          // A valid vtt init segment, though we have no actual subtitles yet.\n          sawWVTT = true;\n        }).parse(data);\n\n    if (!this.timescale_) {\n      // Missing timescale for VTT content. It should be located in the MDHD.\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.TEXT,\n          shaka.util.Error.Code.INVALID_MP4_VTT);\n    }\n\n    if (!sawWVTT) {\n      // A WVTT box should have been seen (a valid vtt init segment with no\n      // actual subtitles).\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.TEXT,\n          shaka.util.Error.Code.INVALID_MP4_VTT);\n    }\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  parseMedia(data, time) {\n    if (!this.timescale_) {\n      // Missing timescale for VTT content. We should have seen the init\n      // segment.\n      shaka.log.error('No init segment for MP4+VTT!');\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.TEXT,\n          shaka.util.Error.Code.INVALID_MP4_VTT);\n    }\n\n    const Mp4VttParser = shaka.text.Mp4VttParser;\n    const Mp4Parser = shaka.util.Mp4Parser;\n\n    let baseTime = 0;\n    /** @type {!Array.<shaka.text.Mp4VttParser.TimeSegment>} */\n    let presentations = [];\n    /** @type {!Uint8Array} */\n    let rawPayload;\n    /** @type {!Array.<shaka.text.Cue>} */\n    const cues = [];\n\n    let sawTFDT = false;\n    let sawTRUN = false;\n    let sawMDAT = false;\n    let defaultDuration = null;\n\n    const parser = new Mp4Parser()\n        .box('moof', Mp4Parser.children)\n        .box('traf', Mp4Parser.children)\n        .fullBox('tfdt', (box) => {\n          sawTFDT = true;\n          goog.asserts.assert(\n              box.version == 0 || box.version == 1,\n              'TFDT version can only be 0 or 1');\n          baseTime = (box.version == 0) ? box.reader.readUint32() :\n                                          box.reader.readUint64();\n        })\n        .fullBox('tfhd', (box) => {\n          goog.asserts.assert(\n              box.flags != null,\n              'A TFHD box should have a valid flags value');\n          defaultDuration = Mp4VttParser.parseTFHD_(box.flags, box.reader);\n        })\n        .fullBox('trun', (box) => {\n          sawTRUN = true;\n          goog.asserts.assert(\n              box.version != null,\n              'A TRUN box should have a valid version value');\n          goog.asserts.assert(\n              box.flags != null,\n              'A TRUN box should have a valid flags value');\n          presentations =\n              Mp4VttParser.parseTRUN_(box.version, box.flags, box.reader);\n        })\n        .box('mdat', Mp4Parser.allData((data) => {\n          goog.asserts.assert(\n              !sawMDAT,\n              'VTT cues in mp4 with multiple MDAT are not currently supported');\n          sawMDAT = true;\n          rawPayload = data;\n        }));\n    parser.parse(data, /* partialOkay= */ false);\n\n    if (!sawMDAT && !sawTFDT && !sawTRUN) {\n      // A required box is missing.\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.TEXT,\n          shaka.util.Error.Code.INVALID_MP4_VTT);\n    }\n\n    let currentTime = baseTime;\n\n    /** @type {!shaka.util.DataViewReader} */\n    const reader = new shaka.util.DataViewReader(\n        rawPayload, shaka.util.DataViewReader.Endianness.BIG_ENDIAN);\n\n    for (const presentation of presentations) {\n      // If one presentation corresponds to multiple payloads, it is assumed\n      // that all of those payloads have the same start time and duration.\n      const duration = presentation.duration || defaultDuration;\n      const startTime = presentation.timeOffset ?\n                      baseTime + presentation.timeOffset :\n                      currentTime;\n      currentTime = startTime + (duration || 0);\n\n      // Read samples until it adds up to the given size.\n      let totalSize = 0;\n      do {\n        // Read the payload size.\n        const payloadSize = reader.readUint32();\n        totalSize += payloadSize;\n\n        // Skip the type.\n        const payloadType = reader.readUint32();\n        const payloadName = shaka.util.Mp4Parser.typeToString(payloadType);\n\n        // Read the data payload.\n        /** @type {Uint8Array} */\n        let payload = null;\n        if (payloadName == 'vttc') {\n          if (payloadSize > 8) {\n            payload = reader.readBytes(payloadSize - 8);\n          }\n        } else if (payloadName == 'vtte') {\n          // It's a vtte, which is a vtt cue that is empty. Ignore any data that\n          // does exist.\n          reader.skip(payloadSize - 8);\n        } else {\n          shaka.log.error('Unknown box ' + payloadName + '! Skipping!');\n          reader.skip(payloadSize - 8);\n        }\n\n        if (duration) {\n          if (payload) {\n            goog.asserts.assert(\n                this.timescale_ != null, 'Timescale should not be null!');\n            const cue = shaka.text.Mp4VttParser.parseVTTC_(\n                payload,\n                time.periodStart + startTime / this.timescale_,\n                time.periodStart + currentTime / this.timescale_);\n            cues.push(cue);\n          }\n        } else {\n          shaka.log.error(\n              'WVTT sample duration unknown, and no default found!');\n        }\n\n        goog.asserts.assert(\n            !presentation.sampleSize || totalSize <= presentation.sampleSize,\n            'The samples do not fit evenly into the sample sizes given in ' +\n            'the TRUN box!');\n\n        // If no sampleSize was specified, it's assumed that this presentation\n        // corresponds to only a single cue.\n      } while (presentation.sampleSize &&\n               (totalSize < presentation.sampleSize));\n    }\n\n    goog.asserts.assert(\n        !reader.hasMoreData(),\n        'MDAT which contain VTT cues and non-VTT data are not currently ' +\n        'supported!');\n\n    return /** @type {!Array.<!shaka.extern.Cue>} */ (\n      cues.filter(shaka.util.Functional.isNotNull));\n  }\n\n  /**\n   * @param {number} flags\n   * @param {!shaka.util.DataViewReader} reader\n   * @return {?number} The default_sample_duration field, if present.\n   * @private\n   */\n  static parseTFHD_(flags, reader) {\n    // Skip \"track_ID\".\n    reader.skip(4);\n\n    // Skip \"base_data_offset\" if present.\n    if (flags & 0x000001) {\n      reader.skip(8);\n    }\n\n    // Skip \"sample_description_index\" if present.\n    if (flags & 0x000002) {\n      reader.skip(4);\n    }\n\n    // Read and return \"default_sample_duration\" if present.\n    if (flags & 0x000008) {\n      return reader.readUint32();\n    }\n\n    // There is no \"default_sample_duration\".\n    return null;\n  }\n\n  /**\n   * @param {number} version\n   * @param {number} flags\n   * @param {!shaka.util.DataViewReader} reader\n   * @return {!Array.<shaka.text.Mp4VttParser.TimeSegment>}\n   * @private\n   */\n  static parseTRUN_(version, flags, reader) {\n    const sampleCount = reader.readUint32();\n\n    // Skip \"data_offset\" if present.\n    if (flags & 0x000001) {\n      reader.skip(4);\n    }\n\n    // Skip \"first_sample_flags\" if present.\n    if (flags & 0x000004) {\n      reader.skip(4);\n    }\n\n    const samples = [];\n\n    for (const _ of shaka.util.Iterables.range(sampleCount)) {\n      shaka.util.Functional.ignored(_);\n      /** @type {shaka.text.Mp4VttParser.TimeSegment} */\n      const sample = {\n        duration: null,\n        sampleSize: null,\n        timeOffset: null,\n      };\n\n      // Read \"sample duration\" if present.\n      if (flags & 0x000100) {\n        sample.duration = reader.readUint32();\n      }\n\n      // Read \"sample_size\" if present.\n      if (flags & 0x000200) {\n        sample.sampleSize = reader.readUint32();\n      }\n\n      // Skip \"sample_flags\" if present.\n      if (flags & 0x000400) {\n        reader.skip(4);\n      }\n\n      // Read \"sample_time_offset\" if present.\n      if (flags & 0x000800) {\n        sample.timeOffset = version == 0 ?\n            reader.readUint32() :\n            reader.readInt32();\n      }\n\n      samples.push(sample);\n    }\n\n    return samples;\n  }\n\n  /**\n   * Parses a vttc box into a cue.\n   *\n   * @param {!Uint8Array} data\n   * @param {number} startTime\n   * @param {number} endTime\n   * @return {shaka.text.Cue}\n   * @private\n   */\n  static parseVTTC_(data, startTime, endTime) {\n    let payload;\n    let id;\n    let settings;\n\n    new shaka.util.Mp4Parser()\n        .box('payl', shaka.util.Mp4Parser.allData((data) => {\n          payload = shaka.util.StringUtils.fromUTF8(data);\n        }))\n        .box('iden', shaka.util.Mp4Parser.allData((data) => {\n          id = shaka.util.StringUtils.fromUTF8(data);\n        }))\n        .box('sttg', shaka.util.Mp4Parser.allData((data) => {\n          settings = shaka.util.StringUtils.fromUTF8(data);\n        }))\n        .parse(data);\n\n    if (payload) {\n      return shaka.text.Mp4VttParser.assembleCue_(\n          payload, id, settings, startTime, endTime);\n    } else {\n      return null;\n    }\n  }\n\n  /**\n   * Take the individual components that make a cue and create a vttc cue.\n   *\n   * @param {string} payload\n   * @param {?string} id\n   * @param {?string} settings\n   * @param {number} startTime\n   * @param {number} endTime\n   * @return {!shaka.text.Cue}\n   * @private\n   */\n  static assembleCue_(payload, id, settings, startTime, endTime) {\n    const cue = new shaka.text.Cue(startTime, endTime, payload);\n\n    if (id) {\n      cue.id = id;\n    }\n\n    if (settings) {\n      const parser = new shaka.util.TextParser(settings);\n\n      let word = parser.readWord();\n\n      while (word) {\n        // TODO: Check WebVTTConfigurationBox for region info.\n        if (!shaka.text.VttTextParser.parseCueSetting(\n            cue, word, /* VTTRegions= */[])) {\n          shaka.log.warning(\n              'VTT parser encountered an invalid VTT setting: ', word,\n              ' The setting will be ignored.');\n        }\n\n        parser.skipWhitespace();\n        word = parser.readWord();\n      }\n    }\n\n    return cue;\n  }\n};\n\n/**\n * @typedef {{\n *    duration: ?number,\n *    sampleSize: ?number,\n *    timeOffset: ?number\n *  }}\n *\n * @property {?number} duration\n *    The length of the segment in timescale units.\n * @property {?number} sampleSize\n *    The size of the segment in bytes.\n * @property {?number} timeOffset\n *    The time since the start of the segment in timescale units. Time\n *    offset is based of the start of the segment. If this value is\n *    missing, the accumated durations preceeding this time segment will\n *    be used to create the start time.\n */\nshaka.text.Mp4VttParser.TimeSegment;\n\nshaka.text.TextEngine.registerParser(\n    'application/mp4; codecs=\"wvtt\"', () => new shaka.text.Mp4VttParser());\n"]}